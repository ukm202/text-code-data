{"nl": "This python program checks whether a given number is perfect number or not.\r\nA perfect number is a positive integer number in which sum of all positive divisors excluding the number itself is equal to that number.\r\n\r\nPerfect Number Example: 28 is perfect number since its divisors are 1, 2, 4, 7 and 14. Sum of divisors is: 1+2+4+7+14=28.\r\n\r\nList of Perfect Numbers: 6, 28, 496, 8128, ...", "code": "# Python program to check Perfect Number\r\n\r\n# Function to check perfect number\r\ndef is_perfect(n):\r\n\r\n    perfect_sum = 0\r\n    \r\n    for i in range(1,n):\r\n        if n%i==0:\r\n            perfect_sum += i\r\n\r\n    return perfect_sum == n\r\n\r\n# Reading number\r\nnumber = int(input('Enter number: '))\r\n\r\n# Function call & Decision\r\nif is_perfect(number):\r\n    print('%d is PERFECT' %(number))\r\nelse:\r\n    print('%d is NOT PERFECT' %(number))"}
{"nl": "Write an efficient function to return maximum occurring character in the input string e.g., if input string is \u201ctest\u201d then function should return \u2018t\u2019.\n \n", "code": "# Python program to return the maximum occurring character in the input string\nASCII_SIZE = 256\n\ndef getMaxOccurringChar(str):\n\t# Create array to keep the count of individual characters\n\t# Initialize the count array to zero\n\tcount = [0] * ASCII_SIZE\n\n\t# Utility variables\n\tmax = -1\n\tc = ''\n\n\t# Traversing through the string and maintaining the count of\n\t# each character\n\tfor i in str:\n\t\tcount[ord(i)]+=1;\n\n\tfor i in str:\n\t\tif max < count[ord(i)]:\n\t\t\tmax = count[ord(i)]\n\t\t\tc = i\n\n\treturn c\n\n# Driver program to test the above function\nstr = \"sample string\"\nprint(\"Max occurring character is\",getMaxOccuringChar(str))\n\n# Although this program can be written in atmost 3 lines in Python\n# the above program has been written for a better understanding of\n# the reader\n\n# Shorter version of the program\n# import collections\n# str = \"sample string\"\n# print \"Max occurring character is \" +\n#\t collections.Counter(str).most_common(1)[0][0]\n\n# This code has been contributed by Bhavya Jain"}
{"nl": "Stacks also known as Last-In-First-Out(LIFO) structures. Stack primarily has two main operation namely push and pop, where push inserts an element at top and pop removes an element from top of the stack.\nNow, whenever an implementation of stack is considered its size is pre-determined or fixed. Even though it is dynamically allocated, still once it is made its size cannot be changed. And hence a condition called \u201cstack full\u201d arises.\u00a0\n\nA Growable array-based Stack can be implemented by allocating new memory larger than previous stack memory and copying elements from old stack to new stack. And then at last change the name of new stack to the name which was given to old stack\nThere are two strategy for growable stack: \n1. Tight Strategy : Add a constant amount to the old stack (N+c) \n2. Growth Strategy : Double the size of old stack (2N)\n\n\n\u00a0", "code": "# Python3 Program to implement growable array based stack\n# using tight strategy\n\u00a0\n# constant amount at which stack is increased\nBOUND = 4\n\u00a0\n# top of the stack\ntop = -1;\na = []\n\u00a0\n# length of stack\nlength = 0;\n\u00a0\n# function to create new stack\ndef create_new():\n\u00a0\u00a0\u00a0\u00a0global length;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# allocate memory for new stack\n\u00a0\u00a0\u00a0\u00a0new_a = [0 for i in range(length + BOUND)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# copying the content of old stack\n\u00a0\u00a0\u00a0\u00a0for i in range(length):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new_a[i] = a[i];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# re-sizing the length\n\u00a0\u00a0\u00a0\u00a0length += BOUND;\n\u00a0\u00a0\u00a0\u00a0return new_a\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# function to push new element\ndef push( element):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0global top, a\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if stack is full, create new one\n\u00a0\u00a0\u00a0\u00a0if (top == length - 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a = create_new();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0top +=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# insert element at top of the stack\n\u00a0\u00a0\u00a0\u00a0a[top] = element;\n\u00a0\u00a0\u00a0\u00a0return a;\n\u00a0\n# function to pop an element\ndef pop():\n\u00a0\u00a0\u00a0\u00a0global top\n\u00a0\u00a0\u00a0\u00a0top -= 1;\n\u00a0\n# function to display\ndef display():\n\u00a0\u00a0\u00a0\u00a0global top\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if top is -1, that means stack is empty\n\u00a0\u00a0\u00a0\u00a0if (top == -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack is Empty\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack: \", end = '')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(top + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[i], end = ' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\nif __name__=='__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# creating initial stack\n\u00a0\u00a0\u00a0\u00a0a = create_new();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# pushing element to top of stack\n\u00a0\u00a0\u00a0\u00a0push(1);\n\u00a0\u00a0\u00a0\u00a0push(2);\n\u00a0\u00a0\u00a0\u00a0push(3);\n\u00a0\u00a0\u00a0\u00a0push(4);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# pushing more element when stack is full\n\u00a0\u00a0\u00a0\u00a0push(5);\n\u00a0\u00a0\u00a0\u00a0push(6);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0push(7);\n\u00a0\u00a0\u00a0\u00a0push(8);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# pushing more element so that stack can grow\n\u00a0\u00a0\u00a0\u00a0push( 9);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "Given a binary tree, check whether it is a mirror of itself.", "code": "# Python program to check if a\r\n# given Binary Tree is symmetric or not\r\n\r\n# Node structure\r\n\r\n\r\nclass Node:\r\n\r\n\t# Utility function to create new node\r\n\tdef __init__(self, key):\r\n\t\tself.key = key\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# Returns True if trees\r\n#with roots as root1 and root 2 are mirror\r\n\r\n\r\ndef isMirror(root1, root2):\r\n\t# If both trees are empty, then they are mirror images\r\n\tif root1 is None and root2 is None:\r\n\t\treturn True\r\n\r\n\t\"\"\" For two trees to be mirror images,\r\n\t\tthe following three conditions must be true\r\n\t\t1 - Their root node's key must be same\r\n\t\t2 - left subtree of left tree and right subtree\r\n\t\tof the right tree have to be mirror images\r\n\t\t3 - right subtree of left tree and left subtree\r\n\t\tof right tree have to be mirror images\r\n\t\"\"\"\r\n\tif (root1 is not None and root2 is not None):\r\n\t\tif root1.key == root2.key:\r\n\t\t\treturn (isMirror(root1.left, root2.right)and\r\n\t\t\t\t\tisMirror(root1.right, root2.left))\r\n\r\n\t# If none of the above conditions is true then root1\r\n\t# and root2 are not mirror images\r\n\treturn False\r\n\r\n\r\ndef isSymmetric(root):\r\n\r\n\t# Check if tree is mirror of itself\r\n\treturn isMirror(root, root)\r\n\r\n\r\n# Driver Code\r\n# Let's construct the tree show in the above figure\r\nroot = Node(1)\r\nroot.left = Node(2)\r\nroot.right = Node(2)\r\nroot.left.left = Node(3)\r\nroot.left.right = Node(4)\r\nroot.right.left = Node(4)\r\nroot.right.right = Node(3)\r\nprint (\"Symmetric\" if isSymmetric(root) == True else \"Not symmetric\")\r\n\r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\r"}
{"nl": "In the previous article, we have discussed Python Program to find the Sum of Series 1^1+2^2+3^3\u2026+N^N\n Given a matrix, the task is to scan and print the elements of the given matrix in Python\n \n What is a matrix:\n \n A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.\n \n Example:\n \n \n \n Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.\n \n In this order, the dimensions of a matrix indicate the number of rows and columns.\n \n \n \n Here as there are 5 rows and 4 columns it is called a 5*4 matrix.", "code": "# Give the number of rows of the matrix as user input using the int(input()) function\n # and store it in a variable.\n mtrxrows = int(input('Enter some random number of rows of the matrix = '))\n # Give the number of columns of the matrix as user input using the int(input()) function\n # and store it in another variable.\n mtrxcols = int(input('Enter some random number of columns of the matrix = '))\n # Take a list and initialize it with an empty value using [] or list() to say gvnmatrix.\n mtrx = []\n # Loop till the given number of rows using the For loop\n for n in range(mtrxrows):\n  # Inside the For loop, Give all the row elements of the given Matrix as a list using\n  # the list(),map(),int(),split() functions and store it in a variable.\n  l = list(map(int, input(\n  'Enter {'+str(mtrxcols)+'} elements of row {'+str(n+1)+'} separated by spaces = ').split()))\n  # Add the above row elements list to gvnmatrix using the append() function.\n  mtrx.append(l)\n # To print all the elements of the given matrix.\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of rows using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Print the element of the matrix by printing gvnmatrix[n][m] value\n  # where n is the iterator value of the parent For loop and m is the iterator\n  # value of the inner For loop.\n  print(mtrx[n][m], end=' ')\n  print()"}
{"nl": "Here, let us see how to get a dictionary from a field in a Python object. We must retrieve the class members when we want to get a dictionary from an object\u2019s field. To get the object attributes in dictionary format, we can use one of the two ways given below:", "code": "# Create a class say student\nclass student:\n  # Create a constructor function which initializes the default values of all the variables \n  def __init__(self):\n  #Taking some random class/Instance variables and intializing them with some random values \n  self.rollno = 1\n  self.marks = 85\n  # Creating a method/function to print all the variables values of the class object\n  def display(self):\n  print('The values of roll number and marks are :',self.rollno, self.marks)\n# Creating object of the above class\nresult = student()\n# Calling the display() method of the student class using the above created object\nresult.display()\n# Calling the __dict__ attribute on the above created object and printing it\nprint(result.__dict__)"}
{"nl": "Given two values n1 and n2 (where n1 < n2) and a root pointer to a Binary Search Tree. Print all the keys of tree in range n1 to n2. i.e. print all nodes n such that n1<=n<=n2 and n is a key of given BST. Print all the keys in increasing order.\n\n\nPrerequisites: Morris traversal | Threaded binary trees\n\n\nInorder traversal uses recursion or stack/queue which consumes O(n) space. But there is one efficient way to do inorder tree traversal using Morris Traversal which is based in Threaded Binary trees. Morris traversal uses no recursion or stack/queue and simply stores some important information in the wasted NULL pointers. Morris traversal consumes constant extra memory O(1) as it uses no recursion or stack/queue. Hence we will use Morris traversal to do inorder traversal in the algorithm presented in this tutorial to print keys of a BST in a given range, which is efficient memory-wise.\n\n\nThe concept of Threaded Binary trees is simple in that they store some useful information in the wasted NULL pointers. In a normal binary tree with n nodes, n+1 NULL pointers waste memory.\n\n\nApproach: Morris Traversal is a very nice memory-efficient technique to do tree traversal without using stack or recursion in constant memory O(1) based on Threaded Binary Trees. Morris traversal can be used in solving problems where inorder tree traversals are used especially in order statistics eg-Kth largest element in BST, Kth smallest in BST etc. Hence, this is where Morris traversal would come handy as a more efficient method to do inorder traversal in constant O(1) space without using any stack or recursion.\n", "code": "# Python3 code to print BST keys in given Range\n# in constant space using Morris traversal.\n\u00a0\n# Helper function to create a new node\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Function to print the keys in range\ndef RangeTraversal(root, n1, n2):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0curr = root\n\u00a0\u00a0\u00a0\u00a0while curr:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if curr.left == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check if current node lies\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# between n1 and n2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if curr.data <= n2 and curr.data >= n1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(curr.data, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr = curr.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre = curr.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# finding the inorder predecessor-\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# inorder predecessor is the right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# most in left subtree or the left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# child, i.e in BST it is the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# maximum(right most) in left subtree.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (pre.right != None and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre.right != curr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre = pre.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if pre.right == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre.right = curr;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr = curr.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre.right = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check if current node lies\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# between n1 and n2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if curr.data <= n2 and curr.data >= n1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(curr.data, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr = curr.right\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructed binary tree is\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 4\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0 / \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 2\u00a0\u00a0\u00a0\u00a0\u00a0 7\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0 / \\ / \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0 1\u00a0 3 6 10\n\u00a0\u00a0\u00a0\u00a0root = newNode(4)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(7)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(1)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(3)\n\u00a0\u00a0\u00a0\u00a0root.right.left = newNode(6)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(10)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0RangeTraversal(root, 4, 12)\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Greed is a dice game played with five six-sided dice. Your mission is to score a throw according to these rules:\n Three 1's => 1000 points\n Three 6's =>  600 points\n Three 5's =>  500 points\n Three 4's =>  400 points\n Three 3's =>  300 points\n Three 2's =>  200 points\n One   1   =>  100 points\n One   5   =>   50 point\nSee the below examples for a better understanding:\n Throw       Score\n ---------   ------------------\n 5 1 3 4 1   250:  50 (for the 5) + 2 * 100 (for the 1s)\n 1 1 1 3 1   1100: 1000 (for three 1s) + 100 (for the other 1)\n 2 4 4 5 4   450:  400 (for three 4s) + 50 (for the 5)\nCreate a function that takes a list of five six-sided throw values and returns the final calculated dice score.\nExamples\ndice_score([2, 3, 4, 6, 2]) \u279e 0\n\ndice_score([4, 4, 4, 3, 3]) \u279e 400\n\ndice_score([2, 4, 4, 5, 4]) \u279e 450\nNotes\nA single die can only be counted once in each roll. For example, a given \"5\" can only be counted as a part of the triplet (contributing to the 500 points) or as a single 50 points, but not both in the same roll.", "code": "def dice_score(throw):\n  threes = [0,1000,200,300,400,500,600]\n    tot = 0\n  for i in set(throw):\n    if throw.count(i) >=3: tot += threes[i]\n    if i ==1:\n      tot += throw.count(i)%3*100\n    if i ==5:\n      tot += throw.count(i)%3*50\n    return tot"}
{"nl": "Write a function that, given a date (in the format MM/DD/YYYY), returns the day of the week as a string. Each day name must be one of the following strings: \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", or \"Saturday\".\nTo illustrate, the day of the week for \"12/07/2016\" is \"Wednesday\".\nExamples\nget_day(\"12/07/2016\") \u279e \"Wednesday\"\n\nget_day(\"09/04/2016\") \u279e \"Sunday\"\n\nget_day(\"12/08/2011\") \u279e \"Thursday\"\nNotes\nThis challenge assumes the week starts on Sunday.", "code": "import datetime\ndef get_day(day):\n  m,d,y = [int(i) for i in day.split('/')]\n  days = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']\n  return days[datetime.date(y,m,d).weekday()]"}
{"nl": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\n\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\n \n\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n \n\nConstraints:\n\nn == ratings.length\n1 <= n <= 2 * 104\n0 <= ratings[i] <= 2 * 104", "code": "class Solution:\n    def candy(self, R):\n        n, ans = len(R), [1]*len(R)\n        \n        for i in range(n-1):\n            if R[i] < R[i+1]:\n                ans[i+1] = max(1 + ans[i], ans[i+1])\n                \n        for i in range(n-2, -1, -1):\n            if R[i+1] < R[i]:\n                ans[i] = max(1 + ans[i+1], ans[i])\n        \n        return sum(ans)"}
{"nl": "Definition and Usage\r\nThe difference() method returns a set that contains the difference between two sets.\r\n\r\nMeaning: The returned set contains items that exist only in the first set, and not in both sets.", "code": "x = {\"apple\", \"banana\", \"cherry\"}\r\ny = {\"google\", \"microsoft\", \"apple\"}\r\n\r\nz = x.difference(y)\r\n\r\nprint(z)"}
{"nl": "Given two Binary Search Trees, find common nodes in them. In other words, find intersection of two BSTs.", "code": "# Python3 program of iterative traversal based\n# method to find common elements in two BSTs.\n\n# A utility function to create a new node\nclass newNode:\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = self.right = None\n\n# Function two print common elements\n# in given two trees\ndef printCommon(root1, root2):\n\t\n\t# Create two stacks for two inorder\n\t# traversals\n\ts1 = []\n\ts2 = []\n\n\twhile 1:\n\t\t\n\t\t# append the Nodes of first\n\t\t# tree in stack s1\n\t\tif root1:\n\t\t\ts1.append(root1)\n\t\t\troot1 = root1.left\n\n\t\t# append the Nodes of second tree\n\t\t# in stack s2\n\t\telif root2:\n\t\t\ts2.append(root2)\n\t\t\troot2 = root2.left\n\n\t\t# Both root1 and root2 are NULL here\n\t\telif len(s1) != 0 and len(s2) != 0:\n\t\t\troot1 = s1[-1]\n\t\t\troot2 = s2[-1]\n\n\t\t\t# If current keys in two trees are same\n\t\t\tif root1.key == root2.key:\n\t\t\t\tprint(root1.key, end = \" \")\n\t\t\t\ts1.pop(-1)\n\t\t\t\ts2.pop(-1)\n\n\t\t\t\t# move to the inorder successor\n\t\t\t\troot1 = root1.right\n\t\t\t\troot2 = root2.right\n\n\t\t\telif root1.key < root2.key:\n\t\t\t\t\n\t\t\t\t# If Node of first tree is smaller, than\n\t\t\t\t# that of second tree, then its obvious\n\t\t\t\t# that the inorder successors of current\n\t\t\t\t# Node can have same value as that of the\n\t\t\t\t# second tree Node. Thus, we pop from s2\n\t\t\t\ts1.pop(-1)\n\t\t\t\troot1 = root1.right\n\n\t\t\t\t# root2 is set to NULL, because we need\n\t\t\t\t# new Nodes of tree 1\n\t\t\t\troot2 = None\n\t\t\telif root1.key > root2.key:\n\t\t\t\ts2.pop(-1)\n\t\t\t\troot2 = root2.right\n\t\t\t\troot1 = None\n\n\t\t# Both roots and both stacks are empty\n\t\telse:\n\t\t\tbreak\n\n# A utility function to do inorder traversal\ndef inorder(root):\n\tif root:\n\t\tinorder(root.left)\n\t\tprint(root.key, end = \" \")\n\t\tinorder(root.right)\n\n# A utility function to insert a new Node\n# with given key in BST\ndef insert(node, key):\n\t\n\t# If the tree is empty, return a new Node\n\tif node == None:\n\t\treturn newNode(key)\n\n\t# Otherwise, recur down the tree\n\tif key < node.key:\n\t\tnode.left = insert(node.left, key)\n\telif key > node.key:\n\t\tnode.right = insert(node.right, key)\n\t\t\n\t# return the (unchanged) Node pointer\n\treturn node\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# Create first tree as shown in example\n\troot1 = None\n\troot1 = insert(root1, 5)\n\troot1 = insert(root1, 1)\n\troot1 = insert(root1, 10)\n\troot1 = insert(root1, 0)\n\troot1 = insert(root1, 4)\n\troot1 = insert(root1, 7)\n\troot1 = insert(root1, 9)\n\n\t# Create second tree as shown in example\n\troot2 = None\n\troot2 = insert(root2, 10)\n\troot2 = insert(root2, 7)\n\troot2 = insert(root2, 20)\n\troot2 = insert(root2, 4)\n\troot2 = insert(root2, 9)\n\n\tprint(\"Tree 1 : \")\n\tinorder(root1)\n\tprint()\n\t\n\tprint(\"Tree 2 : \")\n\tinorder(root2)\n\tprint()\n\n\tprint(\"Common Nodes: \")\n\tprintCommon(root1, root2)\n\t\n# This code is contributed by PranchalK"}
{"nl": "Check the principles of minimalist code in the intro to the first challenge.\nIn the Code tab you will find a code that is missing a single character in order to pass the tests. However, your goal is to submit a function as minimalist as possible. Use the tips in the tips section below.\nWrite a function that returns the boolean True if the given two lists do not share any numbers, and False otherwise.\nTips\nThe operators in and not in test for membership. x in s evaluates to True if x is a member of s, and False otherwise.\nFor example, the code:\ndef startswithvowel(word):\n    for vowel in \"aeiou\":\n        if word[0] == vowel:\n            return True\n    return False\nCan be simplified to:\ndef startswithvowel(word):\n    return word[0] in \"aeiou\"\nBonus\nHere are more examples:\n12 in [1, 50, 12, 43, 7] \u279e True\n1 in [12, 111111, \"x\"] \u279e False\n[3, 4] in [1, 2, 3, 4, 5] \u279e False\n3 in (True, 3, [\"odd\", \"even\"]) \u279e True\n\"odd\" in (True, 3, [\"odd\", \"even\"]) \u279e False\n\"hello\" in \"hellomyfriend\" \u279e True\n\n\"myfriend\" not in \"hello my friend\" \u279e True\n\"bye\" not in \"bye my friend\" \u279e False\n2 not in {0: \"even\", 1: \"odd\"} \u279e True\n1 not in {0: \"even\", 1: \"odd\"} \u279e False\nNotes\nThis is an open series: there isn't a definite list of features for the challenges. Please, do not hesitate to leave your suggestions in the Comments.\nReadability is indeed a subjective concept. Let's discuss it! Feel free to leave your opinion in the Comments.\nYou can find all the exercises in this series over here.", "code": "def not_share(lst1, lst2):\n  return not set(lst1) & set(lst2)"}
{"nl": "Files In Python:\n\nA file is a piece of data or information stored on a computer\u2019s hard drive. You\u2019re already familiar with a variety of file kinds, including music, video, and text files. Manipulation of these files is trivial with Python. Text files and binary files are the two types of files that are commonly used. Binary files contain binary data that can only be read by a computer, whereas text files include plain text.\n\nFor programmers and automation testers, Python file handling (also known as File I/O) is a crucial topic. Working with files is required in order to write to or read data from them.\n\n\n\nIn addition, if you didn\u2019t know, I/O activities are the most expensive techniques via which software might fail. As a result, when implementing file processing for reporting or any other reason, you should proceed with caution. The construction of a high-performance application or a robust solution for automated software testing can benefit from optimizing a single file activity.\n\nGiven a File, the task is to find all the n length words in the given text file and print them.", "code": "# Give the value of n as static input and store it in a variable.\nn = 6\n# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  print('The words of length', n, 'are :')\n  for gvnfileline in givenfilecontent:\n  # Split the words of the line using the split() function and store them in a variable(it is of type list).\n  gvnfilewords = gvnfileline.split()\n  # Loop in the above list using another Nested For loop\n  for word in gvnfilewords:\n  # Check the length of the word is equal to the given value n using the If conditional statement.\n  if(len(word) == n):\n  # If it is true then print it using the print() function.\n  print(word)"}
{"nl": "In this example, we will learn to find all the Armstrong numbers present in between two intervals in Python.", "code": "# Program to check Armstrong numbers in a certain interval\n\nlower = 100\nupper = 2000\n\nfor num in range(lower, upper + 1):\n\n   # order of number\n   order = len(str(num))\n    \n   # initialize sum\n   sum = 0\n\n   temp = num\n   while temp > 0:\n       digit = temp % 10\n       sum += digit ** order\n       temp //= 10\n\n   if num == sum:\n       print(num)"}
{"nl": "In this challenge you will be given a list of numbers. Your task is to \"marry\" each pair of adjacent numbers by adding them, and return the list of \"couples\" (i.e. sums).\nIf the list has an odd length, one number is (sadly) left out, so you should return \"bad match\".\nExamples\nis_good_match([1, 2, 4, 7]) \u279e [1+2, 4+7] \u279e [3, 11]\n\nis_good_match([5, 7, 9, -1, 4, 2]) \u279e [12, 8, 6]\n\nis_good_match([5, 7, 9, -1, 4, 2, 3]) \u279e \"bad match\"\n\nis_good_match([2, 6, 7, -2, 4]) \u279e \"bad match\"\nNotes\nN/A", "code": "def is_good_match(lst):\n  return 'bad match' if len(lst) % 2 else [sum(lst[i:i+2]) for i in range(0, len(), 2)]"}
{"nl": "Mubashir created a simple timer but he needs your help to make it readable inside a microcontroller.\nCreate a function that takes the number of seconds and returns the timer in \"00:00:00\" format.\nExamples\nsimple_timer(0) \u279e \"00:00:00\"\n\nsimple_timer(59) \u279e \"00:00:59\"\n\nsimple_timer(60) \u279e \"00:01:00\"\n\nsimple_timer(3599) \u279e \"00:59:59\"\nNotes\nN/A", "code": "def simple_timer(seconds):\n  h,r=divmod(seconds,3600)\n  m,s=divmod(r,60)\n  return '{:02d}:{:02d}:{:02d}'.format(h,m,s)"}
{"nl": "Write a Python program to print pyramid numbers pattern using for loop.", "code": "rows = int(input(\"Enter Numbers Pyramid Pattern Rows = \"))\n\nprint(\"====The Pyramid of Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(rows, i, -1):\n        print(end = ' ')\n    for k in range(1, i + 1):\n        print(i, end = ' ')\n    print()"}
{"nl": "Bubble Sort Ascending order", "code": "# function which implements the bubble_sort algorithm for givenlist\r\ndef bubbleSort(givenlist):\r\n  # finding the length of given list\r\n    length = len(givenlist)\r\n    # using nested for loops\r\n    for i in range(length-1):\r\n        for j in range(length-i-1):\r\n          # checking if the jth element is greater than j+1 th element\r\n            if(givenlist[j] > givenlist[j+1]):\r\n              # if it is greater then swap the elements\r\n                givenlist[j], givenlist[j+1] = givenlist[j+1], givenlist[j]\r\n\r\n\r\n# given list\r\ngivenlist = [8, 132, 22, 34, 57, 2, 1, 9, 45, 87, 63, 80, 26, 65, 132]\r\n# printing the list before sorting\r\nprint(\"printing the list before sorting :\")\r\nfor i in givenlist:\r\n    print(i, end=\" \")\r\nprint()\r\n# passing this given list to bubbleSort function which sorts the given list\r\nbubbleSort(givenlist)\r\n# printing the list after sorting\r\nprint(\"printing the list after sorting :\")\r\nfor i in givenlist:\r\n    print(i, end=\" \")"}
{"nl": "Create a function that validates whether a number n is within the bounds of lower and upper. Return False if n is not an integer.\nExamples\nint_within_bounds(3, 1, 9) \u279e True\n\nint_within_bounds(6, 1, 6) \u279e False\n\nint_within_bounds(4.5, 3, 8) \u279e False\nNotes\nThe term \"within bounds\" means a number is considered equal or greater than a lower bound and lesser (but not equal) to an upper bound, (see example #2).\nBounds will be always given as integers.", "code": "def int_within_bounds(n, lower, upper):\n  return n in range(lower, upper)"}
{"nl": "Given an n x n matrix, where every row and column is sorted in non-decreasing order. Find the kth smallest element in the given 2D array.\nExample, \n\nInput:k = 3 and array =\n        10, 20, 30, 40\n        15, 25, 35, 45\n        24, 29, 37, 48\n        32, 33, 39, 50 \nOutput: 20\nExplanation: The 3rd smallest element is 20 \n\nInput:k = 7 and array =\n        10, 20, 30, 40\n        15, 25, 35, 45\n        24, 29, 37, 48\n        32, 33, 39, 50 \nOutput: 30\n\nExplanation: The 7th smallest element is 30", "code": "# Program for kth largest element in a 2d array\n# sorted row-wise and column-wise\nfrom sys import maxsize\n\n# A structure to store an entry of heap.\n# The entry contains a value from 2D array,\n# row and column numbers of the value\nclass HeapNode:\n\tdef __init__(self, val, r, c):\n\t\tself.val = val # value to be stored\n\t\tself.r = r # Row number of value in 2D array\n\t\tself.c = c # Column number of value in 2D array\n\n# A utility function to minheapify the node harr[i]\n# of a heap stored in harr[]\ndef minHeapify(harr, i, heap_size):\n\tl = i * 2 + 1\n\tr = i * 2 + 2\n\tif(l < heap_size and r<heap_size and harr[l].val < harr[i].val and harr[r].val < harr[i].val):\n\ttemp= HeapNode(0,0,0)\n\ttemp=harr[r]\n\tharr[r]=harr[i]\n\tharr[i]=harr[l]\n\tharr[l]=temp\n\tminHeapify(harr ,l,heap_size)\n\tminHeapify(harr ,r,heap_size)\n\tif (l < heap_size and harr[l].val < harr[i].val):\n\ttemp= HeapNode(0,0,0)\n\ttemp=harr[i]\n\tharr[i]=harr[l]\n\tharr[l]=temp\n\tminHeapify(harr ,l,heap_size)\n\t\t\t\n# This function returns kth smallest element\n# in a 2D array mat[][]\ndef kthSmallest(mat, n, k):\n\n\t# k must be greater than 0 and smaller than n*n\n\tif k < 0 or k > n * n:\n\t\treturn maxsize\n\n\t# Create a min heap of elements from\n\t# first row of 2D array\n\tharr = [0] * n\n\tfor i in range(n):\n\t\tharr[i] = HeapNode(mat[0][i], 0, i)\n\n\thr = HeapNode(0, 0, 0)\n\tfor i in range(k):\n\n\t\t# Get current heap root\n\t\thr = harr[0]\n\n\t\t# Get next value from column of root's value.\n\t\t# If the value stored at root was last value\n\t\t# in its column, then assign INFINITE as next value\n\t\tnextval = mat[hr.r + 1][hr.c] if (hr.r < n - 1) else maxsize\n\n\t\t# Update heap root with next value\n\t\tharr[0] = HeapNode(nextval, hr.r + 1, hr.c)\n\n\t\t# Heapify root\n\t\tminHeapify(harr, 0, n)\n\n\t# Return the value at last extracted root\n\treturn hr.val\n\n# Driver Code\nif __name__ == \"__main__\":\n\tmat = [[10, 20, 30, 40],\n\t\t[15, 25, 35, 45],\n\t\t[25, 29, 37, 48],\n\t\t[32, 33, 39, 50]]\n\tprint(\"7th smallest element is\",\n\t\t\tkthSmallest(mat, 4, 7))\n\n# This code is contributed by Rishabh Chauhan"}
{"nl": "In this example, you will learn to find the GCD of two numbers using two different methods: function and loops and, Euclidean algorithm", "code": "# Python program to find H.C.F of two numbers\n\n# define a function\ndef compute_hcf(x, y):\n\n# choose the smaller number\n    if x > y:\n        smaller = y\n    else:\n        smaller = x\n    for i in range(1, smaller+1):\n        if((x % i == 0) and (y % i == 0)):\n            hcf = i \n    return hcf\n\nnum1 = 54 \nnum2 = 24\n\nprint(\"The H.C.F. is\", compute_hcf(num1, num2))\n\n# Function to find HCF the Using Euclidian algorithm\ndef compute_hcf(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\nhcf = compute_hcf(300, 400)\nprint(\"The HCF is\", hcf)"}
{"nl": "User Input: Generate first N numbers of Pell Series", "code": "# Give the number N as user input using int(input()) and store it in a variable.\r\nnumb = int(input('Enter some random number = '))\r\n# Take a variable temp1 and initialize it to 1.\r\ntemp1 = 1\r\n# Take another variable temp2 and initialize it to 2.\r\ntemp2 = 2\r\n# Take the third variable temp3 and initialize it to 0.\r\ntemp3 = 0\r\n# Now, print the first two numbers in the series,\r\n# and we'll print the other generated numbers in the order they were generated.\r\nprint('The first', numb, 'numbers of the pell series are :')\r\nprint(temp1, temp2, end=' ')\r\n# Loop till number -2 using For loop.\r\nfor i in range(numb-2):\r\n    # Add the value of temp1 and twice the temp2 value\r\n    # and initialize the temp3 with this value.\r\n    temp3 = temp1+2*temp2\r\n    # Swap the previous number for the previous number's predecessor (temp1 =temp2).\r\n    temp1 = temp2\r\n    # Swap the generated and previously generated numbers (temp2 = temp3)\r\n    temp2 = temp3\r\n    # Print the value of temp3.\r\n    print(temp3, end=' ')"}
{"nl": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\n\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\n\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\n\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.\n\n \n\n", "code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            if sum(nums[:i]) == sum(nums[i+1:]):\n                return i\n        return -1"}
{"nl": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string \"\" if no odd integer exists.\n\nA substring is a contiguous sequence of characters within a string.", "code": "class Solution:\n    def largestOddNumber(self, num: str) -> str:\n        num_r = num[::-1]\n        \n        for index, n in enumerate(num_r):\n            if int(n) %2 != 0:\n                return num_r[index:][::-1]\n            \n        return \"\""}
{"nl": "Create a function that takes:\nA list of keys.\nA list of values (same size).\nTrue, if key and value should be swapped, else False.\nThe function returns the constructed dict. Empty lists return an empty dict.\nExamples\nswap_d([1, 2, 3], [\"one\", \"two\", \"three\"], False)\n\u279e { 1: \"one\", 2: \"two\", 3: \"three\" }\n\nswap_d([1, 2, 3], [\"one\", \"two\", \"three\"], True)\n\u279e { \"one\": 1, \"two\": 2, \"three\": 3 }\n\nswap_d([\"Paris\", 3, 4.5], [\"France\", \"is odd\", \"is half of 9\"], True)\n\u279e { \"France\": \"Paris\", \"is odd\": 3, \"is half of 9\": 4.5 }\nNotes\nTo make it simple, use only hashable (= immutable) keys.\nTo make it simple, use only unique keys.", "code": "def swap_d(k, v, swapped):\n    return dict(zip(v, k)) if swapped else dict(zip(k, v))"}
{"nl": "You are given a binary tree and a given sum. The task is to check if there exist a subtree whose sum of all nodes is equal to the given sum.", "code": "# Python3 program to find if there is a\n# subtree with given sum\n\n# Binary Tree Node\n\"\"\" utility that allocates a newNode\nwith the given key \"\"\"\nclass newnode:\n\n\t# Construct to create a newNode\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# function to check if there exist any\n# subtree with given sum\n# cur_sum -. sum of current subtree\n#\t\t from ptr as root\n# sum_left -. sum of left subtree from\n#\t\t\t ptr as root\n# sum_right -. sum of right subtree\n#\t\t\t from ptr as root\ndef sumSubtreeUtil(ptr,cur_sum,sum):\n\n\t# base condition\n\tif (ptr == None):\n\t\tcur_sum[0] = 0\n\t\treturn False\n\n\t# Here first we go to left sub-tree,\n\t# then right subtree then first we\n\t# calculate sum of all nodes of subtree\n\t# having ptr as root and assign it as cur_sum\n\t# cur_sum = sum_left + sum_right + ptr.data\n\t# after that we check if cur_sum == sum\n\tsum_left, sum_right = [0], [0]\n\tx=sumSubtreeUtil(ptr.left, sum_left, sum)\n\ty=sumSubtreeUtil(ptr.right, sum_right, sum)\n\tcur_sum[0] = (sum_left[0] +\n\t\t\t\tsum_right[0] + ptr.data)\n\treturn ((x or y)or (cur_sum[0] == sum))\n\n# Wrapper over sumSubtreeUtil()\ndef sumSubtree(root, sum):\n\n\t# Initialize sum of subtree with root\n\tcur_sum = [0]\n\n\treturn sumSubtreeUtil(root, cur_sum, sum)\n\n# Driver Code\nif __name__ == '__main__':\n\n\troot = newnode(8)\n\troot.left = newnode(5)\n\troot.right = newnode(4)\n\troot.left.left = newnode(9)\n\troot.left.right = newnode(7)\n\troot.left.right.left = newnode(1)\n\troot.left.right.right = newnode(12)\n\troot.left.right.right.right = newnode(2)\n\troot.right.right = newnode(11)\n\troot.right.right.left = newnode(3)\n\tsum = 22\n\n\tif (sumSubtree(root, sum)) :\n\t\tprint(\"Yes\" )\n\telse:\n\t\tprint(\"No\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Given a matrix and the task is to find the squares of all diagonal elements of a given matrix in python.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[1, 5, 4], [2, 3, 6], [4, 2, 1]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\nprint(\"The squares of diagonal elements of first diagonal:\")\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n is equal to m using the if conditional statement where n\r\n      # is the iterator value of the parent For loop and m is the iterator value of the\r\n      # inner For loop.\r\n        if (n == m):\r\n          # If the statement is true, then print the square of the gvnmatrix[n][m]\r\n            print(mtrx[n][m]**2)\r\n\r\n# Loop till the given number of rows using the For loop.\r\nprint(\"The squares of diagonal elements of second diagonal:\")\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n+m is equal to the mtrxrows-1 using the if conditional\r\n      # statement where n is the iterator value of the parent For loop and\r\n      # m is the iterator value of the inner For loop.\r\n\r\n        if (n+m == mtrxrows-1):\r\n           # If the statement is true, then print the square of the gvnmatrix[n][m]\r\n            print(mtrx[n][m]**2)"}
{"nl": "Given a fraction as a string, return whether or not it is greater than 1 when evaluated.\r\n\r\nExamples\r\ngreater_than_one(\"1/2\") \u279e False\r\n\r\ngreater_than_one(\"7/4\") \u279e True\r\n\r\ngreater_than_one(\"10/10\") \u279e False\r\nNotes\r\nFractions must be strictly greater than 1 (see example #3).", "code": "def greaterThanOne(frac):\r\n\treturn eval(frac) > 1"}
{"nl": "Definition and Usage\r\nThe reverse() method reverses the sorting order of the elements.", "code": "fruits = ['apple', 'banana', 'cherry']\r\n\r\nfruits.reverse()"}
{"nl": "Given a Binary Tree, write a function that returns the size of the largest subtree which is also a Binary Search Tree (BST). If the complete Binary Tree is BST, then return the size of the whole tree.\n\n\n\u00a0", "code": "# Python program to find largest\n# BST in a Binary Tree.\n\u00a0\nINT_MIN = -2147483648\nINT_MAX = 2147483647\n\u00a0\n# Helper function that allocates a new\n# node with the given data and None left\n# and right pointers.\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Returns Information about subtree. The\n# Information also includes size of largest\n# subtree which is a BST\ndef largestBSTBT(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Base cases : When tree is empty or it has\n\u00a0\u00a0\u00a0\u00a0# one child.\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0, INT_MIN, INT_MAX, 0, True\n\u00a0\u00a0\u00a0\u00a0if (root.left == None and root.right == None) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1, root.data, root.data, 1, True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for left subtree and right subtrees\n\u00a0\u00a0\u00a0\u00a0l = largestBSTBT(root.left)\n\u00a0\u00a0\u00a0\u00a0r = largestBSTBT(root.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a return variable and initialize its\n\u00a0\u00a0\u00a0\u00a0# size.\n\u00a0\u00a0\u00a0\u00a0ret = [0, 0, 0, 0, 0]\n\u00a0\u00a0\u00a0\u00a0ret[0] = (1 + l[0] + r[0])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If whole tree rooted under current root is\n\u00a0\u00a0\u00a0\u00a0# BST.\n\u00a0\u00a0\u00a0\u00a0if (l[4] and r[4] and l[1] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.data and r[2] > root.data) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[2] = min(l[2], min(r[2], root.data))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[1] = max(r[1], max(l[1], root.data))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update answer for tree rooted under\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current 'root'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[3] = ret[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[4] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ret\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If whole tree is not BST, return maximum\n\u00a0\u00a0\u00a0\u00a0# of left and right subtrees\n\u00a0\u00a0\u00a0\u00a0ret[3] = max(l[3], r[3])\n\u00a0\u00a0\u00a0\u00a0ret[4] = False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return ret\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\"\"\"Let us construct the following Tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a060\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/ \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a065 70\n\u00a0\u00a0\u00a0\u00a0/\n\u00a0\u00a0\u00a0\u00a050 \"\"\"\n\u00a0\u00a0\u00a0\u00a0root = newNode(60)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(65)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(70)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(50)\n\u00a0\u00a0\u00a0\u00a0print(\"Size of the largest BST is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0largestBSTBT(root)[3])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n\nMinStack() initializes the stack object.\nvoid push(int val) pushes the element val onto the stack.\nvoid pop() removes the element on the top of the stack.\nint top() gets the top element of the stack.\nint getMin() retrieves the minimum element in the stack.", "code": "class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []        \n        \n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.min_stack or x <= self.min_stack[-1]:\n            self.min_stack.append(x)\n    \n    def pop(self) -> None:\n        if self.min_stack[-1] == self.stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]"}
{"nl": "Given a directed and connected graph with n nodes. If there is an edge from u to v then u depends on v. Our task was to find out the sum of dependencies for every node.\n\n\n\u00a0", "code": "# Python3 program to find the sum\u00a0\n# of dependencies\n\u00a0\u00a0\n# To add an edge\ndef addEdge(adj, u, v):\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0adj[u].append(v)\n\u00a0\u00a0\n# Find the sum of all dependencies\ndef findSum(adj, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0sum = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Just find the size at each\u00a0\n\u00a0\u00a0\u00a0\u00a0# vector's index\n\u00a0\u00a0\u00a0\u00a0for u in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += len(adj[u])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return sum\n\u00a0\u00a0\n# Driver code\nif __name__=='__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0V = 4\n\u00a0\u00a0\u00a0\u00a0adj = [[] for i in range(V)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 2)\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 3)\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 1, 3)\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 2, 3)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Sum of dependencies is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0findSum(adj, V))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by rutvik_56\n"}
{"nl": "Parity: Parity of a number refers to whether it contains an odd or even number of 1-bits. The number has \u201codd parity\u201d, if it contains odd number of 1-bits and is \u201ceven parity\u201d if it contains even number of 1-bits. \nMain idea of the below solution is \u2013 Loop while n is not 0 and in loop unset one of the set bits and invert parity.", "code": "# Python3 code to get parity.\n\n# Function to get parity of number n.\n# It returns 1 if n has odd parity,\n# and returns 0 if n has even parity\ndef getParity( n ):\n\tparity = 0\n\twhile n:\n\t\tparity = ~parity\n\t\tn = n & (n - 1)\n\treturn parity\n\n# Driver program to test getParity()\nn = 7\nprint (\"Parity of no \", n,\" = \",\n\t( \"odd\" if getParity(n) else \"even\"))\n\n# This code is contributed by \"Sharad_Bhardwaj\".\n"}
{"nl": "This tutorial will walk you through creating a simple command-line calculator app in Python 3. While we\u2019ll go over one method for creating this software, there are several ways to modify the code and develop a more sophisticated calculator.\n\nTo create our calculator, we\u2019ll employ math operators, variables, conditional statements, functions, and user input.", "code": "givenChoice = input('''\nPlease select which type of operation which we want to apply\\n\nenter + for addition operation\\n\nenter - for subtraction  operation\\n\nenter * for multiplication  operation\\n\nenter / for division  operation\\n''')\n# given two numbers\nnumber1 = int(\n    input(\"Enter the first number of which we wan to do perform calculation: \"))\nnumber2 = int(\n    input(\"Enter the first number of which we wan to do perform calculation: \"))\nif givenChoice == \"+\":\n    # adding the given two numbers\n    print('{} + {} = '.format(number1, number2))\n    print(number1 + number2)\nelif givenChoice == \"-\":\n    # subtracting the given two numbers\n    print('{} - {} = '.format(number1, number2))\n    print(number1 - number2)\nelif givenChoice == \"*\":\n    # multiplying the given two numbers\n    print('{} * {} = '.format(number1, number2))\n    print(number1 * number2)\nelif givenChoice == \"/\":\n    # dividing the given two numbers\n    print('{} / {} = '.format(number1, number2))\n    print(number1 / number2)\nelse:\n    print(\"You have entered the invalid operation\")"}
{"nl": "The left shift operation is similar to multiplication by powers of two, thus, the process is repetitive and can be done recursively.\nSample calculation using the left shift operator (<<):\n10 << 3 = 10 * 2^3 = 10 * 8 = 80\n-32 << 2 = -32 * 2^2 = -32 * 4 = -128\n5 << 2 = 5 * 2^2 = 5 * 4 = 20\nWrite a recursive function that mimics (without the use of <<) the left shift operator and returns the result from the two given integers.\nExamples\nshift_to_left(5, 2) \u279e 20\n\nshift_to_left(10, 3) \u279e 80\n\nshift_to_left(-32, 2) \u279e -128\n\nshift_to_left(-6, 5) \u279e -192\n\nshift_to_left(12, 4) \u279e 192\n\nshift_to_left(46, 6) \u279e 2944\nNotes\nThere will be no negative values for the second parameter y.\nThis challenge is more like recreating of the left shift operation, thus, the use of the operator directly is prohibited.\nYou are expected to solve this challenge via recursion.\nAn iterative version of this challenge can be found via this link.", "code": "def shift_to_left(x, y):\n  return 2 * shift_to_left(x, y-1) if y else x"}
{"nl": "Tarjan Algorithm is based on following facts: \n1. DFS search produces a DFS tree/forest \n2. Strongly Connected Components form subtrees of the DFS tree. \n3. If we can find the head of such subtrees, we can print/store all the nodes in that subtree (including head) and that will be one SCC. \n4. There is no back edge from one SCC to another (There can be cross edges, but cross edges will not be used while processing the graph).\n\nTo find head of a SCC, we calculate disc and low array (as done for articulation point, bridge, biconnected component). As discussed in the previous posts, low[u] indicates earliest visited vertex (the vertex with minimum discovery time) that can be reached from subtree rooted with u. A node u is head if disc[u] = low[u].", "code": "# Python program to find strongly connected components in a given\n# directed graph using Tarjan's algorithm (single DFS)\n#Complexity : O(V+E)\n\nfrom collections import defaultdict\n\n#This class represents an directed graph\n# using adjacency list representation\nclass Graph:\n\n        def __init__(self,vertices):\n                #No. of vertices\n                self.V= vertices\n                \n                # default dictionary to store graph\n                self.graph = defaultdict(list)\n                \n                self.Time = 0\n\n        # function to add an edge to graph\n        def addEdge(self,u,v):\n                self.graph[u].append(v)\n                \n\n        '''A recursive function that find finds and prints strongly connected\n        components using DFS traversal\n        u --> The vertex to be visited next\n        disc[] --> Stores discovery times of visited vertices\n        low[] -- >> earliest visited vertex (the vertex with minimum\n                                discovery time) that can be reached from subtree\n                                rooted with current vertex\n        st -- >> To store all the connected ancestors (could be part\n                of SCC)\n        stackMember[] --> bit/index array for faster check whether\n                                a node is in stack\n        '''\n        def SCCUtil(self,u, low, disc, stackMember, st):\n\n                # Initialize discovery time and low value\n                disc[u] = self.Time\n                low[u] = self.Time\n                self.Time += 1\n                stackMember[u] = True\n                st.append(u)\n\n                # Go through all vertices adjacent to this\n                for v in self.graph[u]:\n                        \n                        # If v is not visited yet, then recur for it\n                        if disc[v] == -1 :\n                        \n                                self.SCCUtil(v, low, disc, stackMember, st)\n\n                                # Check if the subtree rooted with v has a connection to\n                                # one of the ancestors of u\n                                # Case 1 (per above discussion on Disc and Low value)\n                                low[u] = min(low[u], low[v])\n                                                \n                        elif stackMember[v] == True:\n\n                                '''Update low value of 'u' only if 'v' is still in stack\n                                (i.e. it's a back edge, not cross edge).\n                                Case 2 (per above discussion on Disc and Low value) '''\n                                low[u] = min(low[u], disc[v])\n\n                # head node found, pop the stack and print an SCC\n                w = -1 #To store stack extracted vertices\n                if low[u] == disc[u]:\n                        while w != u:\n                                w = st.pop()\n                                print (w, end=\" \")\n                                stackMember[w] = False\n                                \n                        print()\n                        \n        \n\n        #The function to do DFS traversal.\n        # It uses recursive SCCUtil()\n        def SCC(self):\n\n                # Mark all the vertices as not visited\n                # and Initialize parent and visited,\n                # and ap(articulation point) arrays\n                disc = [-1] * (self.V)\n                low = [-1] * (self.V)\n                stackMember = [False] * (self.V)\n                st =[]\n                \n\n                # Call the recursive helper function\n                # to find articulation points\n                # in DFS tree rooted with vertex 'i'\n                for i in range(self.V):\n                        if disc[i] == -1:\n                                self.SCCUtil(i, low, disc, stackMember, st)\n\n\n\n\n\n# Create a graph given in the above diagram\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\nprint (\"SSC in first graph \")\ng1.SCC()\n\ng2 = Graph(4)\ng2.addEdge(0, 1)\ng2.addEdge(1, 2)\ng2.addEdge(2, 3)\nprint (\"nSSC in second graph \")\ng2.SCC()\n\n\ng3 = Graph(7)\ng3.addEdge(0, 1)\ng3.addEdge(1, 2)\ng3.addEdge(2, 0)\ng3.addEdge(1, 3)\ng3.addEdge(1, 4)\ng3.addEdge(1, 6)\ng3.addEdge(3, 5)\ng3.addEdge(4, 5)\nprint (\"nSSC in third graph \")\ng3.SCC()\n\ng4 = Graph(11)\ng4.addEdge(0, 1)\ng4.addEdge(0, 3)\ng4.addEdge(1, 2)\ng4.addEdge(1, 4)\ng4.addEdge(2, 0)\ng4.addEdge(2, 6)\ng4.addEdge(3, 2)\ng4.addEdge(4, 5)\ng4.addEdge(4, 6)\ng4.addEdge(5, 6)\ng4.addEdge(5, 7)\ng4.addEdge(5, 8)\ng4.addEdge(5, 9)\ng4.addEdge(6, 4)\ng4.addEdge(7, 9)\ng4.addEdge(8, 9)\ng4.addEdge(9, 8)\nprint (\"nSSC in fourth graph \")\ng4.SCC();\n\n\ng5 = Graph (5)\ng5.addEdge(0, 1)\ng5.addEdge(1, 2)\ng5.addEdge(2, 3)\ng5.addEdge(2, 4)\ng5.addEdge(3, 0)\ng5.addEdge(4, 2)\nprint (\"nSSC in fifth graph \")\ng5.SCC();\n\n#This code is contributed by Neelam Yadav\n"}
{"nl": "There are three cups on a table, at positions A, B, and C. At the start, there is a ball hidden under the cup at position B.\nHowever, I perform several swaps on the cups, which is notated as two letters. For example, if I swap the cups at positions A and B, I could notate this as AB or BA.\nCreate a function that returns the letter position that the ball is at, once I finish swapping the cups. The swaps will be given to you as a list.\nWorked Example\ncup_swapping([\"AB\", \"CA\", \"AB\"]) \u279e \"C\"\n\n# Ball begins at position B.\n# Cups A and B swap, so the ball is at position A.\n# Cups C and A swap, so the ball is at position C.\n# Cups A and B swap, but the ball is at position C, so it doesn't move.\nExamples\ncup_swapping([\"AB\", \"CA\"]) \u279e \"C\"\n\ncup_swapping([\"AC\", \"CA\", \"CA\", \"AC\"]) \u279e \"B\"\n\ncup_swapping([\"BA\", \"AC\", \"CA\", \"BC\"]) \u279e \"A\"\nNotes\nA swap could be notated in two different ways, since both ways end up with the same outcome.\nAll swaps will be notated as capital letters and will be valid.\nYou cannot swap a cup with itself.", "code": "def cup_swapping(swaps):\n    ball = \"B\"\n    for move in swaps:\n        if ball in move:\n            ball = move[1] if move[0] == ball else move[0]\n    return ball"}
{"nl": "The fileno() method returns the file descriptor of the stream, as a number.\r\n\r\nAn error will occur if the operator system does not use a file descriptor.\n", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.fileno())"}
{"nl": "Given the length, width, and height of a cuboid, the task is to calculate the volume and surface of a given cuboid.", "code": "# Give the length of a cuboid as user input using the float(input()) function and\n# store it in a variable.\ngvn_len = float(input(\"Enter some random number = \"))\n# Give the width of a cuboid as user input using the float(input()) function and\n# store it in another variable.\ngvn_widt = float(input(\"Enter some random number = \"))\n# Give the height of a cuboid as user input using the float(input()) function\n# and store it in another variable.\ngvn_heigt = float(input(\"Enter some random number = \"))\n# Calculate the surface area of a given cuboid using the above given mathematical formula\n# and store it in another variable.\nsurf_area = 2 * (gvn_len * gvn_widt + gvn_len *\n                 gvn_heigt + gvn_widt * gvn_heigt)\n# Calculate the volume of a given cuboid using the above given mathematical formula\n# and store it in another variable.\nVol = gvn_len * gvn_widt * gvn_heigt\n# Calculate the lateral surface area of a given cuboid using the above given mathematical\n# formula and store it in another variable.\nLaterl_surfcarea = 2 * gvn_heigt * (gvn_len + gvn_widt)\n# Print the surface area of a given cuboid.\nprint(\n    \"The given surface Area of a Cuboid with given length,width,height[\", gvn_len, gvn_widt, gvn_heigt, \"]= %.3f\" % surf_area)\n# Print the volume of a given cuboid.\nprint(\n    \"The given volume of a Cuboid with given length,width,height[\", gvn_len, gvn_widt, gvn_heigt, \"]= %.3f\" % Vol)\n# Print the lateral surface area of a given cuboid.\nprint(\n    \"The given lateral surface Area of a Cuboid with given length,width,height[\", gvn_len, gvn_widt, gvn_heigt, \"]= %.3f\" % Laterl_surfcarea)"}
{"nl": "Given a square matrix, find the maximum product of four adjacent elements of the matrix. The adjacent elements of the matrix can be top, down, left, right, diagonal, or anti-diagonal. The four or more numbers should be adjacent to each other. \n\nNote: n should be greater than or equal to 4 i.e n >= 4\n\nExamples : \n\nInput : n = 4\n        {{6, 2, 3 4},\n         {5, 4, 3, 1},\n         {7, 4, 5, 6},\n         {8, 3, 1, 0}}\n\nOutput : 1680 \n\nExplanation:\nMultiplication of 6 5 7 8 produces maximum\nresult and all element are adjacent to \neach other in one direction\n\nInput : n = 5\n        {{1, 2, 3, 4, 5},\n         {6, 7, 8, 9, 1},\n         {2, 3, 4, 5, 6},\n         {7, 8, 9, 1, 0},\n         {9, 6, 4, 2, 3}}\n\n\nOutput: 3024\n\nExplanation:\nMultiplication of 6 7 8 9 produces maximum \nresult and all elements are adjacent to\neach other in one direction.", "code": "# Python3 program to find out the maximum\n# product in the matrix which four elements\n# are adjacent to each other in one direction\nn = 5\n\u00a0\n# function to find max product\ndef FindMaxProduct(arr, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0max = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# iterate the rows.\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# iterate the columns.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range( n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in horizontal row.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((j - 3) >= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i][j - 1] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j - 2] * arr[i][j - 3])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in vertical row.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i - 3) >= 0) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i - 1][j] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i - 2][j] * arr[i - 3][j])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# diagonal going through down - right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i - 3) >= 0 and (j - 3) >= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i - 1][j - 1] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i - 2][j - 2] * arr[i - 3][j - 3])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# diagonal going through up - right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i - 3) >= 0 and (j - 1) <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i - 1][j + 1] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i - 2][j + 2] * arr[i - 3][j + 3])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return max\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# int arr[][4] = {{6, 2, 3, 4},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {5, 4, 3, 1},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {7, 4, 5, 6},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {8, 3, 1, 0}};\n\u00a0\u00a0\u00a0\u00a0# int arr[][5] = {{1, 2, 1, 3, 4},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {5, 6, 3, 9, 2},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {7, 8, 8, 1, 2},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {1, 0, 7, 9, 3},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {3, 0, 8, 4, 9}};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0arr = [[1, 2, 3, 4, 5],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[6, 7, 8, 9, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 3, 4, 5, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[7, 8, 9, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[9, 6, 4, 2, 3]]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(FindMaxProduct(arr, n))\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": "Given a square matrix of order N*N having distinct elements, the task is to sort given matrix in such a way that its rows, columns and both diagonals (diagonal and anti-diagonal) are in increasing order.\n\n\n\u00a0", "code": "# Python program to sort matrix in all-way\nN = 3;\n\u00a0\n# Sorts a matrix in increasing order\ndef sortAllWay(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Consider matrix elements (in row major\n\u00a0\u00a0\u00a0\u00a0# order) and sort the sequence.\n\u00a0\u00a0\u00a0\u00a0ar = [0 for i in range(len(arr) * len(arr))];\n\u00a0\u00a0\u00a0\u00a0k = 0;\n\u00a0\u00a0\u00a0\u00a0for i in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ar[k] = arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k += 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0ar.sort();\n\u00a0\u00a0\u00a0\u00a0k = 0;\n\u00a0\u00a0\u00a0\u00a0for i in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = ar[k];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k += 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return arr;\n\u00a0\n# Driver program\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0arr = [[ 1, 0, 3 ],[ 2, 5, 6 ],[ 9, 4, 8 ]] ;\n\u00a0\u00a0\u00a0\u00a0arr = sortAllWay(arr);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# print resultant matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(arr[i][j], end=\" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print();\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code IS contributed by umadevi9616\n"}
{"nl": "Given a string, the task is to rearrange the letters of a string in Alphabetical order in Python.\n Examples:\n Example1:\n Input:\n Given string = btechgeeks\n Output:\n The original string is [ btechgeeks ]\n \n The modified string after reordering the letters of a string alphabetically is [ bceeeghkst ]\n Example2:\n Input:\n Given string =Good morning this is BTechgeeks\n Output:\n Enter some random string = Good morning this is BTechgeeks\n \n The original string is [ Good morning this is BTechgeeks ]\n \n The modified string after reordering the letters of a string alphabetically is [ BGTcdeeegghhiiikmnnooorssst ]", "code": "# Give the string as static input and store it in variable.\n \n gvnstrng = 'btechgeeks'\n \n # Reorder the letters of a string alphabetically using\n \n # the sorted function(This method returns a list of letters in alphabetical order).\n \n sortdstrng = sorted(gvnstrng)\n \n # Join this using the join() function.\n \n finalstrng = ''.join(sortdstrng)\n \n # Print the modified string after reordering the letters of a string alphabetically.\n \n print('The original string is [', gvnstrng, ']')\n \n print(\n \n  'The modified string after reordering the letters of a string alphabetically is [', finalstrng, ']')\n \n </pre>"}
{"nl": "You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).\n\nYou want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.\n\nReturn the maximum k you can choose such that p is still a subsequence of s after the removals.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.", "code": "class Solution:\n    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\n        left = 0\n        right = len(removable)\n        while left < right:\n            mid = (left + right + 1) // 2\n            res = self.helper(s, set(removable[:mid]), p)\n            if res == True:\n                left = mid\n            else:\n                right = mid - 1\n            \n        return left\n        \n    def helper(self, s, removed, p):\n        # return a true or false\n        slist = list(s)\n        slist = [slist[i] for i in range(len(slist)) if i not in removed]\n        \n        idx = 0\n        for char in slist:\n            if char == p[idx]:\n                idx += 1\n            if idx == len(p):\n                return True\n        \n        return False"}
{"nl": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = -\u221e.\n\nYou must write an algorithm that runs in O(log n) time.", "code": "def findPeakElement(self, nums):\n    left = 0\n    right = len(nums)-1\n\n    # handle condition 3\n    while left < right-1:\n        mid = (left+right)/2\n        if nums[mid] > nums[mid+1] and nums[mid] > nums[mid-1]:\n            return mid\n            \n        if nums[mid] < nums[mid+1]:\n            left = mid+1\n        else:\n            right = mid-1\n            \n    #handle condition 1 and 2\n    return left if nums[left] >= nums[right] else right"}
{"nl": "In mathematics, a Cartesian coordinate system is a coordinate system that specifies each point uniquely in a plane by a set of numeric points.\r\n\r\nCartesian Coordinates is represented by (x,y).\r\n\r\nIn mathematics, the polar coordinate system is a two-dimensional coordinate system in which each point on a plane is determined by a distance from a reference point known as radius and an angle from a reference direction known as theta or simply angle.\r\n\r\nPolar Coordinates system is represented by (r,\u03b8).\r\n\r\nFormula: Polar to Cartesian\r\nTo convert from Polar Coordinates (r,\u03b8) to Cartesian Coordinates (x,y) :\r\nx = r \u00d7 cos( \u03b8 )\r\ny = r \u00d7 sin( \u03b8 )\r\nThis python programs converts Polar Coordinate given by user to Cartesian Coordinate using Polar to Cartesian Conversion Formula.", "code": "# Converting Polar Coordinate to Cartesian Coordinates\r\n# Importing math library\r\nimport math\r\n\r\n# Reading radius and angle of polar coordinate\r\nradius = float(input('Enter radius: '))\r\ntheta = float(input('Enter theta in degree: '))\r\n\r\n# Converting theta from degree to radian\r\ntheta = theta * math.pi/180.0;\r\n\r\n# Converting polar to cartesian coordinates\r\nx = radius * math.cos(theta)\r\ny = radius * math.sin(theta)\r\n\r\n# Displaying cartesian coordinates\r\nprint('Cartesian coordinate is: (x = %0.2f, y = %0.2f)' %(x,y))"}
{"nl": "Given two arrays A[] and B[] consisting of n and m elements respectively. Find the minimum number of elements to remove from each array such that no common element exist in both.\nExamples: \n \n\nInput : A[] = { 1, 2, 3, 4}\n        B[] = { 2, 3, 4, 5, 8 }\nOutput : 3\nWe need to remove 2, 3 and 4 from any array.\n\nInput : A[] = { 4, 2, 4, 4}\n        B[] = { 4, 3 }\nOutput : 1\nWe need to remove 4 from B[]\n\nInput : A[] = { 1, 2, 3, 4 }\n        B[] = { 5, 6, 7 }\nOutput : 0\nThere is no common element in both.\n", "code": "# Python3 program to find minimum\n# element to remove so no common\n# element exist in both array\n\n# To find no elements to remove\n# so no common element exist\ndef minRemove(a, b, n, m):\n\n\t# To store count of array element\n\tcountA = dict()\n\tcountB = dict()\n\n\t# Count elements of a\n\tfor i in range(n):\n\t\tcountA[a[i]] = countA.get(a[i], 0) + 1\n\n\t# Count elements of b\n\tfor i in range(n):\n\t\tcountB[b[i]] = countB.get(b[i], 0) + 1\n\n\t# Traverse through all common\n\t# element, and pick minimum\n\t# occurrence from two arrays\n\tres = 0\n\tfor x in countA:\n\t\tif x in countB.keys():\n\t\t\tres += min(countA[x],countB[x])\n\n\t# To return count of\n\t# minimum elements\n\treturn res\n\n# Driver Code\na = [ 1, 2, 3, 4 ]\nb = [2, 3, 4, 5, 8 ]\nn = len(a)\nm = len(b)\nprint(minRemove(a, b, n, m))\n\n# This code is contributed\n# by mohit kumar"}
{"nl": "Print only consonants in Python | Here, we use the for loop and list comprehension to print consonants in a string in Python. The letters \u2018a\u2019, \u2018e\u2019, \u2018i\u2019, \u2018o\u2019, \u2018u\u2019 and \u2018A\u2019, \u2018E\u2019, \u2018I\u2019, \u2018O\u2019, \u2018U\u2019 are called vowels letters.", "code": "# print only consonants in given string def printConsonants(string): # printing consonants for c in string: if c not in \"AEIOUaeiou \": print(c, end=', ') return c # input from the user string = input('String: ') # call the function printConsonants(string)"}
{"nl": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n\nWhat if we change the game so that players cannot re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.", "code": "def canIWin(self, maxInt: int, total: int) -> bool:\n        @functools.lru_cache(None)\n        def dp(nums, left):\n            return any(left - n <= 0 or not dp(frozenset(nums - {n}), left - n) for n in nums)\n        \n        return  (1 + maxInt) * maxInt // 2 >= total and dp(frozenset(range(1, maxInt + 1)), total)"}
{"nl": "Given the number of rows and number of columns of the box, the task is to print the Hollow Box Number pattern in C, C++, and python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven number of rows of the box =11\ngiven number of columns of the box =19\nOutput:\n\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1  1 \n1  1 \n1  1 \n1  1 \n1  1 \n1  1 \n1  1 \n1  1 \n1  1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\nExample2:\n\nInput:\n\ngiven number of rows of the box =11\ngiven number of columns of the box =19\ngiven character to print ='&'\nOutput:\n\n& & & & & & & & & & & & & \n&  & \n&  & \n&  & \n&  & \n&  & \n&  & \n&  & \n& & & & & & & & & & & & &", "code": "# Give the number of rows and number of columns of the box as static or user input\n# and store them in two separate variables.\nboxrows = 11\nboxcolumns = 19\n# Loop from 1 to the number of rows of the box +1 using a For loop.\nfor m in range(1, boxrows+1):\n  # Loop from 1 to the number of columns of the box +1 using another Nested For loop.\n  for n in range(1, boxcolumns+1):\n  '''Check if the parent iterator value is equal to 1 or the number of rows of the box using the If statement.\n  Check if the inner loop iterator value is equal to 1 or the number of columns of the box using the If statement.\n  Merge these two conditions in a single If statement using or operator.  \n  '''\n  if(m == 1 or m == boxrows or n == 1 or n == boxcolumns):\n  # If the condition is true then print 1 with a space character.\n  print(\"1\", end=\" \")\n  else:\n  # Else print space character.\n  print(\" \", end=\" \")\n  # Print the newline character after the end of the inner For loop.\n  print()"}
{"nl": "A snail goes up the stairs. Every step, he must go up the step, then go across to the next step. He wants to reach the top of the tower.\nWrite a function that returns the distance the snail must travel to the top of the tower given the height and length of each step and the height of the tower.\nExamples\ntotal_distance(0.2, 0.4, 100.0) \u279e 300.0\n# Total distance is 300.\n\ntotal_distance(0.3, 0.2, 25.0) \u279e 41.7\n\ntotal_distance(0.1, 0.1, 6.0) \u279e 12.0\nNotes\nAll given values are greater than 0.\nRound answers to the nearest tenth 0.1.\nNumber of steps determined by tower height divided by stair height.\nFor the purposes of this exercise, the last step's length must be counted to complete the journey.", "code": "def total_distance(height, length, tower):\n  return round(((tower/height)*(height+length)),1)"}
{"nl": "Sort Palindrome Words in a Sentence Using Sort() function (Static input)", "code": "# Give the sentence/string as static input and store it in a variable.\r\ngvnstrng = 'sos how are you madam pip instal'\r\n# Convert the given sentence to a list of words using list()\r\n# and split() functions and store it another variable.\r\nstrngwrdslst = list(gvnstrng.split())\r\n# Take an empty list to say palindromicwordslist\r\n# that stores all the palindromic words in the given string\r\n# and initialize it to null/empty using the list() function or [].\r\npalindromicwordslist = []\r\n# Traverse the given list of words using a for loop.\r\nfor wrd in strngwrdslst:\r\n        # Check if the word is palindrome or not using the slicing\r\n    # and if conditional statement.\r\n    if(wrd == wrd[::-1]):\r\n        # If it is true then append this word to the palindromicwordslist\r\n        # using the append() function.\r\n        palindromicwordslist.append(wrd)\r\n\r\n# Sort the palindromicwordslist using the sort() function.\r\npalindromicwordslist.sort()\r\n# Take a variable say tempo and initialize its value to 0\r\n# (Here it acts as a pointer to palindromicwordslist ).\r\ntempo = 0\r\n# Traverse the list of words of the given sentence using the For loop.\r\nfor wrditr in range(len(strngwrdslst)):\r\n  # Check if the word is palindrome or not using the slicing\r\n    # and if conditional statement.\r\n    if(strngwrdslst[wrditr] == strngwrdslst[wrditr][::-1]):\r\n        # If it is true then modify the word with the palindromicwordslist[tempo] word.\r\n        strngwrdslst[wrditr] = palindromicwordslist[tempo]\r\n        tempo = tempo+1\r\n        # Increment the tempo value by 1.\r\n\r\n\r\n# Convert this list of words of the given sentence\r\n# to the string using the join() function.\r\nfinalstrng = ' '.join(strngwrdslst)\r\nprint('The given string before sorting all the palindromic words is = ', gvnstrng)\r\n# Print the final string after sorting the palindromic words.\r\nprint('The final string after sorting all the palindromic words is = ', finalstrng)"}
{"nl": "Given two numbers \u2018a\u2019 and b\u2019. Write a program to count number of bits needed to be flipped to convert \u2018a\u2019 to \u2018b\u2019. \nExample : \n \n\nInput : a = 10, b = 20\nOutput : 4\nBinary representation of a is 00001010\nBinary representation of b is 00010100\nWe need to flip highlighted four bits in a\nto make it b.\n\nInput : a = 7, b = 10\nOutput : 3\nBinary representation of a is 00000111\nBinary representation of b is 00001010\nWe need to flip highlighted three bits in a\nto make it b.", "code": "# Count number of bits to be flipped\n# to convert A into B\n\n# Function that count set bits\ndef countSetBits( n ):\n\tcount = 0\n\twhile n:\n\t\tcount += 1\n\t\tn &= (n-1)\n\treturn count\n\t\n# Function that return count of\n# flipped number\ndef FlippedCount(a , b):\n\n\t# Return count of set bits in\n\t# a XOR b\n\treturn countSetBits(a^b)\n\n# Driver code\na = 10\nb = 20\nprint(FlippedCount(a, b))\n\n# This code is contributed by \"Sharad_Bhardwaj\"."}
{"nl": "Create a recursive function that determines whether a word is a palindrome or not.\nExamples\nis_palindrome(\"madam\") \u279e true\n\nis_palindrome(\"adieu\") \u279e false\n\nis_palindrome(\"rotor\") \u279e true\nNotes\nAll inputs are in lowercase.\nYou are expected to solve this challenge via recursion.\nYou can check on the Resources tab for more details about recursion.", "code": "def is_palindrome(wrd):\n  return wrd == \"\" or (wrd[0] == wrd[-1] and is_palindrome(wrd[1:-1]))"}
{"nl": "lPaeesh le pemu mnxit ehess rtnisg! Oh, sorry, that was supposed to say: Please help me unmix these strings!\nSomehow my strings have all become mixed up; every pair of characters has been swapped. Help me undo this so I can understand my strings again.\nExamples\nunmix(\"123456\") \u279e \"214365\"\n\nunmix(\"hTsii  s aimex dpus rtni.g\") \u279e \"This is a mixed up string.\"\n\nunmix(\"badce\") \u279e \"abcde\"\nNotes\nThe length of a string can be odd \u2014 in this case the last character is not altered (as there's nothing to swap it with).", "code": "def unmix(txt):\n  return ''.join(txt[i:i+2][::-1] for i in range(0,len(txt),2))"}
{"nl": null, "code": null}
{"nl": "Write a function that returns the position of the second occurrence of \"zip\" in a string, or -1 if it does not occur at least twice. Your code should be general enough to pass every possible case where \"zip\" can occur in a string.", "code": "def find_zip(txt):\n        return txt.find(\"zip\", txt.find(\"zip\")+1)"}
{"nl": "Mubashir was playing with dominos. He concluded that:\nIf the first domino is pushed over, it will keep tipping next dominos to its right.\nReaction will stop if a domino is already tipped over, or if there is an empty space.\nCreate a function which takes a string of current status of the dominos and returns the string after dominos chain reaction.\n\"|\" represents a standing domino.\n\"/\" represents a tripped domino.\n\" \" represents an empty space.\nExamples\ndomino_chain(\"||| ||||//| |/\") \u279e \"/// ||||//| |/\"\n// A space will stop the reaction.\n\ndomino_chain(\"||//||\") \u279e \"////||\"\n// An already tripped domino will stop the reaction.\n\ndomino_chain(\"||||\") \u279e \"////\"\nNotes\nN/A", "code": "def domino_chain(dominos):\n  dominos = list(dominos)\n  for i, d in enumerate(dominos):\n    if d in [' ', '/']:\n      break\n    dominos[i] = '/'\n  return ''.join(dominos)"}
{"nl": "This python program generates hollow right angle triangle pattern made of stars up to n lines.\r\nIn this python example, we first read number of row in the hollow right angle triangle pattern from user using built-in function input(). And then we generate hollow right angle triangle pattern using python's for loop.", "code": "# Hollow Right Angle Triangle Pattern Using Stars\r\n\r\nrow = int(input('Enter number of rows required: '))\r\n\r\nfor i in range(row):\r\n    for j in range(i+1):\r\n        if j==0 or j==i or i==row-1:\r\n            print('*',end=\" \")\r\n        else:\r\n            print(\" \", end=\" \")\r\n    print()"}
{"nl": "Given an array and a number k where k is smaller than the size of the array, we need to find the k\u2019th smallest element in the given array. It is given that all array elements are distinct.\n\nExamples:  \n\n\n\nInput: arr[] = {7, 10, 4, 3, 20, 15} \nk = 3 \nOutput: 7\n\nInput: arr[] = {7, 10, 4, 3, 20, 15} \nk = 4 \nOutput: 10 \n ", "code": "# Python3 program to find k'th smallest\n# element\n\n# Function to return k'th smallest\n# element in a given array\ndef kthSmallest(arr, n, k):\n\n\t# Sort the given array\n\tarr.sort()\n\n\t# Return k'th element in the\n\t# sorted array\n\treturn arr[k-1]\n\n# Driver code\nif __name__=='__main__':\n\tarr = [12, 3, 5, 7, 19]\n\tn = len(arr)\n\tk = 2\n\tprint(\"K'th smallest element is\",\n\t\tkthSmallest(arr, n, k))\n\n# This code is contributed by\n# Shrikant13"}
{"nl": "For this question, treat people as existing only on integers.\nTwo ice cream stands: A and B each occupy a spot on the beach, from [0, 100]. Their positions are represented with coordinates (A, B). One position could be:\n[32, 69]\nPeople are distributed equally from [0, 100], and will purchase ice cream from the stand closest to them.\nFor (A, B) above, we have that everyone from[0, 50] goes to A and everyone from [51, 100] goes to B. People on 50 will go to A because |50 - 32| = 18 < 19 = |50 - 69|, and people on 51 will go to B because |51 - 69| = 18 < 19 = |51 - 32|.\nprofit = total number of integers claimed by the ice cream stand\nWrite a function that calculates the profit for each ice cream stand based on their position. For the example above, profit(32, 69) = [51, 50].\nDisregard ties. For instance, if (A, B) = (49, 51), disregard the person on 50. Profit is equally distributed in this case, with profit(49, 51) = [50, 50].\nExamples\nprofit(32, 69) \u279e [51, 50]\n\nprofit(49, 51) \u279e [50, 50]\n\nprofit(0, 1) \u279e [1, 100]\nNotes\nA < B will always be true.\nA and B will never occupy the same spot.", "code": "def profit(A, B):\n  return [(A+B+1)//2,100-(A+B)//2]"}
{"nl": "You will be given a list of string \"east\" formatted differently every time. Create a function that returns \"west\" wherever there is \"east\". Format the string according to the input. Check the examples below to better understand the question.\nExamples\ndirection([\"east\", \"EAST\", \"eastEAST\"]) \u279e [\"west\", \"WEST\", \"westWEST\"]\n\ndirection([\"eAsT EaSt\", \"EaSt eAsT\"]) \u279e [\"wEsT WeSt\", \"WeSt wEsT\"]\n\ndirection([\"east EAST\", \"e a s t\", \"E A S T\"]) \u279e [\"west WEST\", \"w e s t\", \"W E S T\"]\nNotes\nThe input will only be \"east\" in different formats.", "code": "def direction(lst):\n  return [i.translate(str.maketrans('eEaA','wWeE')) for i in lst]"}
{"nl": "Given a binary tree, print it vertically. The following example illustrates the vertical order traversal.\n\n           1\n        /    \\ \n       2      3\n      / \\   /   \\\n     4   5  6   7\n               /  \\ \n              8   9 \n               \n              \nThe output of print this tree vertically will be:\n4\n2\n1 5 6\n3 8\n7\n9", "code": "# Python program for printing vertical order of a given\n# binary tree\n\n# A binary tree node\nclass Node:\n\t# Constructor to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\n# Utility function to store vertical order in map 'm'\n# 'hd' is horizontal distance of current node from root\n# 'hd' is initially passed as 0\ndef getVerticalOrder(root, hd, m):\n\n\t# Base Case\n\tif root is None:\n\t\treturn\n\t\n\t# Store current node in map 'm'\n\ttry:\n\t\tm[hd].append(root.key)\n\texcept:\n\t\tm[hd] = [root.key]\n\t\n\t# Store nodes in left subtree\n\tgetVerticalOrder(root.left, hd-1, m)\n\t\n\t# Store nodes in right subtree\n\tgetVerticalOrder(root.right, hd+1, m)\n\n# The main function to print vertical order of a binary\n#tree ith given root\ndef printVerticalOrder(root):\n\t\n\t# Create a map and store vertical order in map using\n\t# function getVerticalORder()\n\tm = dict()\n\thd = 0\n\tgetVerticalOrder(root, hd, m)\n\t\n\t# Traverse the map and print nodes at every horizontal\n\t# distance (hd)\n\tfor index, value in enumerate(sorted(m)):\n\t\tfor i in m[value]:\n\t\t\tprint (i,end=\" \")\n\t\tprint()\n\n\n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nroot.right.left.right = Node(8)\nroot.right.right.right = Node(9)\nprint (\"Vertical order traversal is\")\nprintVerticalOrder(root)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)"}
{"nl": "Write a function that converts a dictionary into a list of keys-values tuples.\nExamples\ndict_to_list({\n  \"D\": 1,\n  \"B\": 2,\n  \"C\": 3\n}) \u279e [(\"B\", 2), (\"C\", 3), (\"D\", 1)]\n\ndict_to_list({\n  \"likes\": 2,\n  \"dislikes\": 3,\n  \"followers\": 10\n}) \u279e [(\"dislikes\", 3), (\"followers\", 10), (\"likes\", 2)]\nNotes\nReturn the elements in the list in alphabetical order.", "code": "def dict_to_list(d):\n  return sorted(d.items())"}
{"nl": "Given an unsorted array of integers, sort the array into a wave like array. An array \u2018arr[0..n-1]\u2019 is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= \u2026..\n\nExamples: \n\n\n\n Input:  arr[] = {10, 5, 6, 3, 2, 20, 100, 80}\n Output: arr[] = {10, 5, 6, 2, 20, 3, 100, 80} OR\n                 {20, 5, 10, 2, 80, 6, 100, 3} OR\n                 any other array that is in wave form\n\n Input:  arr[] = {20, 10, 8, 6, 4, 2}\n Output: arr[] = {20, 8, 10, 4, 6, 2} OR\n                 {10, 8, 20, 2, 6, 4} OR\n                 any other array that is in wave form\n\n Input:  arr[] = {2, 4, 6, 8, 10, 20}\n Output: arr[] = {4, 2, 8, 6, 20, 10} OR\n                 any other array that is in wave form\n\n Input:  arr[] = {3, 6, 5, 10, 7, 20}\n Output: arr[] = {6, 3, 10, 5, 20, 7} OR\n                 any other array that is in wave form\n ", "code": "# Python function to sort the array arr[0..n-1] in wave form,\n# i.e., arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= arr[5]\ndef sortInWave(arr, n):\n\t\n\t# Traverse all even elements\n\tfor i in range(0, n, 2):\n\t\t\n\t\t# If current even element is smaller than previous\n\t\tif (i> 0 and arr[i] < arr[i-1]):\n\t\t\tarr[i],arr[i-1] = arr[i-1],arr[i]\n\t\t\n\t\t# If current even element is smaller than next\n\t\tif (i < n-1 and arr[i] < arr[i+1]):\n\t\t\tarr[i],arr[i+1] = arr[i+1],arr[i]\n\n# Driver program\narr = [10, 90, 49, 2, 1, 5, 23]\nsortInWave(arr, len(arr))\nfor i in range(0,len(arr)):\n\tprint (arr[i],end=\" \")\n\t\n# This code is contributed by __Devesh Agrawal__"}
{"nl": "The or keyword is a logical operator.\r\n\r\nLogical operators are used to combine conditional statements.\r\n\r\nThe return value will be True if one of the statements return True, otherwise it will return False.\r\n\r", "code": "x = (5 > 3 or 5 > 10)\r\n\r\nprint(x)"}
{"nl": "Given an integer n, find a sequence that satisfies all of the following:\n\nThe integer 1 occurs once in the sequence.\nEach integer between 2 and n occurs twice in the sequence.\nFor every integer i between 2 and n, the distance between the two occurrences of i is exactly i.\n\nThe distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.\nReturn the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution. \nA sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.\n \nExample 1:\n\nInput: n = 3\nOutput: [3,1,2,3,2]\nExplanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.\n\nExample 2:\n\nInput: n = 5\nOutput: [5,3,1,4,3,5,2,4,2]\n\n \nConstraints:\n\n1 <= n <= 20", "code": "class Solution:\n  def constructDistancedSequence(self, n: int) -> List[int]:\n  \n  arr = [0]*(2*n-1)  # the array we want to put numbers. 0 means no number has been put here\n  i = 0  # current index to put a number  \n  vi = [False] * (n+1)  # check if we have used that number\n  \n# backtracking\n  def dfs(arr, i, vi):\n  # if we already fill the array successfully, return True\n  if i >= (2*n-1):\n  return True\n\n# try each number from n to 1\n  for x in range(n, 0, -1):\n  # two cases:\n  # x > 1, we check two places. Mind index out of bound here.\n  # x = 1, we only check one place\n# arr[i] == 0 means index i is not occupied\n  if (x > 1 and ((not (arr[i] == 0 and (i+x < 2*n-1) and arr[i+x] == 0)) or vi[x]))  \\\nor (x == 1 and (arr[i] != 0 or vi[x])):\n  continue\n\n# if it can be placed, then place it\n  if x > 1:\n  arr[i] = x\n  arr[i+x] = x\n  else:\n  arr[i] = x\n  vi[x] = True\n\n# find the next available place\n  nexti = i+1\n  while nexti < 2*n-1 and arr[nexti]:\n  nexti += 1\n\n# place the next one\n  if dfs(arr, nexti, vi):\n# if it success, it is already the lexicographically largest one, we don't search anymore\n  return True\n\n# backtracking... restore the state\n  if x > 1:\n  arr[i] = 0\n  arr[i+x] = 0\n  else:\n  arr[i] = 0\n  vi[x] = False\n\n# we could not find a solution, return False\n  return False\n\n  dfs(arr, i, vi)\n  return arr"}
{"nl": "A coloured triangle is created from different rows of colours (Red, Green or Blue). Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row. If these colours are identical, the same colour is used in the new row. If colours are different, the missing colour is used in the new row. This process continues untill a single colour is generated in the final row.\nDifferent possibilities of colours are:\nColours Touching:        G G        B G        R G        B R\nNew colour:               G          R          B          G\nWith a bigger example:\nR R G B R G B B\n R B R G B R B\n  G G B R G G\n   G R G B G\n    B B R R\n     B G R\n      R B\n       G\nGoal\nCreate a function which takes first row of the triangle as an input and returns the final colour which would appear at the bottom row. In above example, given input \"RRGBRGBB\" will return \"G\".\nIf you are only given one colour as the input, return that colour.\nThere will be no exception handling case.\nExamples\ncoloured_triangle(\"B\") \u279e \"B\"\n\ncoloured_triangle(\"GB\") \u279e \"R\"\n\ncoloured_triangle(\"RBRGBRB\") \u279e \"G\"\nNotes\nN/A", "code": "def coloured_triangle(row):\n  if len(row) == 1:\n    return row\n  elif len(row) > 2:\n    return ''.join(sorted(set(row), key=row.index))[-1]\n  else:\n    return 'R'"}
{"nl": "You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi.\nA connected trio is a set of three nodes where there is an edge between every pair of them.\nThe degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.\nReturn the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.\n \nExample 1:\n\n\nInput: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\nOutput: 3\nExplanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.\n\nExample 2:\n\n\nInput: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\nOutput: 0\nExplanation: There are exactly three trios:\n1) [1,4,3] with degree 0.\n2) [2,5,6] with degree 2.\n3) [5,6,7] with degree 2.\n\n \nConstraints:\n\n2 <= n <= 400\nedges[i].length == 2\n1 <= edges.length <= n * (n-1) / 2\n1 <= ui, vi <= n\nui != vi\nThere are no repeated edges.", "code": "def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n  graph = defaultdict(set)\n  for u, v in edges:\n  graph[u].add(v)\n  graph[v].add(u)\n  \n  min_degree = float('inf')\n  for u in sorted(range(1, n + 1), key=lambda x: len(graph[x])):\n  if len(graph[u]) >= min_degree / 3:\n  break\n  for v in graph[u]:  \n  for w in graph[v]:\n  if w in graph[u]:\n  min_degree = min(min_degree, len(graph[u]) + len(graph[v]) + len(graph[w]))\n  return min_degree - 6 if min_degree != float('inf') else -1"}
{"nl": null, "code": null}
{"nl": "Given a BST and a sum, find if there is a pair with given sum.", "code": "# Python3 program to find a pair with\n# given sum using hashing\nimport sys\nimport math\n\u00a0\n\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n\u00a0\ndef insert(root, data):\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(data)\n\u00a0\u00a0\u00a0\u00a0if(data < root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, data)\n\u00a0\u00a0\u00a0\u00a0if(data > root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, data)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\ndef findPairUtil(root, summ, unsorted_set):\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0if findPairUtil(root.left, summ, unsorted_set):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0if unsorted_set and (summ-root.data) in unsorted_set:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Pair is Found ({},{})\".format(summ-root.data, root.data))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsorted_set.add(root.data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return findPairUtil(root.right, summ, unsorted_set)\n\u00a0\n\u00a0\ndef findPair(root, summ):\n\u00a0\u00a0\u00a0\u00a0unsorted_set = set()\n\u00a0\u00a0\u00a0\u00a0if(not findPairUtil(root, summ, unsorted_set)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Pair do not exist!\")\n\u00a0\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 8)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 12)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 16)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 25)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0summ = 33\n\u00a0\u00a0\u00a0\u00a0findPair(root, summ)\n\u00a0\n# This code is contributed by Vikash Kumar 37\n"}
{"nl": "In the world of birding there are four-letter codes for the common names of birds. These codes are created by some simple rules:\nIf the bird's name has only one word, the code takes the first four letters of that word.\nIf the name is made up of two words, the code takes the first two letters of each word.\nIf the name is made up of three words, the code is created by taking the first letter from the first two words and the first two letters from the third word.\nIf the name is four words long, the code uses the first letter from all the words.\nThere are other ways codes are created, but this challenge will only use the four rules listed above.\nIn this challenge you will write a function that takes a list of strings of common bird names and create the codes for those names based on the rules above. The function will return a list of codes in the same order in which the input names were presented.\nExamples\nbird_code([\"Black-Capped Chickadee\", \"Common Tern\"]) \u279e [\"BCCH\", \"COTE\"]\n\nbird_code([\"American Redstart\", \"Northern Cardinal\"]) \u279e [\"AMRE\",\"NOCA\"]\n\nbird_code([\"Bobolink\", \"American White Pelican\"]) \u279e [\"BOBO\",\"AWPE\"]\nNotes\nThe four-letter codes in the returned list should be in UPPER CASE.\nIf a common name has a hyphen/dash, it should be considered a space.", "code": "def bird_code(lst):\n  def f(name):\n    w=name.replace('-',' ').upper().split()\n    s={1:[4],2:[2,2],3:[1,1,2],4:[1,1,1,1]}[len(w)]\n    return ''.join(x[:l] for x, l in zip(w, s))\n  return list(map(f,lst))"}
{"nl": "Create a function which adds zeros to the start of a binary string, so that its length is a multiple of 8.\nExamples\ncomplete_binary(\"1100\") \u279e \"00001100\"\n\ncomplete_binary(\"1101100\") \u279e \"01101100\"\n\ncomplete_binary(\"110010100010\") \u279e \"0000110010100010\"\nNotes\nReturn the same string if its length is already a multiple of 8.", "code": "def complete_binary(s):\n  return (-len(s)%8 * '0') + s"}
{"nl": "Given an array arr[] of n integers, find the maximum that maximizes the sum of the value of i*arr[i] where i varies from 0 to n-1.\n\nExamples:  \n\nInput: arr[] = {8, 3, 1, 2}\nOutput: 29\nExplanation: Lets look at all the rotations,\n{8, 3, 1, 2} = 8*0 + 3*1 + 1*2 + 2*3 = 11\n{3, 1, 2, 8} = 3*0 + 1*1 + 2*2 + 8*3 = 29\n{1, 2, 8, 3} = 1*0 + 2*1 + 8*2 + 3*3 = 27\n{2, 8, 3, 1} = 2*0 + 8*1 + 3*2 + 1*3 = 17\n\nInput: arr[] = {3, 2, 1}\nOutput: 7\nExplanation: Lets look at all the rotations,\n{3, 2, 1} = 3*0 + 2*1 + 1*2 = 4\n{2, 1, 3} = 2*0 + 1*1 + 3*2 = 7\n{1, 3, 2} = 1*0 + 3*1 + 2*2 = 7", "code": "# A Naive Python3 program to find\n# maximum sum rotation\nimport sys\n\n# Returns maximum value of i * arr[i]\ndef maxSum(arr, n):\n\n\t# Initialize result\n\tres = -sys.maxsize\n\n\t# Consider rotation beginning with i\n\t# for all possible values of i.\n\tfor i in range(0, n):\n\n\n\t\t# Initialize sum of current rotation\n\t\tcurr_sum = 0\n\t\n\t\t# Compute sum of all values. We don't\n\t\t# actually rotation the array, but\n\t\t# compute sum by finding ndexes when\n\t\t# arr[i] is first element\n\t\tfor j in range(0, n):\n\t\t\n\t\t\tindex = int((i + j)% n)\n\t\t\tcurr_sum += j * arr[index]\n\t\n\n\t\t# Update result if required\n\t\tres = max(res, curr_sum)\n\treturn res\n\n# Driver code\narr = [8, 3, 1, 2]\nn = len(arr)\n\nprint(maxSum(arr, n))\n\n# This code is contributed by\n# Smitha Dinesh Semwal"}
{"nl": "A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, \"abABB\" is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, \"abA\" is not because 'b' appears, but 'B' does not.\nGiven a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence. If there are none, return an empty string.\n \nExample 1:\n\nInput: s = \"YazaAay\"\nOutput: \"aAa\"\nExplanation: \"aAa\" is a nice string because 'A/a' is the only letter of the alphabet in s, and both 'A' and 'a' appear.\n\"aAa\" is the longest nice substring.\n\nExample 2:\n\nInput: s = \"Bb\"\nOutput: \"Bb\"\nExplanation: \"Bb\" is a nice string because both 'B' and 'b' appear. The whole string is a substring.\n\nExample 3:\n\nInput: s = \"c\"\nOutput: \"\"\nExplanation: There are no nice substrings.\n\n \nConstraints:\n\n1 <= s.length <= 100\ns consists of uppercase and lowercase English letters.", "code": "class Solution:\n  def longestNiceSubstring(self, s: str) -> str:\n  if not s: return \"\" # boundary condition \n  ss = set(s)\n  for i, c in enumerate(s):\n  if c.swapcase() not in ss: \n  s0 = self.longestNiceSubstring(s[:i])\n  s1 = self.longestNiceSubstring(s[i+1:])\n  return max(s0, s1, key=len)\n  return s"}
{"nl": "On a crime scene, there are many pieces of evidence that point to a particular person having the murder weapon and motive to kill poor old Tom (although not poor at all).\r\n\r\nCreate a function that takes phrases/words as clues and forms a sentence formatted to have the murder's name, verb, \"Tom as\", Reason.\r\n\r\nSn\tWeapon\tVerb to be used\tReason\r\n1\tPoison\tPoisoned\tOnly X could have such high-grade poison.\r\n2\tKnife\tButchered\tOnly X was in the kitchen.\r\n3\tBat\tSwatted\tOnly X is a baseball player.\r\n4\tGun\tShot\tOnly X had a gun.\r\n5\tBriefcase\tSmacked\tOnly X was after Tom's money.\r\nExamples\r\nsherlock(\"Mr.Red\", \"Knife\") \u279e \"Mr. Red butchered Tom as only he was in the kitchen.\"\r\n\r\nsherlock(\"Ms.Blue\", \"Poison\") \u279e \"Ms. Blue poisoned Tom as only she could have such high-grade poison.\"\r\n\r\nsherlock(\"Mr.Red\", \"Bat\") \u279e \"Mr. Red swatted Tom as only he was a baseball player.\"\r\nNotes\r\nMs/Mr gives you the gender of the murderer.\r\nFeel free to remove the dictionary if you want.", "code": "def sherlock(person,weapon):\r\n\tclass Weapon:\r\n\t\r\n\t\tdef __init__(self, verb, reason):\r\n\t\t\tself.v = verb\r\n\t\t\tself.r = reason\r\n\tclass Person:\r\n\t\tdef gender(name):\r\n\t\t\tif 'Mr.' in name:\r\n\t\t\t\treturn 'M'\r\n\t\t\treturn 'F'\r\n\t\tdef __init__(self, name):\r\n\t\t\tself.name = name\r\n\t\t\tself.gender = Person.gender(name)\r\n\t\t\tself.pronoun = 'he' if self.gender == 'M' else 'she'\r\n\t\r\n\tpoison = Weapon('poisoned', 'only {X} could have such high-grade poison.')\r\n\tknife = Weapon('butchered', 'only {X} was in the kitchen.')\r\n\tbat = Weapon('swatted', 'only {X} is a baseball player.')\r\n\tgun = Weapon('shot', 'only {X} had a gun.')\r\n\tbriefcase = Weapon('smacked', 'only {X} was after Tom\\'s money.')\r\n\t\r\n\tweapon = eval(weapon.lower())\r\n\tperson = Person(person)\r\n\t\r\n\ttry:\r\n\t\treturn person.name +  ' {v} Tom as {r}'.format(v = weapon.v, r = weapon.r).format(X = person.pronoun)\r\n\texcept KeyError:\r\n\t\tprint('{X} {v} Tom as {r}'.format(v = weapon.v, r = weapon.r))"}
{"nl": "Write a function that returns True if all characters in a string are identical and False otherwise.\nExamples\nis_identical(\"aaaaaa\") \u279e True\n\nis_identical(\"aabaaa\") \u279e False\n\nis_identical(\"ccccca\") \u279e False\n\nis_identical(\"kk\") \u279e True\nNotes\nN/A", "code": "def is_identical(s):\n  return len(set(s)) == 1"}
{"nl": "Bob is standing at cell (0, 0), and he wants to reach destination: (row, column). He can only travel right and down. You are going to help Bob by providing instructions for him to reach destination.\nThe instructions are represented as a string, where each character is either:\n\n'H', meaning move horizontally (go right), or\n'V', meaning move vertically (go down).\n\nMultiple instructions will lead Bob to destination. For example, if destination is (2, 3), both \"HHHVV\" and \"HVHVH\" are valid instructions.\nHowever, Bob is very picky. Bob has a lucky number k, and he wants the kth lexicographically smallest instructions that will lead him to destination. k is 1-indexed.\nGiven an integer array destination and an integer k, return the kth lexicographically smallest instructions that will take Bob to destination.\n \nExample 1:\n\n\nInput: destination = [2,3], k = 1\nOutput: \"HHHVV\"\nExplanation: All the instructions that reach (2, 3) in lexicographic order are as follows:\n[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].\n\nExample 2:\n\n\nInput: destination = [2,3], k = 2\nOutput: \"HHVHV\"\n\nExample 3:\n\n\nInput: destination = [2,3], k = 3\nOutput: \"HHVVH\"\n\n \nConstraints:\n\ndestination.length == 2\n1 <= row, column <= 15\n1 <= k <= nCr(row + column, row), where nCr(a, b) denotes a choose b\u200b\u200b\u200b\u200b\u200b.", "code": "def kthSmallestPath(self, destination: List[int], k: int) -> str:\n  from math import comb\n  r, c = destination\n  \n  ret = []\n  remDown = r\n  for i in range(r + c):\n  remSteps = r + c - (i + 1)\n  com = comb(remSteps, remDown)\n  if com >= k:\n  ret.append(\"H\")\n  else:\n  remDown -= 1\n  k -= com\n  ret.append(\"V\")\n  \n  return ''.join(ret)"}
{"nl": "The self Parameter\r\nThe self parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class.\r\n\r\nIt does not have to be named self , you can call it whatever you like, but it has to be the first parameter of any function in the class:", "code": "class Person:\r\n  def __init__(mysillyobject, name, age):\r\n    mysillyobject.name = name\r\n    mysillyobject.age = age\r\n\r\n  def myfunc(abc):\r\n    print(\"Hello my name is \" + abc.name)\r\n\r\np1 = Person(\"John\", 36)\r\np1.myfunc()"}
{"nl": "Given values of two values n1 and n2 in a Binary Search Tree, find the Lowest Common Ancestor (LCA). You may assume that both the values exist in the tree. ", "code": "# A recursive python program to find LCA of two nodes\r\n# n1 and n2\r\n \r\n# A Binary tree node\r\nclass Node:\r\n \r\n    # Constructor to create a new node\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\n \r\n# Function to find LCA of n1 and n2. The function assumes\r\n# that both n1 and n2 are present in BST\r\ndef lca(root, n1, n2):\r\n     \r\n    # Base Case\r\n    if root is None:\r\n        return None\r\n \r\n    # If both n1 and n2 are smaller than root, then LCA\r\n    # lies in left\r\n    if(root.data > n1 and root.data > n2):\r\n        return lca(root.left, n1, n2)\r\n \r\n    # If both n1 and n2 are greater than root, then LCA\r\n    # lies in right\r\n    if(root.data < n1 and root.data < n2):\r\n        return lca(root.right, n1, n2)\r\n \r\n    return root\r\n \r\n# Driver program to test above function\r\n \r\n# Let us construct the BST shown in the figure\r\nroot = Node(20)\r\nroot.left = Node(8)\r\nroot.right = Node(22)\r\nroot.left.left = Node(4)\r\nroot.left.right = Node(12)\r\nroot.left.right.left = Node(10)\r\nroot.left.right.right = Node(14)\r\n \r\nn1 = 10 ; n2 = 14\r\nt = lca(root, n1, n2)\r\nprint (\"LCA of %d and %d is %d\" %(n1, n2, t.data))\r\n \r\nn1 = 14 ; n2 = 8\r\nt = lca(root, n1, n2)\r\nprint (\"LCA of %d and %d is %d\" %(n1, n2 , t.data))\r\n \r\nn1 = 10 ; n2 = 22\r\nt = lca(root, n1, n2)\r\nprint (\"LCA of %d and %d is %d\" %(n1, n2, t.data))\r\n \r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)"}
{"nl": "Create a function that returns a number which can block the player from reaching 3 in a row in a game of Tic Tac Toe. The number given as an argument will correspond to a grid of Tic Tac Toe: topleft is 0, topright is 2, bottomleft is 6, and bottomright is 8.\nCreate a function that takes two numbers a, b and returns another number.\nThis number should be the final one in a line to block the player from winning.\nExamples\nblock_player(0, 3) \u279e 6\n\nblock_player(0, 4) \u279e 8\n\nblock_player(3, 5) \u279e 4\nNotes\nThe values given will always have two filled squares in a line.", "code": "def block_player(a, b):\n    wins = ({0, 1, 2}, {3, 4, 5}, {6, 7, 8}, {0, 4, 8}, \n            {0, 3, 6}, {1, 4, 7}, {2, 5, 8}, {2, 4, 6})\n    for i in wins:\n        if {a, b}.issubset(i):\n            return (i - {a, b}).pop()"}
{"nl": "Given an adjacency matrix representation of an undirected graph. Find if there is any Eulerian Path in the graph. If there is no path print \u201cNo Solution\u201d. If there is any path print the path.\u00a0", "code": "# Efficient Python3 program to\n# find out Eulerian path\n\u00a0\u00a0\n# Function to find out the path\n# It takes the adjacency matrix\n# representation of the graph as input\ndef findpath(graph, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0numofadj = []\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find out number of edges each\n\u00a0\u00a0\u00a0\u00a0# vertex has\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0numofadj.append(sum(graph[i]))\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find out how many vertex has\u00a0\n\u00a0\u00a0\u00a0\u00a0# odd number edges\n\u00a0\u00a0\u00a0\u00a0startpoint, numofodd = 0, 0\n\u00a0\u00a0\u00a0\u00a0for i in range(n - 1, -1, -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (numofadj[i] % 2 == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0numofodd += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0startpoint = i\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If number of vertex with odd number of edges\n\u00a0\u00a0\u00a0\u00a0# is greater than two return \"No Solution\".\n\u00a0\u00a0\u00a0\u00a0if (numofodd > 2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No Solution\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If there is a path find the path\n\u00a0\u00a0\u00a0\u00a0# Initialize empty stack and path\n\u00a0\u00a0\u00a0\u00a0# take the starting current as discussed\n\u00a0\u00a0\u00a0\u00a0stack = []\n\u00a0\u00a0\u00a0\u00a0path = []\n\u00a0\u00a0\u00a0\u00a0cur = startpoint\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Loop will run until there is element in the\n\u00a0\u00a0\u00a0\u00a0# stack or current edge has some neighbour.\n\u00a0\u00a0\u00a0\u00a0while (len(stack) > 0 or sum(graph[cur])!= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current node has not any neighbour\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# add it to path and pop stack set new\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current to the popped element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sum(graph[cur]) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append(cur)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = stack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0del stack[-1]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the current vertex has at least one\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# neighbour add the current vertex to stack,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# remove the edge between them and set the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current to its neighbour.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (graph[cur][i] == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(cur)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0graph[cur][i] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0graph[i][cur] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the path\n\u00a0\u00a0\u00a0\u00a0for ele in path:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(ele, end = \" -> \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(cur)\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Test case 1\n\u00a0\u00a0\u00a0\u00a0graph1 = [ [ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 1, 0, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 0, 0, 0 ] ]\n\u00a0\u00a0\u00a0\u00a0n = len(graph1)\n\u00a0\u00a0\u00a0\u00a0findpath(graph1, n)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Test case 2\n\u00a0\u00a0\u00a0\u00a0graph2 = [ [ 0, 1, 0, 1, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 1, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 1, 1, 0, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 0, 0 ] ]\n\u00a0\u00a0\u00a0\u00a0n = len(graph2)\n\u00a0\u00a0\u00a0\u00a0findpath(graph2, n)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Test case 3\n\u00a0\u00a0\u00a0\u00a0graph3 = [ [ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 1, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 1, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 1, 0, 1, 0 ] ]\n\u00a0\u00a0\u00a0\u00a0n = len(graph3)\n\u00a0\u00a0\u00a0\u00a0findpath(graph3, n)\n\u00a0\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "The following is a simple recursive Ternary Search function ", "code": "# A recursive ternary search function. It returns location of x in\n# given array arr[l..r] is present, otherwise -1\ndef ternarySearch(arr, l, r, x):\n\tif (r >= l):\n\t\tmid1 = l + (r - l)//3\n\t\tmid2 = mid1 + (r - l)//3\n\n\t\t# If x is present at the mid1\n\t\tif arr[mid1] == x:\n\t\t\treturn mid1\n\n\t\t# If x is present at the mid2\n\t\tif arr[mid2] == x:\n\t\t\treturn mid2\n\n\t\t# If x is present in left one-third\n\t\tif arr[mid1] > x:\n\t\t\treturn ternarySearch(arr, l, mid1-1, x)\n\n\t\t# If x is present in right one-third\n\t\tif arr[mid2] < x:\n\t\t\treturn ternarySearch(arr, mid2+1, r, x)\n\n\t\t# If x is present in middle one-third\n\t\treturn ternarySearch(arr, mid1+1, mid2-1, x)\n\t\n\t# We reach here when element is not present in array\n\treturn -1\n\t\n# This code is contributed by ankush_953\n"}
{"nl": "This is to augment AVL tree node to store count together with regular fields like key, left and right pointers. ", "code": "# Python code to delete a node in AVL tree\r\n# Generic tree node class\r\n\r\n\r\nclass TreeNode():\r\n\tdef __init__(self, val):\r\n\t\tself.count = 1 # assigning count variable so that during insertion in will be incremented for duplicate values\r\n\t\t# and during deletion, it will be decremented if has multiple copies.\r\n\t\tself.height = 1\r\n\t\tself.val = val\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n# only insertion and deletion will be affected. if multiple copies are there, entry(count) will be printed during traversal.\r\n\r\n# AVL tree class which supports insertion,\r\n# deletion operations\r\n\r\n\r\nclass AVL_Tree(object):\r\n\r\n\tdef insert(self, root, key):\r\n\r\n\t\t# Step 1 - Perform normal BST\r\n\t\tif not root:\r\n\t\t\treturn TreeNode(key)\r\n\t\telse if key < root.val:\r\n\t\t\troot.left = self.insert(root.left, key)\r\n\t\telse if key > root.val:\r\n\t\t\troot.right = self.insert(root.right, key)\r\n\t\telse:\r\n\t\t\troot.count += 1 # incrementing count if same entry is inserted.\r\n\r\n\t\t# Step 2 - Update the height of the\r\n\t\t# ancestor node\r\n\t\troot.height = 1 + max(self.getHeight(root.left),\r\n\t\t\t\t\t\t\tself.getHeight(root.right))\r\n\r\n\t\t# Step 3 - Get the balance factor\r\n\t\tbalance = self.getBalance(root)\r\n\r\n\t\t# Step 4 - If the node is unbalanced,\r\n\t\t# then try out the 4 cases\r\n\t\t# Case 1 - Left Left\r\n\t\tif balance > 1 and key < root.left.val:\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 2 - Right Right\r\n\t\tif balance < -1 and key > root.right.val:\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\t# Case 3 - Left Right\r\n\t\tif balance > 1 and key > root.left.val:\r\n\t\t\troot.left = self.leftRotate(root.left)\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 4 - Right Left\r\n\t\tif balance < -1 and key < root.right.val:\r\n\t\t\troot.right = self.rightRotate(root.right)\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\treturn root\r\n\r\n\t# Recursive function to delete a node with\r\n\t# given key from subtree with given root.\r\n\t# It returns root of the modified subtree.\r\n\tdef delete(self, root, key):\r\n\r\n\t\t# Step 1 - Perform standard BST delete\r\n\t\tif not root:\r\n\t\t\treturn root\r\n\r\n\t\telse if key < root.val:\r\n\t\t\troot.left = self.delete(root.left, key)\r\n\r\n\t\telse if key > root.val:\r\n\t\t\troot.right = self.delete(root.right, key)\r\n\r\n\t\telse:\r\n\t\t\tif root.count > 1: # if count is more than one i.e multiple copies are there\r\n\t\t\t\troot.count -= 1 # just decrement count\r\n\t\t\t\treturn root # so that one copy will be deleted and return\r\n\r\n\t\t\tif root.left is None:\r\n\t\t\t\ttemp = root.right\r\n\t\t\t\troot = None\r\n\t\t\t\treturn temp\r\n\r\n\t\t\telse if root.right is None:\r\n\t\t\t\ttemp = root.left\r\n\t\t\t\troot = None\r\n\t\t\t\treturn temp\r\n\r\n\t\t\ttemp = self.getMinValueNode(root.right)\r\n\t\t\troot.val = temp.val\r\n\t\t\troot.right = self.delete(root.right,\r\n\t\t\t\t\t\t\t\t\ttemp.val)\r\n\r\n\t\t# If the tree has only one node,\r\n\t\t# simply return it\r\n\t\tif root is None:\r\n\t\t\treturn root\r\n\r\n\t\t# Step 2 - Update the height of the\r\n\t\t# ancestor node\r\n\t\troot.height = 1 + max(self.getHeight(root.left),\r\n\t\t\t\t\t\t\tself.getHeight(root.right))\r\n\r\n\t\t# Step 3 - Get the balance factor\r\n\t\tbalance = self.getBalance(root)\r\n\r\n\t\t# Step 4 - If the node is unbalanced,\r\n\t\t# then try out the 4 cases\r\n\t\t# Case 1 - Left Left\r\n\t\tif balance > 1 and self.getBalance(root.left) >= 0:\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 2 - Right Right\r\n\t\tif balance < -1 and self.getBalance(root.right) <= 0:\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\t# Case 3 - Left Right\r\n\t\tif balance > 1 and self.getBalance(root.left) < 0:\r\n\t\t\troot.left = self.leftRotate(root.left)\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 4 - Right Left\r\n\t\tif balance < -1 and self.getBalance(root.right) > 0:\r\n\t\t\troot.right = self.rightRotate(root.right)\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\treturn root\r\n\r\n\tdef leftRotate(self, z):\r\n\r\n\t\ty = z.right\r\n\t\tT2 = y.left\r\n\r\n\t\t# Perform rotation\r\n\t\ty.left = z\r\n\t\tz.right = T2\r\n\r\n\t\t# Update heights\r\n\t\tz.height = 1 + max(self.getHeight(z.left),\r\n\t\t\t\t\t\tself.getHeight(z.right))\r\n\t\ty.height = 1 + max(self.getHeight(y.left),\r\n\t\t\t\t\t\tself.getHeight(y.right))\r\n\r\n\t\t# Return the new root\r\n\t\treturn y\r\n\r\n\tdef rightRotate(self, z):\r\n\r\n\t\ty = z.left\r\n\t\tT3 = y.right\r\n\r\n\t\t# Perform rotation\r\n\t\ty.right = z\r\n\t\tz.left = T3\r\n\r\n\t\t# Update heights\r\n\t\tz.height = 1 + max(self.getHeight(z.left),\r\n\t\t\t\t\t\tself.getHeight(z.right))\r\n\t\ty.height = 1 + max(self.getHeight(y.left),\r\n\t\t\t\t\t\tself.getHeight(y.right))\r\n\r\n\t\t# Return the new root\r\n\t\treturn y\r\n\r\n\tdef getHeight(self, root):\r\n\t\tif not root:\r\n\t\t\treturn 0\r\n\r\n\t\treturn root.height\r\n\r\n\tdef getBalance(self, root):\r\n\t\tif not root:\r\n\t\t\treturn 0\r\n\r\n\t\treturn self.getHeight(root.left) - self.getHeight(root.right)\r\n\r\n\tdef getMinValueNode(self, root):\r\n\t\tif root is None or root.left is None:\r\n\t\t\treturn root\r\n\r\n\t\treturn self.getMinValueNode(root.left)\r\n\r\n\tdef preOrder(self, root):\r\n\r\n\t\tif not root:\r\n\t\t\treturn\r\n\r\n\t\tprint(\"{}({}) \".format(root.val, root.count), end=\"\")\r\n\t\tself.preOrder(root.left)\r\n\t\tself.preOrder(root.right)\r\n\r\n\r\nmyTree = AVL_Tree()\r\nroot = None\r\nnums = [9, 5, 10, 5, 9, 7, 17]\r\n\r\nfor num in nums:\r\n\troot = myTree.insert(root, num)\r\n\r\n# Preorder Traversal\r\nprint(\"Preorder Traversal after insertion -\")\r\nmyTree.preOrder(root)\r\nprint()\r\n\r\n# Delete\r\nkey = 10\r\nroot = myTree.delete(root, key)\r\nkey = 10\r\nroot = myTree.delete(root, key)\r\nkey = -1\r\nroot = myTree.delete(root, key)\r\nkey = 0\r\nroot = myTree.delete(root, key)\r\n\r\n# Preorder Traversal\r\nprint(\"Preorder Traversal after deletion -\")\r\nmyTree.preOrder(root)\r\nprint()\r\n\r\n# This code is contributed by Ajitesh Pathak\r"}
{"nl": "User Input: Calculate Sum of Series 1\u00b3+2\u00b3+3\u00b3+\u2026.+n\u00b3", "code": "# Import math module using the import keyword.\r\nimport math\r\n# Give the nth term of a series as user input using the int(input()) function and store it in a variable.\r\nnum = int(input(\"Enter some random variable = \"))\r\n# Calculate the sum of cubes of a series with a given nth term using the above\r\n# mathematical formula and math.pow() function. \r\n# Store it in another variable.\r\ncube_sum = math.pow((num * (num + 1)) / 2, 2)\r\n# Print the sum of cubes of a given series with the given n value.\r\nprint(\r\n    \"The sum of cubes of a series with the given n value[\", num, \"] =\", cube_sum)"}
{"nl": "A factor chain is a list where each previous element is a factor of the next consecutive element. The following is a factor chain:\n[3, 6, 12, 36]\n\n# 3 is a factor of 6\n# 6 is a factor of 12\n# 12 is a factor of 36\nCreate a function that determines whether or not a list is a factor chain.\nExamples\nfactor_chain([1, 2, 4, 8, 16, 32]) \u279e True\n\nfactor_chain([1, 1, 1, 1, 1, 1]) \u279e True\n\nfactor_chain([2, 4, 6, 7, 12]) \u279e False\n\nfactor_chain([10, 1]) \u279e False\nNotes\nN/A", "code": "def factor_chain(lst):\n  for x in lst:\n    if (lst[-1]%x != 0):\n      return False\n  return True"}
{"nl": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.\n \nExample 1:\n\n\n\nInput: root = [3,1,4,3,null,1,5]\n\nOutput: 4\n\nExplanation: Nodes in blue are good.\n\nRoot Node (3) is always a good node.\n\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\n\nNode 5 -> (3,4,5) is the maximum value in the path\n\nNode 3 -> (3,1,3) is the maximum value in the path.\nExample 2:\n\n\n\nInput: root = [3,3,null,4,2]\n\nOutput: 3\n\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\nExample 3:\n\n\nInput: root = [1]\n\nOutput: 1\n\nExplanation: Root is considered as good.\n \nConstraints:\n\nThe number of nodes in the binary tree is in the range [1, 10^5].\nEach node's value is between [-10^4, 10^4].", "code": "def goodNodes(self, r, ma=-10000):\n  return self.goodNodes(r.left, max(ma, r.val)) + self.goodNodes(r.right, max(ma, r.val)) + (r.val >= ma) if r else 0"}
{"nl": "Definition and Usage\r\nThe clear() method removes all elements in a set.", "code": "fruits = {\"apple\", \"banana\", \"cherry\"}\r\n\r\nfruits.clear()\r\n\r\nprint(fruits)"}
{"nl": "Files in Python:\n\nOne of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.\n\nAlso, if you didn\u2019t know, I/O operations are the most expensive processes where a program can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.\n\n\n\nConsider the following scenario: you\u2019re planning to construct a large Python project with a large number of workflows. Then it\u2019s unavoidable that you don\u2019t make a log file. You\u2019ll also be handling the log file\u2019s read and write activities. Debugging huge applications with log files is a terrific way to go. It\u2019s usually better to consider a scalable design from the start, as you won\u2019t be sorry later if you didn\u2019t.\n\nFile name Property in Python:\n\nname Property is a built-in property of the File object (IO object) in Python that is used to retrieve the file\u2019s name from the file object.\n\nSyntax:\n\nfileobject.name()\nParameters: This method doesn\u2019t accept any parameters.\n\nReturn Value: \n\nThis method\u2019s return type is <class\u2019str\u2019>, and it returns the file name.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're simply writing the contents into the file.\ngvn_file = open(givenFilename, 'w') \n# Get the given file name using the name property and store it in a variable\nf_name= gvn_file.name\n# Print the given file name.\nprint(\"The given file name is:\", f_name)\n# Close the given file using the close() function\ngvn_file.close()"}
{"nl": "Create a function that takes two parameters (start, stop), and returns the sum of all even numbers in the range.\nExamples\nsum_even_nums_in_range(10, 20) \u279e 90\n# 10, 12, 14, 16, 18, 20\n\nsum_even_nums_in_range(51, 150) \u279e 5050\n\nsum_even_nums_in_range(63, 97) \u279e 1360\nNotes\nRemember that the start and stop values are inclusive.", "code": "def sum_even_nums_in_range(start, stop):\n    return sum(i for i in range(start, stop+1) if not i%2)"}
{"nl": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\n \n\nExample 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\nExample 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.", "code": "from collections import defaultdict\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\n            return 0\n\n        # Since all words are of same length.\n        L = len(beginWord)\n\n        # Dictionary to hold combination of words that can be formed,\n        # from any given word. By changing one letter at a time.\n        all_combo_dict = defaultdict(list)\n        for word in wordList:\n            for i in range(L):\n                # Key is the generic word\n                # Value is a list of words which have the same intermediate generic word.\n                all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\n\n\n        # Queue for BFS\n        queue = collections.deque([(beginWord, 1)])\n        # Visited to make sure we don't repeat processing same word.\n        visited = {beginWord: True}\n        while queue:\n            current_word, level = queue.popleft()\n            for i in range(L):\n                # Intermediate words for current word\n                intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\n\n                # Next states are all the words which share the same intermediate state.\n                for word in all_combo_dict[intermediate_word]:\n                    # If at any point if we find what we are looking for\n                    # i.e. the end word - we can return with the answer.\n                    if word == endWord:\n                        return level + 1\n                    # Otherwise, add it to the BFS Queue. Also mark it visited\n                    if word not in visited:\n                        visited[word] = True\n                        queue.append((word, level + 1))\n                all_combo_dict[intermediate_word] = []\n        return 0"}
{"nl": "A triangulation of a convex polygon is formed by drawing diagonals between non-adjacent vertices (corners) such that the diagonals never intersect. The problem is to find the cost of triangulation with the minimum cost. The cost of a triangulation is sum of the weights of its component triangles. Weight of each triangle is its perimeter.", "code": "# Recursive implementation for minimum\r\n# cost convex polygon triangulation\r\nfrom math import sqrt\r\nMAX = 1000000.0\r\n \r\n# A utility function to find distance\r\n# between two points in a plane\r\ndef dist(p1, p2):\r\n    return sqrt((p1[0] - p2[0])*(p1[0] - p2[0]) + \\\r\n                (p1[1] - p2[1])*(p1[1] - p2[1]))\r\n \r\n# A utility function to find cost of\r\n# a triangle. The cost is considered\r\n# as perimeter (sum of lengths of all edges)\r\n# of the triangle\r\ndef cost(points, i, j, k):\r\n    p1 = points[i]\r\n    p2 = points[j]\r\n    p3 = points[k]\r\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1)\r\n \r\n \r\n# A recursive function to find minimum\r\n# cost of polygon triangulation\r\n# The polygon is represented by points[i..j].\r\ndef mTC(points, i, j):\r\n     \r\n    # There must be at least three points between i and j\r\n    # (including i and j)\r\n    if (j < i + 2):\r\n        return 0\r\n         \r\n    # Initialize result as infinite\r\n    res = MAX\r\n     \r\n    # Find minimum triangulation by considering all\r\n    for k in range(i + 1, j):\r\n        res = min(res, (mTC(points, i, k) + \\\r\n                        mTC(points, k, j) + \\\r\n                        cost(points, i, k, j)))\r\n     \r\n    return round(res, 4)\r\n \r\n \r\n# Driver code\r\npoints = [[0, 0], [1, 0], [2, 1], [1, 2], [0, 2]]\r\nn = len(points)\r\nprint(mTC(points, 0, n-1))\r\n \r\n# This code is contributed by SHUBHAMSINGH10"}
{"nl": "Sum of all nodes in a binary tree", "code": "# Python3 Program to print sum of all\n# the elements of a binary tree\n\n# Binary Tree Node\n\n\"\"\" utility that allocates a new Node\nwith the given key \"\"\"\nclass newNode:\n\n\t# Construct to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\t\t\n# Function to find sum of all the element\ndef addBT(root):\n\tif (root == None):\n\t\treturn 0\n\treturn (root.key + addBT(root.left) +\n\t\t\t\t\taddBT(root.right))\n\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(6)\n\troot.right.right = newNode(7)\n\troot.right.left.right = newNode(8)\n\n\tsum = addBT(root)\n\n\tprint(\"Sum of all the nodes is:\", sum)\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Given a list, the task is to find the greatest distance between two occurrences of an element in a given list of repeated elements.", "code": "# Give the list as static input and store it in a variable.\r\ngvn_lst = [1, 2, 3, 7, 8, 9, 2, 1, 4, 3]\r\n# Calculate the length of the given list using the len() function and store it in\r\n# another variable.\r\nlst_len = len(gvn_lst)\r\n# Create an empty dictionary and store it in another variable.\r\nnew_dict = {}\r\n# Take a variable say \"max_val\" and initialize its value with 0.\r\nmax_val = 0\r\n# Loop till the number of elements of the list using the for loop.\r\nfor itr in range(lst_len):\r\n    # Check if the list element is present in the dictionary keys or not using the\r\n    # if conditional statement.\r\n    if gvn_lst[itr] not in new_dict.keys():\r\n        # If the statement is true, then update the dictionary with the key as a list element\r\n        # and value as an iterator.\r\n        new_dict[gvn_lst[itr]] = itr\r\n # If it is not true, calculate the maximum value of \"max_val\" and iterator -dictionary\r\n# of list of iterator and store it in \"max_val\".\r\n    else:\r\n        max_val = max(max_val, itr-new_dict[gvn_lst[itr]])\r\n # Print \"max_val\" to get the greatest distance between two occurrences of an element\r\n# in a given list of repeated elements.\r\nprint(\"The greatest distance between two occurrences of an element in a given list of repeated elements = \", max_val)"}
{"nl": "Create two functions to_camel_case() and to_snake_case() that each take a single string and convert it into either camelCase or snake_case. If you're not sure what these terms mean, check the Resources tab above.\nExamples\nto_camel_case(\"hello_edabit\") \u279e \"helloEdabit\"\n\nto_snake_case(\"helloEdabit\") \u279e \"hello_edabit\"\n\nto_camel_case(\"is_modal_open\") \u279e \"isModalOpen\"\n\nto_snake_case(\"getColor\") \u279e \"get_color\"\nNotes\nTest input will always be appropriately formatted as either camelCase or snake_case, depending on the function being called.", "code": "import re\ndef to_snake_case(txt):\n  pattern = re.compile(r\"([a-z])([A-Z])\")\n  match = pattern.sub(r'\\1_\\2', txt).lower()\n  return match\n  def to_camel_case(txt):\n  pattern = re.compile(r\"(_)([a-z])\")\n  match = pattern.sub(lambda x: x.group(2).upper(), txt)\n  a = re.sub(r\"_\", \"\", match)\n  return a"}
{"nl": "Given a binary tree, write a function to get the maximum width of the given tree. Width of a tree is maximum of widths of all levels. \n\nLet us consider the below example tree. \n\n         1\n        /  \\\n       2    3\n     /  \\     \\\n    4    5     8 \n              /  \\\n             6    7\nFor the above tree, \nwidth of level 1 is 1, \nwidth of level 2 is 2, \nwidth of level 3 is 3 \nwidth of level 4 is 2. \nSo the maximum width of the tree is 3.\n", "code": "# Python program to find the maximum width of\n# binary tree using Level Order Traversal.\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to get the maximum width of a binary tree\n \n \ndef getMaxWidth(root):\n    maxWidth = 0\n    h = height(root)\n    # Get width of each level and compare the\n    # width with maximum width so far\n    for i in range(1, h+1):\n        width = getWidth(root, i)\n        if (width > maxWidth):\n            maxWidth = width\n    return maxWidth\n \n# Get width of a given level\n \n \ndef getWidth(root, level):\n    if root is None:\n        return 0\n    if level == 1:\n        return 1\n    elif level > 1:\n        return (getWidth(root.left, level-1) +\n                getWidth(root.right, level-1))\n \n# UTILITY FUNCTIONS\n# Compute the \"height\" of a tree -- the number of\n# nodes along the longest path from the root node\n# down to the farthest leaf node.\n \n \ndef height(node):\n    if node is None:\n        return 0\n    else:\n \n        # compute the height of each subtree\n        lHeight = height(node.left)\n        rHeight = height(node.right)\n \n        # use the larger one\n        return (lHeight+1) if (lHeight > rHeight) else (rHeight+1)\n \n \n# Driver code\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n \n\"\"\"\nConstructed binary tree is:\n    1\n    / \\\n    2 3\n    / \\     \\\n4 5 8\n        / \\\n        6 7\n\"\"\"\n# Function call\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n \n# This code is contributed by Naveen Aili"}
{"nl": "Recursion:\n\nRecursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.\n\nGiven a number the task is to calculate the sum of the digits of the given number using recursive approach in Python.\n\nExamples:\n\nExample1:\n\nInput:\n\nEnter some random number = 18627677851\nOutput:\n\nThe total sum of digits off the given number 18627677851 = 58", "code": "# take a empty list\nnumbList = []\n# function which returns count of all the digits of\n# the given number using recursive approach.\n\n\ndef sumDigitsRecursion(numb):\n    # Put the base condition in the function that says\n    # if the number is zero, return the created list.\n    if(numb == 0):\n        return numbList\n    # getting the last digit of the given number using modulus operator\n    numdigit = numb % 10\n    # appending this digit to numberslist using digit function\n    numbList.append(numdigit)\n    # passing numb/10 recursively\n    sumDigitsRecursion(numb//10)\n\n\n# give the number as static input\nnumb = 18627677851\n# passing the number to sumDigitsRecursion function to\n# calculate the sum of digits recursively\nsumDigitsRecursion(numb)\n# calculating the sum of list using sum() function.\nprint('The total sum of digits off the given number', numb, '=', sum(numbList))"}
{"nl": "Write a Python program to print right triangle of 1 and 0 pattern using for loop.", "code": "rows = int(input(\"Enter Right Triangle of 1 & 0 Num Pattern Rows = \"))\n\nprint(\"====Right Angled Triangle of 1 and 0 Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(1, i + 1):\n        if j % 2 == 0:\n           print(0, end = ' ') \n        else:\n            print(1, end = ' ') \n    print()"}
{"nl": "Create a function that takes two parameters and, if both parameters are strings, add them as if they were integers or if the two parameters are integers, concatenate them.", "code": "def stupid_addition(a, b):\r\n    if type(a) == type(b):\r\n        if type(a) == int:\r\n            return str(a) + str(b)\r\n        return int(a)+int(b)"}
{"nl": "We introduced graph coloring and applications in previous post. As discussed in the previous post, graph coloring is widely used. Unfortunately, there is no efficient algorithm available for coloring a graph with minimum number of colors as the problem is a known NP Complete problem. There are approximate algorithms to solve the problem though. Following is the basic Greedy Algorithm to assign colors. It doesn\u2019t guarantee to use minimum colors, but it guarantees an upper bound on the number of colors. The basic algorithm never uses more than d+1 colors where d is the maximum degree of a vertex in the given graph.", "code": "# Python3 program to implement greedy\n# algorithm for graph coloring\n\u00a0\ndef addEdge(adj, v, w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0adj[v].append(w)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Note: the graph is undirected\n\u00a0\u00a0\u00a0\u00a0adj[w].append(v)\u00a0\n\u00a0\u00a0\u00a0\u00a0return adj\n\u00a0\n# Assigns colors (starting from 0) to all\n# vertices and prints the assignment of colors\ndef greedyColoring(adj, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0result = [-1] * V\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Assign the first color to first vertex\n\u00a0\u00a0\u00a0\u00a0result[0] = 0;\n\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A temporary array to store the available colors.\n\u00a0\u00a0\u00a0\u00a0# True value of available[cr] would mean that the\n\u00a0\u00a0\u00a0\u00a0# color cr is assigned to one of its adjacent vertices\n\u00a0\u00a0\u00a0\u00a0available = [False] * V\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Assign colors to remaining V-1 vertices\n\u00a0\u00a0\u00a0\u00a0for u in range(1, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Process all adjacent vertices and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# flag their colors as unavailable\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in adj[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (result[i] != -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0available[result[i]] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Find the first available color\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while cr < V:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (available[cr] == False):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Assign the found color\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[u] = cr\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Reset the values back to false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for the next iteration\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in adj[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (result[i] != -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0available[result[i]] = False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the result\n\u00a0\u00a0\u00a0\u00a0for u in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Vertex\", u, \" --->\u00a0 Color\", result[u])\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0g1 = [[] for i in range(5)]\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 0, 1)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 0, 2)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 1, 2)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 1, 3)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 2, 3)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 3, 4)\n\u00a0\u00a0\u00a0\u00a0print(\"Coloring of graph 1 \")\n\u00a0\u00a0\u00a0\u00a0greedyColoring(g1, 5)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0g2 = [[] for i in range(5)]\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 0, 1)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 0, 2)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 1, 2)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 1, 4)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 2, 4)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 4, 3)\n\u00a0\u00a0\u00a0\u00a0print(\"\\nColoring of graph 2\")\n\u00a0\u00a0\u00a0\u00a0greedyColoring(g2, 5)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Given preorder of a binary tree, calculate its depth(or height) [starting from depth 0].", "code": "#Python program to find height of full binary tree\r\n# using preorder\r\n\t\r\n# function to return max of left subtree height\r\n# or right subtree height\r\ndef findDepthRec(tree, n, index) :\r\n\r\n\tif (index[0] >= n or tree[index[0]] == 'l'):\r\n\t\treturn 0\r\n\r\n\t# calc height of left subtree (In preorder\r\n\t# left subtree is processed before right)\r\n\tindex[0] += 1\r\n\tleft = findDepthRec(tree, n, index)\r\n\r\n\t# calc height of right subtree\r\n\tindex[0] += 1\r\n\tright = findDepthRec(tree, n, index)\r\n\treturn (max(left, right) + 1)\r\n\r\n# Wrapper over findDepthRec()\r\ndef findDepth(tree, n) :\r\n\r\n\tindex = [0]\r\n\treturn findDepthRec(tree, n, index)\r\n\r\n\t\t\r\n# Driver program to test above functions\r\nif __name__ == '__main__':\r\n\ttree= \"nlnnlll\"\r\n\tn = len(tree)\r\n\r\n\tprint(findDepth(tree, n))\r\n\r\n# This code is contributed by SHUBHAMSINGH10\r"}
{"nl": "You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps.\nReturn true if you can make arr equal to target or false otherwise.\n \nExample 1:\n\nInput: target = [1,2,3,4], arr = [2,4,1,3]\nOutput: true\nExplanation: You can follow the next steps to convert arr to target:\n1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3]\n2- Reverse sub-array [4,2], arr becomes [1,2,4,3]\n3- Reverse sub-array [4,3], arr becomes [1,2,3,4]\nThere are multiple ways to convert arr to target, this is not the only way to do so.\n\nExample 2:\n\nInput: target = [7], arr = [7]\nOutput: true\nExplanation: arr is equal to target without any reverses.\n\nExample 3:\n\nInput: target = [3,7,9], arr = [3,7,11]\nOutput: false\nExplanation: arr does not have value 9 and it can never be converted to target.\n\n \nConstraints:\n\ntarget.length == arr.length\n1 <= target.length <= 1000\n1 <= target[i] <= 1000\n1 <= arr[i] <= 1000", "code": "def canBeEqual(self, target, A):\n  return collections.Counter(target) == collections.Counter(A)"}
{"nl": "In this tutorial, the power of 2 or not for python programming can be checked. The user gives a positive integer N and we have to check if it is equivalent to 2^x or not, where x can be zero or a number positive.\n Examples:\n Example1:\n Input:\n given number =2048\n Output:\n The given numb 2048 is power of 2\n Example2:\n Input:\n given number =256\n Output:\n The given numb 256 is power of 2\n Example3:\n Input:\n given number =678\n Output:\n The given numb 678 is not power of 2", "code": "# importing log from math\n \n from math import log\n \n # given number\n \n numb = 2048\n \n # given base (here it is 2 as we have to check whether it is power of 2 or not)\n \n bas = 2\n \n # calculating log2 of the given numb using log function\n \n logvalue = log(numb, bas)\n \n # if the value is integer then it is power of 2\n \n if (int(logvalue) == logvalue):\n \n  print(\"The given numb\", numb, \"is power of 2\")\n \n # else it is not power of 2\n \n else:\n \n  print(\"The given numb\", numb, \"is not power of 2\")"}
{"nl": "Given a square matrix and the task is to check whether the given matrix is a diagonally dominant matrix or not. Diagonally Dominant Matrix :\r\n\r\nA square matrix is said to be diagonally dominating in mathematics if the magnitude of the diagonal entry in a row is greater than or equal to the sum of the magnitudes of all the other (non-diagonal) values in that row for each row of the matrix.", "code": "# Create a function to say checkdiagnolydominant_matx() which takes the given matrix\r\n# and the number of rows of the given matrix as the arguments and returns true or false\r\n\r\n\r\ndef checkdiagnolydominant_matx(mtrx, mtrxrows):\r\n    # Inside the function, Loop till the given number of rows using the For loop.\r\n    for n in range(0, mtrxrows):\r\n       # Take a variable to say rslt_summ and initialize its value to 0.\r\n        rslt_summ = 0\r\n        # Inside the For loop, Iterate till the given number of rows using another\r\n        # Nested For loop(Inner For loop).\r\n\r\n        for m in range(0, mtrxrows):\r\n          # Add the absolute of mtrx[n][m] to the above-initialized rslt_summ and store\r\n          # it in  the same variable.\r\n\r\n            rslt_summ = rslt_summ + abs(mtrx[n][m])\r\n       # Remove the diagonal element by subtracting the abs(mtrx[n][n]) from the rslt_summ and\r\n       # store it in the same variable.\r\n        rslt_summ = rslt_summ - abs(mtrx[n][n])\r\n        # Check if the abs(mtrx[n][n]) (diagonal element) is less than the rslt_summ\r\n        # (Which is the #sum of non diagonal elements) using the if conditional statement.\r\n        if (abs(mtrx[n][n]) < rslt_summ):\r\n          # If it is true, then return False.\r\n            return False\r\n    # Return True.\r\n    return True\r\n\r\n\r\n# Give the matrix as static input and store it in a variable.\r\nmtrx = [[5, 1, 3], [2, 7, 1], [4, 0, 9]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Pass the given matrix and the number of rows of the given matrix as the arguments\r\n# to the checkdiagnolydominant_matx() function and check if returns true or false\r\n# using the if conditional statement.\r\nif((checkdiagnolydominant_matx(mtrx, mtrxrows))):\r\n  # If it is true, print \"Yes, the given matrix is a diagonally dominant matrix\".\r\n    print(\"Yes, the given matrix is a diagonally dominant matrix\")\r\nelse:\r\n  # Else print \"No, the given matrix is not a diagonally dominant matrix\".\r\n    print(\"No, the given matrix is not a diagonally dominant matrix\")"}
{"nl": "Given Nodes with their priority, implement a priority queue using doubly linked list. \n\nPrerequisite : Priority Queue\n\npush(): This function is used to insert a new data into the queue.\npop(): This function removes the element with the lowest priority value form the queue.\npeek() / top(): This function is used to get the lowest priority element in the queue without removing it from the queue.", "code": "# Python3 code to implement priority\n# queue using doubly linked list\n\n# Linked List Node\nclass Node:\n\t\n\tdef __init__(self):\n\t\t\n\t\tself.info = 0\n\t\tself.priority = 0\n\t\tself.next = None\n\t\tself.prev = None\n\nfront = None\nrear = None\n\n# Function to insert a new Node\ndef push(fr, rr, n, p):\n\t\n\tglobal front, rear\n\t\n\tnews = Node()\n\tnews.info = n\n\tnews.priority = p\n\t\n\t# If linked list is empty\n\tif (fr == None):\n\t\tfr = news\n\t\trr = news\n\t\tnews.next = None\n\t\n\telse:\n\t\t\n\t\t# If p is less than or equal fr\n\t\t# node's priority, then insert at\n\t\t# the fr.\n\t\tif (p <= (fr).priority):\n\t\t\tnews.next = fr\n\t\t\t(fr).prev = news.next\n\t\t\tfr = news\n\n\t\t# If p is more rr node's priority,\n\t\t# then insert after the rr.\n\t\telif (p > (rr).priority):\n\t\t\tnews.next = None\n\t\t\t(rr).next = news\n\t\t\tnews.prev = (rr).next\n\t\t\trr = news\n\t\t\n\t\t# Handle other cases\n\t\telse:\n\n\t\t\t# Find position where we need to\n\t\t\t# insert.\n\t\t\tstart = (fr).next\n\t\t\t\n\t\t\twhile (start.priority > p):\n\t\t\t\tstart = start.next\n\t\t\t\t\n\t\t\t(start.prev).next = news\n\t\t\tnews.next = start.prev\n\t\t\tnews.prev = (start.prev).next\n\t\t\tstart.prev = news.next\n\t\t\t\n\tfront = fr\n\trear = rr\n\t\n# Return the value at rr\ndef peek(fr):\n\t\n\treturn fr.info\n\t\t\t\ndef isEmpty(fr):\n\t\n\treturn fr == None\n\n# Removes the element with the\n# least priority value form the list\ndef pop(fr, rr):\n\t\n\tglobal front , rear\n\ttemp = fr\n\tres = temp.info\n\t(fr) = (fr).next\n\t\n\tif (fr == None):\n\t\trr = None\n\t\t\n\tfront = fr\n\trear = rr\n\treturn res\n\n# Driver code\nif __name__=='__main__':\n\t\n\tpush( front, rear, 2, 3)\n\tpush( front, rear, 3, 4)\n\tpush( front, rear, 4, 5)\n\tpush( front, rear, 5, 6)\n\tpush( front, rear, 6, 7)\n\tpush( front, rear, 1, 2)\n\t\n\tprint(pop(front, rear))\n\tprint(peek(front))\n\n# This code is contributed by rutvik_56"}
{"nl": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.", "code": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # If the list has just one element then return that element.\n        if len(nums) == 1:\n            return nums[0]\n\n        # left pointer\n        left = 0\n        # right pointer\n        right = len(nums) - 1\n\n        # if the last element is greater than the first element then there is no rotation.\n        # e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.\n        # Hence the smallest element is first element. A[0]\n        if nums[right] > nums[0]:\n            return nums[0]\n\n        # Binary search way\n        while right >= left:\n            # Find the mid element\n            mid = left + (right - left) / 2\n            # if the mid element is greater than its next element then mid+1 element is the smallest\n            # This point would be the point of change. From higher to lower value.\n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            # if the mid element is lesser than its previous element then mid element is the smallest\n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n\n            # if the mid elements value is greater than the 0th element this means\n            # the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]\n            if nums[mid] > nums[0]:\n                left = mid + 1\n            # if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left\n            else:\n                right = mid - 1"}
{"nl": "You are given a list of dates in the format Dec 11 and a month in the format Dec as arguments. Each date represents a video that was uploaded on that day. Return the number of uploads for a given month.\nExamples\nupload_count([\"Sept 22\", \"Sept 21\", \"Oct 15\"], \"Sept\") \u279e 2\n\nupload_count([\"Sept 22\", \"Sept 21\", \"Oct 15\"], \"Oct\") \u279e 1\nNotes\nIf you only pay attention to the month and ignore the day, the challenge will become easier.", "code": "def upload_count(dates, month):\n  return str(dates).count(month)"}
{"nl": "In the previous post, we discussed range update and point query solutions using BIT. \r\nrangeUpdate(l, r, val) : We add \u2018val\u2019 to element at index \u2018l\u2019. We subtract \u2018val\u2019 from element at index \u2018r+1\u2019. \r\ngetElement(index) [or getSum()]: We return sum of elements from 0 to index which can be quickly obtained using BIT.\r\nWe can compute rangeSum() using getSum() queries. \r\nrangeSum(l, r) = getSum(r) \u2013 getSum(l-1)", "code": "# Python program to demonstrate Range Update\r\n# and Range Queries using BIT\r\n \r\n# Returns sum of arr[0..index]. This function assumes\r\n# that the array is preprocessed and partial sums of\r\n# array elements are stored in BITree[]\r\ndef getSum(BITree: list, index: int) -> int:\r\n    summ = 0 # Initialize result\r\n \r\n    # index in BITree[] is 1 more than the index in arr[]\r\n    index = index + 1\r\n \r\n    # Traverse ancestors of BITree[index]\r\n    while index > 0:\r\n \r\n        # Add current element of BITree to sum\r\n        summ += BITree[index]\r\n \r\n        # Move index to parent node in getSum View\r\n        index -= index & (-index)\r\n    return summ\r\n \r\n# Updates a node in Binary Index Tree (BITree) at given\r\n# index in BITree. The given value 'val' is added to\r\n# BITree[i] and all of its ancestors in tree.\r\ndef updateBit(BITTree: list, n: int, index: int, val: int) -> None:\r\n \r\n    # index in BITree[] is 1 more than the index in arr[]\r\n    index = index + 1\r\n \r\n    # Traverse all ancestors and add 'val'\r\n    while index <= n:\r\n \r\n        # Add 'val' to current node of BI Tree\r\n        BITTree[index] += val\r\n \r\n        # Update index to that of parent in update View\r\n        index += index & (-index)\r\n \r\n \r\n# Returns the sum of array from [0, x]\r\ndef summation(x: int, BITTree1: list, BITTree2: list) -> int:\r\n    return (getSum(BITTree1, x) * x) - getSum(BITTree2, x)\r\n \r\n \r\ndef updateRange(BITTree1: list, BITTree2: list, n: int, val: int, l: int,\r\n                r: int) -> None:\r\n \r\n    # Update Both the Binary Index Trees\r\n    # As discussed in the article\r\n \r\n    # Update BIT1\r\n    updateBit(BITTree1, n, l, val)\r\n    updateBit(BITTree1, n, r + 1, -val)\r\n \r\n    # Update BIT2\r\n    updateBit(BITTree2, n, l, val * (l - 1))\r\n    updateBit(BITTree2, n, r + 1, -val * r)\r\n \r\ndef rangeSum(l: int, r: int, BITTree1: list, BITTree2: list) -> int:\r\n \r\n    # Find sum from [0,r] then subtract sum\r\n    # from [0,l-1] in order to find sum from\r\n    # [l,r]\r\n    return summation(r, BITTree1, BITTree2) - summation(\r\n        l - 1, BITTree1, BITTree2)\r\n \r\n# Driver Code\r\nif __name__ == \"__main__\":\r\n    n = 5\r\n \r\n    # BIT1 to get element at any index\r\n    # in the array\r\n    BITTree1 = [0] * (n + 1)\r\n \r\n    # BIT 2 maintains the extra term\r\n    # which needs to be subtracted\r\n    BITTree2 = [0] * (n + 1)\r\n \r\n    # Add 5 to all the elements from [0,4]\r\n    l = 0\r\n    r = 4\r\n    val = 5\r\n    updateRange(BITTree1, BITTree2, n, val, l, r)\r\n \r\n    # Add 2 to all the elements from [2,4]\r\n    l = 2\r\n    r = 4\r\n    val = 10\r\n    updateRange(BITTree1, BITTree2, n, val, l, r)\r\n \r\n    # Find sum of all the elements from\r\n    # [1,4]\r\n    l = 1\r\n    r = 4\r\n    print(\"Sum of elements from [%d,%d] is %d\" %\r\n        (l, r, rangeSum(l, r, BITTree1, BITTree2)))\r\n \r\n# This code is contributed by\r\n# sanjeev2552"}
{"nl": "Mubashir has started his journey from home. Given a string of directions (N=North, W=West, S=South, E=East), he will walk for one minute in each direction. Determine whether a set of directions will lead him back to the starting position or not.\nExamples\nback_to_home(\"EEWE\") \u279e False\n\nback_to_home(\"NENESSWW\") \u279e True\n\nback_to_home(\"NEESSW\") \u279e False\nNotes\nN/A", "code": "def back_to_home(d):\n  return d.count('N') == d.count('S') and d.count('E') == d.count('W')"}
{"nl": "In this challenge, you have to implement an algorithm to establish if a given positive integer num is a Happy number, and how many steps of the algorithm are needed to establish it.\n\nYou have to repeatedly transform the given num into the sum of its squared digits:\n\n1. If after the transformation the new number is equal to 1, num is a Happy number and the algorithm stops.\n2. If after the transformation, the new number is not equal to 1, you have to transform it again.\n\nIf a number can't be reduced to 1, sooner or later the algorithm will enter into an infinitely repeating loop:\n\n... 20, 4, 16, 37, 58, 89, 145, 42, 20, 4 ...\nGiven a positive integer num, implement a function that returns:\n\nIf num is a Happy number, the string \"HAPPY x\" with the \"x\" being the number of steps necessary to reduce num to 1.\nIf num is not a Happy number, the string \"SAD x\" with the \"x\" being the number of steps necessary to enter into the infinite loop reaching so any number in the series 4, 16, 37, 58, 89, 145, 42, 20, plus the number of steps necessary to obtain again that number.\nLook at the examples below for a better visualization.\n\nExamples\nhappy_algorithm(139) \u279e \"HAPPY 5\"\n\n# Step 1: Transform 139\n# 1\u00b2 + 3\u00b2 + 9\u00b2 = 1 + 9 + 81 = 91\n\n# Step 2: Transform 91\n# 9\u00b2 + 1\u00b2 = 81 + 1 = 82\n\n# Step 3: Transform 82\n# 8\u00b2 + 2\u00b2 = 64 + 4 = 68\n\n# Step 4: Transform 68\n# 6\u00b2 + 8\u00b2 = 36 + 64 = 100\n\n# Step 5: Transform 100\n# 1\u00b2 + 0\u00b2 + 0\u00b2 = 1 + 0 + 0 = 1\n\n# The algorithm stops at step 5: 139 is a Happy number\n\nhappy_algorithm(67) \u279e \"SAD 10\"\n\n# Step 1: Transform 67\n# 6\u00b2 + 7\u00b2 = 36 + 49 = 85\n\n# Step 2: Transform 85\n# 8\u00b2 + 5\u00b2 = 64 + 25 = 89\n# It entered into the infinite loop...\n# ...but we have to demonstrate that is a loop!\n\n# Step 3: Transform 89\n# 8\u00b2 + 9\u00b2 = 64 + 81 = 145\n\n# Step 4: Transform 145: result is 42\n# Step 5: Transform 42: result is 20\n# Step 6: Transform 20: result is 4\n# Step 7: Transform 4: result is 16\n# Step 8: Transform 16: result is 37\n# Step 9: Transform 37: result is 58\n# Step 10: Transform 58: result is 89\n\n# 89 was the result of step 2: it's a loop\n# The algorithm stops at step 10: 67 is not a Happy number\n\nhappy_algorithm(1) \u279e \"HAPPY 1\"\n\n# Step 1: Transform 1\n# 1\u00b2 = 1\n\n# The algorithm stops at step 1: 1 is a Happy number\n\nhappy_algorithm(89) \u279e \"SAD 8\"\n\n# Step 1: Transform 89: result is 145\n# Step 2: Transform 145: result is 42\n# Step 3: Transform 42: result is 20\n# Step 4: Transform 20: result is 4\n# Step 5: Transform 4: result is 16\n# Step 6: Transform 16: result is 37\n# Step 7: Transform 37: result is 58\n# Step 8: Transform 58: result is 89\n\n# 89 was the original number: it's a loop\n# The algorithm stops at step 8: 89 is not a Happy number\nNotes\nThe transformation of a single-digit number is, trivially, the square of the digit (see example #3).\nIf the given number is 1, a step is needed to establish if it's Happy (see example #3).\nTo establish if a number is not happy, you have to find the number of steps necessary to obtain again a number already found (it can be a number obtained through a transformation as in example #2 or the same given number as in example #4).\nYou can expect only positive integers as input, without exceptions to handle.", "code": "def happy_algorithm(n):\n    if n == 1:\n        return 'HAPPY 1'\n    found = [1]\n    while n not in found:\n        found.append(n)\n        n = sum(int(i)**2 for i in str(n))\n    return '{} {}'.format('HAPPY' if n == 1 else 'SAD', len(found) - 1)"}
{"nl": "Create a function that takes a list of factorial expressions and returns the sum.\n\nExamples\neval_factorial([\"2!\", \"3!\"]) \u279e 8\n\neval_factorial([\"5!\", \"4!\", \"2!\"]) \u279e 146\n\neval_factorial([\"0!\", \"1!\"]) \u279e 2", "code": "def eval_factorial(lst):\n\treturn sum(fac(int(k[:-1])) for k in lst)\n\ndef fac(n):\n\treturn n*fac(n-1) if n else 1"}
{"nl": "In the previous article, we have discussed Python Program to Get Tangent value Using math.tan()\n Disarium Number:\n A Disarium number is one in which the sum of each digit raised to the power of its respective position equals the original number.\n like 135 , 89, etc.\n Here 1^1 + 3^2 + 5^3 = 135 so it is disarium Number\n Examples:\n Example1:\n Input:\n Given lower limit range = 7\n \n Given upper limit range = 180\n Output:\n The disarium numbers in the given range 7 and 180 are: \n \n 7 8 9 89 135 175\n Example 2:\n Input:\n Given lower limit range = 1\n \n Given upper limit range = 250\n Output:\n The disarium numbers in the given range 1 and 250 are:\n \n 1 2 3 4 5 6 7 8 9 89 135 175", "code": "# Give the lower limit range as static input and store it in a variable.\n \n lowlim_range = 7\n \n # Give the upper limit range as static input and store it in another variable.\n \n upplim_range = 180\n \n print('The disarium numbers in the given range',\n \n  lowlim_range, 'and', upplim_range, 'are:')\n \n # Loop from lower limit range to upper limit range using For loop.\n \n for m in range(lowlim_range, upplim_range+1):\n \n \n \n  # given number\n \n  num = m\n \n  # intialize result to zero(ans)\n \n  ans = 0\n \n \n \n  # calculating the digits\n \n  digit_s = len(str(num))\n \n  # copy the number in another variable(duplicate)\n \n  dup_numbr = num\n \n  while (dup_numbr != 0):\n \n  # getting the last digit\n \n  remaindr = dup_numbr % 10\n \n  # multiply the result by a digit raised to the power of the iterator value.\n \n  ans = ans + remaindr**digit_s\n \n  digit_s = digit_s - 1\n \n  dup_numbr = dup_numbr//10\n \n  # It is disarium number if it is equal to original number\n \n  if(num == ans):\n \n  print(num, end=' ')\n \n </pre>"}
{"nl": "Given the number of rows(largest number) the task is to print the Right Triangle Number pattern in C, C++, and Python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven number of rows of the right triangle = 11\nOutput:\n\n1 \n2 2 \n3 3 3 \n4 4 4 4 \n5 5 5 5 5 \n6 6 6 6 6 6 \n7 7 7 7 7 7 7 \n8 8 8 8 8 8 8 8 \n9 9 9 9 9 9 9 9 9 \n10 10 10 10 10 10 10 10 10 10 \n11 11 11 11 11 11 11 11 11 11 11\nExample2:\n\nInput:\n\ngiven number of rows of the right triangle = 9\nOutput:\n\n1 \n2 2 \n3 3 3 \n4 4 4 4 \n5 5 5 5 5 \n6 6 6 6 6 6 \n7 7 7 7 7 7 7 \n8 8 8 8 8 8 8 8 \n9 9 9 9 9 9 9 9 9", "code": "# Give the number of rows of the right-angled triangle Number pattern\n# as static input and store it in a variable.\ntriangleNum = 11\n# Loop from 1 to the number of rows using For loop.\nfor m in range(1, triangleNum+1):\n  # Loop from 1 to first loop iterator value using another Nested For loop.\n  for n in range(1, m+1):\n  # Print the iterator value of the nested loop with space in the inner For loop.\n  # (This prints the same number parent loop number of times)\n  print(m, end=' ')\n  # Print the newline character after ending of inner For loop.\n  print()"}
{"nl": "Given a Binary Tree where all values are from 0 to n-1. Construct an ancestor matrix mat[n][n]. Ancestor matrix is defined as below.\nmat[i][j] = 1 if i is ancestor of j\nmat[i][j] = 0, otherwise", "code": "# Python3 program to construct ancestor\n# matrix for given tree.\n\u00a0\nclass newnode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# anc[] stores all ancestors of current node.\n# This function fills ancestors for all nodes.\n# It also returns size of tree. Size of tree\u00a0\n# is used to print ancestor matrix.\ndef ancestorMatrixRec(root, anc):\n\u00a0\u00a0\u00a0\u00a0global mat, MAX\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# base case\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Update all ancestors of current node\n\u00a0\u00a0\u00a0\u00a0data = root.data\n\u00a0\u00a0\u00a0\u00a0for i in range(len(anc)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[anc[i]][data] = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Push data to list of ancestors\n\u00a0\u00a0\u00a0\u00a0anc.append(data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse left and right subtrees\n\u00a0\u00a0\u00a0\u00a0l = ancestorMatrixRec(root.left, anc)\n\u00a0\u00a0\u00a0\u00a0r = ancestorMatrixRec(root.right, anc)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Remove data from list the list of ancestors\n\u00a0\u00a0\u00a0\u00a0# as all descendants of it are processed now.\n\u00a0\u00a0\u00a0\u00a0anc.pop(-1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return l + r + 1\n\u00a0\n# This function mainly calls ancestorMatrixRec()\ndef ancestorMatrix(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an empty ancestor array\n\u00a0\u00a0\u00a0\u00a0anc = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Fill ancestor matrix and find\n\u00a0\u00a0\u00a0\u00a0# size of tree.\n\u00a0\u00a0\u00a0\u00a0n = ancestorMatrixRec(root, anc)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the filled values\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\nMAX = 100\nmat = [[0] * MAX for i in range(MAX)]\n\u00a0\n# Construct the following binary tree\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 5\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 / \\\n#\u00a0\u00a0\u00a0\u00a0 1\u00a0\u00a0\u00a0\u00a0 2\n#\u00a0\u00a0\u00a0\u00a0 / \\ /\n#\u00a0\u00a0\u00a0\u00a0 0 4 3\nroot = newnode(5)\nroot.left = newnode(1)\nroot.right = newnode(2)\nroot.left.left = newnode(0)\nroot.left.right = newnode(4)\nroot.right.left = newnode(3)\n\u00a0\nancestorMatrix(root)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "In this challenge, you have to establish if the digits of a given number form a sequence (ascending or descending).\n\nGiven an integer n, implement a function that returns a string:\n\n\"Metadrome\" if the digits of n form an ascending sequence without repeating digits.\n\"Plaindrome\" if the digits of n form an ascending sequence with repeating digits.\n\"Katadrome\" if the digits of n form a descending sequence without repeating digits.\n\"Nialpdrome\" if the digits of n form a descending sequence with repeating digits.\n\"Repdrome\" if n contains a single repeating digit.\n\"Nondrome\" if none of the above conditions is true.\nExamples\ndigitaldrome(1357) \u279e \"Metadrome\"\n# Ascending sequence without repeating digits\n\ndigitaldrome(12344) \u279e \"Plaindrome\"\n# Ascending sequence with repeating digits\n\ndigitaldrome(7531) \u279e \"Katadrome\"\n# Descending sequence without repeating digits\n\ndigitaldrome(9874441) \u279e \"Nialpdrome\"\n# Descending sequence with  repeating digits\n\ndigitaldrome(666) \u279e \"Repdrome\"\n# There's only a single repeating digit\n\ndigitaldrome(1985) \u279e \"Nondrome\"\n# This is not a sequence\nNotes\nAny given n will be a positive integer.\nThe word \"drome\" comes from the Greek suffix for \"run\", while \"kata\" and \"meta\" are the prefixes for \"down\" (or \"into\") and \"after\" (or \"through\").", "code": "def digitaldrome(n):\r\n    s = str(n)\r\n    ordered = ''.join(sorted(s))\r\n    \r\n    if len(set(s)) == 1:\r\n        return 'Repdrome'\r\n    if s == ordered:\r\n        return 'Metadrome' if len(s) == len(set(s)) else 'Plaindrome'\r\n    if s == ordered[::-1]:\r\n        return 'Katadrome' if len(s) == len(set(s)) else 'Nialpdrome'\r\n    return 'Nondrome'"}
{"nl": "Given a sentence, the task is to print each word of a Sentence along with the number of vowels in each word.\n Examples:\n Example1:\n Input:\n Given word ='Hello this is BTechgeeks'\n Output:\n The total number of vowels in the given word { hello } is 2\n \n The total number of vowels in the given word { this } is 1\n \n The total number of vowels in the given word { is } is 1\n \n The total number of vowels in the given word { btechgeeks } is 3\n Example2:\n Input:\n Given word = 'good morning this is btechgeeks python coding platform'\n Output:\n The total number of vowels in the given word { good } is 2\n \n The total number of vowels in the given word { morning } is 2\n \n The total number of vowels in the given word { this } is 1\n \n The total number of vowels in the given word { is } is 1\n \n The total number of vowels in the given word { btechgeeks } is 3\n \n The total number of vowels in the given word { python } is 1\n \n The total number of vowels in the given word { coding } is 2\n \n The total number of vowels in the given word { platform } is 2", "code": "# Give the sentence as static input and store it in a variable.\n \n givnstrng = 'Hello this is BTechgeeks'\n \n # Convert the given string/sentence to lowercase using the lower() function.\n \n givnstrng = givnstrng.lower()\n \n # To break words from a sentence, use the string.split() method.\n \n # The words will be separated and kept in a list named \u2018wordslst'\n \n wordslst = givnstrng.split()\n \n # Create a list called vowelchars, which will hold all of the vowels in the English alphabet.\n \n vowelchars = ['a', 'e', 'i', 'o', 'u']\n \n # Iterate through the list of words and set up a counter to count\n \n # the number of vowels in each one.\n \n for gvnword in wordslst:\n \n  cntvowel = 0\n \n  # Start a nested loop that iterates throughout the word in question,\n \n  # checking whether any of the characters are vowels.\n \n  for m in gvnword:\n \n  # Increase the counter if a character is a vowel.\n \n  if m in vowelchars:\n \n  cntvowel = cntvowel+1\n \n  # Print the current iteration's word and the value\n \n  # of the counter corresponding with it\n \n  # (which contains the sentence's number of vowels).\n \n  print(\n \n  'The total number of vowels in the given word {', gvnword, '} is', cntvowel)\n \n </pre>"}
{"nl": "Given an undirected tree whose each node is associated with a weight. We need to delete an edge in such a way that difference between sum of weight in one subtree to sum of weight in other subtree is minimized.", "code": "# Python3 program to minimize subtree\u00a0\n# Sum difference by one edge deletion\u00a0\n\u00a0\u00a0\n# DFS method to traverse through edges,\u00a0\n# calculating subtree Sum at each node and\u00a0\n# updating the difference between subtrees\u00a0\ndef dfs(u, parent, totalSum, edge,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subtree, res):\u00a0\n\u00a0\u00a0\u00a0\u00a0Sum = subtree[u]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# loop for all neighbors except parent\u00a0\n\u00a0\u00a0\u00a0\u00a0# and aggregate Sum over all subtrees\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(len(edge[u])):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = edge[u][i]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (v != parent):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dfs(v, u, totalSum, edge,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subtree, res)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Sum += subtree[v]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# store Sum in current node's\u00a0\n\u00a0\u00a0\u00a0\u00a0# subtree index\u00a0\n\u00a0\u00a0\u00a0\u00a0subtree[u] = Sum\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# at one side subtree Sum is 'Sum' and\u00a0\n\u00a0\u00a0\u00a0\u00a0# other side subtree Sum is 'totalSum - Sum'\u00a0\n\u00a0\u00a0\u00a0\u00a0# so their difference will be totalSum - 2*Sum,\u00a0\n\u00a0\u00a0\u00a0\u00a0# by which we'll update res\u00a0\n\u00a0\u00a0\u00a0\u00a0if (u != 0 and abs(totalSum - 2 * Sum) < res[0]):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[0] = abs(totalSum - 2 * Sum)\u00a0\n\u00a0\u00a0\n# Method returns minimum subtree\u00a0\n# Sum difference\u00a0\ndef getMinSubtreeSumDifference(vertex, edges, N):\u00a0\n\u00a0\u00a0\u00a0\u00a0totalSum = 0\n\u00a0\u00a0\u00a0\u00a0subtree = [None] * N\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Calculating total Sum of tree\u00a0\n\u00a0\u00a0\u00a0\u00a0# and initializing subtree Sum's\u00a0\n\u00a0\u00a0\u00a0\u00a0# by vertex values\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subtree[i] = vertex[i]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalSum += vertex[i]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# filling edge data structure\u00a0\n\u00a0\u00a0\u00a0\u00a0edge = [[] for i in range(N)]\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N - 1):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge[edges[i][0]].append(edges[i][1])\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge[edges[i][1]].append(edges[i][0])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0res = [999999999999]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# calling DFS method at node 0,\u00a0\n\u00a0\u00a0\u00a0\u00a0# with parent as -1\u00a0\n\u00a0\u00a0\u00a0\u00a0dfs(0, -1, totalSum, edge, subtree, res)\u00a0\n\u00a0\u00a0\u00a0\u00a0return res[0]\u00a0\n\u00a0\u00a0\n# Driver Code\u00a0\nif __name__ == '__main__':\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0vertex = [4, 2, 1, 6, 3, 5, 2]\u00a0\n\u00a0\u00a0\u00a0\u00a0edges = [[0, 1], [0, 2], [0, 3],\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 4], [2, 5], [3, 6]]\u00a0\n\u00a0\u00a0\u00a0\u00a0N = len(vertex)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(getMinSubtreeSumDifference(vertex,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges, N))\u00a0\n\u00a0\u00a0\n# This code is contributed by PranchalK\u00a0\n"}
{"nl": "We have discussed Dijkstra\u2019s algorithm and its implementation for adjacency matrix representation of graphs. The time complexity for the matrix representation is O(V^2). In this post, O(ELogV) algorithm for adjacency list representation is discussed.\n\nAs discussed in the previous post, in Dijkstra\u2019s algorithm, two sets are maintained, one set contains list of vertices already included in SPT (Shortest Path Tree), other set contains vertices not yet included. With adjacency list representation, all vertices of a graph can be traversed in O(V+E) time using\u00a0BFS. The idea is to traverse all vertices of graph using\u00a0BFS\u00a0and use a Min Heap to store the vertices not yet included in SPT (or the vertices for which shortest distance is not finalized yet). \u00a0Min Heap is used as a priority queue to get the minimum distance vertex from set of not yet\u00a0included\u00a0vertices. Time complexity of operations like extract-min and decrease-key value is O(LogV) for Min Heap.\nFollowing are the detailed steps.\u00a0\n1)\u00a0Create a Min Heap of size V where V is the number of vertices in the given graph. Every node of min heap contains vertex number and distance value of the vertex.\u00a0\n2)\u00a0Initialize Min Heap with source vertex as root (the distance value assigned to source vertex is 0). The distance value assigned to all other vertices is INF (infinite).\u00a0\n3)\u00a0While Min Heap is not empty, do following\u00a0\n\u2026..a)\u00a0Extract the vertex with minimum distance value node from Min Heap. Let the extracted vertex be u.\u00a0\n\u2026..b)\u00a0For every adjacent vertex v of u, check if v is in Min Heap. If v is in Min Heap and distance value is more than weight of u-v plus distance value of u, then update the distance value of v.\n\n", "code": "# A Python program for Dijkstra's shortest\n# path algorithm for adjacency\n# list representation of graph\n\u00a0\nfrom collections import defaultdict\nimport sys\n\u00a0\n\u00a0\nclass Heap():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def newMinHeapNode(self, v, dist):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeapNode = [v, dist]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return minHeapNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A utility function to swap two nodes\n\u00a0\u00a0\u00a0\u00a0# of min heap. Needed for min heapify\n\u00a0\u00a0\u00a0\u00a0def swapMinHeapNode(self, a, b):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = self.array[a]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[a] = self.array[b]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[b] = t\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A standard function to heapify at given idx\n\u00a0\u00a0\u00a0\u00a0# This function also updates position of nodes\n\u00a0\u00a0\u00a0\u00a0# when they are swapped.Position is needed\n\u00a0\u00a0\u00a0\u00a0# for decreaseKey()\n\u00a0\u00a0\u00a0\u00a0def minHeapify(self, idx):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest = idx\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = 2*idx + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = 2*idx + 2\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (left < self.size and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[left][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0< self.array[smallest][1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest = left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (right < self.size and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[right][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0< self.array[smallest][1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest = right\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# The nodes to be swapped in min\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# heap if idx is not smallest\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if smallest != idx:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Swap positions\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[self.array[smallest][0]] = idx\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[self.array[idx][0]] = smallest\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Swap nodes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.swapMinHeapNode(smallest, idx)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.minHeapify(smallest)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Standard function to extract minimum\n\u00a0\u00a0\u00a0\u00a0# node from heap\n\u00a0\u00a0\u00a0\u00a0def extractMin(self):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Return NULL wif heap is empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty() == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Store the root node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = self.array[0]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Replace root node with last node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastNode = self.array[self.size - 1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[0] = lastNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update position of last node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[lastNode[0]] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[root[0]] = self.size - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Reduce heap size and heapify root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.minHeapify(0)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.size == 0 else False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def decreaseKey(self, v, dist):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the index of v in\u00a0 heap array\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = self.pos[v]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the node and update its dist value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[i][1] = dist\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Travel up while the complete tree is\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# not hepified. This is a O(Logn) loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (i > 0 and self.array[i][1] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[(i - 1) // 2][1]):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Swap this node with its parent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[ self.array[i][0] ] = (i-1)//2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[ self.array[(i-1)//2][0] ] = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.swapMinHeapNode(i, (i - 1)//2 )\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# move to parent index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = (i - 1) // 2;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A utility function to check if a given\n\u00a0\u00a0\u00a0\u00a0# vertex 'v' is in min heap or not\n\u00a0\u00a0\u00a0\u00a0def isInMinHeap(self, v):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.pos[v] < self.size:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\ndef printArr(dist, n):\n\u00a0\u00a0\u00a0\u00a0print (\"Vertex\\tDistance from source\")\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"%d\\t\\t%d\" % (i,dist[i]))\n\u00a0\n\u00a0\nclass Graph():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Adds an edge to an undirected graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self, src, dest, weight):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add an edge from src to dest.\u00a0 A new node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is added to the adjacency list of src. The\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# node is added at the beginning. The first\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element of the node has the destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and the second elements has the weight\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode = [dest, weight]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[src].insert(0, newNode)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Since graph is undirected, add an edge\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# from dest to src also\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode = [src, weight]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[dest].insert(0, newNode)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# The main function that calculates distances\n\u00a0\u00a0\u00a0\u00a0# of shortest paths from src to all vertices.\n\u00a0\u00a0\u00a0\u00a0# It is a O(ELogV) function\n\u00a0\u00a0\u00a0\u00a0def dijkstra(self, src):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = self.V\u00a0 # Get the number of vertices in graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist = []\u00a0\u00a0 # dist values used to pick minimum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# weight edge in cut\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# minHeap represents set E\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap = Heap()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#\u00a0 Initialize min heap with all vertices.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# dist value of all vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for v in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist.append(1e7)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.array.append( minHeap.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newMinHeapNode(v, dist[v]))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.pos.append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Make dist value of src vertex as 0 so\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# that it is extracted first\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.pos[src] = src\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[src] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.decreaseKey(src, dist[src])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Initially size of min heap is equal to V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.size = V;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# In the following loop,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# min heap contains all nodes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# whose shortest distance is not yet finalized.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while minHeap.isEmpty() == False:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Extract the vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# with minimum distance value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newHeapNode = minHeap.extractMin()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = newHeapNode[0]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Traverse through all adjacent vertices of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# u (the extracted vertex) and update their\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# distance values\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for pCrawl in self.graph[u]:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = pCrawl[0]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If shortest distance to v is not finalized\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# yet, and distance to v through u is less\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than its previously calculated distance\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (minHeap.isInMinHeap(v) and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[u] != 1e7 and \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pCrawl[1] + dist[u] < dist[v]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[v] = pCrawl[1] + dist[u]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# update distance value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in min heap also\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.decreaseKey(v, dist[v])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printArr(dist,V)\n\u00a0\n\u00a0\n# Driver program to test the above functions\ngraph = Graph(9)\ngraph.addEdge(0, 1, 4)\ngraph.addEdge(0, 7, 8)\ngraph.addEdge(1, 2, 8)\ngraph.addEdge(1, 7, 11)\ngraph.addEdge(2, 3, 7)\ngraph.addEdge(2, 8, 2)\ngraph.addEdge(2, 5, 4)\ngraph.addEdge(3, 4, 9)\ngraph.addEdge(3, 5, 14)\ngraph.addEdge(4, 5, 10)\ngraph.addEdge(5, 6, 2)\ngraph.addEdge(6, 7, 1)\ngraph.addEdge(6, 8, 6)\ngraph.addEdge(7, 8, 7)\ngraph.dijkstra(0)\n\u00a0\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "Print all triplets in sorted array that form AP\n(Arithmetic Progression)\nExamples : \n \n\nInput : arr[] = { 2, 6, 9, 12, 17, 22, 31, 32, 35, 42 };\nOutput :\n6 9 12\n2 12 22\n12 17 22\n2 17 32\n12 22 32\n9 22 35\n2 22 42\n22 32 42\n", "code": "# python 3 program to print all triplets in given\n# array that form Arithmetic Progression\n\n# Function to print all triplets in\n# given sorted array that forms AP\ndef printAllAPTriplets(arr, n):\n\n        for i in range(1, n - 1):\n\n                # Search other two elements of\n                # AP with arr[i] as middle.\n                j = i - 1\n                k = i + 1\n                while(j >= 0 and k < n ):\n\n                        # if a triplet is found\n                        if (arr[j] + arr[k] == 2 * arr[i]):\n                                print(arr[j], \"\", arr[i], \"\", arr[k])\n\n                                # Since elements are distinct,\n                                # arr[k] and arr[j] cannot form\n                                # any more triplets with arr[i]\n                                k += 1\n                                j -= 1\n                        \n\n                        # If middle element is more move to\n                        # higher side, else move lower side.\n                        elif (arr[j] + arr[k] < 2 * arr[i]):\n                                k += 1        \n                        else:\n                                j -= 1        \n                \n# Driver code\narr = [ 2, 6, 9, 12, 17,\n                22, 31, 32, 35, 42 ]\nn = len(arr)\nprintAllAPTriplets(arr, n)\n\n# This article is contributed\n# by Smitha Dinesh Semwal\n"}
{"nl": "Problem: Given an array arr[] of n elements, write a function to search a given element x in arr[].\n\nExamples :  \n\n\n\nInput : arr[] = {10, 20, 80, 30, 60, 50, \n                     110, 100, 130, 170}\n          x = 110;\nOutput : 6\nElement x is present at index 6\n\nInput : arr[] = {10, 20, 80, 30, 60, 50, \n                     110, 100, 130, 170}\n           x = 175;\nOutput : -1\nElement x is not present in arr[].", "code": "# Python3 code to linearly search x in arr[].\n# If x is present then return its location,\n# otherwise return -1\n\n\ndef search(arr, n, x):\n\n\tfor i in range(0, n):\n\t\tif (arr[i] == x):\n\t\t\treturn i\n\treturn -1\n\n\n# Driver Code\narr = [2, 3, 4, 10, 40]\nx = 10\nn = len(arr)\n\n# Function call\nresult = search(arr, n, x)\nif(result == -1):\n\tprint(\"Element is not present in array\")\nelse:\n\tprint(\"Element is present at index\", result)"}
{"nl": "We will look at how to separate odd and even integers in a list into two separate lists.\r\n\r\nWhen you divide a number by two, the result is an even number if the balance is zero.\r\n\r\nAn odd number is one that when divided by two has a remaining balance of one.", "code": "# given list\r\ngiven_list = [7, 24, 72, 39, 65, 87, 93,\r\n              27, 64, 96, 82, 36, 47, 75, 12, 58, 97]\r\n# Create two empty lists. one for storing even numbers and the other\r\n# for storing odd numbers, referred to as evenList and oddList.\r\nevenList = []\r\noddList = []\r\n# Using a for loop, traverse the given list.\r\nfor element in given_list:\r\n    # If the given list element is even then append this element to evenList\r\n    if(element % 2 == 0):\r\n        evenList.append(element)\r\n    # If the given list element is odd then append this element to oddList\r\n    else:\r\n        oddList.append(element)\r\n# printing both evenList and oddList\r\nprint(\"The even elements present in given list are :\")\r\nprint(evenList)\r\nprint(\"The odd elements present in given list are :\")\r\nprint(oddList)"}
{"nl": "In this example, we have defined two set variables and we have performed different set operations: union, intersection, difference and symmetric difference.", "code": "# Program to perform different set operations like in mathematics\n\n# define three sets\nE = {0, 2, 4, 6, 8};\nN = {1, 2, 3, 4, 5};\n\n# set union\nprint(\"Union of E and N is\",E | N)\n\n# set intersection\nprint(\"Intersection of E and N is\",E & N)\n\n# set difference\nprint(\"Difference of E and N is\",E - N)\n\n# set symmetric difference\nprint(\"Symmetric difference of E and N is\",E ^ N)"}
{"nl": "Create a function that takes a single word string and does the following:\nConcatenates inator to the end if the word ends with a consonant, otherwise, concatenate -inator instead.\nAdds the word length of the original word to the end, supplied with \"000\".\nThe examples should make this clear.\nExamples\ninator_inator(\"Shrink\") \u279e \"Shrinkinator 6000\"\n\ninator_inator(\"Doom\") \u279e \"Doominator 4000\"\n\ninator_inator(\"EvilClone\") \u279e \"EvilClone-inator 9000\"\nNotes\nFor the purposes of this challenge, vowels will be a, e, i, o and u only.", "code": "def inator_inator(s):\n  return '{}{}inator {}000'.format(s, '-' if s[-1].lower() in 'aeiou' else '', len(s))"}
{"nl": "Lists in Python:\n A list is exactly what it sounds like: a container for various Python objects such as integers, words, values, and so on. In other programming languages, it is equal to an array. It is denoted with square brackets (and this is one of the attributes that differentiates it from tuples, which are separated by parentheses). It is also mutable, which means it can be changed or altered, as opposed to tuples, which are immutable.\n Given lower limit and upper limit , the task is to print all numbers in the given range which are perfect squares and sum of all Digits in the Number is Less than 10.\n Examples:\n Example1:\n Input:\n Enter some random lower limit =5\n \n Enter some random lower limit =525\n Output:\n Printing the perfect squares numbers list which are less than 10: [9, 16, 25, 36, 81, 100, 121, 144, 225, 324, 400, 441]\n Example2:\n Input:\n Enter some random lower limit =69\n \n Enter some random lower limit =2379\n Output:\n Printing the perfect squares numbers list which are less than 10: [81, 100, 121, 144, 225, 324, 400, 441, 900, 1024, 1521, 1600, 2025, 2304]", "code": "# given lower limit range as static input\n \n lowerlimit = 5\n \n # given upper limit range as static input\n \n upperlimit = 525\n \n # When the element is a perfect square within the range and the total of the digits of the number\n \n # is less than 10, a list must be generated using list comprehension.\n \n prftSquaresList = [k for k in range(\n \n  lowerlimit, upperlimit+1) if (int(k**0.5))**2 == k and sum(list(map(int, str(k)))) &lt; 10]\n \n # printing the list\n \n print(\"Printing the perfect squares numbers list which are less than 10: \", prftSquaresList)\n \n </pre>"}
{"nl": "Method #1: Using For loop (Star Character)\r\nApproach:\r\n\r\nGive the number of rows of the right triangle pattern as static input and store it in a variable.\r\nIterate from 1 to given rows using the First For loop.\r\nIterate from 1 to given rows using another for loop(Nested For loop)\r\nCheck if the iterator value of the inner for loop is less than or equal to given rows \u2013 first iterator value using If statement.\r\nIf the statement is true then print space.\r\nElse print the star character with space.\r\nPrint the newline character after the exit of the inner for loop.\r\nThe Exit of the Program.", "code": "# Give the number of rows of the right triangle pattern as static input and store it in a variable.\r\ntriNumRows = 6\r\n# Iterate from 1 to given rows using the First for loop.\r\nfor m in range(1, triNumRows+1):\r\n    # Iterate from 1 to given rows using another for loop(Nested For loop)\r\n    for n in range(1, triNumRows+1):\r\n        # Check if the iterator value of the inner for loop is less than or equal to given rows - first iterator value using If statement.\r\n        if(n <= triNumRows - m):\r\n            # If the statement is true then print space.\r\n            print(' ', end=' ')\r\n        else:\r\n            # Else print star character with space.\r\n            print('*', end=' ')\r\n    #Print the newline character after the exit of the inner for loop.\r\n    print()"}
{"nl": "How to Find Vowels and Consonants in Python | we use the if-elif-else statement and for loop to find vowel and consonant.", "code": "# Python code to find character is vowels or consonants # inputs from the user c = input('Enter a Characters: ') # find vowel or constant and display result if(c=='A' or c=='a' or c=='E' or c =='e' or c=='I' or c=='i' or c=='O' or c=='o' or c=='U' or c=='u'): print(c, \"is a Vowels.\") else: print(c, \"is a Consonants.\")"}
{"nl": "Given a number, thee task is to reverse the given number in Python.\n Examples:\n Example1:\n Input:\n number=12345\n Output:\n The reversed number = 54321\n Explanation:\n After reversing the number we get 54321\n Example2:\n Input:\n number=7341\n Output:\n The reversed number = 1437\n Example3:\n Input:\n number=9840\n Output:\n The reversed number = 489\n Explanation:\n Here the reversed number is 0489 we neglect the leading zero so the reversed number is 489", "code": "# given number\n \n given_num = 12345\n \n \n \n # Take a variable reverse_number and initialize it to null\n \n reverse_number = 0\n \n \n \n # using while loop to reverse the given number\n \n \n \n while (given_num > 0):\n \n  # implementing the algorithm\n \n  # getting the last digit\n \n  remainder = given_num % 10\n \n  reverse_number = (reverse_number * 10) + remainder\n \n  given_num = given_num // 10\n \n \n \n # Display the result\n \n print(\"The reversed number =\", reverse_number)"}
{"nl": "Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null nodes are assigned tilt to be zero. Therefore, tilt of the whole tree is defined as the sum of all nodes\u2019 tilt.\n\u00a0", "code": "# Python3 Program to find Tilt of\n# Binary Tree\n\u00a0\n# class that allocates a new node\n# with the given data and\n# None left and right pointers.\nclass newNode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.val = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\n# Recursive function to calculate\n# Tilt of whole tree\ndef traverse(root, tilt):\n\u00a0\u00a0\u00a0\u00a0if (not root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Compute tilts of left and right subtrees\n\u00a0\u00a0\u00a0\u00a0# and find sums of left and right subtrees\n\u00a0\u00a0\u00a0\u00a0left = traverse(root.left, tilt)\n\u00a0\u00a0\u00a0\u00a0right = traverse(root.right, tilt)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Add current tilt to overall\n\u00a0\u00a0\u00a0\u00a0tilt[0] += abs(left - right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns sum of nodes under\n\u00a0\u00a0\u00a0\u00a0# current tree\n\u00a0\u00a0\u00a0\u00a0return left + right + root.val\n\u00a0\n# Driver function to print Tilt\n# of whole tree\ndef Tilt(root):\n\u00a0\u00a0\u00a0\u00a0tilt = [0]\n\u00a0\u00a0\u00a0\u00a0traverse(root, tilt)\n\u00a0\u00a0\u00a0\u00a0return tilt[0]\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us construct a Binary Tree\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 4\n\u00a0\u00a0\u00a0\u00a0# / \\\n\u00a0\u00a0\u00a0\u00a0# 2 9\n\u00a0\u00a0\u00a0\u00a0# / \\ \\\n\u00a0\u00a0\u00a0\u00a0# 3 5 7\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = newNode(4)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(9)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(3)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(8)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(7)\n\u00a0\u00a0\u00a0\u00a0print(\"The Tilt of whole tree is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tilt(root))\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Given a matrix with just 0 and 1 elements, the task is to find the row in the matrix with the greatest number of 1s in that row in Python.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[1, 0, 0], [1, 1, 1], [1, 0, 1]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# take a variable which stores the number of 1's in the row and initialize it with 0\r\nmaxOnes = 0\r\n\r\n# Loop till the given number of rows using the For loop.\r\nfor p in range(mtrxrows):\r\n        # calculate the number of ones in that row using the count() function\r\n    numbOfOnes = mtrx[p].count(1)\r\n    # check if the number of ones in that row is greater or equal to\r\n    # than maxOnes using the if conditional statement\r\n    if(numbOfOnes >= maxOnes):\r\n        # if it is true then initializee maxOnes with numbOfOnes\r\n        maxOnes = numbOfOnes\r\n        # take a variable and store this row number in this row\r\n        maxOnesRow = p+1\r\n# print the row that is containing maximum number of 1's by printing  maxOnesRow\r\nprint('The row which is containing maximum number of 1 is :', maxOnesRow)"}
{"nl": "Given a list, rotate the values clockwise by one (the last value is sent to the first position).\nCheck the examples for a better understanding.\nExamples\nrotate_by_one([1, 2, 3, 4, 5]) \u279e [5, 1, 2, 3, 4]\n\nrotate_by_one([6, 5, 8, 9, 7]) \u279e [7, 6, 5, 8, 9]\n\nrotate_by_one([20, 15, 26, 8, 4]) \u279e [4, 20, 15, 26, 8]\nNotes\nAll lists are the same size, so it's not necessary to use loops or to think much about complex solutions.", "code": "def rotate_by_one(lst):\n    return [lst[-1]]+lst[0:-1]"}
{"nl": "In mathematics, Pascal's triangle is an array of the binomial coefficients. Each coefficients can be obtained by summing adjacent elements in preceding rows.\r\n\r\nThis Python program prints Pascal's Triangle up to n rows given by user.", "code": "row = int(input(\"Enter number of rows: \"))\r\n\r\nspace = 36\r\n\r\n# empty list containg all 0s\r\na = [0] * 20 \r\n\r\n\r\nprint(\"\\n\\t\\t\\t\\t*** PASCAL TRIANGLE ***\\n\")\r\nfor i in range(row):\r\n    \r\n    for spi in range(1,space+1):\r\n        print(\" \", end=\"\")\r\n    \r\n    a[i] = 1\r\n    \r\n    for j in range(i+1):\r\n        print('%6d' %(a[j]), end = \"\")\r\n    \r\n    for j in range(i,0,-1):\r\n        a[j] = a[j] + a[j-1]\r\n    \r\n    space = space - 3\r\n    \r\n    print()"}
{"nl": "In the previous article, we have discussed Python Program to Find Maximum Element of each Row in a Matrix\n \n Given a matrix, the task is to find the unique matrix elements in the given matrix in python.\n \n What is a matrix:\n \n A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.\n \n Example:\n \n \n \n Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.\n \n In this order, the dimensions of a matrix indicate the number of rows and columns.\n \n \n \n Here as there are 5 rows and 4 columns it is called a 5*4 matrix.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given Matrix : \n 1 2 2\n 3 4 2 \n 5 1 5\n Output:\n \n The unique matrix elements in the given matrix are :\n 1 2 3 4 5\n Example2:\n \n Input:\n \n Given Matrix : \n 3 4 4\n 1 6 5\n 88 5 3\n Output:\n \n The unique matrix elements in the given matrix are :\n 3 4 1 6 5 88", "code": "# import the Counter Function from collections using the import keyword\n from collections import Counter\n # Give the matrix as static input and store it in a variable.\n mtrx = [[1, 2, 2], [3, 4, 2], [5, 1, 5]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n # take a list and initialize it to empty using [] or list() function\n mtrxlist = []\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # add the gvnmatrix[n][m] value to the list using the append() function\n  # where n is the iterator value of the parent For loop and m is the iterator\n  # value of the inner For loop.\n  mtrxlist.append(mtrx[n][m])\n # Apply the Counter function to the matrix elements list which stores the matrix element\n # as key and its frequency as value\n mtrxfreq = Counter(mtrxlist)\n # Print all the keys of the mtrxfreq(using keys() function)\n # which are the uniques values in the given matrix\n print('The unique matrix elements in the given matrix are :')\n print(*mtrxfreq.keys())"}
{"nl": "The del keyword is used to delete objects. In Python everything is an object, so the del keyword can also be used to delete variables, lists, or parts of a list etc.\r\n\r\n", "code": "class MyClass:\r\n  name = \"John\"\r\n\r\ndel MyClass\r\n\r\nprint(MyClass)"}
{"nl": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n \n\nConstraints:\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10", "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        # Sorting will help us to skip a number that have been\n        # already used at i-th position at specific permutation.\n        nums.sort()\n        ans = []\n        def backtrack(i=0, solution=[]):\n            ans.append(solution[:])\n            \n            for j in range(i, len(nums)):\n                # We can re-use numbers, but not at this position\n                # and same previous premutation\n                if j > i and nums[j] == nums[j-1]:\n                    continue\n                solution.append(nums[j])\n                backtrack(j+1, solution)\n                solution.pop()\n        backtrack()\n        return ans"}
{"nl": "OOP Exercise 4: Create a Bus class that inherits from the Vehicle class. Give the capacity argument of Bus.seating_capacity() a default value of 50.", "code": "class Vehicle:\r\n    def __init__(self, name, max_speed, mileage):\r\n        self.name = name\r\n        self.max_speed = max_speed\r\n        self.mileage = mileage\r\n\r\n    def seating_capacity(self, capacity):\r\n        return f\"The seating capacity of a {self.name} is {capacity} passengers\"\r\n\r\nclass Bus(Vehicle):\r\n    # assign default value to capacity\r\n    def seating_capacity(self, capacity=50):\r\n        return super().seating_capacity(capacity=50)\r\n\r\nSchool_bus = Bus(\"School Volvo\", 180, 12)\r\nprint(School_bus.seating_capacity())"}
{"nl": "Instructions\r\nAn Armstrong number is a number that is the sum of its own digits each raised to the power of the number of digits.\r\n\r\nFor example:\r\n\r\n9 is an Armstrong number, because 9 = 9^1 = 9\r\n10 is not an Armstrong number, because 10 != 1^2 + 0^2 = 1\r\n153 is an Armstrong number, because: 153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\r\n154 is not an Armstrong number, because: 154 != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 = 190\r\nWrite some code to determine whether a number is an Armstrong number.", "code": "# Armstrong numbers are equal to the sum of the powers of their digits\n# Exponent is the length of the number, base 10\ndef is_armstrong_number(number: int) -> bool:\n    \"\"\"Is number the equal to sum of powers of digits?\"\"\"\n    s = str(number)\n    exp = len(s)\n    return number == sum([int(ch)**exp for ch in s])"}
{"nl": "A succinct encoding of Binary Tree takes close to minimum possible space. The number of structurally different binary trees on n nodes is n\u2019th Catalan number. For large n, this is about 4n; thus we need at least about log2 4 n = 2n bits to encode it. A succinct binary tree therefore would occupy 2n+o(n) bits.", "code": "# Python program to demonstrate Succinct Tree Encoding and Decoding\n\u00a0\n# Node structure\nclass Node:\n\u00a0\u00a0\u00a0\u00a0# Utility function to create new Node\n\u00a0\u00a0\u00a0\u00a0def __init__(self , key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\ndef EncodeSuccinct(root , struc , data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If root is None , put 0 in structure array and return\n\u00a0\u00a0\u00a0\u00a0if root is None :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struc.append(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Else place 1 in structure array, key in 'data' array\n\u00a0\u00a0\u00a0\u00a0# and recur for left and right children\n\u00a0\u00a0\u00a0\u00a0struc.append(1)\n\u00a0\u00a0\u00a0\u00a0data.append(root.key)\n\u00a0\u00a0\u00a0\u00a0EncodeSuccinct(root.left , struc , data)\n\u00a0\u00a0\u00a0\u00a0EncodeSuccinct(root.right , struc ,data)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n# Constructs tree from 'struc' and 'data'\ndef DecodeSuccinct(struc , data):\n\u00a0\u00a0\u00a0\u00a0if(len(struc) <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Remove one item from structure list\n\u00a0\u00a0\u00a0\u00a0b = struc[0]\n\u00a0\u00a0\u00a0\u00a0struc.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If removed bit is 1\n\u00a0\u00a0\u00a0\u00a0if b == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0key = data[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#Create a tree node with removed data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#And recur to create left and right subtrees\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = DecodeSuccinct(struc , data);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = DecodeSuccinct(struc , data);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\ndef preorder(root):\n\u00a0\u00a0\u00a0\u00a0if root is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"key: %d\" %(root.key),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if root.left is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"| left child: %d\" %(root.left.key),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if root.right is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"| right child %d\" %(root.right.key),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print ()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0preorder(root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0preorder(root.right)\n\u00a0\n# Driver Program\nroot = Node(10)\nroot.left = Node(20)\nroot.right = Node(30)\nroot.left.left = Node(40)\nroot.left.right = Node(50)\nroot.right.right = Node(70)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\nprint (\"Given Tree\")\npreorder(root)\nstruc = []\ndata = []\nEncodeSuccinct(root , struc , data)\n\u00a0\nprint (\"\\nEncoded Tree\")\nprint (\"Structure List\")\n\u00a0\nfor i in struc:\n\u00a0\u00a0\u00a0\u00a0print (i ,end=\" \")\n\u00a0\nprint (\"\\nDataList\")\nfor value in data:\n\u00a0\u00a0\u00a0\u00a0print (value,end=\" \")\n\u00a0\nnewroot = DecodeSuccinct(struc , data)\n\u00a0\nprint (\"\\n\\nPreorder Traversal of decoded tree\")\npreorder(newroot)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Reversing an integer means to reverse all its digits.\n\nFor example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.\nGiven an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.\n\n ", "code": "class Solution:\n    def isSameAfterReversals(self, num: int) -> bool:\n        return (num == 0 or (num > 0 and num%10 != 0))"}
{"nl": "Create a function that determines whether the input sentence is a smooth sentence, returning a boolean value True if it is, False if it is not.", "code": "def is_smooth(sentence):\n    sentence = sentence.lower().split()\n    first = [first_letter[0] for first_letter in sentence]\n    last = [last_letter[-1] for last_letter in sentence]\n    return first[1:] == last [:-1]"}
{"nl": "Write a function that returns True if two arrays, when combined, form a consecutive sequence. A consecutive sequence is a sequence without any gaps in the integers, e.g. 1, 2, 3, 4, 5 is a consecutive sequence, but 1, 2, 4, 5 is not.\nExamples\nconsecutive_combo([7, 4, 5, 1], [2, 3, 6]) \u279e True\n\nconsecutive_combo([1, 4, 6, 5], [2, 7, 8, 9]) \u279e False\n\nconsecutive_combo([1, 4, 5, 6], [2, 3, 7, 8, 10]) \u279e False\n\nconsecutive_combo([44, 46], [45]) \u279e True\nNotes\nThe input lists will have unique values.\nThe input lists can be in any order.", "code": "def consecutive_combo(lst1, lst2):\n  lst3 = lst1 + lst2\n  return max(lst3) - min(lst3) == len(lst3) - 1"}
{"nl": "You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:\n\nThe ith (0-indexed) request arrives.\nIf all servers are busy, the request is dropped (not handled at all).\nIf the (i % k)th server is available, assign the request to that server.\nOtherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on.\n\nYou are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another array load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.\nReturn a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.\n \nExample 1:\n\n\nInput: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \nOutput: [1] \nExplanation: \nAll of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n\nExample 2:\n\nInput: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\nOutput: [0]\nExplanation: \nThe first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n\nExample 3:\n\nInput: k = 3, arrival = [1,2,3], load = [10,12,11]\nOutput: [0,1,2]\nExplanation: Each server handles a single request, so they are all considered the busiest.\n\n \nConstraints:\n\n1 <= k <= 105\n1 <= arrival.length, load.length <= 105\narrival.length == load.length\n1 <= arrival[i], load[i] <= 109\narrival is strictly increasing.", "code": "def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\nbusy_jobs = []  # heap (job_end_time, node) to free up the nodes quickly\nafter = [] # heap (nodes) free after current server\nbefore = list(range(k))  # heap (nodes) to use for loopback\nrequests_handled = [0] * k\n\nfor i, (arrvl, ld) in enumerate(zip(arrival, load)):\nserver_id = i % k\nif server_id == 0:  # loopback\nafter = before\nbefore = []\n\nwhile busy_jobs and busy_jobs[0][0] <= arrvl:\nfreed_node = heapq.heappop(busy_jobs)[1]\nif freed_node < server_id: heapq.heappush(before, freed_node)\nelse: heapq.heappush(after, freed_node)\n\nuse_queue = after if after else before\nif not use_queue: continue  # request dropped\nusing_node = heapq.heappop(use_queue)\nrequests_handled[using_node] += 1\nheapq.heappush(busy_jobs, (arrvl + ld, using_node))\n\nmaxreqs = max(requests_handled)\nreturn [i for i, handled in enumerate(requests_handled) if handled == maxreqs]"}
{"nl": "List Comprehension\r\nList comprehension offers a shorter syntax when you want to create a new list based on the values of an existing list.\r\n\r\nExample: You want to create a list of all the fruits that has the letter \"a\" in the name.\r\n\r\nWithout list comprehension you will have to write a for statement with a conditional test inside:", "code": "fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\r\nnewlist = []\r\n\r\nfor x in fruits:\r\n  if \"a\" in x:\r\n    newlist.append(x)\r\n\r\nprint(newlist)"}
{"nl": "Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.\n \nExample 1:\n\n\nInput: nums = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,4,2,7,5,3,8,6,9]\n\nExample 2:\n\n\nInput: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\nOutput: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i].length <= 105\n1 <= sum(nums[i].length) <= 105\n1 <= nums[i][j] <= 105", "code": "def findDiagonalOrder(self, A):\n  res = []\n  for i, r in enumerate(A):\n  for j, a in enumerate(r):\n  if len(res) <= i + j:\n  res.append([])\n  res[i + j].append(a)\n  return [a for r in res for a in reversed(r)]"}
{"nl": "Given an array of integers, find length of the longest subarray which contains numbers that can be arranged in a continuous sequence. \r\nIn the previous post, we have discussed a solution that assumes that elements in given array are distinct. Here we discuss a solution that works even if the input array has duplicates.", "code": "# python program to find length of the largest\r\n# subarray which has all contiguous elements */\r\n \r\n# This function prints all distinct elements\r\ndef findLenght(arr, n):\r\n    max_len = 1\r\n    for i in range(0,n - 1):\r\n \r\n        # Create an empty hash set and\r\n        # add i'th element to it\r\n        myset = set()\r\n        myset.add(arr[i])\r\n \r\n        # Initialize max and min in\r\n        # current subarray\r\n        mn = arr[i]\r\n        mx = arr[i]\r\n        for j in range(i + 1,n):\r\n \r\n            # If current element is already\r\n            # in hash set, then this subarray\r\n            # cannot contain contiguous elements\r\n            if arr[j] in myset:\r\n                break\r\n \r\n \r\n            # Else add current element to hash\r\n            # set and update min, max if required.\r\n            myset.add(arr[j])\r\n            mn = min(mn, arr[j])\r\n            mx = max(mx, arr[j])\r\n \r\n            # We have already checked for\r\n            # duplicates, now check for other\r\n            #property and update max_len\r\n            # if needed\r\n            if mx - mn == j - i:\r\n                max_len = max(max_len, mx - mn + 1)\r\n \r\n    return max_len # Return result\r\n \r\n \r\n# Driver code\r\n \r\narr = [10, 12, 12, 10, 10, 11, 10]\r\nn = len(arr)\r\nprint(\"Length of the longest contiguous subarray is\",\r\n                                findLenght(arr,n))\r\n \r\n# This code is contributed by Shrikant13"}
{"nl": "Given three groups of numbers, return a list containing all numbers that appear in more than one group (in ascending order).\nExamples\nnumber_groups([7, 8, 7, 3, 4], [2, 9, 1, 2, 1], [5, 6, 6, 6, 5]) \u279e []\n\nnumber_groups([3, 8, 8, 1, 1], [9, 1, 1, 9, 9], [10, 7, 6, 6, 3]) \u279e [1, 3]\n\nnumber_groups([4, 10, 9, 2, 2], [5, 3, 7, 3, 8], [6, 2, 9, 4, 2]) \u279e [2, 4, 9]\n\nnumber_groups([7, 8, 4, 8, 7], [8, 5, 9, 2, 9], [6, 1, 5, 5, 6]) \u279e [5, 8]\nNotes\nN/A", "code": "def number_groups(*g):\n  a, b, c = [set(i) for i in g]\n  return sorted(set.union(a.intersection(b),a.intersection(c),b.intersection(c)))"}
{"nl": "Given a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n \n\nTest case format:\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\n\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\n \n\nExample 1:\n\n\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).", "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, neighbors):\n        self.val = val\n        self.neighbors = neighbors\n\"\"\"\nfrom collections import deque\nclass Solution(object):\n\n    def cloneGraph(self, node):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n\n        if not node:\n            return node\n\n        # Dictionary to save the visited node and it's respective clone\n        # as key and value respectively. This helps to avoid cycles.\n        visited = {}\n\n        # Put the first node in the queue\n        queue = deque([node])\n        # Clone the node and put it in the visited dictionary.\n        visited[node] = Node(node.val, [])\n\n        # Start BFS traversal\n        while queue:\n            # Pop a node say \"n\" from the from the front of the queue.\n            n = queue.popleft()\n            # Iterate through all the neighbors of the node\n            for neighbor in n.neighbors:\n                if neighbor not in visited:\n                    # Clone the neighbor and put in the visited, if not present already\n                    visited[neighbor] = Node(neighbor.val, [])\n                    # Add the newly encountered node to the queue.\n                    queue.append(neighbor)\n                # Add the clone of the neighbor to the neighbors of the clone node \"n\".\n                visited[n].neighbors.append(visited[neighbor])\n\n        # Return the clone of the node from visited.\n        return visited[node]"}
{"nl": "Given a range (L, R) find total such numbers in the given range such that they have no repeated digits.", "code": "# Python implementation of\r\n# above idea\r\n\r\n# Prefix Array\r\nPrefix = [0]\r\n\r\n# Function to check if\r\n# the given number has\r\n# repeated digit or not\r\ndef repeated_digit(n):\r\n        a = []\r\n        \r\n        # Traversing through each digit\r\n        while n != 0:\r\n                d = n%10\r\n                \r\n                # if the digit is present\r\n                # more than once in the\r\n                # number\r\n                if d in a:\r\n                        \r\n                        # return 0 if the number\r\n                        # has repeated digit\r\n                        return 0\r\n                a.append(d)\r\n                n = n//10\r\n        \r\n        # return 1 if the number has no\r\n        # repeated digit\r\n        return 1\r\n\r\n# Function to pre calculate\r\n# the Prefix array\r\ndef pre_calculation(MAX):\r\n        \r\n        # To use to global Prefix array\r\n        global Prefix\r\n        Prefix.append(repeated_digit(1))\r\n        \r\n        # Traversing through the numbers\r\n        # from 2 to MAX\r\n        for i in range(2,MAX+1):\r\n                \r\n                # Generating the Prefix array\r\n                Prefix.append( repeated_digit(i) +\r\n                                        Prefix[i-1] )\r\n\r\n# Calclute Function\r\ndef calculate(L,R):\r\n        \r\n        # Answer\r\n        return Prefix[R]-Prefix[L-1]\r\n\r\n\r\n# Driver Code\r\n\r\n# Maximum\r\nMAX = 1000\r\n\r\n# Pre-calculating the Prefix array.\r\npre_calculation(MAX)\r\n\r\n# Range\r\nL=1\r\nR=100\r\n\r\n# Calling the calculate function\r\n# to find the total number of number\r\n# which has no repeated digit\r\nprint(calculate(L, R))\r"}
{"nl": null, "code": null}
{"nl": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.", "code": "def minBitFlips(self, start: int, goal: int) -> int:\n        val=start^goal\n        count=0\n        while(val):\n            n=val&1\n            val=val>>1\n            if(n==1):\n                count+=1\n        return count"}
{"nl": "Given a stack, sort it using recursion. Use of any loop constructs like while, for..etc is not allowed. We can only use the following ADT functions on Stack S:\u00a0\nis_empty(S)  : Tests whether stack is empty or not.\npush(S)         : Adds new element to the stack.\npop(S)         : Removes top element from the stack.\ntop(S)         : Returns value of the top element. Note that this function does not remove element from the stack.", "code": "# Python program to sort a stack using recursion\n\u00a0\n# Recursive method to insert element in sorted way\n\u00a0\n\u00a0\ndef sortedInsert(s, element):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case: Either stack is empty or newly inserted\n\u00a0\u00a0\u00a0\u00a0# item is greater than top (more than all existing)\n\u00a0\u00a0\u00a0\u00a0if len(s) == 0 or element > s[-1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(element)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove the top item and recur\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = s.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sortedInsert(s, element)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Put back the top item removed earlier\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(temp)\n\u00a0\n# Method to sort stack\n\u00a0\n\u00a0\ndef sortStack(s):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If stack is not empty\n\u00a0\u00a0\u00a0\u00a0if len(s) != 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove the top item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = s.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Sort remaining stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sortStack(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push the top item back in sorted stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sortedInsert(s, temp)\n\u00a0\n# Printing contents of stack\n\u00a0\n\u00a0\ndef printStack(s):\n\u00a0\u00a0\u00a0\u00a0for i in s[::-1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(i, end=\" \")\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\u00a0\u00a0\u00a0s.append(30)\n\u00a0\u00a0\u00a0\u00a0s.append(-5)\n\u00a0\u00a0\u00a0\u00a0s.append(18)\n\u00a0\u00a0\u00a0\u00a0s.append(14)\n\u00a0\u00a0\u00a0\u00a0s.append(-3)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Stack elements before sorting: \")\n\u00a0\u00a0\u00a0\u00a0printStack(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0sortStack(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"\\nStack elements after sorting: \")\n\u00a0\u00a0\u00a0\u00a0printStack(s)\n\u00a0\n# This code is contributed by Muskan Kalra.\n"}
{"nl": "Starting from the left side of an integer, adjacent digits pair up in \"battle\" and the larger digit wins. If two digits are the same, they both lose. A lone digit automatically wins.\nCreate a function that returns the victorious digits.\nTo illustrate:\nbattle_outcome(578921445) \u279e 7925\n# [57]: 7 wins; [89] 9 wins; [21] 2 wins;\n# [44] neither wins; 5 (automatically) wins\nExamples\nbattle_outcome(32531) \u279e 351\n# 3 deffeats 2, 5 defeats 3, 1 is a single.\n\nbattle_outcome(111) \u279e 1\n# 1 and 1 tie, so neither move on, last 1 is a single.\n\nbattle_outcome(78925) \u279e 895\nNotes\nThere are no winners in a battle with equal digits (neither should be printed).\nIf the length of the number is odd, the lone digit should be printed at the end of the number.", "code": "from itertools import zip_longest\ndef battle_outcome(num):\n  s = str(num)\n  return int(''.join(max(a, b) for a, b in zip_longest(s[::2], s[1::2], fillvalue) if a != b))"}
{"nl": "Given a positive number n, count all distinct Non-Negative Integer pairs (x, y) that satisfy the inequality x*x + y*y < n. \n\nExamples:\n\n\n\nInput:  n = 5\nOutput: 6\nThe pairs are (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (0, 2)\n\nInput: n = 6\nOutput: 8\nThe pairs are (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (0, 2),\n              (1, 2), (2, 1)", "code": "# Python3 implementation of above approach\n\n# This function counts number of pairs\n# (x, y) that satisfy\n# the inequality x*x + y*y < n.\ndef countSolutions(n):\n\n\tres = 0\n\tx = 0\n\twhile(x * x < n):\n\t\ty = 0\n\t\twhile(x * x + y * y < n):\n\t\t\tres = res + 1\n\t\t\ty = y + 1\n\t\tx = x + 1\n\n\treturn res\n\n# Driver program to test above function\nif __name__=='__main__':\n\tprint(\"Total Number of distinct Non-Negative pairs is \",\n\t\tcountSolutions(6))\n\n# This code is contributed by\n# Sanjit_Prasad"}
{"nl": "Bitwise Right Shift", "code": "# Give the number as static input and store it in a variable\r\ngvn_numb = 3\r\n# Right Shift 1 bit of the given number and print the result\r\nprint(\"The number after Right shifting given number by 1 bit:\")\r\nprint(gvn_numb>>1)\r\n# Right Shift 2 bits of the given number and print the result\r\nprint(\"The number after Right shifting given number by 2 bits:\")\r\nprint(gvn_numb>>2)"}
{"nl": "Given a number , write a program to reverse this number using stack.\n\n\n\u00a0", "code": "# Python3 program to reverse the\n# number using a stack\n\u00a0\n# Stack to maintain order of digits\nst = [];\n\u00a0\n# Function to push digits into stack\ndef push_digits(number):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while (number != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.append(number % 10);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0number = int(number / 10);\n\u00a0\n# Function to reverse the number\ndef reverse_number(number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call to push number's\n\u00a0\u00a0\u00a0\u00a0# digits to stack\n\u00a0\u00a0\u00a0\u00a0push_digits(number);\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0reverse = 0;\n\u00a0\u00a0\u00a0\u00a0i = 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Popping the digits and forming\n\u00a0\u00a0\u00a0\u00a0# the reversed number\n\u00a0\u00a0\u00a0\u00a0while (len(st) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reverse = reverse + (st[len(st) - 1] * i);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i * 10;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return the reversed number formed\n\u00a0\u00a0\u00a0\u00a0return reverse;\n\u00a0\n# Driver Code\nnumber = 39997;\n\u00a0\n# Function call to reverse number\nprint(reverse_number(number));\n\u00a0\n# This code is contributed by mits\n"}
{"nl": "You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros.\nIn one operation you can choose any subarray from initial and increment each value by one.\nReturn the minimum number of operations to form a target array from initial.\nThe test cases are generated so that the answer fits in a 32-bit integer.\n \nExample 1:\n\nInput: target = [1,2,3,2,1]\nOutput: 3\nExplanation: We need at least 3 operations to form the target array from the initial array.\n[0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).\n[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).\n[1,2,2,2,1] increment 1 at index 2.\n[1,2,3,2,1] target array is formed.\n\nExample 2:\n\nInput: target = [3,1,1,2]\nOutput: 4\nExplanation: [0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2]\n\nExample 3:\n\nInput: target = [3,1,5,4,2]\nOutput: 7\nExplanation: [0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2].\n\n \nConstraints:\n\n1 <= target.length <= 105\n1 <= target[i] <= 105", "code": "def minNumberOperations(self, A):\n  return sum(max(b - a, 0) for b, a in zip(A, [0] + A))"}
{"nl": "In this program, we will create a doubly linked list and insert every new node at the beginning of the list. If the list is empty, then head and tail will point to the newly added node. If the list is not empty then, insert the new node at the beginning of the list such that the head's previous will point to the new node. Make new node as head of the list, and its previous will point to null.", "code": "#Represent a node of doubly linked list    \nclass Node:    \n    def __init__(self,data):    \n        self.data = data;    \n        self.previous = None;    \n        self.next = None;    \n            \nclass InsertStart:    \n    #Represent the head and tail of the doubly linked list    \n    def __init__(self):    \n        self.head = None;    \n        self.tail = None;    \n            \n    #addAtStart() will add a node to the starting of the list    \n    def addAtStart(self, data):    \n        #Create a new node    \n        newNode = Node(data);    \n            \n        #If list is empty    \n        if(self.head == None):    \n            #Both head and tail will point to newNode    \n            self.head = self.tail = newNode;    \n            #head's previous will point to None    \n            self.head.previous = None;    \n            #tail's next will point to None, as it is the last node of the list    \n            self.tail.next = None;    \n        #Add newNode as new head of the list    \n        else:    \n            #head's previous node will be newNode    \n            self.head.previous = newNode;    \n            #newNode's next node will be head    \n            newNode.next = self.head;    \n            #newNode's previous will point to None    \n            newNode.previous = None;    \n            #newNode will become new head    \n            self.head = newNode;    \n                \n    #display() will print out the nodes of the list    \n    def display(self):    \n        #Node current will point to head    \n        current = self.head;    \n        if(self.head == None):    \n            print(\"List is empty\");    \n            return;    \n        print(\"Adding a node to the start of the list: \");    \n        while(current != None):    \n            #Prints each node by incrementing pointer.    \n            print(current.data),    \n            current = current.next;    \n                \n        print();    \n            \ndList = InsertStart();    \n     \n#Adding 1 to the list    \ndList.addAtStart(1);    \ndList.display();    \n#Adding 2 to the list    \ndList.addAtStart(2);    \ndList.display();    \n#Adding 3 to the list    \ndList.addAtStart(3);    \ndList.display();    \n#Adding 4 to the list    \ndList.addAtStart(4);    \ndList.display();    \n#Adding 5 to the list    \ndList.addAtStart(5);    \ndList.display();    "}
{"nl": "Write a Python program to print consecutive rows numbers in right triangle pattern using for loop.", "code": "rows = int(input(\"Enter Consecutive Numbers in Right Triangle Pattern Rows = \"))\n\nprint(\"====Consecutive Row Numbers Right Triangle Pattern====\")\n\nfor i in range(1, rows + 1):\n    val = i\n    for j in range(1, i + 1):\n        print(val, end = ' ')\n        val = val + rows - j\n    print()"}
{"nl": null, "code": null}
{"nl": "Given a string and the task is to find the longest word from a given sentence.", "code": "# Give the string as user input using the input() function and store it in a variable.\r\nGvn_str = input(\"Enter some random sentence = \")\r\n# Split the given string into a list of words using the split() function and\r\n# store it in another variable say \"wrd_lst\".\r\nwrd_lst = Gvn_str.split()\r\n# Get the longest word from a given sentence using max(), key functions, and\r\n# store it in another variable.\r\nlongst_wrd = max(wrd_lst, key=len)\r\n# Calculate the length of the above-obtained longest word using the len() function\r\n# and store it in another variable.\r\nlen_longst_wrd = len(longst_wrd)\r\n# Print the longest word in the above-given sentence.\r\nprint(\"The Longest Word in the above given sentence = \", longst_wrd)\r\n# Print the above-obtained length of the longest word.\r\nprint(\"The length of the longest word = \", len_longst_wrd)"}
{"nl": "You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots.\n\nYou have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number.\n\nFor example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4.\nReturn the maximum possible AND sum of nums given numSlots slots.", "code": "import json\nclass Solution:\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        \n        filled = [0 for _ in range(numSlots)]\n        n = len(nums)\n        nums.sort()\n        taken = [False for _ in range(n)]\n        filled = [0 for _ in range(numSlots)]\n        \n        @cache\n        def dp(i=0, filled=tuple(filled)):\n            if i >= n:\n                return 0\n            res = 0\n            filled = list(filled)\n            \n            for j in range(numSlots):\n                if filled[j] < 2:\n                    filled[j] += 1\n                    res  = max(res,(nums[i]&(j+1))+ dp(i+1, tuple(filled)))\n                    filled[j] -= 1\n            return res\n        \n        return dp()"}
{"nl": "A Harshad number is a number which is divisible by the sum of its digits. For example, 132 is divisible by 6 (1+3+2).\nA subset of the Harshad numbers are the Moran numbers. Moran numbers yield a prime when divided by the sum of their digits. For example, 133 divided by 7 (1+3+3) yields 19, a prime.\nCreate a function that takes a number and returns \"M\" if the number is a Moran number, \"H\" if it is a (non-Moran) Harshad number, or \"Neither\".\nExamples\nmoran(132) \u279e \"H\"\n\nmoran(133) \u279e \"M\"\n\nmoran(134) \u279e \"Neither\"\nNotes\nN/A", "code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if not n%i:\n            return False\n    return True\ndef moran(n):\n    d = sum(int(i) for i in str(n))\n    if n%d:\n        return 'Neither'\n    return 'M' if is_prime(n//d) else 'H'"}
{"nl": "Given the number of rows of the diamond pattern, the task is to print the Mirrored Half diamond Pattern in C, C++, and Python.", "code": "# Give the number of rows of the diamond pattern as static input and store it in a variable.\ndiamondrows = 9\n# Loop from 0 to the number of rows using For Loop.\nfor m in range(0, diamondrows):\n    # Loop from 0 to the number of rows -iterator value of the parent\n    # For loop using another For loop(Nested For loop).\n    for n in range(0, diamondrows - m):\n        # Print the space character in the inner For loop.\n        print(' ', end='')\n    # Loop from 0 to the iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(0, m):\n        # Print the star character\n        print('*', end='')\n    # After the end of the inner for Loops print the Newline Character.\n    print()\n# Loop from number of rows to 0 in decreasing order using For loop.\nfor m in range(diamondrows, 0, -1):\n    # Loop from 0 to the number of rows -iterator value of the parent\n    # For loop using another For loop(Nested For loop).\n    for n in range(0, diamondrows - m):\n        # Print the space character in the inner For loop.\n        print(' ', end='')\n    # Loop from 0 to the iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(0, m):\n        # Print the star character\n        print('*', end='')\n\n    # After the end of the inner for Loops print the Newline Character.\n    print()"}
{"nl": "Given a matrix, the task is to find the maximum element in the given Matrix in Python", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[2, 9, 1], [11, 4, 5], [9, 2, 3], [1, 2, 3]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Take a variable mtrxmax which stores the maximum element of the given matrix\r\n# and initialize its value to the first element of the given matrix.\r\nmtrxmax = mtrx[0][0]\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n    # Inside the For loop, Iterate till the given number of rows using another\r\n    # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # Check if the gvnmatrix[n][m] value (where n is the iterator value of the\r\n        # parent For loop and m is the iterator value of the inner For loop)\r\n        # is greater than mtrxmax using the if conditional statement.\r\n        if(mtrx[n][m] > mtrxmax):\r\n            # If it is true then modify the mtrxmax value with gvnmatrix[n][m] value.\r\n            mtrxmax = mtrx[n][m]\r\n# Print the mtrxmax value which is the maximum element of the given Matrix\r\nprint('The maximum element of the given matrix', mtrx, 'is :')\r\nprint(mtrxmax)"}
{"nl": "Given the number of rows(largest number) the task is to print the Right Triangle Number pattern in C, C++, and Python.", "code": "# Give the number of rows of the right-angled triangle Number pattern as user input using int(input())\n# and store it in a variable.\ntriangleNum = int(\n    input('Enter some random number of rows of the triangle Number pattern ='))\n# Loop from 1 to the number of rows using For loop.\nfor m in range(1, triangleNum+1):\n    # Loop from 1 to first loop iterator value using another Nested For loop.\n    for n in range(1, m+1):\n        # Print the iterator value of the nested loop with space in the inner For loop.\n        # (This prints the same number parent loop number of times)\n        print(m, end=' ')\n    # Print the newline character after ending of inner For loop.\n    print()"}
{"nl": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\n \n\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0\n \n\nConstraints:\n\n0 <= left <= right <= 231 - 1", "code": "class Solution:\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\n        shift = 0   \n        # find the common 1-bits\n        while m < n:\n            m = m >> 1\n            n = n >> 1\n            shift += 1\n        return m << shift"}
{"nl": "The Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The problem is to find shortest distances between every pair of vertices in a given edge weighted directed Graph.\u00a0", "code": "# Python Program for Floyd Warshall Algorithm\n\u00a0\n# Number of vertices in the graph\nV = 4\n\u00a0\n# Define infinity as the large\n# enough value. This value will be\n# used for vertices not connected to each other\nINF = 99999\n\u00a0\n# Solves all pair shortest path\n# via Floyd Warshall Algorithm\n\u00a0\ndef floydWarshall(graph):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\"\"\" dist[][] will be the output\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0matrix that will finally\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0have the shortest distances\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0between every pair of vertices \"\"\"\n\u00a0\u00a0\u00a0\u00a0\"\"\" initializing the solution matrix\n\u00a0\u00a0\u00a0\u00a0same as input graph matrix\n\u00a0\u00a0\u00a0\u00a0OR we can say that the initial\n\u00a0\u00a0\u00a0\u00a0values of shortest distances\n\u00a0\u00a0\u00a0\u00a0are based on shortest paths considering no\n\u00a0\u00a0\u00a0\u00a0intermediate vertices \"\"\"\n\u00a0\n\u00a0\u00a0\u00a0\u00a0dist = list(map(lambda i: list(map(lambda j: j, i)), graph))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\"\"\" Add all vertices one by one\n\u00a0\u00a0\u00a0\u00a0to the set of intermediate\n\u00a0\u00a0\u00a0\u00a0\u00a0vertices.\n\u00a0\u00a0\u00a0\u00a0\u00a0---> Before start of an iteration,\n\u00a0\u00a0\u00a0\u00a0\u00a0we have shortest distances\n\u00a0\u00a0\u00a0\u00a0\u00a0between all pairs of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0such that the shortest\n\u00a0\u00a0\u00a0\u00a0\u00a0distances consider only the\n\u00a0\u00a0\u00a0\u00a0\u00a0vertices in the set\n\u00a0\u00a0\u00a0\u00a0{0, 1, 2, .. k-1} as intermediate vertices.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0----> After the end of a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iteration, vertex no. k is\n\u00a0\u00a0\u00a0\u00a0\u00a0added to the set of intermediate\n\u00a0\u00a0\u00a0\u00a0\u00a0vertices and the\n\u00a0\u00a0\u00a0\u00a0set becomes {0, 1, 2, .. k}\n\u00a0\u00a0\u00a0\u00a0\"\"\"\n\u00a0\u00a0\u00a0\u00a0for k in range(V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pick all vertices as source one by one\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pick all vertices as destination for the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# above picked source\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If vertex k is on the shortest path from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# i to j, then update the value of dist[i][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i][j] = min(dist[i][j],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i][k] + dist[k][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\n\u00a0\u00a0\u00a0\u00a0printSolution(dist)\n\u00a0\n\u00a0\n# A utility function to print the solution\ndef printSolution(dist):\n\u00a0\u00a0\u00a0\u00a0print (\"Following matrix shows the shortest distances\\\n\u00a0between every pair of vertices\")\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(dist[i][j] == INF):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"%7s\" % (\"INF\"),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"%7d\\t\" % (dist[i][j]),end=' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == V-1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print ()\n\u00a0\n\u00a0\n# Driver program to test the above program\n# Let us create the following weighted graph\n\"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0)------->(3)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 /|\\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05 |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 | 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\|/\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1)------->(2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"\"\"\ngraph = [[0, 5, INF, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, 0, 3, INF],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, 0,\u00a0\u00a0 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, INF, 0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\n# Print the solution\nfloydWarshall(graph)\n# This code is contributed by Mythri J L\n"}
{"nl": "Given an array of n elements, the task is to find the greatest number such that it is product of two elements of given array. If no such element exists, print -1. Elements are within the range of 1 to 10^5.\nExamples : \n \n\nInput :  arr[] = {10, 3, 5, 30, 35}\nOutput:  30\nExplanation: 30 is the product of 10 and 3.\n\nInput :  arr[] = {2, 5, 7, 8}\nOutput:  -1\nExplanation: Since, no such element exists.\n\nInput :  arr[] = {10, 2, 4, 30, 35}\nOutput:  -1\n\nInput :  arr[] = {10, 2, 2, 4, 30, 35}\nOutput:  4\n\nInput  : arr[] = {17, 2, 1, 35, 30}\nOutput : 35", "code": "# Python 3 program to find a pair\n# with product in given array.\n\n# Function to find greatest number\ndef findGreatest( arr , n):\n\n\tresult = -1\n\tfor i in range(n):\n\t\tfor j in range(n - 1):\n\t\t\tfor k in range(j + 1, n):\n\t\t\t\tif (arr[j] * arr[k] == arr[i]):\n\t\t\t\t\tresult = max(result, arr[i])\n\treturn result\n\n# Driver code\nif __name__ == \"__main__\":\n\t\n\tarr = [ 30, 10, 9, 3, 35]\n\tn = len(arr)\n\n\tprint(findGreatest(arr, n))\n\n# This code is contributed by ita_c"}
{"nl": "In mathematics and digital electronics, a binary number is a number expressed in the base-2 numeral system or binary numeral system. Given a list of ones and zeroes of a binary number, return the equivalent decimal value.\nExamples\nbinary_to_decimal([0, 0, 0, 1]) \u279e 1\n\nbinary_to_decimal([0, 0, 1, 0]) \u279e 2\n\nbinary_to_decimal([1, 1, 1, 1, 1, 0, 1, 1, 0, 1]) \u279e 1005\nNotes\nN/A", "code": "def binary_to_decimal(lst):\n  return int(''.join(map(str,lst)),2)"}
{"nl": "Alternative Sorting (User Input)", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n#Store it in a variable.\r\ngvn_lst = list(map(int, input(\r\n   'Enter some random List Elements separated by spaces = ').split()))\r\n# Calculate the length of the given list using the len() function and\r\n# store it in another variable.\r\nlen_lst = len(gvn_lst)\r\n# Sort the given list using the sort() method and store it in another variable.\r\ngvn_lst.sort()\r\n# Take a variable say 'p' and initialize its value with zero.\r\np = 0\r\n# Take another variable say 'q' and initialize its value with the length of the\r\n# given list -1.\r\nq = len_lst-1\r\nprint(\"The Alternative sorting of the above given list is :\")\r\n# Check if the value of p is less than q using the while loop.\r\nwhile (p < q):\r\n    # If the statement is true, then print the value of the given list of q.\r\n    print(gvn_lst[q], end=\" \")\r\n    # Subtract 1 from q (q-1)and store it in the same variable 'q'.\r\n    q -= 1\r\n    # Print the value of the given list of p.\r\n    print(gvn_lst[p], end=\" \")\r\n    # Increment the value of p by 1 and store it in the same variable 'p'.\r\n    p += 1\r\n   # Check if the length of the given list is odd(len_lst % 2 != 0) by using the\r\n   # if conditional statement.\r\nif (len_lst % 2 != 0):\r\n    # If the statement is true, print the value of the given list of p.\r\n    print(gvn_lst[p])"}
{"nl": "Display float number with 2 decimal places using print()", "code": "num = 458.541315\nprint('%.2f' % num)"}
{"nl": "Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k and arr[i] + arr[j] + arr[k] == target.\n\nAs the answer can be very large, return it modulo 109 + 7.", "code": "class Solution(object):\n    def threeSumMulti(self, A, target):\n        MOD = 10**9 + 7\n        count = collections.Counter(A)\n        keys = sorted(count)\n\n        ans = 0\n\n        # Now, let's do a 3sum on \"keys\", for i <= j <= k.\n        # We will use count to add the correct contribution to ans.\n        for i, x in enumerate(keys):\n            T = target - x\n            j, k = i, len(keys) - 1\n            while j <= k:\n                y, z = keys[j], keys[k]\n                if y + z < T:\n                    j += 1\n                elif y + z > T:\n                    k -= 1\n                else: # x+y+z == T, now calculate the size of the contribution\n                    if i < j < k:\n                        ans += count[x] * count[y] * count[z]\n                    elif i == j < k:\n                        ans += count[x] * (count[x] - 1) / 2 * count[z]\n                    elif i < j == k:\n                        ans += count[x] * count[y] * (count[y] - 1) / 2\n                    else:  # i == j == k\n                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6\n\n                    j += 1\n                    k -= 1\n\n        return ans % MOD"}
{"nl": "You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\n\nYou start on square 1 of the board. In each move, starting from square curr, do the following:\n\nChoose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].\nThis choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.\nIf next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.\nThe game ends when you reach the square n2.\nA board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.\n\nNote that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\n\nFor example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.\nReturn the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.", "code": "def snakesAndLadders(self, board: List[List[int]]) -> int:\n        n = len(board)\n        def label_to_position(label):\n            r, c = divmod(label-1, n)\n            if r % 2 == 0:\n                return n-1-r, c\n            else:\n                return n-1-r, n-1-c\n            \n        seen = set()\n        queue = collections.deque()\n        queue.append((1, 0))\n        while queue:\n            label, step = queue.popleft()\n            r, c = label_to_position(label)\n            if board[r][c] != -1:\n                label = board[r][c]\n            if label == n*n:\n                return step\n            for x in range(1, 7):\n                new_label = label + x\n                if new_label <= n*n and new_label not in seen:\n                    seen.add(new_label)\n                    queue.append((new_label, step+1))\n        return -1"}
{"nl": "A condition in which one string or number is rearranged in such a way that each character of the rearranged string or number must be a part of another string or number is known as an anagram. In other words, if the second string is a simple rearrangement of the first, it is said to be an anagram of the first.", "code": "# given two strings\nstring1 = \"skyis\"\nstring2 = \"ssyki\"\n# converting the both strings to lowercase using lower() function.\nstring1 = string1.lower()\nstring2 = string2.lower()\n# checking if both the strings are equal using sorted() function\nif(sorted(string1) == sorted(string2)):\n    print(\"Both the strings are anagrams\")\nelse:\n    print(\"Both the strings are not anagrams\")"}
{"nl": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\n\nReturn the minimum number of operations to reduce the sum of nums by at least half.\n\n ", "code": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        total=sum(nums)\n        h=[-el for el in nums]\n        heapq.heapify(h)\n        res=cur=0\n        while cur<total/2:\n            val=-heapq.heappop(h)\n            cur+=val/2\n            heapq.heappush(h,-val/2)\n            res+=1\n        return res"}
{"nl": "In this program, you'll learn to add two matrices using Nested loop and Next list comprehension, and display it.", "code": "# Program to add two matrices using nested loop\n\nX = [[12,7,3],\n    [4 ,5,6],\n    [7 ,8,9]]\n\nY = [[5,8,1],\n    [6,7,3],\n    [4,5,9]]\n\nresult = [[0,0,0],\n         [0,0,0],\n         [0,0,0]]\n\n# iterate through rows\nfor i in range(len(X)):\n   # iterate through columns\n   for j in range(len(X[0])):\n       result[i][j] = X[i][j] + Y[i][j]\n\nfor r in result:\n   print(r)\n\n# Program to add two matrices using list comprehension\n\nX = [[12,7,3],\n    [4 ,5,6],\n    [7 ,8,9]]\n\nY = [[5,8,1],\n    [6,7,3],\n    [4,5,9]]\n\nresult = [[X[i][j] + Y[i][j]  for j in range(len(X[0]))] for i in range(len(X))]\n\nfor r in result:\n   print(r)"}
{"nl": "Given a Binary Tree where each node has positive and negative values. Convert this to a tree where each node contains the sum of the left and right sub trees in the original tree. The values of leaf nodes are changed to 0.\n\nFor example, the following tree  \n\n                  10\n               /      \\\n             -2        6\n           /   \\      /  \\ \n         8     -4    7    5\nshould be changed to \n\n                 20(4-2+12+6)\n               /      \\\n         4(8-4)      12(7+5)\n           /   \\      /  \\ \n         0      0    0    0", "code": "# Python3 program to convert a tree\n# into its sum tree\n\n# Node definition\nclass node:\n\t\n\tdef __init__(self, data):\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.data = data\n\n# Convert a given tree to a tree where\n# every node contains sum of values of\n# nodes in left and right subtrees\n# in the original tree\ndef toSumTree(Node) :\n\t\n\t# Base case\n\tif(Node == None) :\n\t\treturn 0\n\n\t# Store the old value\n\told_val = Node.data\n\n\t# Recursively call for left and\n\t# right subtrees and store the sum as\n\t# new value of this node\n\tNode.data = toSumTree(Node.left) + \\\n\t\t\t\ttoSumTree(Node.right)\n\n\t# Return the sum of values of nodes\n\t# in left and right subtrees and\n\t# old_value of this node\n\treturn Node.data + old_val\n\n# A utility function to print\n# inorder traversal of a Binary Tree\ndef printInorder(Node) :\n\tif (Node == None) :\n\t\treturn\n\tprintInorder(Node.left)\n\tprint(Node.data, end = \" \")\n\tprintInorder(Node.right)\n\t\n# Utility function to create a new Binary Tree node\ndef newNode(data) :\n\ttemp = node(0)\n\ttemp.data = data\n\ttemp.left = None\n\ttemp.right = None\n\t\n\treturn temp\n\n# Driver Code\nif __name__ == \"__main__\":\n\troot = None\n\tx = 0\n\t\n\t# Constructing tree given in the above figure\n\troot = newNode(10)\n\troot.left = newNode(-2)\n\troot.right = newNode(6)\n\troot.left.left = newNode(8)\n\troot.left.right = newNode(-4)\n\troot.right.left = newNode(7)\n\troot.right.right = newNode(5)\n\t\n\ttoSumTree(root)\n\t\n\t# Print inorder traversal of the converted\n\t# tree to test result of toSumTree()\n\tprint(\"Inorder Traversal of the resultant tree is: \")\n\tprintInorder(root)\n\n# This code is contributed by Arnab Kundu\n"}
{"nl": "Rondo Form is a type of musical structure, in which there is a recurring theme/refrain, notated as A. Here are the rules for valid rondo forms:\nRondo forms always start and end with an A section.\nIn between the A sections, there should be contrasting sections notated as B, then C, then D, etc... No letter should be skipped.\nThere shouldn't be any repeats in the sequence (such as ABBACCA).\nCreate a function which validates whether a given string is a valid Rondo Form.\nExamples\nvalid_rondo(\"ABACADAEAFAGAHAIAJA\") \u279e True\n\nvalid_rondo(\"ABA\") \u279e True\n\nvalid_rondo(\"ABBACCA\") \u279e False\n\nvalid_rondo(\"ACAC\") \u279e False\n\nvalid_rondo(\"A\") \u279e False\nNotes\nInputs will be given as all uppercase.\nFor the purposes of this challenge, accept ABA as valid Rondo forms.", "code": "def valid_rondo(s):\n  n = s.replace(\"A\",\"\")\n  return len(n) and s[::len(s)-1]==\"AA\" and \"AA\" not in n and n in \"BCDEFGHIJKLMNOPQRSTUVWXYZ\""}
{"nl": "Create a function that calculates the number of different squares in an n * n square grid. Check the Resources tab.\nExamples\nnumber_squares(2) \u279e 5\n\nnumber_squares(4) \u279e 30\n\nnumber_squares(5) \u279e 55\nExplanation\nIf n = 0 then the number of squares is 0\nIf n = 1 then the number of squares is 1 + 0 = 1\nIf n = 2 then the number of squares is 2^2 + 1 = 4 + 1 = 5\nIf n = 3 then the number of squares is 3^2 + 5 = 9 + 5 = 14\nAs you can see, for each value of n the number of squares is n squared + the number of squares from the previous value of n.\nNotes\nInput is a positive integer.\nSquare pyramidal number.", "code": "def number_squares(n):\n  return (2 * n**3 + 3 * n**2 + n) / 6"}
{"nl": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\n\nYou should rearrange the elements of nums such that the modified array follows the given conditions:\n\nEvery consecutive pair of integers have opposite signs.\nFor all integers with the same sign, the order in which they were present in nums is preserved.\nThe rearranged array begins with a positive integer.\nReturn the modified array after rearranging the elements to satisfy the aforementioned conditions.", "code": "def rearrangeArray(self, nums: List[int]) -> List[int]:\n    pos, neg = [], []\n    for i in nums:\n        if i > 0: pos.append(i)\n        else: neg.append(i)\n    i, j = 0, 0\n    \n    while j < len(nums):\n        nums[j] = pos[i]\n        nums[j+1] = neg[i]\n        j += 2\n        i += 1\n    \n    return nums"}
{"nl": "Given a list of prices prices and a \"supposed\" total t, return True if there is a hidden fee added to the total (i.e. the total is greater than the sum of prices), otherwise return False.\nExamples\nhas_hidden_fee([\"$2\", \"$4\", \"$1\", \"$8\"], \"$15\") \u279e False\n\nhas_hidden_fee([\"$1\", \"$2\", \"$3\"], \"$6\") \u279e False\n\nhas_hidden_fee([\"$1\"], \"$4\") \u279e True\nNotes\nRemember that each price is given as a string.\nAll $ signs will be at the beginning of the number.", "code": "def has_hidden_fee(prices, t):\n  return sum([int(i[1:]) for i in prices]) < int(t[1:])"}
{"nl": "Given a value V, if we want to make a change for V cents, and we have an infinite supply of each of C = { C1, C2, .., Cm} valued coins, what is the minimum number of coins to make the change? If it\u2019s not possible to make a change, print -1.", "code": "# A Dynamic Programming based Python3 program to\r\n# find minimum of coins to make a given change V\r\nimport sys\r\n \r\n# m is size of coins array (number of\r\n# different coins)\r\ndef minCoins(coins, m, V):\r\n     \r\n    # table[i] will be storing the minimum\r\n    # number of coins required for i value.\r\n    # So table[V] will have result\r\n    table = [0 for i in range(V + 1)]\r\n \r\n    # Base case (If given value V is 0)\r\n    table[0] = 0\r\n \r\n    # Initialize all table values as Infinite\r\n    for i in range(1, V + 1):\r\n        table[i] = sys.maxsize\r\n \r\n    # Compute minimum coins required\r\n    # for all values from 1 to V\r\n    for i in range(1, V + 1):\r\n         \r\n        # Go through all coins smaller than i\r\n        for j in range(m):\r\n            if (coins[j] <= i):\r\n                sub_res = table[i - coins[j]]\r\n                if (sub_res != sys.maxsize and\r\n                    sub_res + 1 < table[i]):\r\n                    table[i] = sub_res + 1\r\n     \r\n    if table[V] == sys.maxsize:\r\n        return -1\r\n       \r\n    return table[V]\r\n \r\n# Driver Code\r\nif __name__ == \"__main__\":\r\n \r\n    coins = [9, 6, 5, 1]\r\n    m = len(coins)\r\n    V = 11\r\n    print(\"Minimum coins required is \",\r\n                 minCoins(coins, m, V))\r\n \r\n# This code is contributed by ita_c"}
{"nl": "Definition and Usage\r\nThe readline() method returns one line from the file.\r\n\r\nYou can also specified how many bytes from the line to return, by using the size parameter.", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.readline())"}
{"nl": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\nEach row must contain the digits 1-9 without repetition.\nEach column must contain the digits 1-9 without repetition.\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\nNote:\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\nOnly the filled cells need to be validated according to the mentioned rules.\n \n\nExample 1:\n\n\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\nExample 2:\n\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n \n\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit 1-9 or '.'.", "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        N = 9\n        # Use binary number to check previous occurrence\n        rows = [0] * N\n        cols = [0] * N\n        boxes = [0] * N\n\n        for r in range(N):\n            for c in range(N):\n                # Check if the position is filled with number\n                if board[r][c] == \".\":\n                    continue\n\n                pos = int(board[r][c]) - 1\n\n                # Check the row\n                if rows[r] & (1 << pos):\n                    return False\n                rows[r] |= (1 << pos)\n\n                # Check the column\n                if cols[c] & (1 << pos):\n                    return False\n                cols[c] |= (1 << pos)\n\n                # Check the box\n                idx = (r // 3) * 3 + c // 3\n                if boxes[idx] & (1 << pos):\n                    return False\n                boxes[idx] |= (1 << pos)\n\n        return True"}
{"nl": "Given the number of rows of the diamond pattern, the task is to print the Hollow diamond star pattern in C, C++, and Python", "code": "# Give the number of rows  as static input and store it in a variable.\ndiamondrows = 6\n\n# Loop from 1 to the number of rows using For Loop.\nfor m in range(1, diamondrows+1):\n    # Loop from 1 to the number of rows -iterator value of the parent\n    # For loop using another For loop(Nested For loop).\n    for n in range(1, diamondrows - m + 1):\n        # Print the space character in the inner For loop.\n        print(end=' ')\n    # Loop from 1 to the 2* iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(1, (2 * m)):\n        # If the value of the iterator is equal to 1 or 2* iterator value\n        # of the parent loop -1 then print star character.\n        if l == 1 or l == m * 2 - 1:\n            print('*', end='')\n        # Else print space character.\n        else:\n            print(' ', end='')\n    # After the end of the inner for Loops print the Newline Character.\n    print()\n\n# loop from number of rows -1 to 0 in decreasing order using For loop.\nfor m in range(diamondrows - 1, 0, -1):\n    # Loop from 1 to number of rows- iterator value\n    # of the parent loop using another For loop(Nested For loop)\n    for n in range(1, diamondrows - m + 1):\n        # Print the space character in the inner For loop.\n        print(end=' ')\n    # Loop from 1 to the 2* iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(1, (2 * m)):\n        # If the value of the iterator is equal to 1 or 2* iterator value\n        # of the parent loop -1 then print star character.\n        if l == 1 or l == m * 2 - 1:\n            print('*', end='')\n        # Else print space character.\n        else:\n            print(' ', end='')\n\n    # After the end of the inner for Loops print the Newline Character.\n    print("}
{"nl": "POV: You are in an exam and time has just run out. While the teacher's back is turned, you hastily take the opportunity to finish scribbling down the last few words of the conclusion.\nFor this challenge, it takes 0.5 seconds to write a character (not including spaces). Given the full sentence and the unfinished sentence as inputs, return the time it takes to finish writing in seconds.\nWorked Example\ntime_to_finish(\n  \"And so brings my conclusion to its conclusion.\",\n  \"And so brings my conclusion to\"\n) \u279e 7\n\n# \"its\" has 3 characters\n# \"conclusion.\" has 11 characters, including punctuation.\n# 11 + 3 = 14\n# 14 x 0.5 = 7\n# Remember not to include spaces.\nExamples\ntime_to_finish(\n  \"And so brings my conclusion to its conclusion.\",\n  \"And so brings my conclusion to its conclus\"\n) \u279e 2\n\ntime_to_finish(\n  \"As a result, my point is still valid.\",\n  \"As a result, my\"\n) \u279e 9\n\ntime_to_finish(\n  \"Thank you for reading my essay.\",\n  \"T\"\n) \u279e 12.5\nNotes\nThe unfinished sentence is always found at the start of a complete sentence.", "code": "def time_to_finish(full, part):\n    return len(full[len(part):].replace(' ', ''))/2"}
{"nl": "For a list of ranges, find the maximum range that is contained in all the ranges. If there is no such range, return \"No overlapping\".\nExamples\noverlapping([(1, 7), (2, 8), (0, 4)]) \u279e (2, 4)\n\noverlapping([(5, 10), (2, 15), (10, 12)]) \u279e (10, 10)\n\noverlapping([(11, 18), (3, 7), (2, 20), (5, 16)]) \u279e \"No overlapping\"\nNotes\nBoth ends are inclusive for all ranges.", "code": "def overlapping(lst):\n    low = max(i[0] for i in lst)\n    high = min(i[1] for i in lst)\n    return (low,high) if high >= low else 'No overlapping'"}
{"nl": "Given two integer arrays startTime and endTime and given an integer queryTime.\nThe ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\nReturn the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.\n \nExample 1:\n\nInput: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\nOutput: 1\nExplanation: We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\n\nExample 2:\n\nInput: startTime = [4], endTime = [4], queryTime = 4\nOutput: 1\nExplanation: The only student was doing their homework at the queryTime.\n\n \nConstraints:\n\nstartTime.length == endTime.length\n1 <= startTime.length <= 100\n1 <= startTime[i] <= endTime[i] <= 1000\n1 <= queryTime <= 1000", "code": "def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n  return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))"}
{"nl": "In the previous article, we have discussed Python Program to find Sum of Tuple Items\n Given a tuple and the task is to find the modulo of the given tuple elements.\n zip() function in python:\n The zip() function returns a zip object, which is an iterator of tuples in which the first item in each provided iterator is coupled together, and so on.\n If the lengths of the provided iterators differ, the length of the new iterator is determined by the iterator with the fewest items.\n Examples:\n Example1:\n Input:\n Given First Tuple= (1, 10, 12, 3, 9)\n \n Given Second Tuple= (10, 9, 8, 7, 6)\n Output:\n The modulus of the given tuple elements (1, 10, 12, 3, 9) and (10, 9, 8, 7, 6) is:\n \n (1, 1, 4, 3, 3)\n Example2:\n Input:\n Given First Tuple= (12, 15, 18, 20, 64)\n \n Given Second Tuple= (5, 6, 1, 7, 8)\n Output:\n The modulus of the given tuple elements (12, 15, 18, 20, 64) and (5, 6, 1, 7, 8) is:\n \n (2, 3, 0, 6, 0)", "code": "# Give the first tuple as static input and store it in a variable.\n \n fst_tupl = (1, 10, 12, 3, 9)\n \n # Give the second tuple as static input and store it in another variable.\n \n secnd_tupl = (10, 9, 8, 7, 6)\n \n # Loop in the first and second tuples using the zip() function, apply modulus function to\n \n # the first tuple iterator value with the second tuple iterator value and convert this\n \n # statement to a tuple using the tuple() function.\n \n rslt_tupl = tuple(ele1 % ele2 for ele1, ele2 in zip(fst_tupl, secnd_tupl))\n \n # Print the modulo of the given tuple elements.\n \n print(\"The modulus of the given tuple elements\",\n \n  fst_tupl, \"and\", secnd_tupl, \"is:\")\n \n print(rslt_tupl)\n \n </pre>"}
{"nl": "Create a function that returns the index of the first vowel in a string.\nExamples\nfirst_vowel(\"apple\") \u279e 0\n\nfirst_vowel(\"hello\") \u279e 1\n\nfirst_vowel(\"STRAWBERRY\") \u279e 3\n\nfirst_vowel(\"pInEaPPLe\") \u279e 1\nNotes\nInput will be single words.\nCharacters in words will be upper or lower case.\n\"y\" is not considered a vowel.\nInput always contains a vowel.", "code": "def first_vowel(txt):\n  return [txt.index(x) for x in txt if x.lower() in 'aeiou'][0]"}
{"nl": "There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i\u200b\u200b\u200b\u200b\u200b\u200b and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n \nExample 1:\n\nInput: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\nExample 2:\n\nInput: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\n \nConstraints:\n\nn == gain.length\n1 <= n <= 100\n-100 <= gain[i] <= 100", "code": "def largestAltitude(self, A):\n  return max(0, max(accumulate(A)))"}
{"nl": "Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n \n\nExample 1:\n\n\n\nInput: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\nOutput: 20\nExplanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\nExample 2:\n\n\n\nInput: root = [4,3,null,1,2]\nOutput: 2\nExplanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\nExample 3:\n\nInput: root = [-4,-2,-5]\nOutput: 0\nExplanation: All values are negatives. Return an empty BST.\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 4 * 104].\n-4 * 104 <= Node.val <= 4 * 104", "code": "class Solution:\n  def maxSumBST(self, root: TreeNode) -> int:\n  res = 0\n  def traverse(root):\n  '''return status_of_bst, size_of_bst, left_bound, right_bound'''\n  nonlocal res\n  if not root: return 1, 0, None, None # this subtree is empty\n  \n  ls, l, ll, lr = traverse(root.left)\n  rs, r, rl, rr = traverse(root.right)\n  \n  if ((ls == 2 and lr < root.val) or ls == 1) and ((rs == 2 and rl > root.val) or rs == 1):\n  # this subtree is a BST\n  size = root.val + l + r\n  res = max(res, size)\n  return 2, size, (ll if ll is not None else root.val), (rr if rr is not None else root.val)\n  return 0, None, None, None # this subtree is not a BST\n  \n  traverse(root)\n  return res"}
{"nl": "Given a sentence of all lowercase words, reverse all the letters in each word, but leave the first and last letters as they are.\nExamples\nmix_middle(\"the quick brown fox jumps high\") \u279e \"the qciuk bworn fox jpmus hgih\"\n\nmix_middle(\"this sentence is quite muddled\") \u279e \"tihs scnetnee is qtiue melddud\"\n\nmix_middle(\"buying a first-class ticket\") \u279e \"bniyug a fsalc-tsris tekcit\"\nNotes\nTreat hyphenated words like one word (example #3).\nNotice how one, two and three-letter words remain unchanged.", "code": "import re\ndef mix_middle(txt):\n  return re.sub(r'(?<=\\b\\w)([\\w-]{2,})(?=\\w\\b)', lambda m: m.group(1)[::-1], txt)"}
{"nl": "A square matrix is given in which each cell represents either a blank or an obstacle. We can place mirrors at blank position. All mirrors will be situated at 45 degree, i.e. they can transfer light from bottom to right if no obstacle is there in their path.\u00a0\n\nIn this question we need to count how many such mirrors can be placed in square matrix which can transfer light from bottom to right.\u00a0\n\n\n\u00a0", "code": "# Python3 program to find how many mirror can transfer\n# light from bottom to right\n\u00a0\n# method returns number of mirror which can transfer\n# light from bottom to right\ndef maximumMirrorInMatrix(mat, N):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To store first obstacles horizontally (from right)\n\u00a0\u00a0\u00a0\u00a0# and vertically (from bottom)\n\u00a0\u00a0\u00a0\u00a0horizontal = [-1 for i in range(N)]\n\u00a0\u00a0\u00a0\u00a0vertical = [-1 for i in range(N)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# looping matrix to mark column for obstacles\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N - 1, -1, -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] == 'B'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark rightmost column with obstacle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0horizontal[i] = j;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# looping matrix to mark rows for obstacles\n\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(N - 1, -1, -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] == 'B'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark leftmost row with obstacle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vertical[j] = i;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0res = 0; # Initialize result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if there is not obstacle on right or below,\n\u00a0\u00a0\u00a0\u00a0# then mirror can be placed to transfer light\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0''' if i > vertical[j] then light can from bottom\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j > horizontal[i] then light can go to right '''\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i > vertical[j] and j > horizontal[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0''' uncomment this code to print actual mirror\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0position also'''\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res+=1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\n\u00a0\n#\u00a0 Driver code to test above method\nN = 5;\n\u00a0\n#\u00a0 B - Blank\u00a0\u00a0\u00a0\u00a0 O - Obstacle\nmat = [\"BBOBB\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BBBBO\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BBBBB\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BOOBO\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BBBOB\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0];\n\u00a0\nprint(maximumMirrorInMatrix(mat, N));\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "The program sorts a list by quicksort.", "code": "def quicksort(alist, start, end):\n    '''Sorts the list from indexes start to end - 1 inclusive.'''\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quicksort(alist, start, p)\n        quicksort(alist, p + 1, end)\n\u00a0\n\u00a0\ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n\u00a0\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n\u00a0\n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\nquicksort(alist, 0, len(alist))\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "Keyword Arguments\r\nYou can also send arguments with the key = value syntax.\r\n\r\nThis way the order of the arguments does not matter.", "code": "def my_function(child3, child2, child1):\r\n  print(\"The youngest child is \" + child3)\r\n\r\nmy_function(child1 = \"Emil\", child2 = \"Tobias\", child3 = \"Linus\")"}
{"nl": "Given a polynomial of the form cnxn + cn-1xn-1 + cn-2xn-2 + \u2026 + c1x + c0 and a value of x, find the value of polynomial for a given value of x. Here cn, cn-1, .. are integers (may be negative) and n is a positive integer.\nInput is in the form of an array say poly[] where poly[0] represents coefficient for xn and poly[1] represents coefficient for xn-1 and so on.\nExamples: \n\n// Evaluate value of 2x3 - 6x2 + 2x - 1 for x = 3\nInput: poly[] = {2, -6, 2, -1}, x = 3\nOutput: 5\n\n// Evaluate value of 2x3 + 3x + 1 for x = 2\nInput: poly[] = {2, 0, 3, 1}, x = 2\nOutput: 23", "code": "# Python program for\n# implementation of Horner Method\n# for Polynomial Evaluation\n\n# returns value of poly[0]x(n-1)\n# + poly[1]x(n-2) + .. + poly[n-1]\ndef horner(poly, n, x):\n\n\t# Initialize result\n\tresult = poly[0]\n\n\t# Evaluate value of polynomial\n\t# using Horner's method\n\tfor i in range(1, n):\n\n\t\tresult = result*x + poly[i]\n\n\treturn result\n\n# Driver program to\n# test above function.\n\n# Let us evaluate value of\n# 2x3 - 6x2 + 2x - 1 for x = 3\npoly = [2, -6, 2, -1]\nx = 3\nn = len(poly)\n\nprint(\"Value of polynomial is \" , horner(poly, n, x))\n\n# This code is contributed\n# by Anant Agarwal."}
{"nl": "The math.fabs() method returns the absolute value of a number, as a float.\r\n\r\nAbsolute denotes a non-negative number. This removes the negative sign of the value if it has any.\r\n\r\nUnlike Python abs(), this method always converts the value to a float value.", "code": "#Import math Library\r\nimport math\r\n\r\n#Print absolute values from numbers\r\nprint(math.fabs(-66.43))\r\nprint(math.fabs(-7))"}
{"nl": "Write a Python program to print same numbers on all sides of a square pattern using for loop.", "code": "rows = int(input(\"Enter Square of same Numbers Pattern Rows = \"))\n\nprint(\"====Print Same Numbers on all Sides of a Square Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(1, rows + 1):\n        if i < j:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - j + 1, end = ' ')\n    for k in range(rows - 1, 0, - 1):\n        if i < k:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - k + 1, end = ' ')\n    print()\n\nfor i in range(rows - 1, 0, -1):\n    for j in range(1, rows + 1):\n        if i < j:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - j + 1, end = ' ')\n    for k in range(rows - 1, 0, - 1):\n        if i < k:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - k + 1, end = ' ')\n    print()"}
{"nl": "In Python, we will address the problem of intersecting two dictionaries via their keys. As a result, something in common between the two dictionaries is required.\n\n\n \nYou\u2019ll come across a concept called Python dictionaries here. Dictionaries are a relatively prevalent data structure in the Python programming language.\n\nBefore going further into it, let us first talk about dictionaries.\n\nDictionaries:\n\nPython dictionaries are mutable collections of things that contain key-value pairs. The dictionary contains two main components: keys and values. These keys must be single elements, and the values can be of any data type, such as list, string, integer, tuple, and so on. The keys are linked to their corresponding values. In other words, the values can be retrieved using their corresponding keys.\n\nA dictionary is created in Python by enclosing numerous key-value pairs in curly braces.", "code": "# Give the two dictionaries as static input and store them in two variables.\ndictionary1 = {'Hello': 'one', 'this': 'two',\n               'is': 'three', 'btechgeeks': 'four'}\ndictionary2 = {'good': 'five', 'morning': 'six',\n               'btechgeeks': 'four', 'is': 'three'}\n\n# printing the original given two dictionaries\nprint(\"The given first dictionary = \", dictionary1)\nprint(\"The given second dictionary = \", dictionary2)\n# Then, using the items() function,\n# convert the dictionaries dictionary1 and dictionary2 into list format.\n# Then, using the & operator, perform their AND operation.\n# The common key-value pairs are then\n# converted into a dictionary and stored in intersectdicts using dict().\nintersectdicts = dict(dictionary1.items() & dictionary2.items())\n\n# Print the new dictionary intersectdicts with the common keys and their values.\nprint(\"printing the intersection of the given two dictionaries = \", (intersectdicts))"}
{"nl": "Given a string and the task is to count all the Non-palindromic words in a given sentence.", "code": "# Give the string as static input and store it in a variable.\r\ngvn_str = \"dad and mom both ordered to bring sos in malayalam\"\r\n# Take an empty list and store it in another variable.\r\nlst = []\r\n# Split the given string using the split() function and store it in another variable.\r\nsplt_str = gvn_str.split()\r\n# Loop in the above-obtained split list of words using the for loop.\r\nfor wrd in splt_str:\r\n    # Check if the iterator value is not equal to the reverse of the iterator value using\r\n    # the if conditional statement.\r\n    if wrd != wrd[::-1]:\r\n     # If the statement is true, then append the respective iterator value to the\r\n        # above initialized empty list using the append() method.\r\n        lst.append(wrd)\r\n# Calculate the length above initialized list \"lst\" using the len() function\r\n# and store it in a variable.\r\n# Print the count of all the Non-palindromic words in a given sentence.\r\ncount = len(lst)\r\n# Print the count of all the Non-palindromic words in a given sentence.\r\nprint(\"The count of all the Non-palindromic words in a given sentence =\", count)"}
{"nl": "A stack permutation is a permutation of objects in the given input queue which is done by transferring elements from input queue to the output queue with the help of a stack and the built-in push and pop functions.\nThe well defined rules are: \n \n\nOnly dequeue from the input queue.\nUse inbuilt push, pop functions in the single stack.\nStack and input queue must be empty at the end.\nOnly enqueue to the output queue.\nThere are a huge number of permutations possible using a stack for a single input queue. \nGiven two arrays, both of unique elements. One represents the input queue and the other represents the output queue. Our task is to check if the given output is possible through stack permutation.", "code": "# Given two arrays, check if one array is\r\n# stack permutation of other.\r\nfrom queue import Queue\r\n\r\n# function to check if Input queue\r\n# is permutable to output queue\r\ndef checkStackPermutation(ip, op, n):\r\n\t\r\n\t# Input queue\r\n\tInput = Queue()\r\n\tfor i in range(n):\r\n\t\tInput.put(ip[i])\r\n\r\n\t# output queue\r\n\toutput = Queue()\r\n\tfor i in range(n):\r\n\t\toutput.put(op[i])\r\n\r\n\t# stack to be used for permutation\r\n\ttempStack = []\r\n\twhile (not Input.empty()):\r\n\t\tele = Input.queue[0]\r\n\t\tInput.get()\r\n\t\tif (ele == output.queue[0]):\r\n\t\t\toutput.get()\r\n\t\t\twhile (len(tempStack) != 0):\r\n\t\t\t\tif (tempStack[-1] == output.queue[0]):\r\n\t\t\t\t\ttempStack.pop()\r\n\t\t\t\t\toutput.get()\r\n\t\t\t\telse:\r\n\t\t\t\t\tbreak\r\n\t\telse:\r\n\t\t\ttempStack.append(ele)\r\n\r\n\t# If after processing, both Input\r\n\t# queue and stack are empty then\r\n\t# the Input queue is permutable\r\n\t# otherwise not.\r\n\treturn (Input.empty() and\r\n\t\tlen(tempStack) == 0)\r\n\r\n# Driver Code\r\nif __name__ == '__main__':\r\n\r\n\t# Input Queue\r\n\tInput = [1, 2, 3]\r\n\r\n\t# Output Queue\r\n\toutput = [2, 1, 3]\r\n\r\n\tn = 3\r\n\r\n\tif (checkStackPermutation(Input,\r\n\t\t\t\t\t\t\toutput, n)):\r\n\t\tprint(\"Yes\")\r\n\telse:\r\n\t\tprint(\"Not Possible\")\r\n\r\n# This code is contributed by PranchalK\r"}
{"nl": "Given a list of directions to spin, \"left\" or \"right\", return an integer of how many full 360\u00b0 rotations were made. Note that each word in the list counts as a 90\u00b0 rotation in that direction.\nWorked Example\nspin_around([\"right\", \"right\", \"right\", \"right\", \"left\", \"right\"]) \u279e 1\n# You spun right 4 times (90 * 4 = 360)\n# You spun left once (360 - 90 = 270)\n# But you spun right once more to make a full rotation (270 + 90 = 360)\nExamples\nspin_around([\"left\", \"right\", \"left\", \"right\"]) \u279e 0\n\nspin_around([\"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\", \"right\"]) \u279e 2\n\nspin_around([\"left\", \"left\", \"left\", \"left\"]) \u279e 1\nNotes\nReturn a positive number.\nAll tests will only include the words \"right\" and \"left\".", "code": "def spin_around(lst):\n  return abs(lst.count('left') - lst.count('right')) // 4"}
{"nl": "Given a number N and the task is to print the series (2, 4, 7, 12, 21, \u2026 N) till the given number N in Python.", "code": "# Give the number N(limit) as static input and store it in a variable.\r\ngvn_numb = 8\r\n# Take a variable to say itr and initialize its value to 0.\r\nitr = 0\r\n# Take another variable say previous_val and initialize its value to 2.\r\nprevious_val = 2\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\n# print the value 2 separated by spaces.\r\nprint(\"2 \",end=\"\")\r\n# Loop until the above-declared variable itr value is less than the\r\n# given number-1 using the while loop.\r\nwhile itr<gvn_numb-1:\r\n    #Inside the loop, Multiply the variable previous_val with 2 and subtract the above\r\n    #itr value from it.\r\n    #Store it in the same variable previous_val.\r\n    previous_val = (previous_val * 2) -itr\r\n    # Print the value of the above previous_val separated by spaces.\r\n    print(previous_val,end=\" \")\r\n    # Increment the above itr value by 1.\r\n    itr+=1"}
{"nl": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n \n\nConstraints:\n\n1 <= num1.length, num2.length <= 200\nnum1 and num2 consist of digits only.\nBoth num1 and num2 do not contain any leading zero, except the number 0 itself.", "code": "def multiply(self, num1: str, num2: str) -> str:\n    n = len(num1)\n    m = len(num2)\n    sum_arr = [0]*(n+m)\n    for i in range(n-1,-1,-1):\n        for j in range(m-1,-1,-1):\n            print(i,j)\n            pos1 = i+j\n            pos2 = pos1+1\n            n1 = int(num1[i])\n            n2 = int(num2[j])\n            \n            mul = (n1 * n2) + sum_arr[pos2]\n            print(n1*n2,sum_arr[pos2])\n            sum_arr[pos1] += mul // 10\n            sum_arr[pos2] = mul % 10\n    print(sum_arr)\n    ans = \"\"\n    for i in range(0,m+n):\n        ans += str(sum_arr[i])\n    \n    return \"0\" if ans.lstrip('0') == \"\" else ans.lstrip('0')"}
{"nl": "Create a function that returns True if each pair of adjacent numbers in a list shares at least one digit and False otherwise.\nExamples\nshared_digits([33, 53, 6351, 12, 2242, 44]) \u279e True\n# 33 and 53 share 3, 53 and 6351 share 3 and 5, etc.\n\nshared_digits([1, 11, 12, 13, 14, 15, 16]) \u279e True\n\nshared_digits([33, 44, 55, 66, 77]) \u279e False\n\nshared_digits([1, 12, 123, 1234, 1235, 6789]) \u279e False\nNotes\nN/A", "code": "def shared_digits(lst):\n  return all(set(str(lst[i-1]))&set(str(lst[i])) for i in range(1, len(lst)))"}
{"nl": "Regular Expressions (RegEx) are a powerful tool used to match or search for a pattern in a string. To use them in Python you need to import the re module. You can do this by adding the following line at the top of your file:\n\nimport re\nWrite a regular expression that will match the files with the extension .py or .pyw. You must use the RegEx line anchor $, which matches the end of a string.\n\nExamples\npattern = \"yourregularexpressionhere\"\n\nbool(re.search(pattern, \"/users/file.py\")) \u279e True\nbool(re.search(pattern, \"/users/file.pyw\")) \u279e True\nbool(re.search(pattern, \"/users/python/file.txt\")) \u279e False\nNotes\nYou don't need to write a function, just the pattern.\nDo not remove import re from the code.\nFind more info on RegEx and line anchors in Resources.\nYou can find all the challenges of this series in my Basic RegEx collection.", "code": "import re\r\n\u200b\r\npattern = '\\.pyw?$'"}
{"nl": "Instructions\r\nFind the difference between the square of the sum and the sum of the squares of the first N natural numbers.\r\n\r\nThe square of the sum of the first ten natural numbers is (1 + 2 + ... + 10)\u00b2 = 55\u00b2 = 3025.\r\n\r\nThe sum of the squares of the first ten natural numbers is 1\u00b2 + 2\u00b2 + ... + 10\u00b2 = 385.\r\n\r\nHence the difference between the square of the sum of the first ten natural numbers and the sum of the squares of the first ten natural numbers is 3025 - 385 = 2640.\r\n\r\nYou are not expected to discover an efficient solution to this yourself from first principles; research is allowed, indeed, encouraged. Finding the best algorithm for the problem is a key skill in software engineering.", "code": "def square_of_sum(number):\n        return int((number*(number+1)/2)**2)\ndef sum_of_squares(number):\n    return int(number*(number+1)*(2*number +1)/6)\ndef difference_of_squares(number):\n    return square_of_sum(number)-sum_of_squares(number)"}
{"nl": "Given an array of n integers, find the sum of f(a[i], a[j]) of all pairs (i, j) such that (1 <= i < j <= n). \n \n\nf(a[i], a[j]): \n\nIf |a[j]-a[i]| > 1\n   f(a[i], a[j]) = a[j] - a[i] \nElse // if |a[j]-a[i]| <= 1\n   f(a[i], a[j]) = 0", "code": "# Python3 program to calculate the\n# sum of f(a[i], aj])\n\n# Function to calculate the sum\ndef sum(a, n):\n\n        # map to keep a count of occurrences\n        cnt = dict()\n\n        # Traverse in the list from start to end\n        # number of times a[i] can be in a pair and\n        # to get the difference we subtract pre_sum.\n        ans = 0\n        pre_sum = 0\n        for i in range(n):\n                ans += (i * a[i]) - pre_sum\n                pre_sum += a[i]\n\n                # if the (a[i]-1) is present then\n                # subtract that value as f(a[i], a[i]-1)=0\n                if (a[i] - 1) in cnt:\n                        ans -= cnt[a[i] - 1]\n\n                # if the (a[i]+1) is present then add that\n                # value as f(a[i], a[i]-1)=0 here we add\n                # as a[i]-(a[i]-1)<0 which would have been\n                # added as negative sum, so we add to remove\n                # this pair from the sum value\n                if (a[i] + 1) in cnt:\n                        ans += cnt[a[i] + 1]\n\n                # keeping a counter for every element\n                if a[i] not in cnt:\n                        cnt[a[i]] = 0\n                cnt[a[i]] += 1\n        \n        return ans\n\n# Driver Code\nif __name__ == '__main__':\n        a = [1, 2, 3, 1, 3]\n        n = len(a)\n        print(sum(a, n))\n                \n# This code is contributed by\n# SHUBHAMSINGH10\n"}
{"nl": "Given a String and the task is to enter \u2018*\u2019 between two identical characters.\n\nExample :\n\nGiven string = btechgeeks\n\nOutput: btechge*eks\n\nExplanation: Since both the e\u2019s are identical and next to each other. so, we enter a \u2018*\u2019 in between them.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven string = \"good morning btechgeekss\"\nOutput:\n\nThe given string after entering '*' between two identical characters= go*od morning btechge*eks*\nExample 2:\n\nInput:\n\nGiven string = \"aabcddeefghii\"\nOutput:\n\nThe given string after entering '*' between two identical characters= a*abcd*de*efghi*", "code": "# Give the string as static input and store it in a variable.\ngvn_str = \"good morning btechgeekss\"\n# Take a new empty string say 'new_str'and store it in another variable.\nnew_str = \"\"\n# Take a variable and initialize its value with '0' and store it in another variable.\nitr = 0\n# Loop from '0' to the length of the given string -1 using for loop and len() function.\nfor itr in range(0, len(gvn_str)-1):\n  # Concat the new_str with the iterator value of the given string and\n  # store it in the same variable 'new_str'\n  new_str = new_str + gvn_str[itr]\n# Check if the iterator value of the given input string is equal to the iterator+1 value\n# of the given input string using the if conditional statement.\n  if(gvn_str[itr] == gvn_str[itr+1]):\n  # If the statement is true, concat the 'new_str' with the '*' symbol and\n  # store it in the same variable 'new_str'.\n  new_str += '*'\n# Print the variable 'new_str' to enter '*' between two identical characters in a\n# given String.\nprint(\"The given string after entering '*' between two identical characters=\", new_str)"}
{"nl": "Given a 4 x 4 matrix, we have to interchange the elements of first and last row and show the resulting matrix.\n\n\u00a0", "code": "# Python code to swap the element\n# of first and last row and display\n# the result\n\u00a0\ndef interchangeFirstLast(mat, n, m):\n\u00a0\u00a0\u00a0\u00a0rows = n\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# swapping of element between\n\u00a0\u00a0\u00a0\u00a0# first and last rows\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = mat[0][i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[0][i] = mat[rows-1][i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[rows-1][i] = t\n\u00a0\n# Driver Program\nmat = [[8, 9, 7, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 7, 6, 5],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[3, 2, 1, 8],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[9, 9, 7, 7]]\n\u00a0\nn = 4\nm = 4\ninterchangeFirstLast(mat, n, m)\n\u00a0\n# printing the interchanged matrix\nfor i in range(n):\n\u00a0\u00a0\u00a0\u00a0for j in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0print(\"\\n\")\n\u00a0\n# This code is contributed by Shrikant13.\n"}
{"nl": "You are given an array target that consists of distinct integers and another integer array arr that can have duplicates.\nIn one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array.\nReturn the minimum number of operations needed to make target a subsequence of arr.\nA subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\n \nExample 1:\n\nInput: target = [5,1,3], arr = [9,4,2,3,4]\nOutput: 2\nExplanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.\n\nExample 2:\n\nInput: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]\nOutput: 3\n\n \nConstraints:\n\n1 <= target.length, arr.length <= 105\n1 <= target[i], arr[i] <= 109\ntarget contains no duplicates.", "code": "def minOperations(self, target, A):\n  ha = {a: i for i, a in enumerate(target)}\n  stack = []\n  for a in A:\n  if a not in ha: continue\n  i = bisect.bisect_left(stack, h[a])\n  if i == len(stack):\n  stack.append(0)\n  stack[i] = h[a]\n  return len(target) - len(stack)"}
{"nl": "Create a function that takes a string as an argument and converts the first character of each word to uppercase. Return the newly formatted string.\r\n\r\nExamples\r\nmake_title(\"This is a title\") \u279e \"This Is A Title\"\r\n\r\nmake_title(\"capitalize every word\") \u279e \"Capitalize Every Word\"\r\n\r\nmake_title(\"I Like Pizza\") \u279e \"I Like Pizza\"\r\n\r\nmake_title(\"PIZZA PIZZA PIZZA\") \u279e \"PIZZA PIZZA PIZZA\"\r\nNotes\r\nYou can expect a valid string for each test case.\r\nSome words may contain more than one uppercase letter (see example #4).", "code": "def make_title(txt):\r\n    lst = [word[0].upper() + word[1:] for word in txt.split(' ')]\r\n    ans = ' '.join(lst)\r\n    return ans"}
{"nl": "Implement a queue in Python using the linked list implementation. The following two main operations must be implemented efficiently.\n\nIn a Queue data structure, we maintain two pointers, front and rear. The front points the first item of queue and rear points to last item.\nenQueue() This operation adds a new node after rear and moves rear to the next node.\ndeQueue() This operation removes the front node and moves front to the next node.\n\u00a0", "code": "# Python3 program to demonstrate linked list\n# based implementation of queue\n\u00a0\n# A linked list (LL) node\n# to store a queue entry\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next = None\n\u00a0\n# A class to represent a queue\n\u00a0\n# The queue, front stores the front node\n# of LL and rear stores the last node of LL\nclass Queue:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = self.rear = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.front == None\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Method to add an item to the queue\n\u00a0\u00a0\u00a0\u00a0def EnQueue(self, item):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = Node(item)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.rear == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = self.rear = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear.next = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = temp\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Method to remove an item from queue\n\u00a0\u00a0\u00a0\u00a0def DeQueue(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = self.front\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = temp.next\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(self.front == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = None\n\u00a0\n# Driver Code\nif __name__== '__main__':\n\u00a0\u00a0\u00a0\u00a0q = Queue()\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(10)\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(20)\n\u00a0\u00a0\u00a0\u00a0q.DeQueue()\n\u00a0\u00a0\u00a0\u00a0q.DeQueue()\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(30)\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(40)\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(50)\n\u00a0\u00a0\u00a0\u00a0q.DeQueue()\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Queue Front \" + str(q.front.data))\n\u00a0\u00a0\u00a0\u00a0print(\"Queue Rear \" + str(q.rear.data))\n\u00a0\u00a0\u00a0\u00a0\n"}
{"nl": "Write a function to print ZigZag order traversal of a binary tree. For the below binary tree the zigzag order traversal will be 1 3 2 7 6 5 4.", "code": "# Python Program to print zigzag traversal\n# of binary tree\n\n# Binary tree node\nclass Node:\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\n\n# function to print zigzag traversal of\n# binary tree\ndef zizagtraversal(root):\n\n\t# Base Case\n\tif root is None:\n\t\treturn\n\n\t# Create two stacks to store current\n\t# and next level\n\tcurrentLevel = []\n\tnextLevel = []\n\n\t# if ltr is true push nodes from\n\t# left to right otherwise from\n\t# right to left\n\tltr = True\n\n\t# append root to currentlevel stack\n\tcurrentLevel.append(root)\n\n\t# Check if stack is empty\n\twhile len(currentLevel) > 0:\n\t\t# pop from stack\n\t\ttemp = currentLevel.pop(-1)\n\t\t# print the data\n\t\tprint(temp.data, \" \", end=\"\")\n\n\t\tif ltr:\n\t\t\t# if ltr is true push left\n\t\t\t# before right\n\t\t\tif temp.left:\n\t\t\t\tnextLevel.append(temp.left)\n\t\t\tif temp.right:\n\t\t\t\tnextLevel.append(temp.right)\n\t\telse:\n\t\t\t# else push right before left\n\t\t\tif temp.right:\n\t\t\t\tnextLevel.append(temp.right)\n\t\t\tif temp.left:\n\t\t\t\tnextLevel.append(temp.left)\n\n\t\tif len(currentLevel) == 0:\n\t\t\t# reverse ltr to push node in\n\t\t\t# opposite order\n\t\t\tltr = not ltr\n\t\t\t# swapping of stacks\n\t\t\tcurrentLevel, nextLevel = nextLevel, currentLevel\n\n\n# Driver program to check above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(7)\nroot.left.right = Node(6)\nroot.right.left = Node(5)\nroot.right.right = Node(4)\nprint(\"Zigzag Order traversal of binary tree is\")\nzizagtraversal(root)\n\n# This code is contributed by Shweta Singh"}
{"nl": "Create a function that takes a list and a number and selectively reverse the order of the list based on the number you're given (second argument). If you're given the arguments [1,2,3,4,5,6] and 2, you would return the list [2,1, 4,3, 6,5].\nExamples\nsel_reverse([1,2,3,4,5,6], 2) \u279e [2,1, 4,3, 6,5]\n\nsel_reverse([2,4,6,8,10,12,14,16], 3) \u279e [6,4,2, 12,10,8, 16,14]\n\nsel_reverse([5,7,2,6,0,4,6], 100) \u279e [6,4,0,6,2,7,5]\nNotes\nIf the list you're given can't be broken up into equal parts, just reverse the remaining numbers (see 2nd expample).\nIf length exceeds the list length, reverse everything.\nIf length is zero, return the original list.", "code": "def sel_reverse(lst, n):\n  if n > 0:\n    new = []\n    for i in range(0, len(lst), n):\n      new += lst[i:i+n][::-1]\n    return new\n  return lst"}
{"nl": "Given a graph, a source vertex in the graph and a number k, find if there is a simple path (without any cycle) starting from given source and ending at any other vertex such that the distance from source to that vertex is atleast \u2018k\u2019 length.\n\n\n\u00a0", "code": "# Program to find if there is a simple path with\n# weight more than k\n\u00a0\u00a0\u00a0\n# This class represents a dipathted graph using\n# adjacency list representation\nclass Graph:\n\u00a0\u00a0\u00a0\u00a0# Allocates memory for adjacency list\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj = [[] for i in range(V)]\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if graph has path more than k length\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanK(self,src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a path array with nothing included\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path = [False]*self.V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add source vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[src] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.pathMoreThanKUtil(src, k, path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Prints shortest paths from src to all other vertices\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanKUtil(self,src, k, path):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If k is 0 or negative, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get all adjacent vertices of source vertex src and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursively explore all paths from src.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while i != len(self.adj[src]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get adjacent vertex and weight of edge\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = self.adj[src][i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w = self.adj[src][i][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If vertex v is already there in path, then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# there is a cycle (we ignore this edge)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (path[v] == True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If weight of is more than k, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (w >= k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Else add this vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this adjacent can provide a path longer\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than k, return true.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (self.pathMoreThanKUtil(v, k-w, path)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Backtrack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If no adjacent could produce longer path, return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Utility function to an edge (u, v) of weight w\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u, v, w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[u].append([v, w])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[v].append([u, w])\n\u00a0\u00a0\u00a0\n# Driver program to test methods of graph class\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# create the graph given in above figure\n\u00a0\u00a0\u00a0\u00a0V = 9\n\u00a0\u00a0\u00a0\u00a0g = Graph(V)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0#\u00a0 making above shown graph\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 1, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 7, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 2, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 7, 11)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 3, 7)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 8, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 5, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 4, 9)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 5, 14)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(4, 5, 10)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(5, 6, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 7, 1)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 8, 6)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(7, 8, 7)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0src = 0\n\u00a0\u00a0\u00a0\u00a0k = 62\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0k = 60\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n"}
{"nl": "In the previous article, we have discussed about Program to Read a Number n and Compute n+nn+nnn in C++ and Python. Let us learn Program to Print Collatz Conjecture for a Given Number in C++ Program.\n Given a number , the task is to print Collatz Conjecture of the given number in C++ and Python.\n Collatz Conjecture:\n \n The Collatz Conjecture states that a specific sequence will always reach the value 1.\n It is given as follows, beginning with some integer n:\n If n is an even number, the following number in the sequence is n/2.\n Otherwise, the following number is 3n+1 (if n is odd).\n \n Examples:\n Example1:\n Input:\n given number =5425\n Output:\n The Collatz Conjecture of the number :\n \n 5425 16276 8138 4069 12208 6104 3052 1526 763 2290 1145 3436 1718 859 2578 1289 3868 1934 967 2902 1451 4354 2177 6532 3266 1633 4900 2450 1225 3676 1838 919 2758 1379 4138 2069 6208 3104 1552 776 388 194 97 292 146 73 220 110 55 166 83 250 125 376 188 94 47 142 71 214 107 322 161 484 242 121 364 182 91 274 137 412 206 103 310 155 466 233 700 350 175 526 263 790 395 1186 593 1780 890 445 1336 668 334 167 502 251 754 377 1132 566 283 850 425 1276 638 319 958 479 1438 719 2158 1079 3238 1619 4858 2429 7288 3644 1822 911 2734 1367 4102 2051 6154 3077 9232 4616 2308 1154 577 1732 866 433 1300 650 325 976 488 244 122 61 184 92 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1\n Example2:\n Input:\n given number=847\n Output:\n The Collatz Conjecture of the number :\n \n 847 2542 1271 3814 1907 5722 2861 8584 4292 2146 1073 3220 1610 805 2416 1208 604 302 151 454 227 682 341 1024 512 256 128 64 32 16 8 4 2 1", "code": "# function which prints collatz sequence of the given number\n \n def printCollatz(numb):\n \n  # Iterate till the given number is not equal to 1 using while loop.\n \n  while numb > 1:\n \n  # Print the number numb\n \n  print(numb, end=' ')\n \n  # If the number is even then set n to n/2.\n \n  if (numb % 2 == 0):\n \n  numb = numb//2\n \n  # If the number is odd then set n to 3*n+1.\n \n  else:\n \n  numb = 3*numb + 1\n \n  # Print 1 after end of while loop.\n \n  print(1, end='')\n \n \n \n \n \n # given number\n \n numb = 179\n \n print('The Collatz Conjecture of the number :')\n \n # passing the given numb to printCollatz function to\n \n # print collatzConjecture sequence of the given number\n \n printCollatz(numb)"}
{"nl": "Write a function that retrieves all words that begin with a vowel.\nExamples\nretrieve(\"A simple life is a happy life for me.\") \u279e [\"a\", \"is\", \"a\"]\n\nretrieve(\"Exercising is a healthy way to burn off energy.\")\n\u279e [\"exercising\", \"is\", \"a\", \"off\", \"energy\"]\n\nretrieve(\"The poor ostrich was ostracized.\")\n\u279e [\"ostrich\", \"ostracized\"]\n\nretrieve(\"\")\n\u279e []\nNotes\nMake all words lower case in the output.\nRetrieve the words in the order they appear in the sentence.", "code": "def retrieve(txt):\n  return [i for i in txt[:-1].lower().split() if i[0] in 'aeiou']"}
{"nl": "There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.\n\n\nEach second, you may perform one of the following operations:\n\nMove the pointer one character counterclockwise or clockwise.\nType the character the pointer is currently on.\nGiven a string word, return the minimum number of seconds to type out the characters in word.\n\n ", "code": "class Solution:\n    def minTimeToType(self, word: str) -> int:\n        \n        def get_index(c):\n            return ord(c) - 96\n        \n        move = 0\n        \n        # initial start is block 'a'\n        prev = 'a'\n        \n        for c in word:\n            \n            pi, ci = map(get_index, (prev, c))\n            \n            # basic move\n            min_move = abs(ci - pi)\n            \n            if ci > pi:\n                # e.g. current=\"z\", prev=\"a\", borrow 26 to prev \n                min_move = min(min_move, (pi + 26 - ci))\n            else:\n                # e.g. current=\"a\", prev=\"z\", borrow 26 to current\n                min_move = min(min_move, (ci + 26 - pi))\n                        \n            # add print time\n            move = move + min_move + 1\n            \n            # update prev pointer\n            prev = c    \n        \n        return move"}
{"nl": "Given a list of contacts containing the username, email and phone number in any order. Identify the same contacts (i.e., the same person having many contacts) and output the same contacts together.\u00a0\n\nNotes: \n1) A contact can store its three fields in any order, i.e., a phone number can appear before username or username can appear before the phone number.\n2) Two contacts are the same if they have either the same username or email or phone number. \n\nExample: \n\nInput: contact[] = \n     { {\"Gaurav\", \"gaurav@gmail.com\", \"gaurav@gfgQA.com\"},\n       { \"Lucky\", \"lucky@gmail.com\", \"+1234567\"},\n       { \"gaurav123\", \"+5412312\", \"gaurav123@skype.com\"}.\n       { \"gaurav1993\", \"+5412312\", \"gaurav@gfgQA.com\"}\n     }\nOutput:\n   0 2 3\n   1 \ncontact[2] is same as contact[3] because they both have same contact number.\ncontact[0] is same as contact[3] because they both have same e-mail address.\nTherefore, contact[0] and contact[2] are also same.", "code": "# A Python3 program to find same contacts\n# in a list of contacts\n\u00a0\n# Structure for storing contact details.\nclass contact:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, field1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0field2, field3):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.field1 = field1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.field2 = field2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.field3 = field3\n\u00a0\n# A utility function to fill entries in\n# adjacency matrix representation of graph\ndef buildGraph(arr, n, mat):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize the adjacency matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse through all contacts\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add mat from i to j and vice versa,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if possible. Since length of each\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# contact field is at max some constant.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (say 30) so body execution of this for\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# loop takes constant time.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(i + 1, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i].field1 == arr[j].field1 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field1 == arr[j].field2 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field1 == arr[j].field3 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field2 == arr[j].field1 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field2 == arr[j].field2 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field2 == arr[j].field3 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field3 == arr[j].field1 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field3 == arr[j].field2 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field3 == arr[j].field3):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[j][i] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n# A recursive function to perform DFS\n# with vertex i as source\ndef DFSvisit(i, mat, visited, sol, n):\n\u00a0\u00a0\u00a0\u00a0visited[i] = True\n\u00a0\u00a0\u00a0\u00a0sol.append(i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] and not visited[j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DFSvisit(j, mat, visited, sol, n)\n\u00a0\n# Finds similar contacts in an\n# array of contacts\ndef findSameContacts(arr, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# vector for storing the solution\n\u00a0\u00a0\u00a0\u00a0sol = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Declare 2D adjacency matrix for mats\n\u00a0\u00a0\u00a0\u00a0mat = [[None] * n for i in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# visited array to keep track\n\u00a0\u00a0\u00a0\u00a0# of visited nodes\n\u00a0\u00a0\u00a0\u00a0visited = [0] * n\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Fill adjacency matrix\n\u00a0\u00a0\u00a0\u00a0buildGraph(arr, n, mat)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Since, we made a graph with contacts\u00a0\n\u00a0\u00a0\u00a0\u00a0# as nodes with fields as links. Two\n\u00a0\u00a0\u00a0\u00a0# nodes are linked if they represent\n\u00a0\u00a0\u00a0\u00a0# the same person. So, total number of\n\u00a0\u00a0\u00a0\u00a0# connected components and nodes in each\n\u00a0\u00a0\u00a0\u00a0# component will be our answer.\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not visited[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DFSvisit(i, mat, visited, sol, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add delimiter to separate nodes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# of one component from other.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sol.append(-1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the solution\n\u00a0\u00a0\u00a0\u00a0for i in range(len(sol)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sol[i] == -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(sol[i], end = \" \")\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0arr = [contact(\"Gaurav\", \"gaurav@gmail.com\", \"gaurav@gfgQA.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"Lucky\", \"lucky@gmail.com\", \"+1234567\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"gaurav123\", \"+5412312\", \"gaurav123@skype.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"gaurav1993\", \"+5412312\", \"gaurav@gfgQA.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"raja\", \"+2231210\", \"raja@gfg.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"bahubali\", \"+878312\", \"raja\")]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0n = len(arr)\n\u00a0\u00a0\u00a0\u00a0findSameContacts(arr, n)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "The program creates a d-ary max-heap and presents a menu to the user to perform various operations on it.", "code": "class D_aryHeap:\n    def __init__(self, d):\n        self.items = []\n        self.d = d\n\u00a0\n    def size(self):\n        return len(self.items)\n\u00a0\n    def parent(self, i):\n        return (i - 1)//self.d\n\u00a0\n    def child(self, index, position):\n        return index*self.d + (position + 1)\n\u00a0\n    def get(self, i):\n        return self.items[i]\n\u00a0\n    def get_max(self):\n        if self.size() == 0:\n            return None\n        return self.items[0]\n\u00a0\n    def extract_max(self):\n        if self.size() == 0:\n            return None\n        largest = self.get_max()\n        self.items[0] = self.items[-1]\n        del self.items[-1]\n        self.max_heapify(0)\n        return largest\n\u00a0\n    def max_heapify(self, i):\n        largest = i\n        for j in range(self.d):\n            c = self.child(i, j)\n            if (c < self.size() and self.get(c) > self.get(largest)):\n                largest = c\n        if (largest != i):\n            self.swap(largest, i)\n            self.max_heapify(largest)\n\u00a0\n    def swap(self, i, j):\n        self.items[i], self.items[j] = self.items[j], self.items[i]\n\u00a0\n    def insert(self, key):\n        index = self.size()\n        self.items.append(key)\n        while (index != 0):\n            p = self.parent(index)\n            if self.get(p) < self.get(index):\n                self.swap(p, index)\n            index = p\n\u00a0\n\u00a0\nd = int(input('Enter the value of D: '));\ndheap = D_aryHeap(d)\n\u00a0\nprint('Menu (this assumes no duplicate keys)')\nprint('insert <data>')\nprint('max get')\nprint('max extract')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'insert':\n        data = int(do[1])\n        dheap.insert(data)\n    elif operation == 'max':\n        suboperation = do[1].strip().lower()\n        if suboperation == 'get':\n            print('Maximum value: {}'.format(dheap.get_max()))\n        elif suboperation == 'extract':\n            print('Maximum value removed: {}'.format(dheap.extract_max()))\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "In this challenge, it's time to ban some impenitent digit!\nYour job is to delete the digits of a given number that, within their name written in English, contain a given vowel.\nGiven an integer n, and a string ban being the vowel to search, implement a function that returns:\nIf the given vowel is not present in the name of any of the digits of n, the same n.\nIf n has at least a digit that contains the given vowel in its name, the new integer obtained after the elimination of banned digits (as a natural number without leading zeros).\nIf all digits of n are banned, a string \"Banned Number\".\nExamples\ndigital_vowel_ban(143, \"o\") \u279e 3\n# 1 = \"One\" contains \"o\" (banned).\n# 4 = \"Four\" contains \"o\" (banned).\n# 3 = \"Three\" is safe.\n\ndigital_vowel_ban(14266330, \"e\") \u279e 4266\n# \"One\" contains \"e\" (banned).\n# \"Four\", \"Two\" and \"Six\" are safe.\n# \"Three\" and \"Zero\" contain \"e\" (banned).\n\ndigital_vowel_ban(4020, \"u\") \u279e 20\n# \"Four\" contains \"u\" (banned).\n# Leading zeros are not considered.\n\ndigital_vowel_ban(586, \"i\") \u279e \"Banned Number\"\n# All digits (\"Five, \"Eight\", \"Six\") contain \"i\".\nNotes\nEvery given number will be a positive integer greater than 0.", "code": "def digital_vowel_ban(n, ban):\n    d = {'e': '0135789', 'i': '5689', 'o': '0124', 'u': '4'}\n    new = ''.join(i for i in str(n) if i not in d.get(ban, ''))\n    return 'Banned Number' if not new else int(new)"}
{"nl": "Given an array that might contain duplicates, find the element whose last appearance is latest.\r\n", "code": "\r\n# Python3 program to find last seen\r\n# element in an array.\r\nimport sys;\r\n \r\n# Returns last seen element in arr[]\r\ndef lastSeenElement(a, n):\r\n     \r\n    # Store last occurrence index of\r\n    # every element\r\n    hash = {}\r\n     \r\n    for i in range(n):\r\n        hash[a[i]] = i\r\n         \r\n    # Find an element in hash with minimum\r\n    # index value\r\n    res_ind = sys.maxsize\r\n    res = 0\r\n     \r\n    for x, y in hash.items():\r\n        if y < res_ind:\r\n            res_ind = y\r\n            res = x\r\n             \r\n    return res\r\n \r\n# Driver code   \r\nif __name__==\"__main__\":\r\n     \r\n    a = [ 2, 1, 2, 2, 4, 1 ]\r\n    n = len(a)\r\n     \r\n    print(lastSeenElement(a,n))\r\n \r\n# This code is contributed by rutvik_56"}
{"nl": "Prerequisites: OPTICS Clustering\r\n\r\nThis article will demonstrate how to implement OPTICS Clustering technique using Sklearn in Python. The dataset used for the demonstration is the Mall Customer Segmentation Data which can be downloaded from Kaggle.", "code": "\r\nimport numpy as np\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib import gridspec\r\nfrom sklearn.cluster import OPTICS, cluster_optics_dbscan\r\nfrom sklearn.preprocessing import normalize, StandardScaler\r\n\r\n# Changing the working location to the location of the data\r\ncd C:\\Users\\Dev\\Desktop\\Kaggle\\Customer Segmentation\r\n  \r\nX = pd.read_csv('Mall_Customers.csv')\r\n  \r\n# Dropping irrelevant columns\r\ndrop_features = ['CustomerID', 'Gender']\r\nX = X.drop(drop_features, axis = 1)\r\n  \r\n# Handling the missing values if any\r\nX.fillna(method ='ffill', inplace = True)\r\n  \r\nX.head()\r\n\r\n\r\n# Scaling the data to bring all the attributes to a comparable level\r\nscaler = StandardScaler()\r\nX_scaled = scaler.fit_transform(X)\r\n  \r\n# Normalizing the data so that the data\r\n# approximately follows a Gaussian distribution\r\nX_normalized = normalize(X_scaled)\r\n  \r\n# Converting the numpy array into a pandas DataFrame\r\nX_normalized = pd.DataFrame(X_normalized)\r\n  \r\n# Renaming the columns\r\nX_normalized.columns = X.columns\r\n  \r\nX_normalized.head()\r\n\r\n\r\n# Building the OPTICS Clustering model\r\noptics_model = OPTICS(min_samples = 10, xi = 0.05, min_cluster_size = 0.05)\r\n  \r\n# Training the model\r\noptics_model.fit(X_normalized)\r\n\r\n# Producing the labels according to the DBSCAN technique with eps = 0.5\r\nlabels1 = cluster_optics_dbscan(reachability = optics_model.reachability_,\r\n                                   core_distances = optics_model.core_distances_,\r\n                                   ordering = optics_model.ordering_, eps = 0.5)\r\n  \r\n# Producing the labels according to the DBSCAN technique with eps = 2.0\r\nlabels2 = cluster_optics_dbscan(reachability = optics_model.reachability_,\r\n                                   core_distances = optics_model.core_distances_,\r\n                                   ordering = optics_model.ordering_, eps = 2)\r\n  \r\n# Creating a numpy array with numbers at equal spaces till\r\n# the specified range\r\nspace = np.arange(len(X_normalized))\r\n  \r\n# Storing the reachability distance of each point\r\nreachability = optics_model.reachability_[optics_model.ordering_]\r\n  \r\n# Storing the cluster labels of each point\r\nlabels = optics_model.labels_[optics_model.ordering_]\r\n  \r\nprint(labels)\r\n\r\n# Defining the framework of the visualization\r\nplt.figure(figsize =(10, 7))\r\nG = gridspec.GridSpec(2, 3)\r\nax1 = plt.subplot(G[0, :])\r\nax2 = plt.subplot(G[1, 0])\r\nax3 = plt.subplot(G[1, 1])\r\nax4 = plt.subplot(G[1, 2])\r\n  \r\n# Plotting the Reachability-Distance Plot\r\ncolors = ['c.', 'b.', 'r.', 'y.', 'g.']\r\nfor Class, colour in zip(range(0, 5), colors):\r\n    Xk = space[labels == Class]\r\n    Rk = reachability[labels == Class]\r\n    ax1.plot(Xk, Rk, colour, alpha = 0.3)\r\nax1.plot(space[labels == -1], reachability[labels == -1], 'k.', alpha = 0.3)\r\nax1.plot(space, np.full_like(space, 2., dtype = float), 'k-', alpha = 0.5)\r\nax1.plot(space, np.full_like(space, 0.5, dtype = float), 'k-.', alpha = 0.5)\r\nax1.set_ylabel('Reachability Distance')\r\nax1.set_title('Reachability Plot')\r\n  \r\n# Plotting the OPTICS Clustering\r\ncolors = ['c.', 'b.', 'r.', 'y.', 'g.']\r\nfor Class, colour in zip(range(0, 5), colors):\r\n    Xk = X_normalized[optics_model.labels_ == Class]\r\n    ax2.plot(Xk.iloc[:, 0], Xk.iloc[:, 1], colour, alpha = 0.3)\r\n      \r\nax2.plot(X_normalized.iloc[optics_model.labels_ == -1, 0],\r\n        X_normalized.iloc[optics_model.labels_ == -1, 1],\r\n       'k+', alpha = 0.1)\r\nax2.set_title('OPTICS Clustering')\r\n  \r\n# Plotting the DBSCAN Clustering with eps = 0.5\r\ncolors = ['c', 'b', 'r', 'y', 'g', 'greenyellow']\r\nfor Class, colour in zip(range(0, 6), colors):\r\n    Xk = X_normalized[labels1 == Class]\r\n    ax3.plot(Xk.iloc[:, 0], Xk.iloc[:, 1], colour, alpha = 0.3, marker ='.')\r\n        \r\nax3.plot(X_normalized.iloc[labels1 == -1, 0],\r\n        X_normalized.iloc[labels1 == -1, 1],\r\n       'k+', alpha = 0.1)\r\nax3.set_title('DBSCAN clustering with eps = 0.5')\r\n  \r\n# Plotting the DBSCAN Clustering with eps = 2.0\r\ncolors = ['c.', 'y.', 'm.', 'g.']\r\nfor Class, colour in zip(range(0, 4), colors):\r\n    Xk = X_normalized.iloc[labels2 == Class]\r\n    ax4.plot(Xk.iloc[:, 0], Xk.iloc[:, 1], colour, alpha = 0.3)\r\n          \r\nax4.plot(X_normalized.iloc[labels2 == -1, 0],\r\n        X_normalized.iloc[labels2 == -1, 1],\r\n       'k+', alpha = 0.1)\r\nax4.set_title('DBSCAN Clustering with eps = 2.0')\r\n  \r\n  \r\nplt.tight_layout()\r\nplt.show()"}
{"nl": "Write a regular expression that ensures the word \"end\" is inside of another word (e.g. \"bending\"). You must use RegEx boundary assertions. Non-word characters such as !, ?, etc. cannot be boundaries.\nExamples\npattern = \"yourregularexpressionhere\"\n\nbool(re.search(pattern, \"The end of the story.\")) \u279e False\nbool(re.search(pattern, \"Endings are pointless.\")) \u279e False\nbool(re.search(pattern, \"Let\"s send!\")) \u279e False\nbool(re.search(pattern, \"We viewed the rendering at the end.\")) \u279e True\nbool(re.search(pattern, \"Sometimes bending the rules is good.\")) \u279e True\nNotes\nYou cannot use \\w, *, . or + in your expression.\nYou don't need to write a function, just the pattern.\nDo not remove import re from the code.\nFind more info on RegEx and boundary assertions in Resources.\nYou can find all the challenges of this series in my Basic RegEx collection.", "code": "import re\npattern = '\\Bend\\B'"}
{"nl": "You may recall that an array arr is a mountain array if and only if:\n\narr.length >= 3\nThere exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\n\n\nGiven an integer array nums\u200b\u200b\u200b, return the minimum number of elements to remove to make nums\u200b\u200b\u200b a mountain array.\n \nExample 1:\n\nInput: nums = [1,3,1]\nOutput: 0\nExplanation: The array itself is a mountain array so we do not need to remove any elements.\n\nExample 2:\n\nInput: nums = [2,1,1,5,6,2,3,1]\nOutput: 3\nExplanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].\n\n \nConstraints:\n\n3 <= nums.length <= 1000\n1 <= nums[i] <= 109\nIt is guaranteed that you can make a mountain array out of nums.", "code": "class Solution:\n  def minimumMountainRemovals(self, nums):\n  def LIS(nums):\n  dp = [10**10] * (len(nums) + 1)\n  lens = [0]*len(nums)\n  for i, elem in enumerate(nums): \n  lens[i] = bisect_left(dp, elem) + 1\n  dp[lens[i] - 1] = elem \n  return lens\n  \n  l1, l2 = LIS(nums), LIS(nums[::-1])[::-1]\n  ans, n = 0, len(nums)\n  for i in range(n):\n  if l1[i] >= 2 and l2[i] >= 2:\n  ans = max(ans, l1[i] + l2[i] - 1)\n  \n  return n - ans"}
{"nl": "Create a function that returns the smallest number of changes it takes to transform one number into one with identical digits. A step is incrementing or decrementing a digit by one.\nExamples\nsmallest_transform(399) \u279e 6\n# 399 transformed to 999 in 6 steps.\n\nsmallest_transform(1234) \u279e 4\n# 1234 can be transformed to either 2222 or 3333 using 4 steps.\n\nsmallest_transform(153) \u279e 4\n\nsmallest_transform(33338) \u279e 5\n\nsmallest_transform(7777) \u279e 0\nNotes\nIf a number already has identical digits, return 0.", "code": "def smallest_transform(num):\n  nums = [int(digit) for digit in str(num)]\n  return min(sum(abs(a - b) for a in nums) for b in nums)"}
{"nl": "Given a dictionary, the task is to print the sum of all the values in the given dictionary in Python.", "code": "# Take a dictionary and initialize it with some random key and value pairs.\ngivendiction = {'heello': 27, 'this': 282, 'is': 98, 'BTechGeeks': 98,\n                'online': 123, 'platform': 32, 'for': 38, 'coding': 10, 'students': 81}\n# values() function returns the tuple of all the values present in the given dictionary.\n# Store this tuple in some variable.\nvalLst = givendiction.values()\n# Calculate the sum of the values list using the sum() function.\nsumvalu = sum(valLst)\n# Print the sum of all the values in the given dictionary.\nprint('The sum of all the values in the given dictionary\\n', givendiction, ':')\nprint(sumvalu)"}
{"nl": "Given a string word, return the sum of the number of vowels ('a', 'e', 'i', 'o', and 'u') in every substring of word.\r\n\r\nA substring is a contiguous (non-empty) sequence of characters within a string.\r\n\r\nNote: Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.\r\n\r\n ", "code": "class Solution:\n    def countVowels(self, word: str) -> int:\n        vows = set(\"aeiou\")\n        l = len(word)\n        s = 0\n        for i in range(l):\n            if word[i] in vows:\n                s += (i + 1) * (l - i)\n        return s"}
{"nl": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n\nReturn the result string after sorting s with this algorithm.\n\n \n\nExample 1:\n\nInput: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"\nExample 2:\n\nInput: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm.\n \n\nConstraints:\n\n1 <= s.length <= 500\ns consists of only lowercase English letters.", "code": "def sortString(self, s: str) -> str:\n  cnt, ans, asc = collections.Counter(s), [], True\n  while cnt:  # if Counter not empty.\n  for c in sorted(cnt) if asc else reversed(sorted(cnt)):  # traverse keys in ascending/descending order.\n  ans.append(c) # append the key.\n  cnt[c] -= 1  # decrease the count.\n  if cnt[c] == 0:  # if the count reaches to 0.\n  del cnt[c]  # remove the key from the Counter.\n  asc = not asc  # change the direction, same as asc ^= True.\n  return ''.join(ans)"}
{"nl": "Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n\nFind the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\nFind the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\nReduce nums[i] to nextLargest.\nReturn the number of operations to make all elements in nums equal.\n\n ", "code": "class Solution:\n    def reductionOperations(self, nums: List[int]) -> int:\n        ans = 0\n        nums.sort(reverse = True)\n        val = 1\n        for i in range(1 , len(nums)):\n            if(nums[i-1] != nums[i]):\n                ans += val\n            val += 1\n        return ans"}
{"nl": "A Bipartite Graph is a graph whose vertices can be divided into two independent sets, U and V such that every edge (u, v) either connects a vertex from U to V or a vertex from V to U. In other words, for every edge (u, v), either u belongs to U and v to V, or u belongs to V and v to U. We can also say that there is no edge that connects vertices of same set.\n", "code": "# Python program to find out whether a\n# given graph is Bipartite or not\n\u00a0\nclass Graph():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = [[0 for column in range(V)] \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for row in range(V)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This function returns true if graph G[V][V]\n\u00a0\u00a0\u00a0\u00a0# is Bipartite, else false\n\u00a0\u00a0\u00a0\u00a0def isBipartite(self, src):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a color array to store colors\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# assigned to all vertices. Vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# number is used as index in this array.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# The value '-1' of\u00a0 colorArr[i] is used to\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# indicate that no color is assigned to\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# vertex 'i'. The value 1 is used to indicate\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# first color is assigned and value 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# indicates second color is assigned.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0colorArr = [-1] * self.V\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Assign first color to source\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0colorArr[src] = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a queue (FIFO) of vertex numbers and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# enqueue source vertex for BFS traversal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(src)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Run while there are vertices in queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (Similar to BFS)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while queue:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = queue.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Return false if there is a self-loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.graph[u][u] == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for v in range(self.V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# An edge from u to v exists and destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# v is not colored\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.graph[u][v] == 1 and colorArr[v] == -1:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Assign alternate color to this\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# adjacent v of u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0colorArr[v] = 1 - colorArr[u]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# An edge from u to v exists and destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# v is colored with same color as u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif self.graph[u][v] == 1 and colorArr[v] == colorArr[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we reach here, then all adjacent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# vertices can be colored with alternate\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# color\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n# Driver program to test above function\ng = Graph(4)\ng.graph = [[0, 1, 0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 1, 0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nprint (\"Yes\" if g.isBipartite(0) else \"No\")\n\u00a0\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "Write a function that returns the greatest common divisor of all list elements. If the greatest common divisor is 1, return 1.\nExamples\nGCD([10, 20, 40]) \u279e 10\n\nGCD([1, 2, 3, 100]) \u279e 1\n\nGCD([1024, 192, 2048, 512]) \u279e 64\nNotes\nList elements are always greater than 0.\nThere is a minimum of two list elements given.", "code": "def GCD(lst):\n  for i in range(min(lst), 1, -1):\n      if all(not j%i for j in lst):\n          return i\n  return 1"}
{"nl": "Method #1: Using For loop (Star Character)\nApproach:\n\nGive the number of rows of the right-angled triangle star pattern as static input and store it in a variable.\nLoop from 1 to the number of rows using For loop.\nLoop from 1 to first loop iterator value using another Nested For loop.\nPrint the star character with space in the inner For loop.\nPrint the newline character after ending of inner For loop.\nThe Exit of the program.", "code": "# Give the number of rows of the right-angled triangle star pattern\r\n# as static input and store it in a variable.\r\ntrianglerows = 19\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, trianglerows+1):\r\n    # Loop from 1 to first loop iterator value using another Nested For loop.\r\n    for n in range(1, m+1):\r\n        # Print the star character with space in the inner For loop.\r\n        print('*', end=' ')\r\n    #Print the newline character after ending of inner For loop.\r\n    print()"}
{"nl": "Create a function that takes in a year and returns the correct century.", "code": "def century(year):\n        century_no = str((year + 99 ) // 100)\n        return '21st century' if century_no == '21' else century_no + 'th century'"}
{"nl": "Python program to check given number is an even number or odd number? We will discuss different methods to check number is odd or even. A number will be given to the program and the python program will check the given number is odd or even. We will also find all odd and even numbers in between a given range in Python.", "code": "# Python program to check given number is an even or odd # take inputs num = 5 # check number is even or odd if(num % 2 == 0): print('{0} is an even number'.format(num)) else: print('{0} is an odd number'.format(num))"}
{"nl": "Eulerian Path is a path in graph that visits every edge exactly once. Eulerian Circuit is an Eulerian Path which starts and ends on the same vertex. \n\nA graph is said to be eulerian if it has a eulerian cycle. We have discussed eulerian circuit for an undirected graph. In this post, the same is discussed for a directed graph.", "code": "# A Python3 program to check if a given\n# directed graph is Eulerian or not\n\nfrom collections import defaultdict\n\nclass Graph():\n\n        def __init__(self, vertices):\n                self.V = vertices\n                self.graph = defaultdict(list)\n                self.IN = [0] * vertices\n\n        def addEdge(self, v, u):\n\n                self.graph[v].append(u)\n                self.IN[u] += 1\n\n        def DFSUtil(self, v, visited):\n                visited[v] = True\n                for node in self.graph[v]:\n                        if visited[node] == False:\n                                self.DFSUtil(node, visited)\n\n        def getTranspose(self):\n                gr = Graph(self.V)\n\n                for node in range(self.V):\n                        for child in self.graph[node]:\n                                gr.addEdge(child, node)\n\n                return gr\n\n        def isSC(self):\n                visited = [False] * self.V\n\n                v = 0\n                for v in range(self.V):\n                        if len(self.graph[v]) > 0:\n                                break\n\n                self.DFSUtil(v, visited)\n\n                # If DFS traversal doesn't visit all\n                # vertices, then return false.\n                for i in range(self.V):\n                        if visited[i] == False:\n                                return False\n\n                gr = self.getTranspose()\n\n                visited = [False] * self.V\n                gr.DFSUtil(v, visited)\n\n                for i in range(self.V):\n                        if visited[i] == False:\n                                return False\n\n                return True\n\n        def isEulerianCycle(self):\n\n                # Check if all non-zero degree vertices\n                # are connected\n                if self.isSC() == False:\n                        return False\n\n                # Check if in degree and out degree of\n                # every vertex is same\n                for v in range(self.V):\n                        if len(self.graph[v]) != self.IN[v]:\n                                return False\n\n                return True\n\n\ng = Graph(5);\ng.addEdge(1, 0);\ng.addEdge(0, 2);\ng.addEdge(2, 1);\ng.addEdge(0, 3);\ng.addEdge(3, 4);\ng.addEdge(4, 0);\nif g.isEulerianCycle():\nprint( \"Given directed graph is eulerian\");\nelse:\nprint( \"Given directed graph is NOT eulerian\");\n\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "Scan the number of elements/strings and store it in a variable\r\nTake a new list say anslist\r\nTake a count and initialize it to 0\r\nUsing a for loop, accept the values into the list and put them into the list.\r\nThen use an if statement to check that the term that will be removed coincides with the element and the occurrence number.\r\nIf it matches then increment the count\r\nIf the count doesn\u2019t matches with the occurrence value then append it to anslist.\r\nPrint the anslist.", "code": "# Taking a empty list\r\nlistWords = []\r\n# Taking an empty list which gives the result say anslist\r\nanslist = []\r\n# taking a word count and initalize it to 0\r\nwordCount = 0\r\n# scanning the number of strings\r\nnumb = int(input(\"enter the total number of strings :\"))\r\n# Using for loop\r\nfor i in range(numb):\r\n    elem = input(\"enter some random string or word :\\n\")\r\n    listWords.append(elem)\r\n# given word\r\ngiven_word = input(\"Enter the word which you want to remove the ith occurrence\")\r\n# given occurrence number\r\noccur = int(\r\n    input(\"Enter which occurrence you wish to delete of the provided term\"))\r\n\r\n# printing the list before removing the ith occurrence of word\r\nprint(\"printing the list before removing the ith occurrence of word :\")\r\nprint(listWords)\r\n# Traversing the given listWords\r\nfor word in listWords:\r\n    # checking if the given word mathches with the word\r\n    if(word == given_word):\r\n        # increasing the count\r\n        wordCount = wordCount+1\r\n        # If the count doesn't matches with the occurrence value then append it to anslist.\r\n        if(wordCount != occur):\r\n            anslist.append(word)\r\n    else:\r\n        anslist.append(word)\r\n# printing the list before after the ith occurrence of word\r\nprint(\"printing the list after removing the ith occurrence of word :\")\r\nprint(anslist)"}
{"nl": "Given a binary tree with parent pointers, find the right sibling of a given node(pointer to the node will be given), if it doesn\u2019t exist return null. Do it in O(1) space and O(n) time?", "code": "# Python3 program to print right sibling\n# of a node\n\u00a0\n# A class to create a new Binary\n# Tree Node\nclass newNode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, item, parent):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.parent = parent\n\u00a0\n# Method to find right sibling\ndef findRightSibling(node, level):\n\u00a0\u00a0\u00a0\u00a0if (node == None or node.parent == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# GET Parent pointer whose right child is not\n\u00a0\u00a0\u00a0\u00a0# a parent or itself of this node. There might\n\u00a0\u00a0\u00a0\u00a0# be case when parent has no right child, but,\n\u00a0\u00a0\u00a0\u00a0# current node is left child of the parent\n\u00a0\u00a0\u00a0\u00a0# (second condition is for that).\n\u00a0\u00a0\u00a0\u00a0while (node.parent.right == node or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(node.parent.right == None and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.parent.left == node)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.parent == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.parent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0level -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Move to the required child, where\n\u00a0\u00a0\u00a0\u00a0# right sibling can be present\n\u00a0\u00a0\u00a0\u00a0node = node.parent.right\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# find right sibling in the given subtree\n\u00a0\u00a0\u00a0\u00a0# (from current node), when level will be 0\n\u00a0\u00a0\u00a0\u00a0while (level < 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Iterate through subtree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.left != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (node.right != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if no child are there, we cannot\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# have right sibling in this path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0level += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (level == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This is the case when we reach 9 node\n\u00a0\u00a0\u00a0\u00a0# in the tree, where we need to again\n\u00a0\u00a0\u00a0\u00a0# recursively find the right sibling\n\u00a0\u00a0\u00a0\u00a0return findRightSibling(node, level)\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = newNode(1, None)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2, root)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(3, root)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(4, root.left)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(6, root.left)\n\u00a0\u00a0\u00a0\u00a0root.left.left.left = newNode(7, root.left.left)\n\u00a0\u00a0\u00a0\u00a0root.left.left.left.left = newNode(10, root.left.left.left)\n\u00a0\u00a0\u00a0\u00a0root.left.right.right = newNode(9, root.left.right)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(5, root.right)\n\u00a0\u00a0\u00a0\u00a0root.right.right.right = newNode(8, root.right.right)\n\u00a0\u00a0\u00a0\u00a0root.right.right.right.right = newNode(12, root.right.right.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# passing 10\n\u00a0\u00a0\u00a0\u00a0res = findRightSibling(root.left.left.left.left, 0)\n\u00a0\u00a0\u00a0\u00a0if (res == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No right sibling\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(res.data)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "When a chord is drawn in a circle, it divides the circle into two parts. These two parts of the circle are known as circle segments. The smaller area is referred to as the Minor segment, while the larger area is referred to as the Major segment.\r\n\r\nGiven the radius of the circle and the angle that forms a minor segment, the task is to find the areas of both major and minor segments of a circle.\r\n\r\nFormula:\r\n\r\npi * r2 * (angle/360) \u2013 1/2 * r2 * Sin(angle)", "code": "# Import math module using the import keyword.\r\nimport math\r\n\r\n# Create a function to say BothSegments_area() which takes the given radius and angle\r\n# as the arguments, and returns the major and minor segments area.\r\n\r\n\r\ndef BothSegments_area(gven_radius, gven_angl):\r\n        # Inside the function, calculate the value area of the sector using the above\r\n        # given mathematical formula and store it in a variable.\r\n    rsltareaof_sectr = pi * (gven_radius * gven_radius) * (gven_angl / 360)\r\n\r\n    # Calculate the area of the triangle using the above given mathematical formula and\r\n    #  math.sin() function.\r\n    # store it in another variable.\r\n    rsltareaof_triangl = 1 / 2 * \\\r\n        (gven_radius * gven_radius) * math.sin((gven_angl * pi) / 180)\r\n\r\n    # Subtract the area of a triangle from the area of a sector and return it.\r\n    return rsltareaof_sectr - rsltareaof_triangl\r\n\r\n\r\n# Give the radius as static input and store it in a variable.\r\ngven_radius = 20\r\n# Give the angle as static input and store it in another variable.\r\ngven_angl = 60\r\n# Take a variable and initialize the pi value as 3.14159.\r\npi = 3.14159\r\n# Pass the given radius and angle as the arguments to the BothSegments_area()\r\n# function and print the area of the minor segment.\r\nprint(\"The minor segment area =\",\r\n      BothSegments_area(gven_radius, gven_angl))\r\n# Pass the given radius and 360-angle as the arguments to the BothSegments_area()\r\n# function and print the area of the major segment.\r\nprint(\"The major segment area =\",\r\n      BothSegments_area(gven_radius, (360 - gven_angl)))"}
{"nl": "Write a function that validates whether two strings are identical. Make it case insensitive.\r\n\r\nExamples\r\nmatch(\"hello\", \"hELLo\") \u279e True\r\n\r\nmatch(\"motive\", \"emotive\") \u279e False\r\n\r\nmatch(\"venom\", \"VENOM\") \u279e True\r\n\r\nmatch(\"mask\", \"mAskinG\") \u279e False", "code": "def match(s1, s2):\r\n  return s1.lower() == s2.lower()"}
{"nl": "This program prints ASCII table in Python programming language using while loop and built-in function chr().\r\n\r\nFunction chr() returns a Unicode string of one character.", "code": "digit = 0\r\n\r\nwhile digit<=255:\r\n    print(\"%d = %c\" %(digit, chr(digit)))\r\n    digit += 1"}
{"nl": "Given a binary tree root and a linked list with head as the first node. \n\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.\n\nIn this context downward path means a path that starts at some node and goes downwards.\n\n \n\nExample 1:\n\n\n\nInput: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.  \nExample 2:\n\n\n\nInput: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExample 3:\n\nInput: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head.\n \n\nConstraints:\n\nThe number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val <= 100 for each node in the linked list and binary tree.", "code": "class Solution(object):\n\n  def isSubPath(self, head, root):\n  A, dp = [head.val], [0]\n  i = 0\n  node = head.next\n  while node:\n  while i and node.val != A[i]:\n  i = dp[i - 1]\n  i += node.val == A[i]\n  A.append(node.val)\n  dp.append(i)\n  node = node.next\n\n  def dfs(root, i):\n  if not root: return False\n  while i and root.val != A[i]:\n  i = dp[i - 1]\n  i += root.val == A[i]\n  return i == len(dp) or dfs(root.left, i) or dfs(root.right, i)\n  return dfs(root, 0)"}
{"nl": "Feature Scaling or Standardization: It is a step of Data Pre Processing that is applied to independent variables or features of data. It basically helps to normalize the data within a particular range. Sometimes, it also helps in speeding up the calculations in an algorithm.", "code": "\r\nimport pandas as pd\r\nfrom sklearn.preprocessing import StandardScaler\r\n \r\n# Read Data from CSV\r\ndata = read_csv('Geeksforgeeks.csv')\r\ndata.head()\r\n \r\n# Initialise the Scaler\r\nscaler = StandardScaler()\r\n \r\n# To scale data\r\nscaler.fit(data)"}
{"nl": "Given an integer x, return true if x is palindrome integer.\n\nAn integer is a palindrome when it reads the same backward as forward.\n\nFor example, 121 is a palindrome while 123 is not.\n \n\nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n \n\nConstraints:\n\n-231 <= x <= 231 - 1", "code": "def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\n                return False\n        \n        result = 0\n        while x > result:\n                result = result * 10 + x % 10\n                x = x // 10\n                \n        return True if (x == result or x == result // 10) else False"}
{"nl": "A Narcissistic Number is a number that is the sum of its own digits each raised to the power of the number of digits.\nFor example, take 153 (3 digits), which is narcisstic:\n1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n1652 (4 digits), is non-narcisstic:\n1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938\nCreate a function which returns True or False depending upon whether the given number n is a Narcissistic number or not.\nExamples\nis_narcissistic(153) \u279e True\n\nis_narcissistic(370) \u279e True\n\nis_narcissistic(1652) \u279e False\nNotes\nN/A", "code": "def is_narcissistic(n):\n  return sum([int(i)**len(str(n)) for i in str(n)])==n"}
{"nl": "Instructions\nCalculate the Hamming Distance between two DNA strands.\n\nYour body is made up of cells that contain DNA. Those cells regularly wear out and need replacing, which they achieve by dividing into daughter cells. In fact, the average human body experiences about 10 quadrillion cell divisions in a lifetime!\n\nWhen cells divide, their DNA replicates too. Sometimes during this process mistakes happen and single pieces of DNA get encoded with the incorrect information. If we compare two strands of DNA and count the differences between them we can see how many mistakes occurred. This is known as the \"Hamming Distance\".\n\nWe read DNA using the letters C,A,G and T. Two strands might look like this:\n\nGAGCCTACTAACGGGAT\nCATCGTAATGACGGCCT\n^ ^ ^  ^ ^    ^^\nThey have 7 differences, and therefore the Hamming Distance is 7.\n\nThe Hamming Distance is useful for lots of things in science, not just biology, so it's a nice phrase to be familiar with :)\n\nImplementation notes\nThe Hamming distance is only defined for sequences of equal length, so an attempt to calculate it between sequences of different lengths should not work.\n\nException messages\nSometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.\n\nThis particular exercise requires that you use the raise statement to \"throw\" a ValueError when the strands being checked are not the same length. The tests will only pass if you both raise the exception and include a message with it.\n\nTo raise a ValueError with a message, write the message as an argument to the exception type:\n\n# When the sequences being passed are not the same length.\nraise ValueError(\"Strands must be of equal length.\")", "code": "def distance(strand_a, strand_b):\r\n    if len(strand_a) != len(strand_b):\r\n        raise ValueError('not of equal length')\r\n    errors = [a!=b for a,b in zip(strand_a, strand_b)]\r\n    return sum(errors)"}
{"nl": "Write a function that takes the number of seconds and returns the digital format clock time as a string. Time should be counted from 00:00:00.\nExamples\ndigital_clock(5025) \u279e \"01:23:45\"\n# 5025 seconds is 1 hour, 23 mins, 45 secs.\n\ndigital_clock(61201) \u279e \"17:00:01\"\n# No AM/PM. 24h format.\n\ndigital_clock(87000) \u279e \"00:10:00\"\n# It's 00:10 next day.\nNotes\nseconds is always greater than or equal to 0.", "code": "def digital_clock(s):\n  return \"{:02d}:{:02d}:{:02d}\".format(s//60//60%24, s//60%60, s%60)"}
{"nl": "In this post, we will write the programs for hexadecimal to decimal conversion in Python language. We will be given a hexadecimal number and the python program to convert the given hexadecimal number into an equivalent decimal number.", "code": "# Python program to convert hexadecimal to decimal def HexDecimal(num): #user-defined function ch = dec = i = 0 length = len(num) - 1 while length >= 0: if num[length]>='0' and num[length]<='9': temp = int(num[length]) elif num[length]>='A' and num[length]<='F': temp = ord(num[length]) - 55 elif num[length]>='a' and num[length]<='f': temp = ord(num[length]) - 87 else: ch = 1 break dec = dec + (temp * (16 ** i)) length = length - 1 i = i+1 return dec # take inputs num = input('Enter hexadecimal number: ') # calling function and display result print('The decimal value is =', HexDecimal(num))"}
{"nl": "We will develop a program to print shapes of triangles using stars.", "code": "# Python star pattern to print left half pyramid  def pattern(n): for i in range(1, n+1): # print star print(\"* \" * i) # take input n = int(input('Enter number of row: ')) # function call pattern(n)"}
{"nl": "To create a date, we can use the datetime() class (constructor) of the datetime module.\r\n\r\nThe datetime() class requires three parameters to create a date: year, month, day.", "code": "import datetime\r\n\r\nx = datetime.datetime(2020, 5, 17)\r\n\r\nprint(x)"}
{"nl": "Rearrange the given Number to form the Smallest Number (User Input)", "code": "# Give the number as user input using int(input()) and store it in a variable.\r\nnumb = int(input('Enter some random number = '))\r\n# Convert the given number to a string and sort it.\r\nstrnumb = str(numb)\r\nstrnumb = sorted(strnumb)\r\n# After sorting join it using the join() function.\r\nsortednumb = ''.join(strnumb)\r\n# Count the number of 0's present in this number\r\n# using the count() function and store it in a variable say m.\r\nm = sortednumb.count('0')\r\n# Convert the given number to a list of digits using the list() function.\r\nnumbdigi = list(sortednumb)\r\n# Swap the first index digit and mth index digit in the list using ',' operator.\r\nnumbdigi[0], numbdigi[m] = numbdigi[m], numbdigi[0]\r\n# Join the list into the string using the join() function.\r\nfinalres = ''.join(numbdigi)\r\n# Print the result\r\nprint('The smallest number that can be formed from',\r\n      numb, 'is [', finalres, ']')"}
{"nl": "Find Armstrong Number in an Interval (User input)", "code": "# Give the lower limit range as user input and store it in a variable.\r\ngvn_lower_lmt = int(input(\"Enter some Random number = \"))\r\n# Give the upper limit range as user input and store it in another variable.\r\ngvn_upper_lmt = int(input(\"Enter some Random number = \"))\r\n# Loop from lower limit range to upper limit range using For loop.\r\nprint(\"The Armstrong numbers in the given range: \")\r\nfor numbr in range(gvn_lower_lmt, gvn_upper_lmt + 1):\r\n\r\n    # Inside the for loop take a variable say 'num' and initialize it's value to\r\n    # iterator value .\r\n    # Count how many digits there are in the number.\r\n    no_digits = len(str(numbr))\r\n\r\n # intialize result to zero(tot_sum)\r\n    tot_sum = 0\r\n  # copy the number in another variable(duplicate)\r\n    tempry = numbr\r\n    while tempry > 0:\r\n      # getting the last digit\r\n        rem = tempry % 10\r\n       # multiply the result by a digit raised to the power of the number of digits\r\n        tot_sum += rem ** no_digits\r\n        tempry //= 10\r\n   # It is Armstrong number if it is equal to original number\r\n    if numbr == tot_sum:\r\n        print(numbr)"}
{"nl": "In the previous article, we have discussed Python Program to Find Sum of Series 5^2+10^2+15^2+\u2026..N^2\n Given a number N and the task is to find the sum of series (1/2!+2/3!+3/5!+\u2026..N/(N+1)!) till the given number N in Python.\n Examples:\n Example1:\n Input:\n Given Number (Limit) = 6\n Output:\n The above series sum till the given number N{ 6 } = 0.9998015873015872\n Example2:\n Input:\n Given Number (Limit) = 13\n Output:\n The above series sum till the given number N{ 13 } = 0.9999999999885293", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the number N(limit) as static input and store it in a variable.\n \n gvn_numb = 6\n \n # Take a variable to say itr and initialize its value to 1.\n \n itr = 1\n \n # Take a variable to say rsltseries_summ and initialize its value to 0.0\n \n # (Floating point number)\n \n rsltseries_summ = 0.0\n \n # Loop until the above-declared variable itr value is less than or equal to the\n \n # given number using the while loop.\n \n while(itr &lt;= gvn_numb):\n \n  # Calculate the factorial of itr+1 using the math.factorial() method and\n \n  # store it in another variable.\n \n  factrl = math.factorial(itr+1)\n \n  # Calculate the value of itr divided by the above result factorial and convert it\n \n  # into float using the float() function.\n \n  # Store it in another variable.\n \n  p = float(itr/factrl)\n \n  # Add the above result to the rsltseries_summ and store it in the same variable.\n \n  rsltseries_summ += p\n \n  # Increment the above itr value by 1.\n \n  itr += 1\n \n # Print the sum of series till the given number N.\n \n print(\n \n  \"The above series sum till the given number N{\", gvn_numb, \"} = \", rsltseries_summ)\n \n </pre>"}
{"nl": "You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original.\n\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\n\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.", "code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        if len(original) != m*n:\n            return []\n\n        result = []\n        for i in range(m):\n            result.append([float('inf')]*n)\n            for j in range(n):\n                result[i][j] = original[i*n+j]\n        return result"}
{"nl": "Given the sides of a parallelogram, the task is to calculate the circumference of a parallelogram for the given sides in python.\r\n\r\nCircumference of Parallelogram:\r\n\r\nA parallelogram\u2019s opposite sides are equal in length and parallel. Angles are equal when paired, but not always at 90 degrees. The circumference of a parallelogram can be calculated by multiplying the sum of two adjacent sides by two.\r\n\r\nFormula:\r\n\r\nThe circumference of parallelogram = (2*a)+(2*b)\r\n\r\nwhere a, b are the sides of a parallelogram\r\n\r\nPython round() function:\r\n\r\nThe round() function returns a floating-point number with the specified number of decimals that is a rounded version of the specified number.", "code": "# Create a function to say parallelogram_circumference() which takes the given two\r\n# sides as the argument and returns the circumference of the given parallelogram.\r\n\r\n\r\ndef parallelogram_circumference(fst_side, scnd_side):\r\n    # Inside the function, calculate the circumference of the parallelogram using the\r\n        # above given mathematical formula and store it in another variable.\r\n    paralgrm_circum = (2 * fst_side) + (2 * scnd_side)\r\n    # Return the above result.\r\n    return paralgrm_circum\r\n\r\n\r\n# Give the first side as static input and store it in a variable.\r\nfst_side = 5\r\n# Give the second side as static input and store it in another variable.\r\nscnd_side = 6\r\n# Pass the given two sides as the arguments to the parallelogram_circumference() function\r\n# and round it off to up to 3 places after the decimal point using the round() function.\r\n# Store it in another variable.\r\ncircumfrnce = round(parallelogram_circumference(fst_side, scnd_side), 3)\r\n# Print the above result which gives the circumference of the parallelogram for\r\n# the given sides.\r\nprint(\r\n    \"The Circumference of a parallelogram for the given two sides{\", fst_side, \",\", scnd_side, \"} = \", circumfrnce)"}
{"nl": "The in keyword has two purposes:\r\n\r\nThe in keyword is used to check if a value is present in a sequence (list, range, string etc.).\r\n\r\nThe in keyword is also used to iterate through a sequence in a for loop:", "code": "fruits = [\"apple\", \"banana\", \"cherry\"]\r\n\r\nif \"banana\" in fruits:\r\n  print(\"yes\")"}
{"nl": "Create a function that converts two lists of x- and y- coordinates into a list of (x, y) coordinates.\nExamples\nconvert_cartesian([1, 5, 3, 3, 4], [5, 8, 9, 1, 0]) \n\u279e [[1, 5], [5, 8], [3, 9], [3, 1], [4, 0]]\n\nconvert_cartesian([9, 8, 3], [1, 1, 1]) \n\u279e [[9, 1], [8, 1], [3, 1]]\nNotes\nEach coordinate is a list, not a tuple.\nx and y arrays will always be the same length.", "code": "def convert_cartesian(x, y): \n  return list(map(list, zip(x, y)))"}
{"nl": "The try block lets you test a block of code for errors.\r\n\r\nThe except block lets you handle the error.\r\n\r\nThe finally block lets you execute code, regardless of the result of the try- and except blocks.\r\n\r\nException Handling\r\nWhen an error occurs, or exception as we call it, Python will normally stop and generate an error message.\r\n\r\nThese exceptions can be handled using the try statement:", "code": "try:\r\n  print(x)\r\nexcept:\r\n  print(\"An exception occurred\")"}
{"nl": "Write a program to add one to a given number. The use of operators like \u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018/\u2019, \u2018++\u2019, \u2018\u2013\u2018 \u2026etc are not allowed. ", "code": "# Python3 code to add 1\n# one to a given number\ndef addOne(x) :\n\t\n\tm = 1;\n\t# Flip all the set bits\n\t# until we find a 0\n\twhile(x & m):\n\t\tx = x ^ m\n\t\tm <<= 1\n\t\n\t# flip the rightmost\n\t# 0 bit\n\tx = x ^ m\n\treturn x\n\n# Driver program\nn = 13\nprint addOne(n)\n\n# This code is contributed by Prerna Saini.\n"}
{"nl": "The if keyword is used to create conditional statements (if statements), and allows you to execute a block of code only if a condition is True.\r\n\r\nUse the else keyword to execute code if the condition is False, see example below.", "code": "x = 5\r\nif x > 3:\r\n  print(\"YES\")"}
{"nl": "Files in Python:\n\nPython file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python\u2019s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.\n\nGiven a file, the task is to write 1 to 100 numbers into a given file in Python.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\nwith open(givenFilename, 'w') as givenfilecontent:\n  # Iterate from 1 to 100 using the for loop\n  for itr in range(1,101):\n  # Convert the iterator value into a string using the str() function and write it into\n  # the file using the write() function\n  givenfilecontent.write(str(itr) + \"\\t\")"}
{"nl": "Create a function that takes a list of integers that represent the amount in dollars that a single stock is worth, and return the maximum profit that could have been made by buying stock on day x and selling stock on day y where y>x.\nIf given the following list:\n[44, 30, 24, 32, 35, 30, 40, 38, 15]\n... your program should return 16 because at index 2 the stock was worth $24 and at the index 6 the stock was then worth $40, so if you bought the stock at 24 and sold it on 40, you would have made a profit of $16, which is the maximum profit that could have been made with this list of stock prices.\nIf there is no profit that could have been made with the stock prices, then your program should return -1 (e.g. [[10, 9, 8, 2]] should return -1).\nExamples\nstock_picker([10, 12, 4, 5, 9]) \u279e 5\n\nstock_picker([14, 20, 4, 12, 5, 11]) \u279e 8\n\nstock_picker([80, 60, 10, 8]) \u279e -1\nNotes\nN/A", "code": "def stock_picker(lst):\n  return max([max(lst[i+1::])-lst[i] for i in range(len(lst)-1)]+[-1])"}
{"nl": "Print Numbers, that contain 1, 2 and 3, in Ascending Order (User Input)", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\ngven_lst = list(map(int, input(\r\n   'Enter some random List Elements separated by spaces = ').split()))\r\n# Take a new empty list say \"numb\" and store it in another variable.\r\nnumb = []\r\n# Loop in the given list using the for loop.\r\nfor itr in gven_lst:\r\n # Inside the loop, convert the iterator value to the string using the str() function\r\n    # and store it in another variable.\r\n    strng_number = str(itr)\r\n# Check if 1 and 2 and 3 are present in the string number using the if conditional\r\n# statement and 'and' keyword.\r\n    if '1' in strng_number and '2' in strng_number and '3' in strng_number:\r\n        # If the statement is true, then append the iterator value to the above initialized\r\n        # new empty list \"numb\".\r\n        numb.append(itr)\r\n # Sort the above list \"numb\" using the sort() function.\r\nnumb.sort()\r\n# print the list \"numb\" to print the numbers with the digits 1, 2, and 3 in ascending order,\r\n# which is separated by commas.\r\nprint(\"The numbers with the digits 1, 2, and 3 in ascending order, which is separated by commas= \", numb)"}
{"nl": "In this program, we have an array of elements to count the occurrence of its each element. One of the approaches to resolve this problem is to maintain one array to store the counts of each element of the array. Loop through the array and count the occurrence of each element as frequency and store it in another array fr.\n\n1    2   8  3   2   2   2   5   1  ", "code": "#Initialize array     \narr = [1, 2, 8, 3, 2, 2, 2, 5, 1];     \n#Array fr will store frequencies of element    \nfr = [None] * len(arr);    \nvisited = -1;    \n     \nfor i in range(0, len(arr)):    \n    count = 1;    \n    for j in range(i+1, len(arr)):    \n        if(arr[i] == arr[j]):    \n            count = count + 1;    \n            #To avoid counting same element again    \n            fr[j] = visited;    \n                \n    if(fr[i] != visited):    \n        fr[i] = count;    \n     \n#Displays the frequency of each element present in array    \nprint(\"---------------------\");    \nprint(\" Element | Frequency\");    \nprint(\"---------------------\");    \nfor i in range(0, len(fr)):    \n    if(fr[i] != visited):    \n        print(\"    \" + str(arr[i]) + \"    |    \" + str(fr[i]));    \nprint(\"---------------------\");    "}
{"nl": "Pandas Period.strftime() Function:\r\n\r\nDepending on the chosen format, Period.strftime() Function of the pandas module returns a string representation of the Period. The format must be a string that contains one or more directives.\r\n\r\nThe method supports the same directives as the standard Python distribution\u2019s time.strftime() function, as well as the particular additional directives %f, %F, %q (formatting and documentation(docs) adapted from scikits.timeries)\r\n\r\nSyntax:", "code": "# Import pandas module using the import keyword.\r\nimport pandas as pd\r\n# Pass some random frequency(here S= secondly frequency), year, month, day,\r\n# hour, minute, second as the arguments to the Period() function\r\n# of the pandas module to get the Period object\r\nperiod_obj = pd.Period(freq ='S', year = 2015, month = 5, day = 16,\r\n                         hour = 12, minute = 28, second = 10)\r\n  \r\n# Print the given period object\r\nprint(\"The given period object:\")\r\nprint(period_obj)\r\nprint()\r\n# Pass some random format as an argument to the strftime() function\r\n# to get a string representation of the given Period object in the given format.\r\n# Here, %b - month name, %d - day of the month, %Y - year, %A - weekday\r\nprint(\"The Period object in the given format:\")\r\nperiod_obj.strftime('%b. %d, %Y was a %A')"}
{"nl": "Create a program that converts a phone number with letters to one with only numbers.\nNumber Letter\n0 none\n1 none\n2 ABC\n3 DEF\n4 GHI\n5 JKL\n6 MNO\n7 PQRS\n8 TUV\n9 WXYZ\nExamples\ntext_to_num(\"123-647-EYES\") \u279e \"123-647-3937\"\n\ntext_to_num(\"(325)444-TEST\") \u279e \"(325)444-8378\"\n\ntext_to_num(\"653-TRY-THIS\") \u279e \"653-879-8447\"\n\ntext_to_num(\"435-224-7613\") \u279e \"435-224-7613\"\nNotes\nAll inputs will be formatted as a string representing a proper phone number in the format XXX-XXX-XXXX or (XXX)XXX-XXXX, using numbers and capital letters.\nCheck the Resources tab for more info on telephone keypads.", "code": "def text_to_num(phone):\n  alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  num = \"22233344455566677778889999\"\n  dic = dict(zip(alpha,num))\n  return \"\".join([dic[i] if i.isalpha() else i for i in phone])"}
{"nl": "Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL). The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be the same as in Inorder for the given Binary Tree. The first node of Inorder traversal (leftmost node in BT) must be the head node of the DLL.  ", "code": "# A simple inorder traversal based program to convert a\n# Binary Tree to DLL\n\n# A Binary Tree node\nclass Node:\n\t\n\t# Constructor to create a new tree node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Standard Inorder traversal of tree\ndef inorder(root):\n\t\n\tif root is not None:\n\t\tinorder(root.left)\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\tinorder(root.right)\n\n# Changes left pointers to work as previous pointers\n# in converted DLL\n# The function simply does inorder traversal of\n# Binary Tree and updates\n# left pointer using previously visited node\ndef fixPrevPtr(root):\n\tif root is not None:\n\t\tfixPrevPtr(root.left)\n\t\troot.left = fixPrevPtr.pre\n\t\tfixPrevPtr.pre = root\n\t\tfixPrevPtr(root.right)\n\n# Changes right pointers to work as next pointers in\n# converted DLL\ndef fixNextPtr(root):\n\n\tprev = None\n\t# Find the right most node in BT or last node in DLL\n\twhile(root and root.right != None):\n\t\troot = root.right\n\n\t# Start from the rightmost node, traverse back using\n\t# left pointers\n\t# While traversing, change right pointer of nodes\n\twhile(root and root.left != None):\n\t\tprev = root\n\t\troot = root.left\n\t\troot.right = prev\n\n\t# The leftmost node is head of linked list, return it\n\treturn root\n\n# The main function that converts BST to DLL and returns\n# head of DLL\ndef BTToDLL(root):\n\t\n\t# Set the previous pointer\n\tfixPrevPtr(root)\n\n\t# Set the next pointer and return head of DLL\n\treturn fixNextPtr(root)\n\n# Traversses the DLL from left to right\ndef printList(root):\n\twhile(root != None):\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\troot = root.right\n\n# Driver program to test above function\nroot = Node(10)\nroot.left = Node(12)\nroot.right = Node(15)\nroot.left.left = Node(25)\nroot.left.right = Node(30)\nroot.right.left = Node(36)\n\nprint (\"Inorder Tree Traversal\")\ninorder(root)\n\n# Static variable pre for function fixPrevPtr\nfixPrevPtr.pre = None\nhead = BTToDLL(root)\n\nprint (\"\\nDLL Traversal\")\nprintList(head)\n\t\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Tuple in Python:\n\nA tuple is an immutable list of objects. That means the elements of a tuple cannot be modified or changed while the program is running.\n\nsplit() function:\n\nSyntax: input string.split(seperator=None, maxsplit=-1)\n\nIt delimits the string with the separator and returns a list of words from it. The maxsplit parameter specifies the maximum number of splits that can be performed. If it is -1 or not specified, all possible splits are performed.\n\n\n\nExample:  Given string =  \u2018hello btechgeeks goodmorning\u2019.split()\n\nOutput : [\u2018hello\u2019, \u2018btechgeeks\u2019, \u2018goodmorning\u2019 ]\n\nGiven a string and the task is to find a tuple with a comma-separated string.\n\nExamples:\n\nExample 1:\n\nInput: \n\nGiven String = 'good, morning, btechgeeks'  (static input)\nOutput:\n\nGiven input String =  good, morning, btechgeeks\nA tuple with comma-separated string is :  ('good', ' morning', ' btechgeeks')\nExample 2:\n\nInput:\n\nGiven String = hello, btechgeeks, 123  (user input)\nOutput:\n\nA tuple with comma-separated string is : ('hello', ' btechgeeks', ' 123')", "code": "# Give the string as static input and store it in a variable.\ngvn_str = 'good, morning, btechgeeks'\n# Print the above-given input string.\nprint(\"Given input String = \", gvn_str)\n# Split the given input string separated by commas using the split() function\n# and convert it into a tuple.\n# Store it in another variable.\ntupl = tuple(gvn_str.split(\",\"))\n# Print the tuple with a comma-separated string.\nprint(\"A tuple with comma-separated string is : \", tupl)"}
{"nl": "Create a function that takes in two lists and returns True if the second list follows the first list by one element, and False otherwise. In other words, determine if the second list is the first list shifted to the right by 1.\nExamples\nsimon_says([1, 2], [5, 1]) \u279e True\n\nsimon_says([1, 2], [5, 5]) \u279e False\n\nsimon_says([1, 2, 3, 4, 5], [0, 1, 2, 3, 4]) \u279e True\n\nsimon_says([1, 2, 3, 4, 5], [5, 5, 1, 2, 3]) \u279e False\nNotes\nBoth input lists will be of the same length, and will have a minimum length of 2.\nThe values of the 0-indexed element in the second list and the n-1th indexed element in the first list do not matter.", "code": "def simon_says(lst1, lst2):\n  return lst1[:-1] == lst2[1:]"}
{"nl": "Given three integer arrays and a \u201csum\u201d, the task is to check if there are three elements a, b, c such that a + b + c = sum and a, b and c belong to three different arrays. \n\nExamples : \n\nInput : a1[] = { 1 , 2 , 3 , 4 , 5 };\n    a2[] = { 2 , 3 , 6 , 1 , 2 };\n    a3[] = { 3 , 2 , 4 , 5 , 6 };  \n        sum = 9\nOutput : Yes\n1  + 2  + 6 = 9  here 1 from a1[] and 2 from\na2[] and 6 from a3[]   ", "code": "# Python3 program to find three element\n# from different three arrays such\n# that a + b + c is equal to\n# given sum\n\n# Function to check if there is\n# an element from each array such\n# that sum of the three elements is\n# equal to given sum.\ndef findTriplet(a1, a2, a3,\n                                n1, n2, n3, sum):\n\n        # Store elements of first\n        # array in hash\n        s = set()\n\n        # sum last two arrays element\n        # one by one\n        for i in range(n1):\n                s.add(a1[i])\n\n        for i in range(n2):\n                for j in range(n3):\n\n                        # Consider current pair and\n                        # find if there is an element\n                        # in a1[] such that these three\n                        # form a required triplet\n                        if sum - a2[i] - a3[j] in s:\n                                return True\n        return False\n\n# Driver code\na1 = [1, 2, 3, 4, 5]\na2 = [2, 3, 6, 1, 2]\na3 = [3, 24, 5, 6]\nn1 = len(a1)\nn2 = len(a2)\nn3 = len(a3)\nsum = 9\nif findTriplet(a1, a2, a3,\n                        n1, n2, n3, sum) == True:\n        print(\"Yes\")\nelse:\n        print(\"No\")\n\n# This code is contributed by Shrikant13\n"}
{"nl": "Given two strings, the task is to find the common characters between Two Strings.", "code": "# Give the first string as User input  using the input() function , convert the given string into lower case\n# using built-in lower() method and store it in a variable.\nfst_strng = input(\"Enter some Random String = \").lower()\n# Give the  second string as User input  using the input() function, convert the given string into lower case\n# using built-in lower() method and store it in another variable.\nsecnd_strng = input(\"Enter some Random String = \").lower()\n# Get the Common characters between both the above given strings using built-in\n# intersection() method which is a set method.\n# Sort the above given string using  built-in sorted() method.\n# Join the the above given string using built-in join()method .\n# Print all the Common Characters between the above given two Strings.\nprint(\"The Common Characters between the above given two Strings = \",\n      ''.join(sorted(set.intersection(set(fst_strng), set(secnd_strng)))))"}
{"nl": "Given a Binary Search Tree and two keys in it. Find the distance between two nodes with given two keys. It may be assumed that both keys exist in BST.", "code": "# Python3 program to find distance between\n# two nodes in BST\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Standard BST insert function\ndef insert(root, key):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = newNode(key)\n\u00a0\u00a0\u00a0\u00a0else if root.key > key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, key)\n\u00a0\u00a0\u00a0\u00a0else if root.key < key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, key)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# This function returns distance of x from\n# root. This function assumes that x exists\n# in BST and BST is not NULL.\ndef distanceFromRoot(root, x):\n\u00a0\u00a0\u00a0\u00a0if root.key == x:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0else if root.key > x:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1 + distanceFromRoot(root.left, x)\n\u00a0\u00a0\u00a0\u00a0return 1 + distanceFromRoot(root.right, x)\n\u00a0\n# Returns minimum distance between a and b.\n# This function assumes that a and b exist\n# in BST.\ndef distanceBetween2(root, a, b):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Both keys lie in left\n\u00a0\u00a0\u00a0\u00a0if root.key > a and root.key > b:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return distanceBetween2(root.left, a, b)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Both keys lie in right\n\u00a0\u00a0\u00a0\u00a0if root.key < a and root.key < b: # same path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return distanceBetween2(root.right, a, b)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Lie in opposite directions\n\u00a0\u00a0\u00a0\u00a0# (Root is LCA of two nodes)\n\u00a0\u00a0\u00a0\u00a0if root.key >= a and root.key <= b:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (distanceFromRoot(root, a) +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distanceFromRoot(root, b))\n\u00a0\n# This function make sure that a is smaller\n# than b before making a call to findDistWrapper()\ndef findDistWrapper(root, a, b):\n\u00a0\u00a0\u00a0\u00a0if a > b:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a, b = b, a\n\u00a0\u00a0\u00a0\u00a0return distanceBetween2(root, a, b)\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0insert(root, 5)\n\u00a0\u00a0\u00a0\u00a0insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0insert(root, 30)\n\u00a0\u00a0\u00a0\u00a0insert(root, 25)\n\u00a0\u00a0\u00a0\u00a0insert(root, 35)\n\u00a0\u00a0\u00a0\u00a0a, b = 5, 55\n\u00a0\u00a0\u00a0\u00a0print(findDistWrapper(root, 5, 35))\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Given an expression string exp, write a program to examine whether the pairs and the orders of \u201c{\u201c, \u201c}\u201d, \u201c(\u201c, \u201c)\u201d, \u201c[\u201c, \u201c]\u201d are correct in exp.", "code": "# Python3 program to check for\n# balanced brackets.\n\u00a0\n# function to check if\n# brackets are balanced\n\u00a0\n\u00a0\ndef areBracketsBalanced(expr):\n\u00a0\u00a0\u00a0\u00a0stack = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing the Expression\n\u00a0\u00a0\u00a0\u00a0for char in expr:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char in [\"(\", \"{\", \"[\"]:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push the element in the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(char)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# IF current character is not opening\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# bracket, then it must be closing.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# So stack cannot be empty at this point.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_char = stack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current_char == '(':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char != \")\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current_char == '{':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char != \"}\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current_char == '[':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char != \"]\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Check Empty Stack\n\u00a0\u00a0\u00a0\u00a0if stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0expr = \"{()}[]\"\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call\n\u00a0\u00a0\u00a0\u00a0if areBracketsBalanced(expr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Balanced\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Not Balanced\")\n\u00a0\n# This code is contributed by AnkitRai01 and improved\n# by Raju Pitta\n"}
{"nl": "You are given a 0-indexed array of n integers arr.\n\nThe interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.\n\nReturn an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].\n\nNote: |x| is the absolute value of x.\n\n ", "code": "class Solution:\n    def getDistances(self, arr: List[int]) -> List[int]:\n        \n        def helper(nums):\n            n = len(nums)\n            res = [0]*n\n            d = {}\n            for i, num in enumerate(nums):\n                if num not in d:\n                    d[num] = [i, 1]\n                else:\n                    prev_index, cnt = d[num]\n                    res[i] = res[prev_index] + (i - prev_index)*cnt\n                    d[num] = [i, cnt+1]\n            return res\n        \n        left = helper(arr)\n        right = helper(arr[::-1])[::-1]\n        return [x+y for x,y in zip(left, right)]"}
{"nl": "Given an array arr[] of n integers, construct a Product Array prod[] (of same size) such that prod[i] is equal to the product of all the elements of arr[] except arr[i]. Solve it without division operator in O(n) time.\n\nStore the product of all the elements is a variable and then iterate the array and add product/current_index_value in a new array. and then return this new array.", "code": "# Python3 program for the above approach\r\ndef productExceptSelf(a, n):\r\n\t\r\n\tprod = 1\r\n\tflag = 0\r\n\t\r\n\tfor i in range(n):\r\n\t\t\r\n\t\t# Counting number of elements\r\n\t\t# which have value\r\n\t\t# 0\r\n\t\tif (a[i] == 0):\r\n\t\t\tflag += 1\r\n\t\telse:\r\n\t\t\tprod *= a[i]\r\n\t\r\n\t# Creating a new array of size n\r\n\tarr = [0 for i in range(n)]\r\n\t\r\n\tfor i in range(n):\r\n\t\t\r\n\t\t# If number of elements in\r\n\t\t# array with value 0\r\n\t\t# is more than 1 than each\r\n\t\t# value in new array\r\n\t\t# will be equal to 0\r\n\t\tif (flag > 1):\r\n\t\t\tarr[i] = 0\r\n\t\t\r\n\t\t# If no element having value\r\n\t\t# 0 than we will\r\n\t\t# insert product/a[i] in new array\r\n\t\telif (flag == 0):\r\n\t\t\tarr[i] = (prod // a[i])\r\n\t\t\r\n\t\t# If 1 element of array having\r\n\t\t# value 0 than all\r\n\t\t# the elements except that index\r\n\t\t# value , will be\r\n\t\t# equal to 0\r\n\t\telif (flag == 1 and a[i] != 0):\r\n\t\t\tarr[i] = 0\r\n\t\t\r\n\t\t# If(flag == 1 && a[i] == 0)\r\n\t\telse:\r\n\t\t\tarr[i] = prod\r\n\t\t\t\r\n\treturn arr\r\n\r\n# Driver Code\r\nn = 5\r\narray = [ 10, 3, 5, 6, 2 ]\r\nans = productExceptSelf(array, n)\r\n\r\nprint(*ans)\r\n\r\n# This code is contributed by rag2127\r"}
{"nl": "Here, we will discuss all possible methods to write a python program to calculate the area of the circle. The radius of the circle will be given and the python program will calculate the area of the circle using various methods.", "code": "# python program to find area of circle # take inputs r = 10 # calculate area of circle area = 3.14 * r * r # display result print('Area of circle = ',area)"}
{"nl": "Given a Directed Acyclic Graph of n nodes (numbered from 1 to n) and m edges. The task is to find the number of sink nodes. A sink node is a node such that no edge emerges out of it.\n\nExamples: \n\nInput : n = 4, m = 2\n        Edges[] = {{2, 3}, {4, 3}} \nOutput : 2", "code": "# Python3 program to count number if sink nodes\n\u00a0\u00a0\n# Return the number of Sink NOdes.\u00a0\ndef countSink(n, m, edgeFrom, edgeTo):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Array for marking the non-sink node.\u00a0\n\u00a0\u00a0\u00a0\u00a0mark = [0] * (n + 1)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Marking the non-sink node.\n\u00a0\u00a0\u00a0\u00a0for i in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mark[edgeFrom[i]] = 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Counting the sink nodes.\u00a0\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(1, n + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not mark[i]):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count += 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0n = 4\n\u00a0\u00a0\u00a0\u00a0m = 2\n\u00a0\u00a0\u00a0\u00a0edgeFrom = [2, 4]\u00a0\n\u00a0\u00a0\u00a0\u00a0edgeTo = [3, 3]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(countSink(n, m, edgeFrom, edgeTo))\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "There is a programming language with only four operations and one variable X:\n\n++X and X++ increments the value of the variable X by 1.\n--X and X-- decrements the value of the variable X by 1.\nInitially, the value of X is 0.\n\nGiven an array of strings operations containing a list of operations, return the final value of X after performing all the operations.\n\n ", "code": "class Solution:\n    def finalValueAfterOperations(self, operations: List[str]) -> int:\n        ans = 0\n        for operation in operations:\n            ans = ans + 1 if operation in [\"++X\",\"X++\"] else ans-1\n        return ans"}
{"nl": "There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard.\n\nWhen making a move for a piece, you choose a destination square that the piece will travel toward and stop on.\n\nA rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).\nA queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\nA bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\nYou must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.\n\nReturn the number of valid move combinations\u200b\u200b\u200b\u200b\u200b.\n\nNotes:\n\nNo two pieces will start in the same square.\nYou may choose the square a piece is already on as its destination.\nIf two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.", "code": "def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\n        n = len(pieces)\n        rook_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n        bishop_dirs = [(1, 1), (-1, 1), (-1, -1), (1, -1)]\n        \n        dir_map = {\n            'rook': rook_dirs + [(0, 0)],\n            'bishop': bishop_dirs + [(0, 0)],\n            'queen': rook_dirs + bishop_dirs + [(0, 0)]\n        }\n        \n        # count num of moves can be made given positions and directions\n        def count_moves(positions, directions):\n            # if all pieces reached destination, there's no more moves\n            if all(direction == (0, 0) for direction in directions):\n                return 0\n            \n            # do the move\n            new_positions = [(i + di, j + dj) \n                             for (i, j), (di, dj) in zip(positions, directions)\n                             if 1 <= i + di <= 8 and 1 <= j + dj <= 8]\n            \n            # if any pieces hit the wall, or they are in the same position\n            if len(set(new_positions)) != n:\n                return 0\n            \n            # found 1 valid move\n            n_moves = 1\n            \n            # get all the possible directions, recursively call to count moves\n            for new_direction in get_directions(directions, 0, []):\n                n_moves += count_moves(new_positions, new_direction)\n            return n_moves\n        \n        # backtrack to get all possible directions combination given last directions\n        def get_directions(dirs, curr_idx, stack):\n            if len(stack) == n:\n                yield stack\n                return\n            for i in range(curr_idx, n):\n                stack.append(dirs[i])\n                for d in get_directions(dirs, i + 1, stack):\n                    yield d\n                stack.pop()\n                if any(dirs[i]):\n                    stack.append((0, 0))\n                    for d in get_directions(dirs, i + 1, stack):\n                        yield d\n                    stack.pop()\n        \n        # backtrack to get all initial directions, call count_moves() when the stack is full \n        def init_directions_and_count(stack):\n            n_moves = 0\n            if len(stack) == n:\n                n_moves += count_moves(positions, stack)\n            else:            \n                piece_to_add = pieces[len(stack)]            \n                for direction in dir_map[piece_to_add]:\n                    stack.append(direction)\n                    n_moves += init_directions_and_count(stack)\n                    stack.pop()\n            return n_moves\n        \n        # plus one for all pieces stays at initial locations\n        return init_directions_and_count([]) + 1"}
{"nl": "Given an array, count pairs in the array such that one element of the pair divides the other.\nExamples: \n \n\nInput  : arr[] = {1, 2, 3}\nOutput : 2\nThe two pairs are (1, 2) and (1, 3)\n\nInput : arr[] = {2, 3, 5, 7}\nOutput: 0", "code": "# Python3 program to count\n# divisible pairs.\n\ndef countDivisibles(arr, n) :\n\n        res = 0\n\n        # Iterate through all pairs\n        for i in range(0, n) :\n                for j in range(i+1, n) :\n                        \n                        # Increment count if one divides\n                        # other\n                        if (arr[i] % arr[j] == 0 or\n                        arr[j] % arr[i] == 0) :\n                                res+=1\n\n        return res\n\n# Driver code\nif __name__=='__main__':\n        a = [1, 2, 3, 9]\n        n = len(a)\n        print(countDivisibles(a, n) )\n\n# this code is contributed by\n# Smitha Dinesh Semwal\n"}
{"nl": "Static Input: Using List Comprehension to Create List of Tuples", "code": "# given lower limit range as static input\r\nlowerlimit = 5\r\n# given upper limit range as static input\r\nupperlimit = 13\r\n# Using list comprehension, generate a list of tuples with the first element being the number within\r\n# the range and the second element being the square of the number.\r\nlistOfTuples = [(k, k**2) for k in range(lowerlimit, upperlimit+1)]\r\n# printing the list of tuples\r\nprint('The list of Tuples are : ', listOfTuples)"}
{"nl": "Given a value N, if we want to make change for N cents, and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins, how many ways can we make the change? The order of coins doesn\u2019t matter.\nFor example, for N = 4 and S = {1,2,3}, there are four solutions: {1,1,1,1},{1,1,2},{2,2},{1,3}. So output should be 4. For N = 10 and S = {2, 5, 3, 6}, there are five solutions: {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} and {5,5}. So the output should be 5.", "code": "# Python program for the above approach\ndef coinchange(a, v, n, dp):\n\tif (v == 0):\n\t\tdp[n][v] = 1;\n\t\treturn dp[n][v];\n\tif (n == 0):\n\t\treturn 0;\n\tif (dp[n][v] != -1):\n\t\treturn dp[n][v];\n\tif (a[n - 1] <= v):\n\n\t\t# Either Pick this coin or not\n\t\tdp[n][v] = coinchange(a, v - a[n - 1], n, dp) + coinchange(a, v, n - 1, dp);\n\t\treturn dp[n][v];\n\telse: # We have no option but to leave this coin\n\t\tdp[n][v] = coinchange(a, v, n - 1, dp);\n\t\treturn dp[n][v];\n\n# Driver code\nif __name__ == '__main__':\n\ttc = 1;\n\twhile (tc != 0):\n\t\tn = 3;\n\t\tv = 4;\n\t\ta = [ 1, 2, 3 ];\n\t\tdp = [[-1 for i in range(v+1)] for j in range(n+1)]\n\t\tres = coinchange(a, v, n, dp);\n\t\tprint(res);\n\t\ttc -= 1;\n\t\n# This code is contributed by Rajput-Ji"}
{"nl": "Given a list, the task is to find the sum of the elements which are having an odd frequency in the given array/List.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven List =  [10, 4, 2, 10, 1, 2, 3, 4, 5, 6, 6]\nOutput:\n\nThe sum of all odd frequency elements in the given list [10, 4, 2, 10, 1, 2, 3, 4, 5, 6, 6] is:\n9", "code": "# Take a dictionary and initialize it to empty\n# using the {} or dict() say freqncyDictionary.\nfreqncyDictionary = {}\n# Give the list as static input and store it in a variable.\ngvnlst = [10, 4, 2, 10, 1, 2, 3, 4, 5, 6, 6]\n# Loop in the given list using the For loop.\nfor i in gvnlst:\n        # Inside the For loop,\n    # Check if the list element is present in the dictionary\n    # or not using the if conditional statement and 'in' keyword.\n    if i in freqncyDictionary.keys():\n                # If it is true then increment the count of the list element\n        # in the dictionary by 1.\n        freqncyDictionary[i] = freqncyDictionary[i]+1\n    # Else initialize the dictionary with the list element as key and value as 1.\n    else:\n        freqncyDictionary[i] = 1\n\n# Take a variable say oddfreqncycnt and initialize its value to 0.\noddfreqncycnt = 0\n# Loop in the freqncyDictionary using the For loop.\nfor elemnt in freqncyDictionary:\n    # Check if the key in the freqncyDictionary having value odd\n    # using the if conditional statement.\n    if(freqncyDictionary[elemnt] % 2 != 0):\n                # If it is true then increment the oddfreqncycnt by the key\n        # and store it in the same variable.\n        oddfreqncycnt += elemnt\n# After the end of For loop then print the oddfreqncycnt value.\nprint('The sum of all odd frequency elements in the given list', gvnlst, 'is:')\nprint(oddfreqncycnt)"}
{"nl": "This python program generates right angle triangle pattern of stars up to n lines.\r\nIn this python example, we first read number of row in the right angle triangle pattern from user using built-in function input(). Since function input() returns string value, we need to convert given number to number type using int(). And then we generate right angle triangle pattern using python's loops", "code": "# Generating Right Angle Triangle Pattern Using Stars\r\n\r\nrow = int(input('Enter number of rows required: '))\r\n\r\nfor i in range(row):\r\n    for j in range(i+1):\r\n        print('*',end=' ')\r\n    print()"}
{"nl": "Given an array arr of size N, the task is to find the largest element in the given array. \n\nExample: \n\n\n\nInput: arr[] = {10, 20, 4}\nOutput: 20\n\nInput : arr[] = {20, 10, 20, 4, 100}\nOutput : 100", "code": "# Python3 program to find maximum\n# in arr[] of size n\n\n# Function to find maximum\n# in arr[] of size n\ndef largest(arr,n):\n# Initialize maximum element\nmax = arr[0]\t\t\n\n# Traverse array elements from second\t\t\n# and compare every element with\t\t\n# current max\t\t\nfor i in range(1, n):\t\t\n\tif arr[i] > max:\t\t\n\t\tmax = arr[i]\t\t\nreturn max\n\n# Driver Code\narr = [10, 324, 45, 90, 9808]\nn = len(arr)\n\n#calculating length of an array\nAns = largest(arr,n)\n\n# display max\nprint (\"Largest in given array is\",Ans)\n\n# This code is contributed by Jai Parkash Bhardwaj\n# and improved by ssaha3475"}
{"nl": "We will discuss how to check if a number is repeated in a list. In Python, there are many methods available on the list data type that help you check duplicates elements in a given list. In this post, we are using set(), len(), count(), list comprehension, enumerate(), slicing, OrderedDict.fromkeys(), and numpy function.", "code": "# Python program to check for duplicates in list # take list my_list = [1, 3, 5, 1] # printing original list print('List:', my_list) # check duplicates using set() seen = set() duplicate_item = {x for x in my_list if x in seen or (seen.add(x) or False)} if duplicate_item: print('Yes, the list contains duplicates.') else: print('No, the list does not contains duplicates.')"}
{"nl": "In the matrix-chain multiplication problem, we are given a sequence of matrices A(1), A(2), \u2026, A(n). The aim is to compute the product A(1)\u2026A(n) with the minimum number of scalar multiplications. Thus, we have to find an optimal parenthesization of the matrix product A(1)\u2026A(n) such that the cost of computing the product is minimized.", "code": "def matrix_product(p):\n    \"\"\"Return m and s.\n\u00a0\n    m[i][j] is the minimum number of scalar multiplications needed to compute the\n    product of matrices A(i), A(i + 1), ..., A(j).\n\u00a0\n    s[i][j] is the index of the matrix after which the product is split in an\n    optimal parenthesization of the matrix product.\n\u00a0\n    p[0... n] is a list such that matrix A(i) has dimensions p[i - 1] x p[i].\n    \"\"\"\n    length = len(p) # len(p) = number of matrices + 1\n\u00a0\n    # m[i][j] is the minimum number of multiplications needed to compute the\n    # product of matrices A(i), A(i+1), ..., A(j)\n    # s[i][j] is the matrix after which the product is split in the minimum\n    # number of multiplications needed\n    m = [[-1]*length for _ in range(length)]\n    s = [[-1]*length for _ in range(length)]\n\u00a0\n    matrix_product_helper(p, 1, length - 1, m, s)\n\u00a0\n    return m, s\n\u00a0\n\u00a0\ndef matrix_product_helper(p, start, end, m, s):\n    \"\"\"Return minimum number of scalar multiplications needed to compute the\n    product of matrices A(start), A(start + 1), ..., A(end).\n\u00a0\n    The minimum number of scalar multiplications needed to compute the\n    product of matrices A(i), A(i + 1), ..., A(j) is stored in m[i][j].\n\u00a0\n    The index of the matrix after which the above product is split in an optimal\n    parenthesization is stored in s[i][j].\n\u00a0\n    p[0... n] is a list such that matrix A(i) has dimensions p[i - 1] x p[i].\n    \"\"\"\n    if m[start][end] >= 0:\n        return m[start][end]\n\u00a0\n    if start == end:\n        q = 0\n    else:\n        q = float('inf')\n        for k in range(start, end):\n            temp = matrix_product_helper(p, start, k, m, s) \\\n                   + matrix_product_helper(p, k + 1, end, m, s) \\\n                   + p[start - 1]*p[k]*p[end]\n            if q > temp:\n                q = temp\n                s[start][end] = k\n\u00a0\n    m[start][end] = q\n    return q\n\u00a0\n\u00a0\ndef print_parenthesization(s, start, end):\n    \"\"\"Print the optimal parenthesization of the matrix product A(start) x\n    A(start + 1) x ... x A(end).\n\u00a0\n    s[i][j] is the index of the matrix after which the product is split in an\n    optimal parenthesization of the matrix product.\n    \"\"\"\n    if start == end:\n        print('A[{}]'.format(start), end='')\n        return\n\u00a0\n    k = s[start][end]\n\u00a0\n    print('(', end='')\n    print_parenthesization(s, start, k)\n    print_parenthesization(s, k + 1, end)\n    print(')', end='')\n\u00a0\n\u00a0\nn = int(input('Enter number of matrices: '))\np = []\nfor i in range(n):\n    temp = int(input('Enter number of rows in matrix {}: '.format(i + 1)))\n    p.append(temp)\ntemp = int(input('Enter number of columns in matrix {}: '.format(n)))\np.append(temp)\n\u00a0\nm, s = matrix_product(p)\nprint('The number of scalar multiplications needed:', m[1][n])\nprint('Optimal parenthesization: ', end='')\nprint_parenthesization(s, 1, n)"}
{"nl": "Given an array of n elements, where each element is at most k away from its target position, devise an algorithm that sorts in O(n log k) time. For example, let us consider k is 2, an element at index 7 in the sorted array, can be at indexes 5, 6, 7, 8, 9 in the given array.\n\nExamples: \n\nInput : arr[] = {6, 5, 3, 2, 8, 10, 9}\n            k = 3 \nOutput : arr[] = {2, 3, 5, 6, 8, 9, 10}\n\nInput : arr[] = {10, 9, 8, 7, 4, 70, 60, 50}\n         k = 4\nOutput : arr[] = {4, 7, 8, 9, 10, 50, 60, 70}", "code": "# A Python3 program to sort a\n# nearly sorted array.\n\nfrom heapq import heappop, heappush, heapify\n\n\n# A utility function to print\n# array elements\ndef print_array(arr: list):\n\tfor elem in arr:\n\t\tprint(elem, end=' ')\n\n# Given an array of size n, where every\n# element is k away from its target\n# position, sorts the array in O(nLogk) time.\n\n\ndef sort_k(arr: list, n: int, k: int):\n\t\"\"\"\n\t:param arr: input array\n\t:param n: length of the array\n\t:param k: max distance, which every\n\telement is away from its target position.\n\t:return: None\n\t\"\"\"\n\t# List of first k+1 items\n\theap = arr[:k + 1]\n\n\t# using heapify to convert list\n\t# into heap(or min heap)\n\theapify(heap)\n\n\t# \"rem_elmnts_index\" is index for remaining\n\t# elements in arr and \"target_index\" is\n\t# target index of for current minimum element\n\t# in Min Heap \"heap\".\n\ttarget_index = 0\n\tfor rem_elmnts_index in range(k + 1, n):\n\t\tarr[target_index] = heappop(heap)\n\t\theappush(heap, arr[rem_elmnts_index])\n\t\ttarget_index += 1\n\n\twhile heap:\n\t\tarr[target_index] = heappop(heap)\n\t\ttarget_index += 1\n\n\n# Driver Code\nk = 3\narr = [2, 6, 3, 12, 56, 8]\nn = len(arr)\nsort_k(arr, n, k)\n\nprint('Following is sorted array')\nprint_array(arr)\n\n# This code is contributed by\n# Veerat Beri(viratberi)"}
{"nl": "Given an integer \u2018K\u2019 and a binary tree in string format. Every node of a tree has value in range from 0 to 9. We need to find sum of elements at K-th level from root. The root is at level 0. \nTree is given in the form: (node value(left subtree)(right subtree)) \n\nExamples: \n\nInput : tree = \"(0(5(6()())(4()(9()())))(7(1()())(3()())))\" \n        k = 2\nOutput : 14\nIts tree representation is shown below", "code": "# Python3 implementation to find sum of\n# digits of elements at k-th level\n\n# Function to find sum of digits\n# of elements at k-th level\ndef sumAtKthLevel(tree, k) :\n\n\tlevel = -1\n\tsum = 0 # Initialize result\n\tn = len(tree)\n\n\tfor i in range(n):\n\t\t\n\t\t# increasing level number\n\t\tif (tree[i] == '(') :\n\t\t\tlevel += 1\n\n\t\t# decreasing level number\n\t\telse if (tree[i] == ')'):\n\t\t\tlevel -= 1\n\n\t\telse:\n\t\t\n\t\t\t# check if current level is\n\t\t\t# the desired level or not\n\t\t\tif (level == k) :\n\t\t\t\tsum += (ord(tree[i]) - ord('0'))\n\t\t\n\t# required sum\n\treturn sum\n\n# Driver Code\nif __name__ == '__main__':\n\ttree = \"(0(5(6()())(4()(9()())))(7(1()())(3()())))\"\n\tk = 2\n\tprint(sumAtKthLevel(tree, k))\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Given the number of rows of the pyramid, the task is to print the Pyramid Star pattern in C, C++, and Python.", "code": "# Give the number of rows of the pyramid as static input and store it in a variable.\npyRows = 10\n# Loop from the number of rows to 0 in decreasing order using For Loop.\n# Loop from 0 to the number of rows using For Loop.\nfor m in range(0, pyRows):\n    # Loop from 0 to the number of rows - iterator value-1 of the parent For loop\\\n    # using another Nested For loop(Inner For loop).\n    for n in range(0, pyRows-m-1):\n        # Print the space character in the inner For loop.\n        print(end=' ')\n    # Loop from 0 to the iterator value+1 of the parent For loop\n    # using another Nested For loop(Inner For loop).\n\n    for l in range(0, m+1):\n        # Print the star character with a star character in the inner For loop.\n        print('*', end=' ')\n    print()"}
{"nl": "Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n \nExample 1:\n\nInput: nums = [1,1,1,1,1], target = 2\nOutput: 2\nExplanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\nExample 2:\n\nInput: nums = [-1,3,5,1,4,2,-9], target = 6\nOutput: 2\nExplanation: There are 3 subarrays with sum equal to 6.\n([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n0 <= target <= 106", "code": "class Solution:\n  def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n  seen = set([0])\n  ans = curr = 0\n\n  for i, num in enumerate(nums):\n  curr += num\n  prev = curr - target\n  if prev in seen:\n  ans += 1\n  seen = set()\n  seen.add(curr)\n  \n  return ans"}
{"nl": "Create a function that takes a string as an argument and returns the Morse code equivalent.\nExamples\nencode_morse(\"EDABBIT CHALLENGE\") \u279e \". -.. .- -... -... .. -   -.-. .... .- .-.. .-.. . -. --. .\"\n\nencode_morse(\"HELP ME !\") \u279e \".... . .-.. .--.   -- .   -.-.--\"\nThis dictionary can be used for coding:\nchar_to_dots = {\n  'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',\n  'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',\n  'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',\n  'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',\n  'Y': '-.--', 'Z': '--..', ' ': ' ', '0': '-----',\n  '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',\n  '6': '-....', '7': '--...', '8': '---..', '9': '----.',\n  '&': '.-...', \"'\": '.----.', '@': '.--.-.', ')': '-.--.-', '(': '-.--.',\n  ':': '---...', ',': '--..--', '=': '-...-', '!': '-.-.--', '.': '.-.-.-',\n  '-': '-....-', '+': '.-.-.', '\"': '.-..-.', '?': '..--..', '/': '-..-.'\n}\nNotes\nOuput should be International Morse Code, and use the standard conventions for symbols not defined inside the ITU recommendation (see Resources).\nInput value can be lower or upper case.\nInput string can have digits.\nInput string can have some special characters (e.g. comma, colon, apostrophe, period, question mark, exclamation mark).\nOne space \" \" is expected after each character, except the last one.", "code": "def encode_morse(txt):\n  d = {'A':'.-', 'B':'-...',\n     'C':'-.-.', 'D':'-..', 'E':'.',\n     'F':'..-.', 'G':'--.', 'H':'....',\n     'I':'..', 'J':'.---', 'K':'-.-',\n     'L':'.-..', 'M':'--', 'N':'-.',\n     'O':'---', 'P':'.--.', 'Q':'--.-',\n     'R':'.-.', 'S':'...', 'T':'-',\n     'U':'..-', 'V':'...-', 'W':'.--',\n     'X':'-..-', 'Y':'-.--', 'Z':'--..',\n     '1':'.----', '2':'..---', '3':'...--',\n     '4':'....-', '5':'.....', '6':'-....',\n     '7':'--...', '8':'---..', '9':'----.',\n     '0':'-----', ',':'--..--', '.':'.-.-.-',\n     '?':'..--..', '/':'-..-.', '-':'-....-',\n     '(':'-.--.', ')':'-.--.-', '!': '-.-.--', \n     ' ': ' ', \"'\": '.----.', ':': '---...'}\n       return ' '.join(d[i] for i in txt.upper())"}
{"nl": "Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).\n \nExample 1:\n\nInput: nums = [3,4,5,2]\nOutput: 12 \nExplanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. \n\nExample 2:\n\nInput: nums = [1,5,4,5]\nOutput: 16\nExplanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.\n\nExample 3:\n\nInput: nums = [3,7]\nOutput: 12\n\n \nConstraints:\n\n2 <= nums.length <= 500\n1 <= nums[i] <= 10^3", "code": "def maxProduct(self, nums: List[int]) -> int:\n  mx1 = mx2 = -math.inf\n  for n in nums:\n  if n > mx1:\n  mx2 = mx1\n  mx1 = n\n  elif n > mx2:\n  mx2 = n\n  return (mx1 - 1) * (mx2 - 1)"}
{"nl": "Exercise 8: Generate random secure token of 64 bytes and random URL", "code": "import secrets\r\n\r\nprint(\"Random secure Hexadecimal token is \", secrets.token_hex(64))\r\nprint(\"Random secure URL is \", secrets.token_urlsafe(64))"}
{"nl": "Method #1: Using For Loop (Static Input)\r\nApproach:\r\n\r\nGive the number of rows as static input and store it in a variable.\r\nLoop from 1 to the number of rows using For loop.\r\nLoop from iterator value of the parent For loop -1 to 0 in decreasing order using another for loop(Nested For loop).\r\nPrint the 2 power n value with space where n is the value of the inner for loop.\r\nPrint the Newline character after the end of the inner loop.\r\nThe Exit of the Program.", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumbrrows = 7\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numbrrows):\r\n    # Loop from iterator value of the parent For loop -1 to 0\r\n    # in decreasing order using another for loop(Nested For loop).\r\n    for n in range(m - 1, -1, -1):\r\n        # Print the 2 power n value with space where n is the value of the inner for loop.\r\n        print(2**n, end=' ')\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "Given a matrix and a number(element) the task is to find the position of the given element in the given matrix in Python.\r\n\r\nIf the element does not exist in the given matrix then print the given element doesn\u2019t exist in the given matrix.\r\n\r\nIf there are multiple answers we print all of them.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[2, 9, 1], [11, 4, 5], [9, 2, 3], [1, 2, 3]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Give the number/element as static input and store it in a variable to say gvnele.\r\ngvnele = 9\r\n# Take a variable to say tempo and initialize its value to 0\r\n# (Here tempo as temp variable which says whether the element is present\r\n# or not in matrix at the end).\r\ntempo = 0\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n    # Inside the For loop, Iterate till the given number of rows using another\r\n    # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # Check if the gvnmatrix[n][m] value\r\n        # (where n is the iterator value of the parent For loop and\r\n        # m is the iterator value of the inner For loop)\r\n        # is equal to gvnele using the if conditional statement.\r\n        if(mtrx[n][m] == gvnele):\r\n            # If it is true then print the iterator value of parent for loop+1\r\n            # (Here it acts as row number)\r\n            # and also print the inner loop iterator value+1\r\n            # (Here it acts as column number).\r\n            print('The given element {', gvnele, '} is present at row {' +\r\n                  str(n+1)+'} and column {'+str(m+1)+'}')\r\n            # Set the value of tempo to 1.\r\n            tempo = 1\r\n# After the end of loops check if the value of tempo is 0\r\n# or not using the if conditional statement.\r\nif(tempo == 0):\r\n        # If it is true then print the given element doesn't exist in the given matrix.\r\n    print('the given element doesnot exist in the given matrix.')"}
{"nl": "In Python, there are many methods available on the list data type that help you remove an element from a given list. In this post, we will discuss how to remove items or elements from the list using remove(), pop(), clear(), and del operator. We will take a list while declaring the variables then the Python program removes the element from the list. Finally, the new list will be displayed on the screen.", "code": "# Python program to remove item from list # take list my_list = ['C', 'Java', 'Python', 'HTML', 'Javascript'] # printing original list print('List:', my_list) # removed HTML from the list my_list.remove('HTML') # print list after item deletion print('New list:', my_list)"}
{"nl": "You are given a string s, an integer k, a letter letter, and an integer repetition.\n\nReturn the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times.\n\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\nA string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\n\n ", "code": "class Solution:\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n        counts,total = 0, 0\n        n = len(s)\n        for ch in s:\n            if ch==letter:\n                total +=1\n        stack = []\n        occ = 0\n        for idx,ch in enumerate(s):\n            if ch==letter:\n                counts +=1\n            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): \n                occ -= stack.pop()==letter\n            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):\n                stack.append(ch)\n            elif ch==letter and len(stack)+(total-counts)<k:\n                stack.append(ch)\n                occ +=1\n        return ''.join(stack)"}
{"nl": "Exercise 9: Roll dice in such a way that every time you get the same number\n\nDice has 6 numbers (from 1 to 6). Roll dice in such a way that every time you must get the same output number. do this 5 times.", "code": "import random\r\n\r\ndice = [1, 2, 3, 4, 5, 6]\r\nprint(\"Randomly selecting same number of a dice\")\r\nfor i in range(5):\r\n    random.seed(25)\r\n    print(random.choice(dice))"}
{"nl": "Files in Python:\n\nOne of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.\n\nAlso, if you didn\u2019t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.\n\n\n\nConsider the following scenario: you\u2019re planning to construct a large Python project with a large number of workflows. Then it\u2019s unavoidable that you don\u2019t make a log file. You\u2019ll also be handling the log file\u2019s read and write activities. Debugging huge applications with log files is a terrific way to go. It\u2019s usually better to consider a scalable design from the start, as you won\u2019t be sorry later if you didn\u2019t.\n\nFile errors Property in Python:\n\nIn Python, the errors Property is a built-in property of the File object (IO object), and it is used to obtain the Unicode error handler along with the Unicode.\n\nSyntax:\n\nfileobject.errors\nParameters: This property has no arguments\n\nReturn Value: This method\u2019s return type is <class\u2019str\u2019>, and it returns the Unicode error handler as a string.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\ngvn_file = open(givenFilename, 'w') \n# Apply errors function to the given file and print it\nprint(\"In write-mode:\", gvn_file.errors)\n# Close the given file using the close function\ngvn_file.close()\n# Open the file in append mode. In this case, we're appending the contents into the file.\ngvn_file = open(givenFilename, 'a') \n# Apply errors function to the given file and print it\nprint(\"In append-mode:\", gvn_file.errors)\n# Close the given file using the close function\ngvn_file.close()\n# Open the file in write mode and pass errors ='ignore' as the \n# arguments to the open() function\ngvn_file = open(givenFilename, 'w', errors='ignore') \n# Apply errors function to the given file and print it\nprint(\"In write-mode with errors=ignore:\", gvn_file.errors)\n# Close the given file using the close function\ngvn_file.close()"}
{"nl": "Create a function that takes a list of strings and returns a dictionary.\nExamples\nstr_to_dict([\"1=one\", \"2=two\", \"3=three\", \"4=four\"]) \u279e {\"1\": \"one\", \"2\": \"two\", \"3\": \"three\", \"4\": \"four\"}\n\nstr_to_dict([\"dog=bark\", \"cat=meow\", \"cow=moo\"]) \u279e {\"dog\": \"bark\", \"cat\": \"meow\", \"cow\": \"moo\"}\n\nstr_to_dict([\"bob=human\", \"lola=dog\", \"mittens=cat\", \"todd=frog\"]) \u279e {\"bob\": \"human\", \"lola\": \"dog\", \"mittens\": \"cat\", \"todd\": \"frog\"}\nNotes\nKey and value with be separated with =.\nInput list will be of various lengths.\nThe key will be the first element in the string and the value with be the second.", "code": "def str_to_dict(lst):\n    return dict(i.split('=') for i in lst)"}
{"nl": "Given two circles of radius r and R, their centers are both at the origin. Given another circle with radius r1 and center at (x1, y1). Check to see if the third circle (circle of radius r1) is entirely contained within the ring formed by two circles of radius r and R", "code": "# import the math module using the import keyword\r\nimport math\r\n# Give the first circle radius(small circle) r as static input and\r\n# store it in a variable say rVal.\r\nrVal = 8\r\n# Give the second circle radius (Big circle) R as static input and\r\n# store it in another variable say RVal.\r\nRVal = 4\r\n# Give the Third Circle(Which we want to check Condition) radius r1 as\r\n# static input and store it in another variable say r1Val\r\nr1Val = 2\r\n# Give the x coordinates and y coordinates of the third circle and\r\n# store them in two separate variables.\r\nxCoordinate = 6\r\nyCoordinate = 0\r\n# Calculate the distance(dis value) using Pythagoras theorem and sqrt() function\r\n# and store the result in a variable say disVal.\r\ndisVal = math.sqrt(xCoordinate * xCoordinate + yCoordinate * yCoordinate)\r\n# Check the Condition (dis \u2013 r1)> = r and (dis + r1)< = R \r\n# using the if conditional Statement.\r\nif((disVal-r1Val >= RVal and disVal+r1Val <= rVal)):\r\n    # If it is true then Print the given circle inside the ring \r\n    print('The given circle lies inside the ring')\r\nelse:\r\n    # Else print the circle does not lie inside.\r\n    print('The given circle does not lies inside the ring')"}
{"nl": "You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.\nThe value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).\nFind the kth largest value (1-indexed) of all the coordinates of matrix.\n \nExample 1:\n\nInput: matrix = [[5,2],[1,6]], k = 1\nOutput: 7\nExplanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.\n\nExample 2:\n\nInput: matrix = [[5,2],[1,6]], k = 2\nOutput: 5\nExplanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.\n\nExample 3:\n\nInput: matrix = [[5,2],[1,6]], k = 3\nOutput: 4\nExplanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.\n \nConstraints:\n\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 1000\n0 <= matrix[i][j] <= 106\n1 <= k <= m * n", "code": "def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n  R, C = map(len, (matrix, matrix[0]))\n  ans = [[0] * (C + 1) for _ in range(R + 1)]\n  heap = []\n  for r, row in enumerate(matrix):\n  for c, cell in enumerate(row):\n  ans[r + 1][c + 1] = cell ^ ans[r + 1][c] ^ ans[r][c + 1] ^ ans[r][c]\n  heapq.heappush(heap, ans[r + 1][c + 1])\n  if len(heap) > k:\n heapq.heappop(heap)\n  return heap[0]"}
{"nl": "There are N stations on route of a train. The train goes from station 0 to N-1. The ticket cost for all pair of stations (i, j) is given where j is greater than i. Find the minimum cost to reach the destination.", "code": "# A Dynamic Programming based\n# solution to find min cost\n# to reach station N-1\n# from station 0.\n \nINF = 2147483647\nN = 4\n  \n# This function returns the\n# smallest possible cost to\n# reach station N-1 from station 0.\ndef minCost(cost):\n \n    # dist[i] stores minimum\n    # cost to reach station i\n    # from station 0.\n    dist=[0 for i in range(N)]\n    for i in range(N):\n        dist[i] = INF\n    dist[0] = 0\n  \n    # Go through every station\n    # and check if using it\n    # as an intermediate station\n    # gives better path\n    for i in range(N):\n        for j in range(i+1,N):\n            if (dist[j] > dist[i] + cost[i][j]):\n                dist[j] = dist[i] + cost[i][j]\n  \n    return dist[N-1]\n \n  \n# Driver program to\n# test above function\n \ncost= [ [0, 15, 80, 90],\n            [INF, 0, 40, 50],\n            [INF, INF, 0, 70],\n            [INF, INF, INF, 0]]\n             \nprint(\"The Minimum cost to reach station \",\n           N,\" is \",minCost(cost))\n \n# This code is contributed\n# by Anant Agarwal."}
{"nl": "On a vacation abroad, you see a souvenir shop and decide to head inside. There are snow globes, postcards, fridge magnets and all the other goodies you'd typically find.\nGiven a list of prices of things in the store and the amount of money you have, return the maximum number of items you could possibly buy.\nExamples\nmaximum_items([\"$1\", \"$1\", \"$2\"], \"$3\") \u279e 2\n\nmaximum_items([\"$10\", \"$7\", \"$2\", \"$60\"], \"$20\") \u279e 3\n\nmaximum_items([\"$15\", \"$5\", \"$30\", \"$30\", \"$10\"], \"$2\") \u279e \"Not enough funds!\"\nNotes\nIf you cannot afford anything, return \"Not enough funds!\"\nPrices will be whole numbers.", "code": "def maximum_items(prices, budget):\n  n=0\n  prices=sorted([int(i[1:]) for i in prices])\n  budget=int(budget[1:])\n  while prices and prices[0]<=budget:\n    n+=1\n    budget-=prices.pop(0)\n  return n if n else 'Not enough funds!'"}
{"nl": "Simple Linear Regression is a statistical method that allows us to summarize and study relationships between two continuous (quantitative) variables. One variable denoted x is regarded as an independent variable and other one denoted y is regarded as a dependent variable. It is assumed that the two variables are linearly related. Hence, we try to find a linear function that predicts the response value (y) as accurately as possible as a function of the feature or independent variable (x).\n\nThe simplest form of the regression equation with one dependent and one independent variable is defined by the formula:\n", "code": "# Simple Linear Regression\n\n# Importing the libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Importing the dataset\ndataset = pd.read_csv('Salary_Data.csv')\nX = dataset.iloc[:, :-1].values\ny = dataset.iloc[:, 1].values\n\n# Splitting the dataset into the Training set and Test set\nfrom sklearn.cross_validation import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(\n\t\t\tX, y, test_size = 1/3, random_state = 0)\n\n# Fitting Simple Linear Regression to the Training set\nfrom sklearn.linear_model import LinearRegression\nregressor = LinearRegression()\nregressor.fit(X_train, y_train)\n\n# Predicting the Test set results\ny_pred = regressor.predict(X_test)\n\n# Visualising the Training set results\nplt.scatter(X_train, y_train, color = 'red')\nplt.plot(X_train, regressor.predict(X_train), color = 'blue')\nplt.title('Salary vs Experience (Training set)')\nplt.xlabel('Years of Experience')\nplt.ylabel('Salary')\nplt.show()\n\n# Visualising the Test set results\nplt.scatter(X_test, y_test, color = 'red')\nplt.plot(X_train, regressor.predict(X_train), color = 'blue')\nplt.title('Salary vs Experience (Test set)')\nplt.xlabel('Years of Experience')\nplt.ylabel('Salary')\nplt.show()"}
{"nl": "Create a function that takes a number as input and returns True if the sum of its digits has the same parity as the entire number. Otherwise, return False.\nExamples\nparity_analysis(243) \u279e True\n# 243 is odd and so is 9 (2 + 4 + 3)\n\nparity_analysis(12) \u279e False\n# 12 is even but 3 is odd (1 + 2)\n\nparity_analysis(3) \u279e True\n# 3 is odd and 3 is odd and 3 is odd (3)\nNotes\nParity is whether a number is even or odd. If the sum of the digits is even and the number itself is even, return True. The same goes if the number is odd and so is the sum of its digits.\nSingle digits will obviously have the same parities (see example #3).", "code": "def parityAnalysis(num):\n  digit_sum = sum(int(i) for i in str(num))\n  return digit_sum%2 == num%2"}
{"nl": "In this example, you will learn to copy the content of a file to another file using Python.", "code": "from shutil import copyfile\ncopyfile(\"/root/a.txt\", \"/root/b.txt\")"}
{"nl": "Create a function that takes a multi-dimensional list and converts it (recursively) into a single-dimensional list and returns it. Use a RECURSIVE approach.\nExamples\nflatten([[17.2, 5, \"code\"]]) \u279e [17.2, 5, \"code\"]\n\nflatten([[[[[2, 14, \"rubber\"]]], 2, 3, 4]])) \u279e [2, 14, \"rubber\", 2, 3, 4]\n\nflatten([[\"dimension\"]]) \u279e [\"dimension\"]\nNotes\nInput contains at least one element.\nThe use of built-in methods is discouraged.\nA similar version of this challenge can be found here.", "code": "def flatten(lst):\n  return sum((flatten(l) for l in lst),[]) if type(lst)==list else [lst]"}
{"nl": "Instructions\r\nGiven a word, compute the Scrabble score for that word.\r\n\r\nLetter Values\r\nYou'll need these:\r\n\r\nLetter                           Value\r\nA, E, I, O, U, L, N, R, S, T       1\r\nD, G                               2\r\nB, C, M, P                         3\r\nF, H, V, W, Y                      4\r\nK                                  5\r\nJ, X                               8\r\nQ, Z                               10\r\nExamples\r\n\"cabbage\" should be scored as worth 14 points:\r\n\r\n3 points for C\r\n1 point for A, twice\r\n3 points for B, twice\r\n2 points for G\r\n1 point for E\r\nAnd to total:\r\n\r\n3 + 2*1 + 2*3 + 2 + 1\r\n= 3 + 2 + 6 + 3\r\n= 5 + 9\r\n= 14\r\nExtensions\r\nYou can play a double or a triple letter.\r\nYou can play a double or a triple word.", "code": "scores = {}\r\nfor k, v in {\r\n            \"AEIOULNRST\": 1,\r\n            \"DG\": 2,\r\n            \"BCMP\": 3,\r\n            \"FHVWY\": 4,\r\n            \"K\": 5,\r\n            \"JX\": 8,\r\n            \"QZ\": 10\r\n        }.items():\r\n    scores.update({x: v for x in k})\r\ndef score(word):\r\n    return sum([scores[char] for char in word.upper()])"}
{"nl": "Given any number, we can create a new number by adding the sums of squares of digits of that number. For example, given 203, our new number is 4 + 0 + 9 = 13. If we repeat this process, we get a sequence of numbers:\n203 -> 13 -> 10 -> 1 -> 1\nSometimes, like with 203, the sequence reaches (and stays at) 1. Numbers like this are called happy.\nNot all numbers are happy. If we started with 11, the sequence would be:\n11 -> 2 -> 4 -> 16 -> ...\nThis sequence will never reach 1, and so the number 11 is called unhappy.\nGiven a positive whole number, you have to determine whether that number is happy or unhappy.\nExamples\nhappy(203) \u279e True\n\nhappy(11) \u279e False\n\nhappy(107) \u279e False\nNotes\nYou can assume (and it is actually true!) that all positive whole numbers are either happy or unhappy. Any happy number will have a 1 in its sequence, and every unhappy number will have a 4 in its sequence.\nThe only numbers passed to your function will be positive whole numbers.", "code": "def happy(n):\n  n = sum(int(i)**2 for i in str(n))\n  return True if n == 1 else False if n == 4 else happy(n)"}
{"nl": "In the diamond star pattern program, we will discuss how to print two types of pyramid star pattern programs, first normal pyramid, and second downward pyramid.", "code": "# Python program to print diamond star pattern using for loop # take input n = 4 # printing pyramid for i in range(n): for j in range(n-i-1): # print spaces print(\"\", end=\" \") for j in range(2*i+1): # print stars print(\"*\", end=\"\") print() # printing downward pyramid for i in range(n-1): for j in range(i+1): # print spaces print(\"\", end=\" \") for j in range(2*(n-i-1)-1): # print stars print(\"*\", end=\"\") print()"}
{"nl": "Given a sentence, create a function that replaces every \"a\" as an article with \"an absolute\". It should return the same string without any change if it doesn't have any \"a\".\nExamples\nabsolute(\"I am a champion!!!\") \u279e \"I am an absolute champion!!!\"\n\nabsolute(\"Such an amazing bowler.\") \u279e \"Such an amazing bowler.\"\n\nabsolute(\"A man with no haters.\") \u279e \"An absolute man with no haters.\"\nNotes\nWatch for uppercase letters as shown in example #3.", "code": "def absolute(txt):\n    return txt.replace('a ','an absolute ').replace('A ','an absolute ').capitalize()"}
{"nl": "Given a boolean matrix mat[M][N] of size M X N, modify it such that if a matrix cell mat[i][j] is 1 (or true) then make all the cells of ith row and jth column as 1. ", "code": "# Python3 Code For A Boolean Matrix Question\r\nR = 3\r\nC = 4\r\n \r\ndef modifyMatrix(mat):\r\n    row = [0] * R\r\n    col = [0] * C\r\n     \r\n    # Initialize all values of row[] as 0\r\n    for i in range(0, R):\r\n        row[i] = 0\r\n         \r\n    # Initialize all values of col[] as 0\r\n    for i in range(0, C) :\r\n        col[i] = 0\r\n \r\n \r\n    # Store the rows and columns to be marked\r\n    # as 1 in row[] and col[] arrays respectively\r\n    for i in range(0, R) :\r\n         \r\n        for j in range(0, C) :\r\n            if (mat[i][j] == 1) :\r\n                row[i] = 1\r\n                col[j] = 1\r\n             \r\n    # Modify the input matrix mat[] using the\r\n    # above constructed row[] and col[] arrays\r\n    for i in range(0, R) :\r\n         \r\n        for j in range(0, C):\r\n            if ( row[i] == 1 or col[j] == 1 ) :\r\n                mat[i][j] = 1\r\n                 \r\n# A utility function to print a 2D matrix\r\ndef printMatrix(mat) :\r\n    for i in range(0, R):\r\n         \r\n        for j in range(0, C) :\r\n            print(mat[i][j], end = \" \")\r\n        print()\r\n         \r\n# Driver Code\r\nmat = [ [1, 0, 0, 1],\r\n        [0, 0, 1, 0],\r\n        [0, 0, 0, 0] ]\r\n \r\nprint(\"Input Matrix n\")\r\nprintMatrix(mat)\r\n \r\nmodifyMatrix(mat)\r\n \r\nprint(\"Matrix after modification n\")\r\nprintMatrix(mat)\r\n \r\n# This code is contributed by Nikita Tiwari."}
{"nl": "Get the Length of a Set\r\nTo determine how many items a set has, use the len() method.", "code": "thisset = {\"apple\", \"banana\", \"cherry\"}\r\n\r\nprint(len(thisset))"}
{"nl": "Given a binary tree containing n nodes. The problem is to find the maximum sum obtained when the tree is spirally traversed. In spiral traversal one by one all levels are being traversed with the root level traversed from right to left, then next level from left to right, then further next level from right to left and so on.", "code": "# Python3 Implementation to find the maximum Spiral Sum\n\n# Structure of a node in binary tree\nclass Node:\n\t\n\tdef __init__(self, data):\n\t\t\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# function to find the maximum sum contiguous subarray\n# implementing kadane's algorithm\ndef maxSum(Arr):\n\n\tcurrSum = maxSum = 0\n\tfor element in Arr:\n\t\tcurrSum = max(currSum + element, element)\n\t\tmaxSum = max(maxSum, currSum)\n\n\treturn maxSum\n\n# function to find maximum spiral sum\ndef maxSpiralSum(root):\n\n\t# if tree is empty\n\tif not root:\n\t\treturn 0\n\n\t# create two stacks to stopre alternative levels\n\tstack_s1 = [] # from levels right to left\n\tstack_s2 = [] # from levels left to right\n\n\t# store spiral order traversal in Arr\n\tArr = []\n\tstack_s1.append(root)\n\n\t# traversing tree in spiral form\n\t# until there are elements in any one\n\t# of the stack\n\twhile stack_s1 or stack_s2:\n\n\t\t# traverse current level from s1 and\n\t\t# push node of next level to s2\n\t\twhile stack_s1:\n\t\t\t\n\t\t\ttemp = stack_s1.pop()\n\n\t\t\t# append temp-> data to Arr\n\t\t\tArr.append(temp.data)\n\n\t\t\tif temp.right:\n\t\t\t\tstack_s2.append(temp.right)\n\t\t\tif temp.left:\n\t\t\t\tstack_s2.append(temp.left)\n\n\t\t# traverse current level from s2 and\n\t\t# push node of next level to s1\n\t\twhile stack_s2:\n\t\t\t\n\t\t\ttemp = stack_s2.pop()\n\n\t\t\t# append temp-> data to Arr\n\t\t\tArr.append(temp.data)\n\n\t\t\tif temp.left:\n\t\t\t\tstack_s1.append(temp.left)\n\t\t\tif temp.right:\n\t\t\t\tstack_s1.append(temp.right)\n\n\treturn maxSum(Arr)\n\n# Driver code\nif __name__ == \"__main__\":\n\n\troot = Node(-2)\n\troot.left = Node(-3)\n\troot.right = Node(4)\n\troot.left.left = Node(5)\n\troot.left.right = Node(1)\n\troot.right.left = Node(-2)\n\troot.right.right = Node(-1)\n\troot.left.left.left = Node(-3)\n\troot.right.right.right = Node(2)\n\n\tprint(\"Maximum Spiral Sum is : \", maxSpiralSum(root))\n\n# This code is contributed by\n# Mayank Chaudhary (chaudhary_19)\n"}
{"nl": "Imagine you run a website that presents users with different coding challenges in levels Easy, Medium, and Hard, where users get points for completing challenges. An Easy challenge is worth 5 points, a Medium challenge is worth 10 points, and a Hard challenge is worth 20 points.\nCreate a function that takes the amount of challenges a user has completed for each challenge level, and calculates the user's total number of points. Keep in mind that a user cannot complete negative challenges, so the function should return the string \"invalid\" if any of the passed parameters are negative.\nExamples\nscore_calculator(1, 2, 3) \u279e 85\n\nscore_calculator(1, 0, 10) \u279e 205\n\nscore_calculator(5, 2, -6) \u279e \"invalid\"\nNotes\nN/A", "code": "def score_calculator(e, m, h):\n  return \"invalid\" if min([e,m,h]) < 0 else e * 5 + m * 10 + h * 20"}
{"nl": "Given a list of five values, calculate the average star rating, rounded to two decimal places. The list contains user votes per star, so the first element [0] contains the number of 1-star ratings and the last element [4], the number of 5-star ratings.\nReturn the average score in [brackets], followed by a space and asterisks' * to represent the star rating, rounded to the nearest whole star.\nExamples\nstar_rating([55, 67, 98, 115, 61]) \u279e \"[3.15] ***\"\n\nstar_rating([0, 2, 0, 1, 23]) \u279e \"[4.73] *****\"\n\nstar_rating([16, 17, 23, 40, 45]) \u279e \"[3.57] ****\"\nNotes\nRound stars to whole stars.", "code": "def star_rating(lst):\n  x = sum(lst[i] * (i+1) for i in range(len(lst))) / sum(lst)\n  return \"[{:.2f}] {}\".format(x, \"*\" * int(round(x,0)))"}
{"nl": "Method #1: Using For Loop (Star Character)\r\nApproach:\r\nGive the number of rows of the x pattern as static input and store it in a variable.\r\nLoop from 0 to the number of rows using For loop.\r\nLoop from 0 to the number of rows using another For loop(Inner For loop).\r\nCheck if the parent loop iterator value is equal to the inner loop iterator value or if the inner loop iterator value is equal to the number of rows-parent loop iterator value-1 using If conditional Statement.\r\nPrint the star character with space if the condition is true.\r\nElse print space character.\r\nPrint the newline character after the end of the inner For loop.\r\nThe Exit of the program.", "code": "# Give the number of rows of the x pattern as static input and store it in a variable.\r\nxrows=10\r\n\r\n#Loop from 0 to the number of rows using For loop.\r\nfor m in range(0, xrows):\r\n    # Loop from 0 to the number of rows using another For loop(Inner For loop).\r\n    for n in range(0, xrows):\r\n        '''Check if the parent loop iterator value is equal to the inner loop \r\n        iterator value or if the inner loop iterator value is equal to the number\r\n        of rows-parent loop iterator value-1 using If conditional Statement.'''\r\n        if(m==n or n==xrows - 1 - m):\r\n          #Print the star character with space if the condition is true.\r\n          print('*',end=' ')\r\n        else:\r\n          #Else print space character.\r\n          print(' ',end=' ')\r\n     #Print the newline character after the end of the inner For loop.      \r\n    print()"}
{"nl": "A keyboard and a mouse cost in total x, knowing that the keyboard costs y more than the mouse, calculate the price of the mouse. Round the price of the mouse.\nExamples\nKM({\"Total\": \"10.00$\", \"Difference\": \"0.40$\", \"Mouse\": \"?\"})\n\u279e {\"Total\": \"10.00$\", \"Difference\":\"0.40$\", \"Mouse\": \"4.8$\"}\n\nKM({\"Total\": \"90.00$\", \"Difference\": \"5.40$\", \"Mouse\": \"?\"})\n\u279e {\"Total\": \"90.00$\", \"Difference\": \"5.40$\", \"Mouse\": \"42.3$\"}\n\nKM({\"Total\": \"1.30$\", \"Difference\": \"0.80$\", \"Mouse\": \"?\"})\n\u279e {\"Total\": \"1.30$\", \"Difference\": \"0.80$\", \"Mouse\": \"0.25$\"}\nNotes\nIf you get stuck, check the Resources tab.", "code": "def KM(table):\n    c = round((float(table[\"Total\"][:-1]) - float(table[\"Difference\"][:-1])) / 2, )\n    table[\"Mouse\"] = \"{}$\".format(c)\n    return table"}
{"nl": "Create a function that takes a string as an argument. The function must return a string containing 1s and 0s based on the string argument's words. If any word in the argument is not equal to \"zero\" or \"one\" (case insensitive), you should ignore it. The returned string's length should be a multiple of 8, if the string is not a multiple of 8 you should remove the numbers in excess.\nExamples\ntext_to_number_binary(\"zero one zero one zero one zero one\") \u279e \"01010101\"\n\ntext_to_number_binary(\"Zero one zero ONE zero one zero one\") \u279e \"01010101\"\n\ntext_to_number_binary(\"zero one zero one zero one zero one one two\") \u279e \"01010101\"\n\ntext_to_number_binary(\"zero one zero one zero one zero three\") \u279e \"\"\n\ntext_to_number_binary(\"one one\") \u279e \"\"\nNotes\nYou must return the result as a string.", "code": "def text_to_number_binary(txt):\n  s = ''.join('1' if t.lower()=='one' else '0' if t.lower()=='zero' else '' for   txt.split(' '))\n  return s[:(8*(len(s)//8))]"}
{"nl": "Given a Binary Tree where all values are from 0 to n-1. Construct an ancestor matrix mat[n][n]. Ancestor matrix is defined as below.\n\nmat[i][j] = 1 if i is ancestor of j\r\nmat[i][j] = 0, otherwise", "code": "# Python3 program to construct ancestor\r\n# matrix for given tree.\r\nsize = 6\r\n\r\nM = [[0 for j in range(size)]\r\n\t\tfor i in range(size)]\r\n\r\n# A binary tree node\r\nclass Node:\r\n\t\r\n\tdef __init__(self, data):\r\n\t\t\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\t\tself.data = data\r\n\t\t\r\n# Helper function to create a new node\r\ndef newnode(data):\r\n\r\n\ttemp = Node(data)\r\n\t\r\n\treturn temp\r\n\r\ndef printMatrix():\r\n\t\r\n\tfor i in range(size):\r\n\t\tfor j in range(size):\r\n\t\t\tprint(M[i][j], end = ' ')\r\n\t\t\r\n\t\tprint()\t\r\n\r\n# First PreOrder Traversal\r\ndef MatrixUtil(root, index):\r\n\t\r\n\tif (root == None):\r\n\t\treturn\r\n\t\r\n\tpreData = root.data\r\n\t\t\t\r\n\t# Since there is no ancestor for\r\n\t# root node, so we doesn't assign\r\n\t# it's value as 1\t\t\r\n\tif (index == -1):\r\n\t\tindex = root.data\r\n\telse:\r\n\t\tM[index][preData] = 1\r\n\t\r\n\tMatrixUtil(root.left, preData)\r\n\tMatrixUtil(root.right, preData)\r\n\r\ndef Matrix(root):\r\n\t\r\n\t# Call Func MatrixUtil\r\n\tMatrixUtil(root, -1)\r\n\t\r\n\t# Applying Transitive Closure\r\n\t# for the given Matrix\r\n\tfor i in range(size):\r\n\t\tfor j in range(size):\r\n\t\t\tfor k in range(size):\r\n\t\t\t\tM[j][k] = (M[j][k] or\r\n\t\t\t\t\t\t(M[j][i] and\r\n\t\t\t\t\t\tM[i][k]))\r\n\t\r\n\t# Printing Matrix\r\n\tprintMatrix()\r\n\r\n# Driver code\r\nif __name__==\"__main__\":\r\n\t\r\n\troot = newnode(5)\r\n\troot.left = newnode(1)\r\n\troot.right = newnode(2)\r\n\troot.left.left = newnode(0)\r\n\troot.left.right = newnode(4)\r\n\troot.right.left = newnode(3)\r\n\r\n\tMatrix(root)\r\n\t\r\n# This code is contributed by rutvik_56\r"}
{"nl": "Create a function that returns True if smaller lists can concatenate to form the target list and False otherwise.\nExamples\ncanConcatenate([[1, 2, 3, 4], [5, 6], [7]], [1, 2, 3, 4, 5, 6, 7]) \u279e True\n\ncanConcatenate([[2, 1, 3], [5, 4, 7, 6]], [7, 6, 5, 4, 3, 2, 1]) \u279e True\n\ncanConcatenate([[2, 1, 3], [5, 4, 7, 6, 7]], [1, 2, 3, 4, 5, 6, 7]) \u279e False\n# Duplicate 7s not found in target list.\n\ncanConcatenate([[2, 1, 3], [5, 4, 7]], [1, 2, 3, 4, 5, 6, 7]) \u279e False\n# Missing 6 from target list.\nNotes\nLists do not have to be sorted (see example #2).\nLists should concatenate to create the final list exactly (see examples #3 and #4).", "code": "def canConcatenate(lst, target):\n  return sorted(sum(lst,[])) == sorted(target)"}
{"nl": "Upper Triangular Matrix:\r\n\r\nAn upper triangular matrix is a square matrix in which all of the entries below the major diagonal are zero. Given a matrix and the task is to display an upper triangular matrix of the given matrix in Python.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[5, 3, 2], [6, 1, 5], [4, 8, 2]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\nprint(\"The Upper Triangular matrix of the given matrix is :\")\r\n# To print all the elements of the given matrix.\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n is greater than m using the if conditional statement where n\r\n      # is the iterator value of the parent For loop and m is the iterator value of the\r\n      # inner For loop.\r\n        if n > m:\r\n          # If the statement is true, then print 0.\r\n            print(\"0 \", end=\"\")\r\n        else:\r\n          # Else Print the element of the matrix by printing gvnmatrix[n][m] value.\r\n            print(mtrx[n][m], end=\" \")\r\n    print()"}
{"nl": "A rational number is defined as the quotient of two integers a and b, called the numerator and denominator, respectively, where b != 0.\n", "code": "from __future__ import division\nimport math\nclass Rational(object):\n    def __init__(self, numer, denom):\n        gcd = math.gcd(numer, denom)\n        self.numer = int(numer / gcd)\n        self.denom = int(denom / gcd)\n        if numer < 0 or denom < 0:\n            self.numer = -1 * abs(self.numer)\n            self.denom = abs(self.denom)\n            \n    def __eq__(self, other):\n        return self.numer == other.numer and self.denom == other.denom\n    def __repr__(self):\n        return '{}/{}'.format(self.numer, self.denom)\n    def __add__(self, other):\n        return Rational(self.numer*other.denom + self.denom*other.numer,\n                        self.denom * other.denom)\n    def __sub__(self, other):\n        return Rational(self.numer*other.denom - self.denom*other.numer,\n                        self.denom * other.denom)\n    def __mul__(self, other):\n        return Rational(self.numer*other.numer, self.denom * other.denom)\n    def __truediv__(self, other):\n        if (self.numer < 0 and other.numer < 0) or (self.numer > 0 and other.numer > 0):\n            return Rational(abs(self.numer*other.denom), abs(self.denom * other.numer))\n        else:\n            return Rational(-1*abs(self.numer*other.denom), abs(self.denom * other.numer))\n    def __abs__(self):\n        return Rational(abs(self.numer),abs(self.denom))\n    def __pow__(self, power):\n        if type(power) is int and power >= 0:\n            return Rational(self.numer ** power,self.denom ** power)\n        elif type(power) is int and power < 0:\n            return Rational(self.denom ** abs(power),self.numer ** abs(power))\n        else:\n            return self.numer ** power / self.denom ** power\n    def __rpow__(self, base):\n        return math.pow(base**self.numer, 1/self.denom)"}
{"nl": "Swapping Three Variables Without Using any Temporary Variable Using Arithmetic Operators (Static Input)", "code": "# Give the first number as static input and store it in a variable.\r\nfst_numb = 30\r\n# Give the second number as static input and store it in another variable.\r\nscnd_numb = 45\r\n# Give the third number as static input and store it in another variable.\r\nthrd_numb = 21\r\nprint(\"The above given three numbers before swapping :\")\r\nprint(\"first number = \", fst_numb, \"second number = \",\r\n      scnd_numb, \"third number = \", thrd_numb)\r\n# Add first, second, and third numbers and assign the result to the first number.\r\nfst_numb = fst_numb + scnd_numb + thrd_numb\r\n# Add second, and third numbers and subtract the result from the given first number.\r\n# Assign the result to the second number.\r\nscnd_numb = fst_numb - (scnd_numb+thrd_numb)\r\n# Add second, and third numbers and subtract the result from the given first number.\r\n# Assign the result to the given third number.\r\nthrd_numb = fst_numb - (scnd_numb+thrd_numb)\r\n# Add second, and third numbers and subtract the result from the given first number.\r\n# Assign the result to the given first number.\r\nfst_numb = fst_numb - (scnd_numb+thrd_numb)\r\n# Print the given three numbers after swapping without using a temporary variable.\r\nprint(\"The above given three numbers after swapping without using temporary variable:\")\r\nprint(\"first number = \", fst_numb, \"second number = \",\r\n      scnd_numb, \"third number = \", thrd_numb)"}
{"nl": "Create a function that takes a number num and returns the first 10 multiples of num with 1 added to it, separated by commas.\nExamples\nn_tables_plus_one(7) \u279e \"8,15,22,29,36,43,50,57,64,71\"\n\nn_tables_plus_one(1) \u279e \"2,3,4,5,6,7,8,9,10,11\"\n\nn_tables_plus_one(3) \u279e \"4,7,10,13,16,19,22,25,28,31\"\nNotes\nThere is no comma after the last number.", "code": "def n_tables_plus_one(num):\n  return ','.join(str(num * n + 1) for n in range(1, 11))"}
{"nl": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\n\nReturn the maximum distance between two houses with different colors.\n\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.\n\n ", "code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans  = 0\n        for i, color in enumerate(colors):\n            if color != colors[0]: ans = max(ans, i)\n            if color != colors[-1]: ans = max(ans, len(colors) - 1 - i)\n        return ans"}
{"nl": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character\n \n\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n \n\nConstraints:\n\n0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.", "code": "class Solution:\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        n = len(word1)\n        m = len(word2)\n        \n        # if one of the strings is empty\n        if n * m == 0:\n            return n + m\n        \n        # array to store the convertion history\n        d = [ [0] * (m + 1) for _ in range(n + 1)]\n        \n        # init boundaries\n        for i in range(n + 1):\n            d[i][0] = i\n        for j in range(m + 1):\n            d[0][j] = j\n        \n        # DP compute \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                left = d[i - 1][j] + 1\n                down = d[i][j - 1] + 1\n                left_down = d[i - 1][j - 1] \n                if word1[i - 1] != word2[j - 1]:\n                    left_down += 1\n                d[i][j] = min(left, down, left_down)\n        \n        return d[n][m]"}
{"nl": "In this example, we'll learn to convert kilometers to miles and display it.", "code": "# Taking kilometers input from the user\nkilometers = float(input(\"Enter value in kilometers: \"))\n\n# conversion factor\nconv_fac = 0.621371\n\n# calculate miles\nmiles = kilometers * conv_fac\nprint('%0.2f kilometers is equal to %0.2f miles' %(kilometers,miles))"}
{"nl": "You are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1.\n\nYou are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, either directly or indirectly through other people.\n\nInitially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, where requests[j] = [uj, vj] is a friend request between person uj and person vj.\n\nA friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), and upon a successful request, uj and vj become direct friends for all future friend requests.\n\nReturn a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not.\n\nNote: If uj and vj are already direct friends, the request is still successful", "code": "class UniSet:\n    def __init__(self, n):\n        self.uni = list(range(n))\n        self.rep = [1 << i for i in range(n)]\n        self.cnf = [0] * n\n    \n    def find(self, x):\n        if self.uni[x] != x: self.uni[x] = self.find(self.uni[x])\n        return self.uni[x]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def check_merge(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if self.cnf[x] & self.rep[y] | self.rep[x] & self.cnf[y]: return False\n        x, y = min(x, y), max(x, y)\n        self.uni[y] = x\n        self.rep[x] |= self.rep[y]\n        self.cnf[x] |= self.cnf[y]\n        return True\n\nclass Solution:\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n        uni = UniSet(n)\n        for x, y in restrictions:\n            uni.cnf[x] |= 1 << y\n            uni.cnf[y] |= 1 << x\n        return [uni.check_merge(x, y) for x, y in requests]"}
{"nl": "You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.\n\nReturn the string that represents the kth largest integer in nums.\n\nNote: Duplicate numbers should be counted distinctly. For example, if nums is [\"1\",\"2\",\"2\"], \"2\" is the first largest integer, \"2\" is the second-largest integer, and \"1\" is the third-largest integer.", "code": "class Solution(object):\n    def kthLargestNumber(self, nums, k):\n        \"\"\"\n        :type nums: List[str]\n        :type k: int\n        :rtype: str\n        \"\"\"\n        nums.sort(reverse = True, key=lambda x:int(x))\n        return nums[k-1]"}
{"nl": "Exercise 6: Generate a random Password which meets the following conditions:\nPassword length must be 10 characters long.\nIt must contain at least 2 upper case letters, 1 digit, and 1 special symbol.", "code": "import random\r\nimport string\r\n\r\ndef randomPassword():\r\n    randomSource = string.ascii_letters + string.digits + string.punctuation\r\n    password = random.sample(randomSource, 6)\r\n    password += random.sample(string.ascii_uppercase, 2)\r\n    password += random.choice(string.digits)\r\n    password += random.choice(string.punctuation)\r\n\r\n    passwordList = list(password)\r\n    random.SystemRandom().shuffle(passwordList)\r\n    password = ''.join(passwordList)\r\n    return password\r\n\r\nprint (\"Password is \", randomPassword())"}
{"nl": "Given a list, the task is to write a program to print all perfect squares from the given list using list comprehension and Math Module.\n \n Using list comprehension and the math module, you\u2019ll learn how to check whether the elements in a Python list entered by the user are perfect squares or not.\n \n \n \n List comprehensions are a neat trick that allows us to create a new list depending on the values of an existing list in only one line, making the code look shorter and more concise because we aren\u2019t committing to the problem with an entire loop.\n Python\u2019s math module is a highly valuable tool because it offers a large number of mathematical functions that we may utilize in our programs.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given list =[19, 24, 25, 36, 81, 144, 600, 900, 225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n Output:\n \n The given list is = [19, 24, 25, 36, 81, 144, 600, 900, 225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n The perfect squares numbers of the given list is = [25, 36, 81, 144, 900, 225, 4, 9, 1, 16, 49, 49, 25, 25]\n Example2:\n \n Input:\n \n Given list =[37, 82, 81, 467, 839, 8383, 1000, 1900, 10000, 9, 48, 49, 64, 121, 56]\n Output:\n \n Enter some random List Elements separated by spaces = 37 82 81 467 839 8383 1000 1900 10000 9 48 49 64 121 56\n The given list is = [37, 82, 81, 467, 839, 8383, 1000, 1900, 10000, 9, 48, 49, 64, 121, 56]\n The perfect squares numbers of the given list is = [81, 10000, 9, 49, 64, 121]", "code": "# Import the math module using the import statement.\n import math\n # Give the list as static input and store it in a variable.\n gvnlst = [19, 24, 25, 36, 81, 144, 600, 900,\n  225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n print('The given list is =', gvnlst)\n # Using List comprehension, floor(), and sqrt() functions\n # to check whether the element value of the list is a perfect square or not.\n # (An Element is said to be a perfect square if the floor value of the square root\n # of the number is equal to the sqrt of the number)\n prftsquareslist = [elemen for elemen in gvnlst if (\n  math.sqrt(elemen) == math.floor(math.sqrt(elemen)))]\n # Print the new list which contains only perfect squares of the original list.\n print('The perfect squares numbers of the given list is =', prftsquareslist)"}
{"nl": "Hamiltonian Path in an undirected graph is a path that visits each vertex exactly once. A Hamiltonian cycle (or Hamiltonian circuit) is a Hamiltonian Path such that there is an edge (in the graph) from the last vertex to the first vertex of the Hamiltonian Path. Determine whether a given graph contains Hamiltonian Cycle or not. If it contains, then prints the path. Following are the input and output of the required function.\nInput: \nA 2D array graph[V][V] where V is the number of vertices in graph and graph[V][V] is adjacency matrix representation of the graph. A value graph[i][j] is 1 if there is a direct edge from i to j, otherwise graph[i][j] is 0.\nOutput: \nAn array path[V] that should contain the Hamiltonian Path. path[i] should represent the ith vertex in the Hamiltonian Path. The code should also return false if there is no Hamiltonian Cycle in the graph.\nFor example, a Hamiltonian Cycle in the following graph is {0, 1, 2, 4, 3, 0}.\n\n(0)--(1)--(2)\n |   / \\   |\n |  /   \\  | \n | /     \\ |\n(3)-------(4)\nAnd the following graph doesn\u2019t contain any Hamiltonian Cycle.\n\n\n\n(0)--(1)--(2)\n |   / \\   |\n |  /   \\  | \n | /     \\ |\n(3)      (4) ", "code": "# Python program for solution of\n# hamiltonian cycle problem\n\nclass Graph():\n\tdef __init__(self, vertices):\n\t\tself.graph = [[0 for column in range(vertices)]\n\t\t\t\t\t\t\tfor row in range(vertices)]\n\t\tself.V = vertices\n\n\t''' Check if this vertex is an adjacent vertex\n\t\tof the previously added vertex and is not\n\t\tincluded in the path earlier '''\n\tdef isSafe(self, v, pos, path):\n\t\t# Check if current vertex and last vertex\n\t\t# in path are adjacent\n\t\tif self.graph[ path[pos-1] ][v] == 0:\n\t\t\treturn False\n\n\t\t# Check if current vertex not already in path\n\t\tfor vertex in path:\n\t\t\tif vertex == v:\n\t\t\t\treturn False\n\n\t\treturn True\n\n\t# A recursive utility function to solve\n\t# hamiltonian cycle problem\n\tdef hamCycleUtil(self, path, pos):\n\n\t\t# base case: if all vertices are\n\t\t# included in the path\n\t\tif pos == self.V:\n\t\t\t# Last vertex must be adjacent to the\n\t\t\t# first vertex in path to make a cycle\n\t\t\tif self.graph[ path[pos-1] ][ path[0] ] == 1:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\n\t\t# Try different vertices as a next candidate\n\t\t# in Hamiltonian Cycle. We don't try for 0 as\n\t\t# we included 0 as starting point in hamCycle()\n\t\tfor v in range(1,self.V):\n\n\t\t\tif self.isSafe(v, pos, path) == True:\n\n\t\t\t\tpath[pos] = v\n\n\t\t\t\tif self.hamCycleUtil(path, pos+1) == True:\n\t\t\t\t\treturn True\n\n\t\t\t\t# Remove current vertex if it doesn't\n\t\t\t\t# lead to a solution\n\t\t\t\tpath[pos] = -1\n\n\t\treturn False\n\n\tdef hamCycle(self):\n\t\tpath = [-1] * self.V\n\n\t\t''' Let us put vertex 0 as the first vertex\n\t\t\tin the path. If there is a Hamiltonian Cycle,\n\t\t\tthen the path can be started from any point\n\t\t\tof the cycle as the graph is undirected '''\n\t\tpath[0] = 0\n\n\t\tif self.hamCycleUtil(path,1) == False:\n\t\t\tprint (\"Solution does not exist\\n\")\n\t\t\treturn False\n\n\t\tself.printSolution(path)\n\t\treturn True\n\n\tdef printSolution(self, path):\n\t\tprint (\"Solution Exists: Following\",\n\t\t\t\t\"is one Hamiltonian Cycle\")\n\t\tfor vertex in path:\n\t\t\tprint (vertex, end = \" \")\n\t\tprint (path[0], \"\\n\")\n\n# Driver Code\n\n''' Let us create the following graph\n\t(0)--(1)--(2)\n\t| / \\ |\n\t| / \\ |\n\t| /\t \\ |\n\t(3)-------(4) '''\ng1 = Graph(5)\ng1.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1],\n\t\t\t[0, 1, 0, 0, 1,],[1, 1, 0, 0, 1],\n\t\t\t[0, 1, 1, 1, 0], ]\n\n# Print the solution\ng1.hamCycle();\n\n''' Let us create the following graph\n\t(0)--(1)--(2)\n\t| / \\ |\n\t| / \\ |\n\t| /\t \\ |\n\t(3)\t (4) '''\ng2 = Graph(5)\ng2.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1],\n\t\t[0, 1, 0, 0, 1,], [1, 1, 0, 0, 0],\n\t\t[0, 1, 1, 0, 0], ]\n\n# Print the solution\ng2.hamCycle();\n\n# This code is contributed by Divyanshu Mehta"}
{"nl": "Dictionaries in Python:\n\nDictionary is a mutable built-in Python Data Structure. It is conceptually related to List, Set, and Tuples. It is, however, indexed by keys rather than a sequence of numbers and can be thought of as associative arrays. On a high level, it consists of a key and its associated value. The Dictionary class in Python represents a hash-table implementation.\n\nGiven a string , the task is to create a Python program for creating a dictionary with the Key as the first character and the Value as words beginning with that character.", "code": "# Scanning the given string\ngiven_string = input(\"Enter some random string separated by spaces = \")\n# Split the given string into words using split() function\n# Convert this into list using list() function.\nlistString = given_string.split()\n# Declare a dictionary which is empty using {} or dict()\nresultdict = {}\n# Traverse the list String\nfor stringword in listString:\n  # checking if the first character of the word exists in dictionary resultdict keys or not\n    if(stringword[0] not in resultdict.keys()):\n        resultdict[stringword[0]] = []\n        # adding this character to the resultdict\n        resultdict[stringword[0]].append(stringword)\n    else:\n      # If it is present, add the word to the associated sublist as the value.\n        if(stringword not in resultdict[stringword[0]]):\n            resultdict[stringword[0]].append(stringword)\nfor key, value in resultdict.items():\n    print(key, \":::\", value)"}
{"nl": "Create a function that checks if a given integer is exactly the factorial of an integer or not. True if it is, False otherwise.\nExamples\nis_factorial(2) \u279e True\n# 2 = 2 * 1 = 2!\n\nis_factorial(27) \u279e False\n\nis_factorial(24) \u279e True\n# 24 = 4 * 3 * 2 * 1 = 4!\nNotes\nNo error handling is necessary. Inputs are all positive integers.\nAlternatively, you can solve this with a recursive approach.\nThere are similar versions of this challenge that is a bit more challenging than this one (a recursive and a non-recursive).", "code": "def is_factorial(n):\n  i,f = 1,1\n  while f < n:\n    i+=1\n    f*= i\n  return n == f"}
{"nl": "The problem is to find the shortest distance between all pairs of vertices in a weighted directed graph that can have negative edge weights. For the problem to be well-defined, there should be no cycles in the graph with a negative total weight.", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def __len__(self):\n        return len(self.vertices)\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef floyd_warshall(g):\n    \"\"\"Return dictionaries distance and next_v.\n\u00a0\n    distance[u][v] is the shortest distance from vertex u to v.\n    next_v[u][v] is the next vertex after vertex v in the shortest path from u\n    to v. It is None if there is no path between them. next_v[u][u] should be\n    None for all u.\n\u00a0\n    g is a Graph object which can have negative edge weights.\n    \"\"\"\n    distance = {v:dict.fromkeys(g, float('inf')) for v in g}\n    next_v = {v:dict.fromkeys(g, None) for v in g}\n\u00a0\n    for v in g:\n        for n in v.get_neighbours():\n            distance[v][n] = v.get_weight(n)\n            next_v[v][n] = n\n\u00a0\n    for v in g:\n         distance[v][v] = 0\n         next_v[v][v] = None\n\u00a0\n    for p in g: \n        for v in g:\n            for w in g:\n                if distance[v][w] > distance[v][p] + distance[p][w]:\n                    distance[v][w] = distance[v][p] + distance[p][w]\n                    next_v[v][w] = next_v[v][p]\n\u00a0\n    return distance, next_v\n\u00a0\n\u00a0\ndef print_path(next_v, u, v):\n    \"\"\"Print shortest path from vertex u to v.\n\u00a0\n    next_v is a dictionary where next_v[u][v] is the next vertex after vertex u\n    in the shortest path from u to v. It is None if there is no path between\n    them. next_v[u][u] should be None for all u.\n\u00a0\n    u and v are Vertex objects.\n    \"\"\"\n    p = u\n    while (next_v[p][v]):\n        print('{} -> '.format(p.get_key()), end='')\n        p = next_v[p][v]\n    print('{} '.format(v.get_key()), end='')\n\u00a0\n\u00a0\ng = Graph()\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('floyd-warshall')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'floyd-warshall':\n        distance, next_v = floyd_warshall(g)\n        print('Shortest distances:')\n        for start in g:\n            for end in g:\n                if next_v[start][end]:\n                    print('From {} to {}: '.format(start.get_key(),\n                                                    end.get_key()),\n                            end = '')\n                    print_path(next_v, start, end)\n                    print('(distance {})'.format(distance[start][end]))\n\u00a0\n    elif operation == 'display':\n        print('Vertices: ', end='')\n        for v in g:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in g:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "In the previous article, we have discussed about CPP11 \u2013 Variadic Template Function | Tutorial & Examples. Let us learn how to Print Identity Matrix in C++ Program.\n \n What is a matrix:\n \n A matrix is a rectangular numeric sequence separated into columns and rows. A matrix element, also known as an entry, is a number that occurs in a matrix.\n \n Example:\n \n \n \n The matrix shown above has 5 rows and 4 columns, with entries ranging from 1 to 20.\n \n The dimensions of a matrix reflect the number of rows and columns in this sequence.\n \n \n \n Because there are 5 rows and 4 columns, this is referred to as a 5*4 matrix.\n \n We will learn how to print an identity matrix in Python in this lesson. If all of the diagonal elements of a matrix from the upper left corner to the bottom right corner are 1, and all other members are 0, the matrix is said to be an identity matrix.\n We also need to understand the terms \u2018row\u2019 and \u2018column\u2019 in relation to matrices. A matrix with m rows and n columns is referred to as a (m x n) matrix. It is worth noting that the identity matrix is also referred to as the unit matrix. For an identity matrix, the row count equals the column count.\n \n \n \n As a result, identity matrices are defined by their size rather than by their row and column. If the size is \u2018n,\u2019 it will contain \u2018n\u2019 rows and \u2018n\u2019 columns. These matrices with equal row and column sizes are also known as square matrices.\n \n Given the dimension of the square matrix ,the task is to print the identity matrix of dimensions n*n in C++\n \n Examples:\n \n Example1:\n \n Input:\n \n given dimension=10\n Output:\n \n 1 0 0 0 0 0 0 0 0 0 \n 0 1 0 0 0 0 0 0 0 0 \n 0 0 1 0 0 0 0 0 0 0 \n 0 0 0 1 0 0 0 0 0 0 \n 0 0 0 0 1 0 0 0 0 0 \n 0 0 0 0 0 1 0 0 0 0 \n 0 0 0 0 0 0 1 0 0 0 \n 0 0 0 0 0 0 0 1 0 0 \n 0 0 0 0 0 0 0 0 1 0 \n 0 0 0 0 0 0 0 0 0 1\n Example2:\n \n Input:\n \n given dimension=7\n Output:\n \n 1 0 0 0 0 0 0 \n 0 1 0 0 0 0 0 \n 0 0 1 0 0 0 0 \n 0 0 0 1 0 0 0 \n 0 0 0 0 1 0 0 \n 0 0 0 0 0 1 0 \n 0 0 0 0 0 0 1", "code": "#include \n using namespace std;\n // function which prints the identity matrix of the given\n // dimension\n int printIdentityMat(int dimen)\n { // taking two variables rownum and colnum of integer type\n  int rownum, colnum;\n  // using nested for loops\n  for (rownum = 0; rownum < dimen; rownum++) {\n  for (colnum = 0; colnum < dimen; colnum++) {\n  // if the rownum is equal to colnum then print 1\n  if (rownum == colnum)\n  cout << 1 << \" \";\n  // else print 0\n  else\n  cout << 0 << \" \";\n  }\n  cout << endl;\n  }\n  return 0;\n }\n // Driver Code\n int main()\n { // given dimensions\n  int dimensions = 10;\n  // passing the given dimension to printIdentityMat\n  // function to print identity matrix\n  printIdentityMat(dimensions);\n  return 0;\n }"}
{"nl": "You are given an array of n integer and an integer K. Find the number of total unordered pairs {i, j} such that absolute value of (ai + aj \u2013 K), i.e., |ai + aj \u2013 k| is minimal possible where i != j.\nExamples: \n \n\nInput : arr[] = {0, 4, 6, 2, 4}, \n            K = 7\nOutput : Minimal Value = 1\n         Total  Pairs = 5 \nExplanation : Pairs resulting minimal value are :\n              {a1, a3}, {a2, a4}, {a2, a5}, {a3, a4}, {a4, a5} \n\nInput : arr[] = {4, 6, 2, 4}  , K = 9\nOutput : Minimal Value = 1\n         Total Pairs = 4 \nExplanation : Pairs resulting minimal value are :\n              {a1, a2}, {a1, a4}, {a2, a3}, {a2, a4} ", "code": "# Python3 program to find number of pairs\n# and minimal possible value\n\n# function for finding pairs and min value\ndef pairs(arr, n, k):\n\t\n\t# initialize smallest and count\n\tsmallest = 999999999999\n\tcount = 0\n\n\t# iterate over all pairs\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\t\n\t\t\t# is abs value is smaller than smallest\n\t\t\t# update smallest and reset count to 1\n\t\t\tif abs(arr[i] + arr[j] - k) < smallest:\n\t\t\t\tsmallest = abs(arr[i] + arr[j] - k)\n\t\t\t\tcount = 1\n\n\t\t\t# if abs value is equal to smallest\n\t\t\t# increment count value\n\t\t\telif abs(arr[i] + arr[j] - k) == smallest:\n\t\t\t\tcount += 1\n\n\t# print result\n\tprint(\"Minimal Value = \", smallest)\n\tprint(\"Total Pairs = \", count)\n\n# Driver Code\nif __name__ == '__main__':\n\tarr = [3, 5, 7, 5, 1, 9, 9]\n\tk = 12\n\tn = len(arr)\n\tpairs(arr, n, k)\n\t\n# This code is contributed by PranchalK"}
{"nl": "A number n is automorphic if n^2 ends in n.\nFor example: n=5, n^2=25\nCreate a function that takes a number and returns True if the number is automorphic, False if it isn't.\nExamples\nis_automorphic(5) \u279e True\n\nis_automorphic(8) \u279e False\n\nis_automorphic(76) \u279e True\nNotes\nN/A", "code": "def is_automorphic(n):\n  return str(n**2).endswith(str(n))"}
{"nl": "Variables that are created outside of a function (as in all of the examples above) are known as global variables.\r\n\r\nGlobal variables can be used by everyone, both inside of functions and outside.", "code": "x = \"awesome\"\r\n\r\ndef myfunc():\r\n  print(\"Python is \" + x)\r\n\r\nmyfunc()"}
{"nl": "Your task is to create a fence worth $1 million. You are given the price of the material (per character), meaning the length of the fence will change depending on the cost of the material.\nCreate a function which constructs this pricey pricey fence, using the letter \"H\" to build.\nconstruct_fence(\"$50,000\") \u279e \"HHHHHHHHHHHHHHHHHHHHHHHHHHHH\"\n# 20 fence posts were set up ($1,000,000 / $50,000 = 20)\nExamples\nconstruct_fence(\"$50,000\") \u279e \"HHHHHHHHHHHHHHHHHHHHHHHHHHHH\"\n\nconstruct_fence(\"$100,000\") \u279e \"HHHHHHHHHH\"\n\nconstruct_fence(\"$1,000,000\") \u279e \"H\"\nNotes\nYou are ordered to spend all of your $1,000,000 budget...", "code": "def construct_fence(p):\n  p = int(p.replace(',', '')[1:])\n  return 'H' * (1000000//p)"}
{"nl": "Given a matrix of size n \u00d7 m consisting of 0\u2019s and 1\u2019s. We need to find the number of unique cells with value 1 such that the corresponding entire row and the entire column do not have another 1. Return the number of unique cells.", "code": "# Python3 program to count unique cells in\n# a matrix\n\u00a0\nMAX = 100\n\u00a0\n# Returns true if mat[i][j] is unique\ndef isUnique(mat, i, j, n, m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# checking in row calculating sumrow\n\u00a0\u00a0\u00a0\u00a0# will be moving column wise\n\u00a0\u00a0\u00a0\u00a0sumrow = 0\n\u00a0\u00a0\u00a0\u00a0for k in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumrow += mat[i][k]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sumrow > 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# checking in column calculating sumcol\n\u00a0\u00a0\u00a0\u00a0# will be moving row wise\n\u00a0\u00a0\u00a0\u00a0sumcol = 0\n\u00a0\u00a0\u00a0\u00a0for k in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumcol += mat[k][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sumcol > 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\ndef countUnique(mat, n, m):\n\u00a0\u00a0\u00a0\u00a0uniquecount = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] and isUnique(mat, i, j, n, m)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0uniquecount += 1\n\u00a0\u00a0\u00a0\u00a0return uniquecount\n\u00a0\n# Driver code\n\u00a0\nmat = [[0, 1, 0, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 0, 1]]\nprint(countUnique(mat, 3, 4))\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "A Machine Learning model is defined as a mathematical model with a number of parameters that need to be learned from the data. However, there are some parameters, known as Hyperparameters and those cannot be directly learned. They are commonly chosen by humans based on some intuition or hit and trial before the actual training begins. These parameters exhibit their importance by improving the performance of the model such as its complexity or its learning rate. Models can have many hyper-parameters and finding the best combination of parameters can be treated as a search problem.\nSVM also has some hyper-parameters (like what C or gamma values to use) and finding optimal hyper-parameter is a very hard task to solve. But it can be found by just trying all combinations and see what parameters work best. The main idea behind it is to create a grid of hyper-parameters and just try all of their combinations (hence, this method is called Gridsearch, But don\u2019t worry! we don\u2019t have to do it manually because Scikit-learn has this functionality built-in with GridSearchCV.\nGridSearchCV takes a dictionary that describes the parameters that could be tried on a model to train it. The grid of parameters is defined as a dictionary, where the keys are the parameters and the values are the settings to be tested.\nThis article demonstrates how to use the GridSearchCV searching method to find optimal hyper-parameters and hence improve the accuracy/prediction results \n ", "code": "import pandas as pd\nimport numpy as np\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.datasets import load_breast_cancer\nfrom sklearn.svm import SVC\n\ncancer = load_breast_cancer()\n\n# The data set is presented in a dictionary form:\nprint(cancer.keys())\ndf_feat = pd.DataFrame(cancer['data'],\n\t\t\t\t\tcolumns = cancer['feature_names'])\n\n# cancer column is our target\ndf_target = pd.DataFrame(cancer['target'],\n\t\t\t\t\tcolumns =['Cancer'])\n\nprint(\"Feature Variables: \")\nprint(df_feat.info())\nprint(\"Dataframe looks like : \")\nprint(df_feat.head())\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(\n\t\t\t\t\t\tdf_feat, np.ravel(df_target),\n\t\t\t\ttest_size = 0.30, random_state = 101)\n# train the model on train set\nmodel = SVC()\nmodel.fit(X_train, y_train)\n\n# print prediction results\npredictions = model.predict(X_test)\nprint(classification_report(y_test, predictions))\nfrom sklearn.model_selection import GridSearchCV\n\n# defining parameter range\nparam_grid = {'C': [0.1, 1, 10, 100, 1000],\n\t\t\t'gamma': [1, 0.1, 0.01, 0.001, 0.0001],\n\t\t\t'kernel': ['rbf']}\n\ngrid = GridSearchCV(SVC(), param_grid, refit = True, verbose = 3)\n\n# fitting the model for grid search\ngrid.fit(X_train, y_train)\n# print best parameter after tuning\nprint(grid.best_params_)\n\n# print how our model looks after hyper-parameter tuning\nprint(grid.best_estimator_)\ngrid_predictions = grid.predict(X_test)\n\n# print classification report\nprint(classification_report(y_test, grid_predictions))\n"}
{"nl": "Given a n x n matrix of integers and a positive integer k. The problem is to count all sub-matrices having sum divisible by the given value k.\nExamples: \n \nInput : mat[][] = { {5, -1, 6},\n            {-2, 3, 8},\n            {7, 4, -9} }\n\n        k = 4\n\nOutput : 6\nThe index range for the sub-matrices are:\n(0, 0) to (0, 1)\n(1, 0) to (2, 1)\n(0, 0) to (2, 1)\n(2, 1) to (2, 1)\n(0, 1) to (1, 2)\n(1, 2) to (1, 2)\n\n\u00a0", "code": "# Python implementation to\n# count sub-matrices having\n# sum divisible by the\n# value 'k'\n\u00a0\n# function to count all\n# sub-arrays divisible by k\ndef subCount(arr, n, k) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# create auxiliary hash\n\u00a0\u00a0\u00a0\u00a0# array to count frequency\n\u00a0\u00a0\u00a0\u00a0# of remainders\n\u00a0\u00a0\u00a0\u00a0mod = [0] * k;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse original array\n\u00a0\u00a0\u00a0\u00a0# and compute cumulative\n\u00a0\u00a0\u00a0\u00a0# sum take remainder of\n\u00a0\u00a0\u00a0\u00a0# this current cumulative\n\u00a0\u00a0\u00a0\u00a0# sum and increase count\n\u00a0\u00a0\u00a0\u00a0# by 1 for this remainder\n\u00a0\u00a0\u00a0\u00a0# in mod array\n\u00a0\u00a0\u00a0\u00a0cumSum = 0;\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cumSum = cumSum + arr[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as the sum can be\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# negative, taking\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# modulo twice\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mod[((cumSum % k) + k) % k] = mod[\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((cumSum % k) + k) % k] + 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0result = 0; # Initialize result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse mod\n\u00a0\u00a0\u00a0\u00a0for i in range(0, k) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If there are more than\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one prefix subarrays\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# with a particular mod value.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mod[i] > 1) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result + int((mod[i] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(mod[i] - 1)) / 2);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# add the subarrays starting\n\u00a0\u00a0\u00a0\u00a0# from the arr[i] which are\n\u00a0\u00a0\u00a0\u00a0# divisible by k itself\n\u00a0\u00a0\u00a0\u00a0result = result + mod[0];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return result;\n\u00a0\n# function to count all\n# sub-matrices having sum\n# divisible by the value 'k'\ndef countSubmatrix(mat, n, k) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Variable to store\n\u00a0\u00a0\u00a0\u00a0# the final output\n\u00a0\u00a0\u00a0\u00a0tot_count = 0;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0temp = [0] * n;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Set the left column\n\u00a0\u00a0\u00a0\u00a0for left in range(0, n - 1) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Set the right column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for the left column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# set by outer loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for right in range(left, n) :\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum between\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current left and right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for every row 'i'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(0, n) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp[i] = (temp[i] +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][right]);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Count number of subarrays\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in temp having sum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# divisible by 'k' and then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# add it to 'tot_count'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tot_count = (tot_count +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subCount(temp, n, k));\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# required count of\n\u00a0\u00a0\u00a0\u00a0# sub-matrices having\n\u00a0\u00a0\u00a0\u00a0# sum divisible by 'k'\n\u00a0\u00a0\u00a0\u00a0return tot_count;\n\u00a0\n# Driver Code\nmat = [[5, -1, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[-2, 3, 8],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[7, 4, -9]];\nn = 3;\nk = 4;\nprint (\"Count = {}\" . format(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0countSubmatrix(mat, n, k)));\n\u00a0\n# This code is contributed by\n# Manish Shaw(manishshaw1)\n"}
{"nl": "Given a square matrix of order n*n, you have to interchange the elements of both diagonals. \nExamples : \n\nInput : matrix[][] = {1, 2, 3,\n                      4, 5, 6,\n                      7, 8, 9} \nOutput : matrix[][] = {3, 2, 1,\n                       4, 5, 6,\n                       9, 8, 7} \n\nInput : matrix[][] = {4,  2,  3,  1,\n                      5,  7,  6,  8,\n                      9, 11, 10, 12,\n                     16, 14, 15, 13} \nOutput : matrix[][] = {1,  2,  3,  4,\n                       5,  6,  7,  8,\n                       9, 10, 11, 12,\n                      11, 14, 15, 16}\n\n\u00a0", "code": "# Python program to interchange\n# the diagonals of matrix\nN = 3;\n\u00a0\n# Function to interchange diagonals\ndef interchangeDiagonals(array):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# swap elements of diagonal\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i != N / 2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = array[i][i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0array[i][i] = array[i][N - i - 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0array[i][N - i - 1] = temp;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(array[i][j], end = \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print();\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0array = [ 4, 5, 6 ],[ 1, 2, 3 ],[ 7, 8, 9 ];\n\u00a0\u00a0\u00a0\u00a0interchangeDiagonals(array);\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by Rajput-Ji\n"}
{"nl": "The math.erfc() method returns the complementary error function of a number.\r\n\r\nThis method accepts a value between - inf and + inf, and returns a value between 0 and 2.\r\n\r\n", "code": "# Import math Library\r\nimport math\r\n\r\n# Print complementary error function for different numbers\r\nprint (math.erfc(0.67))\r\nprint (math.erfc(1.34))\r\nprint (math.erfc(-6))"}
{"nl": "The math.acosh() method returns the inverse hyperbolic cosine of a number.\r\n\r\nNote: The parameter passed in acosh() must be greater than or equal to 1.", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the inverse hyperbolic cosine of different numbers\r\nprint (math.acosh(7))\r\nprint (math.acosh(56))\r\nprint (math.acosh(2.45))\r\nprint (math.acosh(1))"}
{"nl": "For each challenge of this series you do not need to submit a function. Instead, you need to submit a formatted template string to get a certain outcome.\nWrite a template string according to the following example:\nExample\ntemplate = \"yourtemplatestringhere\"\ntemplate.format(\"name\", me = \"John\", him = \"Joe\") \u279e \"My name is John. His name is Joe.\"\nTips\nYou can pass keyword arguments to .format() that can then be accessed by placing the key inside a place holder.\nFor example:\n\"I'm {age} years old.\".format(age = 30) \u279e \"I'm 30 years old.\"\nNotes\nSubmit a string, not a function.\nDo not change the name of the variable template.\nYou can find all the exercises in this series over here.", "code": "template = \"My {0} is {me}. His {0} is {him}.\""}
{"nl": "There are many situations where we use integer values as index in array to see presence or absence, we can use bit manipulations to optimize space in such problems.\r\nLet us consider below problem as an example.\r\nGiven two numbers say a and b, mark the multiples of 2 and 5 between a and b using less than O(|b \u2013 a|) space and output each of the multiples. ", "code": "# Python3 code to for marking multiples\r\nimport math\r\n\r\n# index >> 5 corresponds to dividing index by 32\r\n# index & 31 corresponds to modulo operation of\r\n# index by 32\r\n\r\n# Function to check value of bit position whether\r\n# it is zero or one\r\ndef checkbit( array, index):\r\n\treturn array[index >> 5] & (1 << (index & 31))\r\n\r\n# Sets value of bit for corresponding index\r\ndef setbit( array, index):\r\n\tarray[index >> 5] |= (1 << (index & 31))\r\n\r\n# Driver code\r\na = 2\r\nb = 10\r\nsize = abs(b - a)\r\n\r\n# Size that will be used is actual_size/32\r\n# ceil is used to initialize the array with\r\n# positive number\r\nsize = math.ceil(size / 32)\r\n\t\r\n# Array is dynamically initialized as\r\n# we are calculating size at run time\r\narray = [0 for i in range(size)]\r\n\r\n# Iterate through every index from a to b and\r\n# call setbit() if it is a multiple of 2 or 5\r\nfor i in range(a, b + 1):\r\n\tif (i % 2 == 0 or i % 5 == 0):\r\n\t\tsetbit(array, i - a)\r\n\r\nprint(\"MULTIPLES of 2 and 5:\")\r\nfor i in range(a, b + 1):\r\n\tif (checkbit(array, i - a)):\r\n\t\tprint(i, end = \" \")\r\n\r\n# This code is contributed by rohitsingh07052\r"}
{"nl": "You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2p - 1] in their binary representations. You are allowed to do the following operation any number of times:\n\nChoose two elements x and y from nums.\nChoose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.\nFor example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.\n\nFind the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.\n\nNote: The answer should be the minimum product before the modulo operation is done.\n\n ", "code": "class Solution:\n    def minNonZeroProduct(self, p: int) -> int:\n        x = (1 << p) - 1\n        return pow(x-1, (x-1)//2, 1_000_000_007) * x % 1_000_000_007"}
{"nl": "Files in Python:\n\nPython file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python\u2019s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.\n\nGiven a file, the task is to write a list content into the given File.", "code": "# Give the list as static input and store it in a variable.\ngvn_lst = ['hello', 'this', 'is', 'Btechgeeks', 'good morning']\n# Make a single variable to store the path of the file. This is a constant value. \n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\nwith open(givenFilename, 'w') as givenfilecontent:\n  # Iterate in the above given list using the for loop\n  for itr in gvn_lst:\n  # Write the iterator value(list elements) into the file using the write() function\n  givenfilecontent.write(\"%s\\n\" % itr)\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nfilecontent = open(\"samplefile.txt\")\n# Read the above file using the read() function(get the content) and print it.\nprint(filecontent.read())"}
{"nl": "Given a text txt[0..n-1] and a pattern pat[0..m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] and its permutations (or anagrams) in txt[]. You may assume that n > m. ", "code": "# Python program to search all\r\n# anagrams of a pattern in a text\r\n \r\nMAX=256\r\n \r\n# This function returns true\r\n# if contents of arr1[] and arr2[]\r\n# are same, otherwise false.\r\ndef compare(arr1, arr2):\r\n    for i in range(MAX):\r\n        if arr1[i] != arr2[i]:\r\n            return False\r\n    return True\r\n     \r\n# This function search for all\r\n# permutations of pat[] in txt[] \r\ndef search(pat, txt):\r\n \r\n    M = len(pat)\r\n    N = len(txt)\r\n \r\n    # countP[]:  Store count of\r\n    # all characters of pattern\r\n    # countTW[]: Store count of\r\n    # current window of text\r\n    countP = [0]*MAX\r\n \r\n    countTW = [0]*MAX\r\n \r\n    for i in range(M):\r\n        (countP[ord(pat[i]) ]) += 1\r\n        (countTW[ord(txt[i]) ]) += 1\r\n \r\n    # Traverse through remaining\r\n    # characters of pattern\r\n    for i in range(M,N):\r\n \r\n        # Compare counts of current\r\n        # window of text with\r\n        # counts of pattern[]\r\n        if compare(countP, countTW):\r\n            print(\"Found at Index\", (i-M))\r\n \r\n        # Add current character to current window\r\n        (countTW[ ord(txt[i]) ]) += 1\r\n \r\n        # Remove the first character of previous window\r\n        (countTW[ ord(txt[i-M]) ]) -= 1\r\n     \r\n    # Check for the last window in text   \r\n    if compare(countP, countTW):\r\n        print(\"Found at Index\", N-M)\r\n         \r\n# Driver program to test above function      \r\ntxt = \"BACDGABCDA\"\r\npat = \"ABCD\"      \r\nsearch(pat, txt)  \r\n \r\n# This code is contributed\r\n# by Upendra Singh Bartwal"}
{"nl": "You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.\nYou can apply either of the following two operations any number of times and in any order on s:\n\nAdd a to all odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = \"3456\" and a = 5, s becomes \"3951\".\nRotate s to the right by b positions. For example, if s = \"3456\" and b = 1, s becomes \"6345\".\n\nReturn the lexicographically smallest string you can obtain by applying the above operations any number of times on s.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"0158\" is lexicographically smaller than \"0190\" because the first position they differ is at the third letter, and '5' comes before '9'.\n \nExample 1:\n\nInput: s = \"5525\", a = 9, b = 2\nOutput: \"2050\"\nExplanation: We can apply the following operations:\nStart:  \"5525\"\nRotate: \"2555\"\nAdd:  \"2454\"\nAdd:  \"2353\"\nRotate: \"5323\"\nAdd:  \"5222\"\nAdd:  \"5121\"\nRotate: \"2151\"\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bAdd:  \"2050\"\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\nThere is no way to obtain a string that is lexicographically smaller then \"2050\".\n\nExample 2:\n\nInput: s = \"74\", a = 5, b = 1\nOutput: \"24\"\nExplanation: We can apply the following operations:\nStart:  \"74\"\nRotate: \"47\"\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bAdd:  \"42\"\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bRotate: \"24\"\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\nThere is no way to obtain a string that is lexicographically smaller then \"24\".\n\nExample 3:\n\nInput: s = \"0011\", a = 4, b = 2\nOutput: \"0011\"\nExplanation: There are no sequence of operations that will give us a lexicographically smaller string than \"0011\".\n\n \nConstraints:\n\n2 <= s.length <= 100\ns.length is even.\ns consists of digits from 0 to 9 only.\n1 <= a <= 9\n1 <= b <= s.length - 1", "code": "def findLexSmallestString(self, s: str, a: int, b: int) -> str:\n  \n  def dfs(s: str) -> str:\n  if s not in seen:\n  seen.add(s)\n  addA = list(s)\n  for i, c in enumerate(addA):\n  if i % 2 == 1:\n  addA[i] = str((int(c) + a) % 10)\n  return min(s, dfs(''.join(addA)), dfs(s[b :] + s[: b]))\n  return s  \n  \n  seen = set()\n  return dfs(s)"}
{"nl": "Create a function that takes in a two-dimensional list and returns the number of sub-lists with only identical elements.\nExamples\ncount_identical([\n  [1],\n  [2],\n  [3],\n  [4]\n]) \u279e 4\n\n# Single-item lists still count as having identical elements.\n\n\ncount_identical([\n  [1, 2],\n  [2, 3],\n  [3, 4],\n  [4, 4]\n]) \u279e 1\n\n\ncount_identical([\n  [33, 33],\n  [5],\n  [\"a\", \"a\"],\n  [2, 2, 2],\n  [1, 2, 2],\n  [3, 1]\n]) \u279e 4\n\n# 4 lists with identical elements: [33, 33], [5], [\"a\", \"a\"], and [2, 2, 2]\n\n\ncount_identical([\n  [\"@\", \"@\", \"@\", \"@\"],\n  [2, 3], [3, 4], [4, 4]\n]) \u279e 2\nNotes\nSingle-element lists count as (trivially) having identical elements.", "code": "def count_identical(lst):\n  return len([c for c in lst if len(set(c))==1])"}
{"nl": "A Collatz sequence is generated by repeatedly applying the following rules to an integer and then to each resulting integer in turn:\nIf even: divide by 2.\nIf odd: multiply by 3, then add 1.\nThe Collatz algorithm has been tested and found to always reach 1 for all positive integers.\nCreate a function that, when given two positive integers a b, returns the string \"a\" if integer a took fewer steps to reach 1 than b when passed through the Collatz sequence, or \"b\" if integer b took fewer steps to reach 1 than a.\nExamples\ncollatz(10, 15) \u279e \"a\"\n# Because 10.0 - 5.0 - 16.0 - 8.0 - 4.0 - 2.0 - 1.0: 6 steps\n# 15.0 - 46.0 - 23.0 - 70.0 - 35.0 - 106.0 - 53.0 - 160.0 - 80.0 - 40.0 - 20.0 - 10.0 - 5.0 - 16.0 - 8.0 - 4.0 - 2.0 - 1.0: 17 steps\n\ncollatz(13, 16) \u279e \"b\"\n\ncollatz(53782, 72534) \u279e \"b\"\nNotes\nAssume a and b never take the same number of steps to reach 1.", "code": "def steps(x, count = 0):\n    while x > 1:\n        count += 1\n        if x % 2:\n            x = 3*x +1\n        else:\n            x //= 2\n    return count\n            def collatz(a, b):\n    return \"a\" if steps(a) < steps(b) else \"b\""}
{"nl": "Definition and Usage\r\nThe statistics.mean() method calculates the mean (average) of the given data set.\r\n\r\nTip: Mean = add up all the given values, then divide by how many values there are.", "code": "# Import statistics Library\r\nimport statistics\r\n\r\n# Calculate average values\r\nprint(statistics.mean([1, 3, 5, 7, 9, 11, 13]))\r\nprint(statistics.mean([1, 3, 5, 7, 9, 11]))\r\nprint(statistics.mean([-11, 5.5, -3.4, 7.1, -9, 22]))"}
{"nl": "Create a function that takes two strings and determines if an anagram of the first string is in the second string. Anagrams of \"bag\" are \"bag\", \"bga\", \"abg\", \"agb\", \"gab\", \"gba\". Since none of those anagrams are in \"grab\", the answer is false. A \"g\", \"a\", and \"b\" are in the string \"grab\", but they're split up by the \"r\".\r\n\r\nExamples\r\nana_str_str(\"car\", \"race\") \u279e True\r\n\r\nana_str_str(\"nod\", \"done\") \u279e True\r\n\r\nana_str_str(\"bag\", \"grab\") \u279e False\r\nNotes\r\nInputs will be valid strings in all lowercase letters.\r\nThere exists a linear time algorithm for this.", "code": "from itertools import *\r\ndef ana_str_str(needle, haystack):\r\n  return any(''.join(p) in haystack for p in permutations(needle))"}
{"nl": "What is Matrix?\n\nIn mathematics, matrix is a rectangular array of numbers, symbols or expressions arranged in the form of rows and columns. For example: if you take a matrix A which is a 2x3 matrix then it can be shown like this:\n\n2       3          5  \n8       12        7  \nImage representation:\n\nPython Nativ Data Programs1\nIn Python, matrices can be implemented as nested list. Each element of the matrix is treated as a row. For example X = [[1, 2], [3, 4], [5, 6]] would represent a 3x2 matrix. First row can be selected as X[0] and the element in first row, first column can be selected as X[0][0].\n\nLet's take two matrices X and Y, having the following value:\n\nX = [[1,2,3],  \n    [4,5,6],  \n    [7,8,9]]  \n  \nY = [[10,11,12],  \n    [13,14,15],  \n    [16,17,18]]  ", "code": "X = [[1,2,3],  \n       [4,5,6],  \n       [7,8,9]]  \n  \nY = [[10,11,12],  \n       [13,14,15],  \n       [16,17,18]]  \n  \nResult = [[0,0,0],  \n                [0,0,0],  \n                [0,0,0]]  \n# iterate through rows  \nfor i in range(len(X)):  \n   # iterate through columns  \n   for j in range(len(X[0])):  \n       result[i][j] = X[i][j] + Y[i][j]  \nfor r in result:  \n   print(r)  "}
{"nl": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\n\nNotice that you are not allowed to change any street.\n\nReturn true if there is a valid path in the grid or false otherwise.\n\n \n\nExample 1:\n\n\nInput: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\nExample 2:\n\n\nInput: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\nExample 3:\n\nInput: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n \n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6", "code": "def hasValidPath(self, A):\n  m, n = len(A), len(A[0])\n  uf = {(i, j): (i, j) for i in xrange(-1, m * 2) for j in xrange(-1, n * 2)}\n\n  def find(x):\n  if uf[x] != x:\n  uf[x] = find(uf[x])\n  return uf[x]\n\n  def merge(i, j, di, dj):\n  uf[find((i, j))] = find((i + di, j + dj))\n\n  for i in xrange(m):\n  for j in xrange(n):\n  if A[i][j] in [2, 5, 6]: merge(i * 2, j * 2, -1, 0)\n  if A[i][j] in [1, 3, 5]: merge(i * 2, j * 2, 0, -1)\n  if A[i][j] in [2, 3, 4]: merge(i * 2, j * 2, 1, 0)\n  if A[i][j] in [1, 4, 6]: merge(i * 2, j * 2, 0, 1)\n  return find((0, 0)) == find((m * 2 - 2, n * 2 - 2))"}
{"nl": "Write a function that, given the start start_num and end end_num values, return a list containing all the numbers inclusive to that range. See examples below.\nExamples\ninclusive_list(1, 5) \u279e [1, 2, 3, 4, 5]\n\ninclusive_list(2, 8) \u279e [2, 3, 4, 5, 6, 7, 8]\n\ninclusive_list(10, 20) \u279e [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\ninclusive_list(17, 5) \u279e [17]\nNotes\nThe numbers in the list are sorted in ascending order.\nIf start_num is greater than end_num, return a list with the higher value. See example #4.\nA recursive version of this challenge can be found here.", "code": "def inclusive_list(startNum, endNum):\n  return list(range(startNum, endNum+1)) or [startNum]"}
{"nl": "Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \u2026 shows the first 11 ugly numbers. By convention, 1 is included. \nGiven a number n, the task is to find n\u2019th Ugly number.\n\nExamples:  \n\n\n\nInput  : n = 7\nOutput : 8\n\nInput  : n = 10\nOutput : 12\n\nInput  : n = 15\nOutput : 24\n\nInput  : n = 150\nOutput : 5832", "code": "# Python program to find n'th Ugly number\n\n# Function to get the nth ugly number\n\n\ndef getNthUglyNo(n):\n\n\tugly = [0] * n # To store ugly numbers\n\n\t# 1 is the first ugly number\n\tugly[0] = 1\n\n\t# i2, i3, i5 will indicate indices for\n\t# 2,3,5 respectively\n\ti2 = i3 = i5 = 0\n\n\t# Set initial multiple value\n\tnext_multiple_of_2 = 2\n\tnext_multiple_of_3 = 3\n\tnext_multiple_of_5 = 5\n\n\t# Start loop to find value from\n\t# ugly[1] to ugly[n]\n\tfor l in range(1, n):\n\n\t\t# Choose the min value of all\n\t\t# available multiples\n\t\tugly[l] = min(next_multiple_of_2,\n\t\t\t\t\tnext_multiple_of_3,\n\t\t\t\t\tnext_multiple_of_5)\n\n\t\t# Increment the value of index accordingly\n\t\tif ugly[l] == next_multiple_of_2:\n\t\t\ti2 += 1\n\t\t\tnext_multiple_of_2 = ugly[i2] * 2\n\n\t\tif ugly[l] == next_multiple_of_3:\n\t\t\ti3 += 1\n\t\t\tnext_multiple_of_3 = ugly[i3] * 3\n\n\t\tif ugly[l] == next_multiple_of_5:\n\t\t\ti5 += 1\n\t\t\tnext_multiple_of_5 = ugly[i5] * 5\n\n\t# Return ugly[n] value\n\treturn ugly[-1]\n\n# Driver Code\ndef main():\n\n\tn = 150\n\n\tprint getNthUglyNo(n)\n\n\nif __name__ == '__main__':\n\tmain()\n\n# This code is contributed by Neelam Yadav"}
{"nl": "We can multiply a number by 7 using bitwise operator. First left shift the number by 3 bits (you will get 8n) then subtract the original numberfrom the shifted number and return the difference (8n \u2013 n). ", "code": "# Python program to multiply any\n# positive number to 7\n\n# Function to multiply any number with 7\ndef multiplyBySeven(n):\n\n\t# Note the inner bracket here.\n\t# This is needed because\n\t# precedence of '-' operator is\n\t# higher than '<<'\n\treturn ((n << 3) - n)\n\n# Driver code\nn = 4\nprint(multiplyBySeven(n))\n\n# This code is contributed by Danish Raza\n"}
{"nl": "You are given a list of n-1 integers and these integers are in the range of 1 to n. There are no duplicates in the list. One of the integers is missing in the list. Write an efficient code to find the missing integer.\nExample: \n\nInput: arr[] = {1, 2, 4, 6, 3, 7, 8}\nOutput: 5\nExplanation: The missing number from 1 to 8 is 5\n\nInput: arr[] = {1, 2, 3, 5}\nOutput: 4\nExplanation: The missing number from 1 to 5 is 4", "code": "# getMissingNo takes list as argument\ndef getMissingNo(A):\n\tn = len(A)\n\ttotal = (n + 1)*(n + 2)/2\n\tsum_of_A = sum(A)\n\treturn total - sum_of_A\n\n\n# Driver program to test the above function\nA = [1, 2, 4, 5, 6]\nmiss = getMissingNo(A)\nprint(miss)\n# This code is contributed by Pratik Chhajer"}
{"nl": "Following is a typical recursive implementation of QuickSort for arrays. The implementation uses last element as pivot. ", "code": "# A Python program to sort a linked list using Quicksort\nhead = None\n\n# a node of the doubly linked list\nclass Node:\n\tdef __init__(self, d):\n\t\tself.data = d\n\t\tself.next = None\n\t\tself.prev = None\n\n# A utility function to find last node of linked list\ndef lastNode(node):\n\twhile(node.next != None):\n\t\t\tnode = node.next;\n\treturn node;\n\n# Considers last element as pivot, places the pivot element at its\n# correct position in sorted array, and places all smaller (smaller than\n# pivot) to left of pivot and all greater elements to right of pivot\ndef partition(l, h):\n\n\t# set pivot as h element\n\t\tx = h.data;\n\t\t\n\t\t# similar to i = l-1 for array implementation\n\t\ti = l.prev;\n\t\t\n\t\tj = l\n\t\t\n\t\t# Similar to \"for (int j = l; j <= h- 1; j++)\"\n\t\twhile(j != h):\n\t\t\tif(j.data <= x):\n\t\t\t\n\t\t\t\t# Similar to i++ for array\n\t\t\t\ti = l if(i == None) else i.next;\n\n\t\t\t\ttemp = i.data;\n\t\t\t\ti.data = j.data;\n\t\t\t\tj.data = temp;\n\t\t\tj = j.next\n\t\t\t\t\t\t\n\t\ti = l if (i == None) else i.next; # Similar to i++\n\t\ttemp = i.data;\n\t\ti.data = h.data;\n\t\th.data = temp;\n\t\treturn i;\n\n# A recursive implementation of quicksort for linked list\ndef _quickSort(l,h):\n\tif(h != None and l != h and l != h.next):\n\t\t\ttemp = partition(l, h);\n\t\t\t_quickSort(l,temp.prev);\n\t\t\t_quickSort(temp.next, h);\n\t\t\n# The main function to sort a linked list. It mainly calls _quickSort()\ndef quickSort(node):\n\n\t# Find last node\n\t\thead = lastNode(node);\n\t\t\n\t\t# Call the recursive QuickSort\n\t\t_quickSort(node,head);\n\n# A utility function to print contents of arr\ndef printList(head):\n\twhile(head != None):\n\t\t\tprint(head.data, end=\" \");\n\t\t\thead = head.next;\n\t\t\n# Function to insert a node at the beginning of the Doubly Linked List\ndef push(new_Data):\n\tglobal head;\n\tnew_Node = Node(new_Data);\t # allocate node\n\t\t\n\t# if head is null, head = new_Node\n\tif(head == None):\n\t\thead = new_Node;\n\t\treturn;\n\t\n\t# link the old list off the new node\n\tnew_Node.next = head;\n\t\t\n\t# change prev of head node to new node\n\thead.prev = new_Node;\n\t\t\n\t# since we are adding at the beginning, prev is always NULL\n\tnew_Node.prev = None;\n\t\t\n\t# move the head to point to the new node\n\thead = new_Node;\n\n# Driver program to test above function\npush(5);\npush(20);\npush(4);\npush(3);\npush(30);\n\n\nprint(\"Linked List before sorting \");\nprintList(head);\nprint(\"\\nLinked List after sorting\");\nquickSort(head);\nprintList(head);\n\n# This code is contributed by _saurabh_jaiswal"}
{"nl": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven an integer, convert it to a roman numeral.\n\n \n\nExample 1:\n\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\nExample 2:\n\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\nExample 3:\n\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n \n\nConstraints:\n\n1 <= num <= 3999\nAccepted\n671,769\nSubmissions\n1,132,112", "code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        thousands = [\"\", \"M\", \"MM\", \"MMM\"]\n        hundreds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n        return (thousands[num // 1000] + hundreds[num % 1000 // 100] \n               + tens[num % 100 // 10] + ones[num % 10])"}
{"nl": "What exactly is sorting? What\u2019s the big deal about it? In this part, we will attempt to answer these questions.\n We\u2019ve sorted everything from books in a library to words in a dictionary to database entries and processor instructions on a number of occasions.\n This means that when we sort things, we must first determine the criteria by which we will organize the items in the sequence provided to us. For the purposes of this lesson, we\u2019ll suppose that the criteria is a number\u2019s value, and we\u2019ll sort a set of numbers.\n The most significant goal of sorting in computer science is to create efficient algorithms. Binary Search is a lightning-fast search algorithm that would be impossible to use in an unsorted set of objects.\n On sorted data, almost all set operations are extremely fast.\n Apart from creating efficient algorithms, sorting is employed when a program\u2019s sole purpose is to sort things, such as when working with a deck of cards. As a result, sorting algorithms are one of the most important things for a programmer to understand.\n Sorting algorithms are programs that reorganize a huge number of elements into a certain order, such as from highest to lowest, or vice versa, or even alphabetically.\n These algorithms take an input list, process it (that is, perform operations on it), and then return a sorted list.\n The importance of sorting comes from the idea that if data is kept in a sorted fashion, data searching may be greatly improved. Sorting can also be used to display data in a more legible fashion. The instances of sorting in real-life circumstances are as follows:\n Telephone Directory :The telephone directory keeps track of people\u2019s phone numbers, which are classified by their names so that they may be quickly found.\n Dictionary : The dictionary organizes terms alphabetically so that searching for a specific word is simple.\n Examples:\n Sorting in Ascending order\n Example1:\n Input:\n givenlist = [8, 132, 22, 34, 57, 2, 1, 9, 45, 87, 63, 80, 26, 65, 132]\n Output:\n printing the list before sorting :\n \n 8 132 22 34 57 2 1 9 45 87 63 80 26 65 132 \n \n printing the list after sorting :\n \n 1 2 8 9 22 26 34 45 57 63 65 80 87 132 132\n Example2:\n Input:\n givenlist = [\"hello\", \"this\", \"is\", \"BTechGeeeks\", \"python\", \"new\", \"online\",\n \n  \"platform\", \"for\", \"all\", \"students\", \"who\", \"are\", \"excited\", \"about\", \"coding\"]\n Output:\n printing the list before sorting :\n \n hello this is BTechGeeeks python new online platform for all students who are excited about coding \n \n printing the list after sorting :\n \n BTechGeeeks about all are coding excited for hello is new online platform python students this who\n Sorting in descending order example\n Example 3:\n Input:\n givenlist = [8, 132, 22, 34, 57, 2, 1, 9, 45, 87, 63, 80, 26, 65, 132]\n Output:\n printing the list before sorting :\n \n 8 132 22 34 57 2 1 9 45 87 63 80 26 65 132 \n \n printing the list after sorting :\n \n 132 132 87 80 65 63 57 45 34 26 22 9 8 2 1\n Example4:\n Input:\n givenlist = [\"hello\", \"this\", \"is\", \"BTechGeeeks\", \"python\", \"new\", \"online\",\n \n  \"platform\", \"for\", \"all\", \"students\", \"who\", \"are\", \"excited\", \"about\", \"coding\"]\n Output:\n printing the list before sorting :\n \n hello this is BTechGeeeks python new online platform for all students who are excited about coding \n \n printing the list after sorting :\n \n who this students python platform online new is hello for excited coding are all about BTechGeeeks", "code": "# function which implements the selection_sort algorithm for givenlist\n \n def selectionSort(givenlist):\n \n  length = len(givenlist)\n \n  for i in range(length):\n \n  # To begin, consider the first element in the unsorted section to be the smallest.\n \n  minValue = i\n \n \n \n  for j in range(i+1, length):\n \n  if (givenlist[j] < givenlist[minValue]):\n \n  # If a smaller element is identified, update the position\n \n  # of the minimum element.\n \n  minValue = j\n \n \n \n  # Replace the smallest(minValue) element with the first element\n \n  # of the unsorted portion.\n \n  givenlist[i], givenlist[minValue] = givenlist[minValue], givenlist[i]\n \n \n \n \n \n # given list\n \n givenlist = [\"hello\", \"this\", \"is\", \"BTechGeeeks\", \"python\", \"new\", \"online\",\n \n  \"platform\", \"for\", \"all\", \"students\", \"who\", \"are\", \"excited\", \"about\", \"coding\"]\n \n # printing the list before sorting\n \n print(\"printing the list before sorting :\")\n \n for i in givenlist:\n \n  print(i, end=\" \")\n \n print()\n \n # passing this given list to selectionSort function which sorts the given list\n \n selectionSort(givenlist)\n \n # printing the list after sorting\n \n print(\"printing the list after sorting :\")\n \n for i in givenlist:\n \n  print(i, end=\" \")"}
{"nl": "Check the principles of minimalist code in the intro to the first challenge.\nIn the Code tab you will find a code that is missing a single character in order to pass the tests. However, your goal is to submit a function as minimalist as possible. Use the tips in the tips section below.\nWrite a function that returns the strings:\n\"both\" if both given booleans a and b are True.\n\"first\" if only a is True.\n\"second\" if only b is True .\n\"neither\" if both a and b are False.\nTips\nIf-else statements can be written as a oneliner using Python's ternary operator.\nFor example, the code:\ndef startswith(name):\n  if name[0] in \"AEIOU\":\n    return \"vowel\"\n  else:\n    return \"consonant\"\nCan be simplified to:\ndef startswith(name):\n  return \"vowel\" if name[0] in \"AEIOU\" else \"consonant\"\nBonus\nYou can concatenate as many ternary operators as you want. However, concatenating too many will definitely diminish the readability of your code.\n\"majority\" if  x > 50 else \"minority\" if x < 50 else \"draw\"\nNotes\nThis is an open series: there isn't a definite list of features for the challenges. Please, do not hesitate to leave your suggestions in the Comments.\nReadability is indeed a subjective concept. Let's discuss it! Feel free to leave your opinion in the Comments.\nYou can find all the exercises in this series over here.", "code": "def are_true(a, b):\n  return 'both' if a and b else 'first' if a else 'second' if b else 'neither'"}
{"nl": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n \n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExample 2:\n\nInput: nums = []\nOutput: []\nExample 3:\n\nInput: nums = [0]\nOutput: []\n \n\nConstraints:\n\n0 <= nums.length <= 3000\n-105 <= nums[i] <= 105", "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res, dups = set(), set()\n        seen = {}\n        for i, val1 in enumerate(nums):\n            if val1 not in dups:\n                dups.add(val1)\n                for j, val2 in enumerate(nums[i+1:]):\n                    complement = -val1 - val2\n                    if complement in seen and seen[complement] == i:\n                        res.add(tuple(sorted((val1, val2, complement))))\n                    seen[val2] = i\n        return res"}
{"nl": "Create a function that, given a string with at least three characters, returns an array of its:\nLength.\nFirst character.\nLast character.\nMiddle character, if the string has an odd number of characters. Middle TWO characters, if the string has an even number of characters.\nIndex of the second occurrence of the second character in the format \"@ index #\" and \"not found\" if the second character doesn't occur again.\nExamples\nall_about_strings(\"LASA\") \u279e [4, \"L\", \"A\", \"AS\", \"@ index 3\"]\n\nall_about_strings(\"Computer\") \u279e [8, \"C\", \"r\", \"pu\", \"not found\"]\n\nall_about_strings(\"Science\") \u279e [7, \"S\", \"e\", \"e\", \"@ index 5\"]\nNotes\nN/A", "code": "def all_about_strings(txt):\n  return [\n    len(txt),\n    txt[0],\n    txt[-1],\n    txt[(len(txt)-1)//2:(len(txt)+2)//2],\n    \"@ index {}\".format(txt.index(txt[1], 2)) if txt[1] in txt[2:] else \"not found\"\n  ]"}
{"nl": "Given a singly linked list, write a function to swap elements pairwise. \n\nInput : 1->2->3->4->5->6->NULL \nOutput : 2->1->4->3->6->5->NULL\n\nInput : 1->2->3->4->5->NULL \nOutput : 2->1->4->3->5->NULL\n\nInput : 1->NULL \nOutput : 1->NULL \n \n\nFor example, if the linked list is 1->2->3->4->5 then the function should change it to 2->1->4->3->5, and if the linked list is then the function should change it to.  ", "code": "# Python program to swap the elements of linked list pairwise\n\n# Node class\n\n\nclass Node:\n\n\t# Constructor to initialize the node object\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\n\nclass LinkedList:\n\n\t# Function to initialize head\n\tdef __init__(self):\n\t\tself.head = None\n\n\t# Function to pairwise swap elements of a linked list\n\tdef pairwiseSwap(self):\n\t\ttemp = self.head\n\n\t\t# There are no nodes in linked list\n\t\tif temp is None:\n\t\t\treturn\n\n\t\t# Traverse furthethr only if there are at least two\n\t\t# left\n\t\twhile(temp and temp.next):\n\n\t\t\t# If both nodes are same,\n\t\t\t# no need to swap data\n\t\t\tif(temp.data != temp.next.data):\n\n\t\t\t\t# Swap data of node with its next node's data\n\t\t\t\ttemp.data, temp.next.data = temp.next.data, temp.data\n\n\t\t\t# Move temp by 2 to the next pair\n\t\t\ttemp = temp.next.next\n\n\t# Function to insert a new node at the beginning\n\tdef push(self, new_data):\n\t\tnew_node = Node(new_data)\n\t\tnew_node.next = self.head\n\t\tself.head = new_node\n\n\t# Utility function to print the linked LinkedList\n\tdef printList(self):\n\t\ttemp = self.head\n\t\twhile(temp):\n\t\t\tprint temp.data,\n\t\t\ttemp = temp.next\n\n\n# Driver program\nllist = LinkedList()\nllist.push(5)\nllist.push(4)\nllist.push(3)\nllist.push(2)\nllist.push(1)\n\nprint \"Linked list before calling pairWiseSwap() \"\nllist.printList()\n\nllist.pairwiseSwap()\n\nprint \"\\nLinked list after calling pairWiseSwap()\"\nllist.printList()\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type.\n\nYou need to distribute all products to the retail stores following these rules:\n\nA store can only be given at most one product type but can be given any amount of it.\nAfter distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store.\nReturn the minimum possible x.\n\n ", "code": "class Solution:\n    def minimizedMaximum(self, n: int, nums: List[int]) -> int:\n        lo, hi = 1, max(nums)\n        while(lo<hi):\n            mid = (lo+hi)//2\n            count = sum([ceil(k/mid) for k in nums])\n            if count > n:\n                lo = mid+1\n            else:\n                hi = mid\n        return lo"}
{"nl": "Given an array of size n, the task is to find whether array can represent a BST with n levels.\u00a0\n\n\nSince levels are n, we construct a tree in the following manner.\u00a0\n\n\nAssuming a number X,\u00a0\nNumber higher than X is on the right side\nNumber lower than X is on the left side.\nNote: during the insertion, we never go beyond a number already visited.\nExamples: \n \n\nInput : 500, 200, 90, 250, 100\nOutput : No\n\nInput : 5123, 3300, 783, 1111, 890\nOutput : Yes", "code": "# Python program to Check given array\n# can represent BST or not\n\u00a0\n# A binary tree node has data,\n# left child and right child\nclass newNode():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# To create a Tree with n levels. We always\n# insert new node to left if it is less than\n# previous value.\ndef createNLevelTree(arr, n):\n\u00a0\u00a0\u00a0\u00a0root = newNode(arr[0])\n\u00a0\u00a0\u00a0\u00a0temp = root\n\u00a0\u00a0\u00a0\u00a0for i in range(1, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.key > arr[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.left = newNode(arr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.right = newNode(arr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Please refer below post for details of this\n# function.\n# https:# www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\ndef isBST(root, min, max):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (root.key < min or root.key > max):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Allow only distinct values\n\u00a0\u00a0\u00a0\u00a0return (isBST(root.left, min, (root.key) - 1) and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isBST(root.right,(root.key) + 1, max))\n\u00a0\n# Returns tree if given array of size n can\n# represent a BST of n levels.\ndef canRepresentNLevelBST(arr, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = createNLevelTree(arr, n)\n\u00a0\u00a0\u00a0\u00a0return isBST(root, 0, 2**32)\n\u00a0\n# Driver code\narr = [512, 330, 78, 11, 8]\nn = len(arr)\n\u00a0\nif (canRepresentNLevelBST(arr, n)):\n\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\n# This code is contributed by SHUBHAMSINGH10\n"}
{"nl": "Given an array of integers, print the array in such a way that the first element is first maximum and second element is first minimum and so on.", "code": "# Python 3 program to print an array\r\n# in alternate sorted manner.\r\n\r\n# Function to print alternate sorted\r\n# values\r\ndef alternateSort(arr, n):\r\n\r\n\t# Sorting the array\r\n\tarr.sort()\r\n\r\n\t# Printing the last element of array\r\n\t# first and then first element and then\r\n\t# second last element and then second\r\n\t# element and so on.\r\n\ti = 0\r\n\tj = n-1\r\n\t\r\n\twhile (i < j):\r\n\t\r\n\t\tprint(arr[j], end =\" \")\r\n\t\tj-= 1\r\n\t\tprint(arr[i], end =\" \")\r\n\t\ti+= 1\r\n\r\n\t# If the total element in array is odd\r\n\t# then print the last middle element.\r\n\tif (n % 2 != 0):\r\n\t\tprint(arr[i])\r\n\r\n\r\n# Driver code\r\narr = [1, 12, 4, 6, 7, 10]\r\nn = len(arr)\r\n\r\nalternateSort(arr, n)\r\n\r\n# This code is contributed by\r\n# Smitha Dinesh Semwal\r"}
{"nl": "Write a Python Program to Print Hollow Box Pattern of Numbers 1 and 0", "code": "# Python Program to Print Hollow Box Pattern of Numbers 1 and 0\n \nrows = int(input(\"Please Enter the total Number of Rows  : \"))\ncolumns = int(input(\"Please Enter the total Number of Columns  : \"))\n\nprint(\"Hollow Box Pattern of Numbers\") \n \nfor i in range(1, rows + 1):\n    for j in range(1, columns + 1):\n        if(i == 1 or i == rows or j == 1 or j == columns):          \n            print('1', end = '  ')\n        else:\n            print(' ', end = '  ')\n    print()"}
{"nl": "Print all the Prime Numbers within a Given Range Using for loop(User Input)", "code": "# Give the number as user input with the help\r\n# of the int(input()) function and store it in a variable.\r\ngivenNumbr = int(input('Enter some random upper limit range = '))\r\nprint('The prime numbers from 2 to upper limit [', givenNumbr, '] :')\r\n# Set the first for loop to have a range of 2 to the upper limit range.\r\nfor valu in range(2, givenNumbr+1):\r\n  # Take a temporary variable which is the count variable and initialize it to zero.\r\n    cntvar = 0\r\n    # Allow the second for loop to have a range of 2 to\r\n    # half the number (excluding 1 and the number itself).\r\n    for divi in range(2, valu//2+1):\r\n      # Then, using the if statement, determine the number of divisors\r\n      # and increment the count variable each time.\r\n        if(valu % divi == 0):\r\n            cntvar = cntvar+1\r\n    # The number is prime if the number of divisors is lower than or equal to zero.\r\n    if(cntvar <= 0):\r\n        print(valu, end=' ')"}
{"nl": "The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.\nThe numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string \"abe\" is equal to 1 + 2 + 5 = 8.\nYou are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to k.\nNote that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\n \nExample 1:\n\nInput: n = 3, k = 27\nOutput: \"aay\"\nExplanation: The numeric value of the string is 1 + 1 + 25 = 27, and it is the smallest string with such a value and length equal to 3.\n\nExample 2:\n\nInput: n = 5, k = 73\nOutput: \"aaszz\"\n\n \nConstraints:\n\n1 <= n <= 105\nn <= k <= 26 * n", "code": "class Solution:\n  def getSmallestString(self, n: int, k: int) -> str:\n  res, k, i = ['a'] * n, k - n, n - 1\n  while k:\n  k += 1\n  if k/26 >= 1:\n  res[i], k, i = 'z', k - 26, i - 1\n  else:\n  res[i], k = chr(k + 96), 0\n\n  return ''.join(res)"}
{"nl": "JSON in Python\r\nJSON is a syntax for storing and exchanging data.\r\n\r\nJSON is text, written with JavaScript object notation.\r\n\r\nPython has a built-in package called json, which can be used to work with JSON data.", "code": "import json"}
{"nl": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n\n \n\nExample 1:\n\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\nExample 2:\n\n\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.", "code": "class Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        if head is None:\n            return False\n        slow = head\n        fast = head.next\n        while slow != fast:\n            if fast is None or fast.next is None:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n        return True"}
{"nl": "Given an array, how to check if the given array represents a Binary Max-Heap.\nExamples: \n\nInput:  arr[] = {90, 15, 10, 7, 12, 2} \nOutput: True\nThe given array represents below tree\n       90\n     /    \\\n   15      10\n  /  \\     /\n 7    12  2 \nThe tree follows max-heap property as every\nnode is greater than all of its descendants.\n\nInput:  arr[] = {9, 15, 10, 7, 12, 11} \nOutput: False\nThe given array represents below tree\n       9\n     /    \\\n   15      10\n  /  \\     /\n 7    12  11\nThe tree doesn't follows max-heap property 9 is \nsmaller than 15 and 10, and 10 is smaller than 11. ", "code": "# Python3 program to check whether a\n# given array represents a max-heap or not\n\n# Returns true if arr[i..n-1]\n# represents a max-heap\ndef isHeap(arr, i, n):\n\t\n\t# If (2 * i) + 1 >= n, then leaf node, so return true\n\tif i >= int((n - 1) / 2):\n\t\treturn True\n\t\n\t# If an internal node and is greater\n\t# than its children, and same is\n\t# recursively true for the children\n\tif(arr[i] >= arr[2 * i + 1] and\n\tarr[i] >= arr[2 * i + 2] and\n\tisHeap(arr, 2 * i + 1, n) and\n\tisHeap(arr, 2 * i + 2, n)):\n\t\treturn True\n\t\n\treturn False\n\n# Driver Code\nif __name__ == '__main__':\n\tarr = [90, 15, 10, 7, 12, 2, 7, 3]\n\tn = len(arr) - 1\n\n\tif isHeap(arr, 0, n):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n\n# This code is contributed by PranchalK"}
{"nl": "Create a function that takes a number as an argument and returns the appropriate error message. You should do this without using the switch or if statements.\nThe input error will be 1 to 5:\n1 >> \"Check the fan: e1\"\n2 >> \"Emergency stop: e2\"\n3 >> \"Pump Error: e3\"\n4 >> \"c: e4\"\n5 >> \"Temperature Sensor Error: e5\"\nFor any other value, return 101 (you can use an if statment here).\nExamples\nerror(1) \u279e \"Check the fan: e1\"\n\nerror(2) \u279e \"Emergency stop: e2\"\n\nerror(3) \u279e \"Pump Error: e3\"\nNotes\nDo this without using the switch or if statements.", "code": "def error(n):\n  return {\n    1: 'Check the fan: e1',\n    2: 'Emergency stop: e2',\n    3: 'Pump Error: e3',\n    4: 'c: e4',\n    5: 'Temperature Sensor Error: e5',\n  }.get(n, 101)"}
{"nl": "In the previous article, we have discussed Python Program to Display an Upper Triangular Matrix\n \n Given a matrix and the task is to find the sum of all elements in a 2-dimensional array of the given matrix in Python.\n \n What is a matrix:\n \n A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.\n \n Example:\n \n \n \n Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.\n \n In this order, the dimensions of a matrix indicate the number of rows and columns.\n \n \n \n Here as there are 5 rows and 4 columns it is called a 5*4 matrix.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given Matix : \n 1 6 4 \n 8 1 3 \n 1 6 2\n Output:\n \n The sum of all elements in 2 dimensional array for a given matrix is :\n 32\n Example2:\n \n Input:\n \n Given Matix : \n 0 8\n 3 7\n Output:\n \n The sum of all elements in 2 dimensional array for a given matrix is :\n 18", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[1, 6, 4], [8, 1, 3], [1, 6, 2]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n print(\"The sum of all elements in 2 dimensional array for a given matrix is :\")\n # Take a variable say rslt_sum and initialize its value to 0.\n rslt_sum = 0\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Add the gvnmatrix[n][m] to the above-initialized\n  # rslt_sum and store it in the same variable rslt_sum.\n  rslt_sum += mtrx[n][m]\n # Print the variable rslt_sum to get the sum of all elements in a 2 dimensional array for\n # a given matrix\n print(rslt_sum)"}
{"nl": "You have a 1-indexed binary string of length n where all the bits are 0 initially. We will flip all the bits of this binary string (i.e., change them from 0 to 1) one by one. You are given a 1-indexed integer array flips where flips[i] indicates that the bit at index i will be flipped in the ith step.\n\nA binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.\n\nReturn the number of times the binary string is prefix-aligned during the flipping process.\n\n \n\nExample 1:\n\nInput: flips = [3,2,4,1,5]\nOutput: 2\nExplanation: The binary string is initially \"00000\".\nAfter applying step 1: The string becomes \"00100\", which is not prefix-aligned.\nAfter applying step 2: The string becomes \"01100\", which is not prefix-aligned.\nAfter applying step 3: The string becomes \"01110\", which is not prefix-aligned.\nAfter applying step 4: The string becomes \"11110\", which is prefix-aligned.\nAfter applying step 5: The string becomes \"11111\", which is prefix-aligned.\nWe can see that the string was prefix-aligned 2 times, so we return 2.\nExample 2:\n\nInput: flips = [4,1,2,3]\nOutput: 1\nExplanation: The binary string is initially \"0000\".\nAfter applying step 1: The string becomes \"0001\", which is not prefix-aligned.\nAfter applying step 2: The string becomes \"1001\", which is not prefix-aligned.\nAfter applying step 3: The string becomes \"1101\", which is not prefix-aligned.\nAfter applying step 4: The string becomes \"1111\", which is prefix-aligned.\nWe can see that the string was prefix-aligned 1 time, so we return 1.\n \n\nConstraints:\n\nn == flips.length\n1 <= n <= 5 * 104\nflips is a permutation of the integers in the range [1, n].", "code": "def numTimesAllBlue(self, A):\n  right = res = 0\n  for i, a in enumerate(A, 1):\n  right = max(right, a)\n  res += right == i\n  return res"}
{"nl": "Given the number of rows of the right triangle, the task is to print Mirrored Right Triangle Star Pattern in C, C++, and Python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven number of rows of the right triangle =6\nOutput:\n\n  * \n  * * \n  * * * \n  * * * * \n  * * * * * \n* * * * * *\nExample2:\n\nInput:\n\ngiven number of rows of the right triangle =\nGiven character to print ='$'\nOutput:\n\n  $ \n  $ $ \n  $ $ $ \n  $ $ $ $ \n  $ $ $ $ $ \n$ $ $ $ $ $", "code": "# Give the number of rows of the right triangle pattern as static input and store it in a variable.\ntriNumRows = 6\n# Iterate from 1 to given rows using the First for loop.\nfor m in range(1, triNumRows+1):\n  # Iterate from 1 to given rows using another for loop(Nested For loop)\n  for n in range(1, triNumRows+1):\n  # Check if the iterator value of the inner for loop is less than or equal to given rows - first iterator value using If statement.\n  if(n <= triNumRows - m):\n  # If the statement is true then print space.\n  print(' ', end=' ')\n  else:\n  # Else print star character with space.\n  print('*', end=' ')\n  #Print the newline character after the exit of the inner for loop.\n  print()"}
{"nl": "For a game of Dungeons & Dragons, each player starts by generating a character they can play with. This character has, among other things, six abilities; strength, dexterity, constitution, intelligence, wisdom and charisma. These six abilities have scores that are determined randomly. You do this by rolling four 6-sided dice and record the sum of the largest three dice. You do this six times, once for each ability.\n\nYour character's initial hitpoints are 10 + your character's constitution modifier. You find your character's constitution modifier by subtracting 10 from your character's constitution, divide by 2 and round down.\n\nWrite a random character generator that follows the rules above.\n\nFor example, the six throws of four dice may look like:\n\n5, 3, 1, 6: You discard the 1 and sum 5 + 3 + 6 = 14, which you assign to strength.\n3, 2, 5, 3: You discard the 2 and sum 3 + 5 + 3 = 11, which you assign to dexterity.\n1, 1, 1, 1: You discard the 1 and sum 1 + 1 + 1 = 3, which you assign to constitution.\n2, 1, 6, 6: You discard the 1 and sum 2 + 6 + 6 = 14, which you assign to intelligence.\n3, 5, 3, 4: You discard the 3 and sum 5 + 3 + 4 = 12, which you assign to wisdom.\n6, 6, 6, 6: You discard the 6 and sum 6 + 6 + 6 = 18, which you assign to charisma.\nBecause constitution is 3, the constitution modifier is -4 and the hitpoints are 6.", "code": "import random\nABILITIES = (\n    'strength', 'dexterity', 'constitution',\n    'intelligence', 'wisdom', 'charisma')\ndef modifier(score):\n    return (score - 10) // 2\nclass Character:\n    def __init__(self):\n        for ability in ABILITIES:\n            setattr(self, ability, self.ability())\n        self.hitpoints = 10 + modifier(self.constitution)\n    def ability(self):\n        dices = sorted(random.randint(1, 6) for _ in range(4))\n        return sum(dices[1:])"}
{"nl": "Given a 2D matrix and a set of cell indexes e.g., an array of (i, j) where i indicates row and j column. For every given cell index (i, j), find sums of all matrix elements except the elements present in i\u2019th row and/or j\u2019th column.\n\n\u00a0", "code": "# Python3 implementation of the approach\n\u00a0\n# A structure to represent a cell index\nclass Cell:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, r, c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.r = r # r is row, varies from 0 to R-1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.c = c # c is column, varies from 0 to C-1\n\u00a0\n# A simple solution to find sums\n# for a given array of cell indexes\ndef printSums(mat, arr, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Iterate through all cell indexes\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Sum = 0; r = arr[i].r; c = arr[i].c\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Compute sum for current cell index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0, R):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(0, C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j != r and k != c:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Sum += mat[j][k]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(Sum)\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[1, 1, 2], [3, 4, 6], [5, 3, 2]]\n\u00a0\u00a0\u00a0\u00a0R = C = 3\n\u00a0\u00a0\u00a0\u00a0arr = [Cell(0, 0), Cell(1, 1), Cell(0, 1)]\n\u00a0\u00a0\u00a0\u00a0n = len(arr)\n\u00a0\u00a0\u00a0\u00a0printSums(mat, arr, n)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by Rituraj Jain\n"}
{"nl": "Given a Prefix expression, convert it into a Postfix expression. \nConversion of Prefix expression directly to Postfix without going through the process of converting them first to Infix and then to Postfix is much better in terms of computation and better understanding the expression (Computers evaluate using Postfix expression). ", "code": "# Write Python3 code here\n# -*- coding: utf-8 -*-\n\u00a0\n# Example Input\ns = \"*-A/BC-/AKL\"\n\u00a0\n# Stack for storing operands\nstack = []\n\u00a0\noperators = set(['+', '-', '*', '/', '^'])\n\u00a0\n# Reversing the order\ns = s[::-1]\n\u00a0\n# iterating through individual tokens\nfor i in s:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if token is operator\n\u00a0\u00a0\u00a0\u00a0if i in operators:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop 2 elements from stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a = stack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b = stack.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# concatenate them as operand1 +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# operand2 + operator\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = a+b+i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(temp)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# else if operand\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(i)\n\u00a0\n# printing final output\nprint(*stack)\n"}
{"nl": "The problem is to find the shortest distance to all vertices from a source vertex in a weighted graph.", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef dijkstra(g, source):\n    \"\"\"Return distance where distance[v] is min distance from source to v.\n\u00a0\n    This will return a dictionary distance.\n\u00a0\n    g is a Graph object.\n    source is a Vertex object in g.\n    \"\"\"\n    unvisited = set(g)\n    distance = dict.fromkeys(g, float('inf'))\n    distance[source] = 0\n\u00a0\n    while unvisited != set():\n        # find vertex with minimum distance\n        closest = min(unvisited, key=lambda v: distance[v])\n\u00a0\n        # mark as visited\n        unvisited.remove(closest)\n\u00a0\n        # update distances\n        for neighbour in closest.get_neighbours():\n           if neighbour in unvisited:\n               new_distance = distance[closest] + closest.get_weight(neighbour)\n               if distance[neighbour] > new_distance:\n                   distance[neighbour] = new_distance\n\u00a0\n    return distance\n\u00a0\n\u00a0\ng = Graph()\nprint('Undirected Graph')\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('shortest <source vertex key>')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                    g.add_edge(dest, src, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'shortest':\n        key = int(do[1])\n        source = g.get_vertex(key)\n        distance = dijkstra(g, source)\n        print('Distances from {}: '.format(key))\n        for v in distance:\n            print('Distance to {}: {}'.format(v.get_key(), distance[v]))\n        print()\n\u00a0\n    elif operation == 'display':\n        print('Vertices: ', end='')\n        for v in g:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in g:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Given a number N and the task is to print the series ( 0,2,8,14,24,34 \u2026N) till the given number N in Python.", "code": "# Give the number N as static input and store it in a variable.\r\ngvn_numb = 5\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Take another variable say previous_val and initialize its value to 0.\r\nprevious_val = 0\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nwhile itr <= gvn_numb:\r\n  # Inside the loop, check if the above itr value is even or not using the if\r\n  # conditional statement.\r\n    if(itr % 2 == 0):\r\n      # If it is true, calculate the value of itr raised to the power 2 using the pow()\r\n          # function and subtract 2 from it.\r\n      # Store it in the same variable previous_val.\r\n        previous_val = pow(itr, 2) - 2\r\n        # Print the value of the above previous_val separated by spaces.\r\n        print(previous_val, end=\" \")\r\n    else:\r\n     # Else, If it is false calculate the value of itr raised to the power 2 using the pow()\r\n         # function and subtract 1 from it.\r\n         # Store it in the same variable previous_val.\r\n        previous_val = pow(itr, 2) - 1\r\n        # Print the value of the above previous_val separated by spaces.\r\n        print(previous_val, end=\" \")\r\n  # Increment the above itr value by 1.\r\n    itr += 1"}
{"nl": null, "code": null}
{"nl": "Given a directed tree with V vertices and V-1 edges, we need to choose such a root (from given nodes from where we can reach to every other node) with a minimum number of edge reversal.\u00a0", "code": "# Python3 program to find min edge reversal\n# to make every node reachable from root\nimport sys\n\u00a0\u00a0\n# Method to dfs in tree and populates\u00a0\n# disRev values\ndef dfs(g, disRev, visit, u):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Visit current node\n\u00a0\u00a0\u00a0\u00a0visit[u] = True\n\u00a0\u00a0\u00a0\u00a0totalRev = 0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Looping over all neighbors\n\u00a0\u00a0\u00a0\u00a0for i in range(len(g[u])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = g[u][i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not visit[v]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Distance of v will be one more\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than distance of u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[v][0] = disRev[u][0] + 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Initialize back edge count same as\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# parent node's count\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[v][1] = disRev[u][1]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If there is a reverse edge from u to i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then only update\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (g[u][i][1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[v][1] = disRev[u][1] + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalRev += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalRev += dfs(g, disRev, visit, v)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return total reversal in subtree rooted at u\n\u00a0\u00a0\u00a0\u00a0return totalRev\n\u00a0\u00a0\n# Method prints root and minimum number of\n# edge reversal\ndef printMinEdgeReverseForRootNode(edges, e):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Number of nodes are one more than\n\u00a0\u00a0\u00a0\u00a0# number of edges\n\u00a0\u00a0\u00a0\u00a0V = e + 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Data structure to store directed tree\n\u00a0\u00a0\u00a0\u00a0g = [[] for i in range(V)]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# disRev stores two values - distance\n\u00a0\u00a0\u00a0\u00a0# and back edge count from root node\n\u00a0\u00a0\u00a0\u00a0disRev = [[0, 0] for i in range(V)]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0visit = [False for i in range(V)]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# u, v\n\u00a0\u00a0\u00a0\u00a0for i in range(e):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = edges[i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = edges[i][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add 0 weight in direction of u to v\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g[u].append([v, 0])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add 1 weight in reverse direction\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g[v].append([u, 1])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize all variables\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visit[i] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[i][0] = disRev[i][1] = 0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = 0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# dfs populates disRev data structure and\n\u00a0\u00a0\u00a0\u00a0# store total reverse edge counts\n\u00a0\u00a0\u00a0\u00a0totalRev = dfs(g, disRev, visit, root)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# UnComment below lines to preach node's\n\u00a0\u00a0\u00a0\u00a0# distance and edge reversal count from root node\n\u00a0\u00a0\u00a0\u00a0# for (i = 0 i < V i++)\n\u00a0\u00a0\u00a0\u00a0# {\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 cout << i << \" : \" << disRev[i][0]\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 << \" \" << disRev[i][1] << endl\n\u00a0\u00a0\u00a0\u00a0# }\n\u00a0\u00a0\u00a0\u00a0res = sys.maxsize\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Loop over all nodes to choose\u00a0\n\u00a0\u00a0\u00a0\u00a0# minimum edge reversal\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (reversal in path to i) + (reversal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in all other tree parts)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edgesToRev = ((totalRev - disRev[i][1]) +\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(disRev[i][0] - disRev[i][1]))\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Choose minimum among all values\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (edgesToRev < res):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = edgesToRev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = i\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the designated root and total\n\u00a0\u00a0\u00a0\u00a0# edge reversal made\n\u00a0\u00a0\u00a0\u00a0print(root, res)\u00a0\n\u00a0\u00a0\n# Driver code\u00a0\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0edges = [ [ 0, 1 ], [ 2, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 3, 2 ], [ 3, 4 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 5, 4 ], [ 5, 6 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 7, 6 ] ]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0e = len(edges)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0printMinEdgeReverseForRootNode(edges, e)\n\u00a0\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": null, "code": null}
{"nl": "Given an unsorted array arr of nonnegative integers and an integer sum, find a continuous subarray which adds to a given sum. There may be more than one subarrays with sum as the given sum, print first such subarray. ", "code": "# An efficient program\r\n# to print subarray\r\n# with sum as given sum\r\n\r\n# Returns true if the\r\n# there is a subarray\r\n# of arr[] with sum\r\n# equal to 'sum'\r\n# otherwise returns\r\n# false. Also, prints\r\n# the result.\r\ndef subArraySum(arr, n, sum_):\r\n\t\r\n\t# Initialize curr_sum as\r\n\t# value of first element\r\n\t# and starting point as 0\r\n\tcurr_sum = arr[0]\r\n\tstart = 0\r\n\r\n\t# Add elements one by\r\n\t# one to curr_sum and\r\n\t# if the curr_sum exceeds\r\n\t# the sum, then remove\r\n\t# starting element\r\n\ti = 1\r\n\twhile i <= n:\r\n\t\t\r\n\t\t# If curr_sum exceeds\r\n\t\t# the sum, then remove\r\n\t\t# the starting elements\r\n\t\twhile curr_sum > sum_ and start < i-1:\r\n\t\t\r\n\t\t\tcurr_sum = curr_sum - arr[start]\r\n\t\t\tstart += 1\r\n\t\t\t\r\n\t\t# If curr_sum becomes\r\n\t\t# equal to sum, then\r\n\t\t# return true\r\n\t\tif curr_sum == sum_:\r\n\t\t\tprint (\"Sum found between indexes\")\r\n\t\t\tprint (\"% d and % d\"%(start, i-1))\r\n\t\t\treturn 1\r\n\r\n\t\t# Add this element\r\n\t\t# to curr_sum\r\n\t\tif i < n:\r\n\t\t\tcurr_sum = curr_sum + arr[i]\r\n\t\ti += 1\r\n\r\n\t# If we reach here,\r\n\t# then no subarray\r\n\tprint (\"No subarray found\")\r\n\treturn 0\r\n\r\n# Driver program\r\narr = [15, 2, 4, 8, 9, 5, 10, 23]\r\nn = len(arr)\r\nsum_ = 23\r\n\r\nsubArraySum(arr, n, sum_)\r\n\r\n# This code is Contributed by shreyanshi_arun.\r"}
{"nl": "Create a function that returns the prime factorization of an integer as a sorted list of tuples. Include the multiplicity of each prime in the tuples:\r\n\r\n[(prime_0, mult_0), ..., (prime_k, mult_k)]\r\nwhere prime_0 < prime_1 < ... < prime_k\r\nExamples\r\nfactorize(4) \u279e [(2, 2)]\r\n\r\nfactorize(10) \u279e [(2, 1), (5, 1)]\r\n\r\nfactorize(60) \u279e [(2, 2), (3, 1), (5, 1)]\r\nNotes\r\nDon't worry about negatives or floats. All inputs will be positive integers.\r\n1 is not a prime! Do not include it. You will not be given 1 as an input.\r\nAll inputs will be less than 10,000.", "code": "def factorize(n):\r\n\td = {}\r\n\tfor i in range(2, n+1):\r\n\t\twhile n % i == 0:\r\n\t\t\td[i] = 1 if i not in d else d[i] + 1\r\n\t\t\tn //= i\r\n\treturn sorted(d.items())"}
{"nl": "This is a reverse coding challenge. Normally you're given explicit directions with how to create a function. Here, you must generate your own function to satisfy the relationship between the inputs and outputs.\nYour task is to create a function that, when fed the inputs below, produces the sample outputs shown.\nExamples\n[5, 7, 8, 2, 1], 2 \u279e [1, 1, 0, 0, 1]\n\n[9, 8, 16, 47], 4 \u279e [1, 0, 0, 3]\n\n[17, 11, 99, 55, 23, 1], 5 \u279e [2, 1, 4, 0, 3, 1]\n\n[6, 1], 7 \u279e [6, 1]\n\n[3, 2, 9], 3 \u279e [0, 2, 0]\n\n[48, 22, 0, 19, 33, 100], 10 \u279e [8, 2, 0, 9, 3, 0]\nNotes\nIf you get stuck, see Comments for a hint.", "code": "def mystery_func(lst, n):\n  return [i%n for i in lst]"}
{"nl": "Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.\nReturn true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.\n \nExample 1:\n\n\nInput: path = \"NES\"\nOutput: false \nExplanation: Notice that the path doesn't cross any point more than once.\n\nExample 2:\n\n\nInput: path = \"NESWW\"\nOutput: true\nExplanation: Notice that the path visits the origin twice.\n \nConstraints:\n\n1 <= path.length <= 104\npath[i] is either 'N', 'S', 'E', or 'W'.", "code": "def isPathCrossing(self, path: str) -> bool:\n  cur = (0, 0)\n  seen = {cur}\n  dir = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}\n  for char in path:\n  cur = tuple(map(operator.add, cur, dir[char]))\n  if cur in seen:\n  return True\n  seen.add(cur)\n  return False"}
{"nl": "In this post another method of circular queue implementation is discussed, using Circular Singly Linked List.\n\nOperations on Circular Queue:\n\nFront:Get the front item from queue.\nRear: Get the last item from queue.\nenQueue(value) This function is used to insert an element into the circular queue. In a circular queue, the new element is always inserted at Rear position.", "code": "# Python3 program for insertion and\u00a0\n# deletion in Circular Queue\u00a0\n\u00a0\u00a0\n# Structure of a Node\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.link = None\n\u00a0\u00a0\nclass Queue:\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0front = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rear = None\n\u00a0\u00a0\n# Function to create Circular queue\u00a0\ndef enQueue(q, value):\n\u00a0\u00a0\u00a0\u00a0temp = Node()\u00a0\n\u00a0\u00a0\u00a0\u00a0temp.data = value\u00a0\n\u00a0\u00a0\u00a0\u00a0if (q.front == None):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.front = temp\u00a0\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.rear.link = temp\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0q.rear = temp\u00a0\n\u00a0\u00a0\u00a0\u00a0q.rear.link = q.front\n\u00a0\u00a0\n# Function to delete element from\u00a0\n# Circular Queue\u00a0\ndef deQueue(q):\n\u00a0\u00a0\u00a0\u00a0if (q.front == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue is empty\")\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -999999999999\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If this is the last node to be deleted\u00a0\n\u00a0\u00a0\u00a0\u00a0value = None # Value to be dequeued\u00a0\n\u00a0\u00a0\u00a0\u00a0if (q.front == q.rear):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value = q.front.data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.front = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.rear = None\n\u00a0\u00a0\u00a0\u00a0else: # There are more than one nodes\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = q.front\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value = temp.data\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.front = q.front.link\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.rear.link = q.front\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return value\u00a0\n\u00a0\u00a0\n# Function displaying the elements\u00a0\n# of Circular Queue\u00a0\ndef displayQueue(q):\n\u00a0\u00a0\u00a0\u00a0temp = q.front\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Elements in Circular Queue are: \",\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end = \" \")\u00a0\n\u00a0\u00a0\u00a0\u00a0while (temp.link != q.front):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(temp.data, end = \" \")\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.link\n\u00a0\u00a0\u00a0\u00a0print(temp.data)\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a queue and initialize\n\u00a0\u00a0\u00a0\u00a0# front and rear\u00a0\n\u00a0\u00a0\u00a0\u00a0q = Queue()\u00a0\n\u00a0\u00a0\u00a0\u00a0q.front = q.rear = None\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Inserting elements in Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 14)\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 22)\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 6)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Display elements present in\u00a0\n\u00a0\u00a0\u00a0\u00a0# Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0displayQueue(q)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Deleting elements from Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Deleted value = \", deQueue(q))\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Deleted value = \", deQueue(q))\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Remaining elements in Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0displayQueue(q)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 9)\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 20)\u00a0\n\u00a0\u00a0\u00a0\u00a0displayQueue(q)\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Given a sentence and the task is to replace a word with asterisks in a given Sentence.", "code": "# Give the string as user input using the input() function and store it in a variable.\r\ngvn_str = input(\"Enter some random sentence = \")\r\n# Give the replaceable word as user input using the input() function and store it in another variable.\r\ngvn_wrd = input(\"Enter some random word = \")\r\n# Split the given string into a list of words using the split() function and\r\n# store it in another variable say \"wrd_lst\".\r\nwrd_lst = gvn_str.split()\r\n# Multiply the asterisk symbol with the length of the given input word using\r\n# the len() function and store it in another variable.\r\nreplacd_word = '*' * len(gvn_wrd)\r\n# Loop in the above-obtained word list using the for loop.\r\nfor itr in range(len(wrd_lst)):\r\n  # Check if the iterator value is equal to the given input word using the if\r\n  # conditional statement.\r\n # check if thw word at the iterator index is equal is given\r\n    if wrd_lst[itr] == gvn_wrd:\r\n      # if it is truw thwn replce the word t the iterator index with the replaced word\r\n        wrd_lst[itr] = replacd_word\r\n# Convert the above-got word list to string using the join() function.\r\nfinl_str = ' '.join(wrd_lst)\r\n# Print the above-obtained string to replace a word with an asterisk in a\r\n# given input sentence.\r\nprint(\"The given string [\", gvn_str,\r\n      \"] after replacing with a given word with an asterisk :\")\r\nprint(finl_str)"}
{"nl": "In this python example, we'll learn to convert miles taken from user to kilometers and display it.", "code": "# miles input from the user\r\nmiles = float(input(\"Enter value in miles: \"))\r\n\r\n# calculate kilometers and display\r\nkilometers = miles * 1.60934\r\nprint('%0.3f miles is equal to %0.3f kilometers' %(miles, kilometers))"}
{"nl": "Given an array of integers, our task is to write a program that efficiently finds the second largest element present in the array. \nExample:\n\nInput: arr[] = {12, 35, 1, 10, 34, 1}\nOutput: The second largest element is 34.\nExplanation: The largest element of the \narray is 35 and the second \nlargest element is 34\n\nInput: arr[] = {10, 5, 10}\nOutput: The second largest element is 5.\nExplanation: The largest element of \nthe array is 10 and the second \nlargest element is 5\n\nInput: arr[] = {10, 10, 10}\nOutput: The second largest does not exist.\nExplanation: Largest element of the array \nis 10 there is no second largest element", "code": "# Python3 program to find second\n# largest element in an array\n\n# Function to print the\n# second largest elements\ndef print2largest(arr,\n\t\t\t\tarr_size):\n\n# There should be\n# atleast two elements\nif (arr_size < 2):\n\tprint(\" Invalid Input \")\n\treturn\n\n# Sort the array\narr.sort\n\n# Start from second last\n# element as the largest\n# element is at last\nfor i in range(arr_size-2,\n\t\t\t\t-1, -1):\n\n\t# If the element is not\n\t# equal to largest element\n\tif (arr[i] != arr[arr_size - 1]) :\n\t\n\tprint(\"The second largest element is\",\n\t\t\tarr[i])\n\treturn\n\nprint(\"There is no second largest element\")\n\n# Driver code\narr = [12, 35, 1, 10, 34, 1]\nn = len(arr)\nprint2largest(arr, n)\n\n# This code is contributed by divyeshrabadiya07"}
{"nl": "In the previous article, we had to print many pyramids star patterns using for loop and while loop but here, we have to print the hollow pyramid star patterns using for loop and while loop.", "code": "# Hollow pyramid star pattern in Python # user-defined function def pattern(n): for i in range(n): for j in range(n-i-1): # print the spaces print(\" \", end=\" \") for j in range(2*i+1): # printing stars if j == 0 or j == 2*i: # print the stars print(\"*\", end=\" \") else: if i == n-1: # print the stars print(\"*\", end=\" \") else: # print the spaces print(\" \", end=\" \") print() # input from the user n = int(input('Enter any number: ')) # the function call pattern(n)"}
{"nl": "Check if Two Numbers are Equal Without using Arithmetic and Comparison Operators Using Xor(^) Operator (Static Input)", "code": "# Create a function isEqualNumbers()\r\n# which takes the given two numbers as arguments and\r\n# returns true if they are equal\r\n# else returns false if they are not equal.\r\n\r\n\r\ndef isEqualNumbers(first_numb, second_numb):\r\n        # Inside the isEqualNumbers() function.\r\n        # Apply xor to the first number and second number and\r\n    # store it in a variable say xor_result.\r\n    xor_result = first_numb ^ second_numb\r\n    # Check if the value of xor_result is not equal to 0\r\n    # using the if conditional statement.\r\n    if(xor_result != 0):\r\n        # If it is true then return False\r\n        return False\r\n    # Else return True.\r\n    return True\r\n\r\n\r\n# Inside the main code.\r\n# Give the first number as static input and store it in a variable.\r\nfirstnumb = 10\r\n# Give the second number as static input and store it in another variable.\r\nsecondnumb = 10\r\n# Pass the given two numbers as the arguments to isEqualNumbers() function\r\n# and store the result in a variable Reslt.\r\nReslt = isEqualNumbers(firstnumb, secondnumb)\r\n# Check if the Value of Reslt using the If conditional statement.\r\nif(Reslt):\r\n        # If it is true then print the given two numbers are Equal.\r\n    print('The given two numbers {', firstnumb,\r\n          ',', secondnumb, '} are Equal')\r\n# Else print the given two numbers are Not Equal.\r\nelse:\r\n    print('The given two numbers {', firstnumb,\r\n          ',', secondnumb, '} are Not equal')"}
{"nl": "Given an n x n square matrix, find sum of all sub-squares of size k x k where k is smaller than or equal to n.\u00a0", "code": "# A simple Python 3 program to find sum\n# of all subsquares of size k x k\n\u00a0\n# Size of given matrix\nn = 5\n\u00a0\n# A simple function to find sum of all\n# sub-squares of size k x k in a given\n# square matrix of size n x n\ndef printSumSimple(mat, k):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# k must be smaller than or equal to n\n\u00a0\u00a0\u00a0\u00a0if (k > n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# row number of first cell in current\n\u00a0\u00a0\u00a0\u00a0# sub-square of size k x k\n\u00a0\u00a0\u00a0\u00a0for i in range(n - k + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# column of first cell in current\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sub-square of size k x k\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n - k + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate and print sum of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current sub-square\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for p in range(i, k + i):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for q in range(j, k + j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += mat[p][q]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(sum, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Line separator for sub-squares\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# starting with next row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[1, 1, 1, 1, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 2, 2, 2, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[3, 3, 3, 3, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 4, 4, 4, 4],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[5, 5, 5, 5, 5]]\n\u00a0\u00a0\u00a0\u00a0k = 3\n\u00a0\u00a0\u00a0\u00a0printSumSimple(mat, k)\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": "Given the base_1, base_2, and height of the trapezoid, the task is to calculate the area of the given trapezoid.", "code": "# Give the first base as static input and store it in a variable.\nfst_base = 2\n# Give the second base as static input and store it in another variable.\nsecnd_base = 4\n# Give the height of the given trapezoid as static input and store it in another variable\ngvn_Heigt = 1.5\n# Calculate the area of the given trapezoid using the above given mathematical formula\n# and store it in another variable.\ntrapezod_area = 0.5 * (fst_base + secnd_base) * gvn_Heigt\nprint(\"The Area of the given Trapezoid = \", trapezod_area)"}
{"nl": "Create a function that takes a number n as an argument and checks whether the given number can be expressed as a sum of two or more consecutive positive numbers.\nExamples\nconsecutiveSum(9) \u279e True\n# 9 can be expressed as a sum of (2 + 3 + 4) or (4 + 5).\n\nconsecutiveSum(10) \u279e True\n# 10 can be expressed as a sum of 1 + 2 + 3 + 4.\n\nconsecutiveSum(64) \u279e False\nNotes\nN/A", "code": "def consecutive_sum(n):\n  i, res = 2, 0\n  while 2 ** i <= n:\n    res = 2 ** i\n    i += 1\n  return res != n"}
{"nl": "0 represents the dog.\nEach list represents a house and each 1 represents an empty room.\nReturn the house and the room where it is located, there can be only one dog lost per building.\nExamples\nlost_dog([1, 1, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1])\n\u279e \"Dog not found!\"\n\nlost_dog([1, 1, 1, 1, 1, 1],  [0, 1, 1, 1, 1, 1],  [1, 0, 1, 1, 1, 1],  [1, 1, 1, 1, 1, 1])\n\u279e {\"Dog1\": \"House (2) and Room (1)\", \"Dog2\": \"House (3) and Room (2)\"}\n\nlost_dog([1, 1, 1, 1, 1, 0],  [0, 1, 1, 1, 1, 1],  [1, 0, 1, 1, 1, 1],  [1, 1, 0, 1, 1, 1])\n\u279e {\"Dog1\": \"House (1) and Room (6)\", \"Dog2\": \"House (2) and Room (1)\", \"Dog3\": \"House (3) and Room (2)\", \"Dog4\": \"House (4) and Room (3)\"}\nNotes\nCheck the Resources if you're stuck.", "code": "def lost_dog(*args, n=0):\n    res = dict()\n    for r, row in enumerate(args):\n        if 0 in row:\n            n += 1\n            res[\"Dog{}\".format(n)] = (\"House ({}) and Room ({})\"\n                                      .format(r + 1, row.index(0) + 1))\n    return res if n else \"Dog not found!\""}
{"nl": "If a person traveled up a hill for 18mins at 20mph and then traveled back down the same path at 60mph then their average speed traveled was 30mph.\nWrite a function that returns the average speed traveled given an uphill time, uphill rate and a downhill rate. Uphill time is given in minutes. Return the rate as an integer (mph). No rounding is necessary.\nExamples\nave_spd(18, 20, 60) \u279e 30\n\nave_spd(30, 10, 30) \u279e 15\n\nave_spd(30, 8, 24) \u279e 12\nNotes\nThe solution is not dividing the sum of the speeds by 2.\nCheck the Resources tab if your stuck.", "code": "def ave_spd(_, up, down):\n  return 2*up*down/(up+down)"}
{"nl": "Create a function that takes two arguments (text, key) and returns a new encrypted text using the key. For example, if the input is \"a\" and the key is 1, it should move that letter 1 step in alphabetic order so the output would be \"b\".\nExamples\ncaesar_cipher(\"hello\", 5) \u279e \"mjqqt\"\n\ncaesar_cipher(\"hello world\", 1) \u279e \"ifmmp xpsme\"\n\ncaesar_cipher(\"a\", 2) \u279e \"c\"\nNotes\nThe input is only letters and spaces; no special characters.", "code": "def caesar_cipher(text, key):\n    in_ = 'abcdefghijklmnopqrstuvwxyz'\n    out = in_[key:] + in_[:key]\n    return text.translate(str.maketrans(in_, out))"}
{"nl": "In the previous article, we have discussed Python Program to Find Sum of Series 1/2!+2/3!+3/5!+\u2026..N/(N+1)!\n Given a number N and the task is to find the sum of series (1^1/1+2^2/2+3^3/3\u2026+N^N/N) till the given number N in Python.\n Examples:\n Example1:\n Input:\n Given Number (Limit) = 4\n Output:\n The above series sum till the given number N{ 4 } = 76.0\n Example2:\n Input:\n Given Number (Limit) = 9\n Output:\n The above series sum till the given number N{ 9 } = 45269999.0", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the number N(limit) as static input and store it in a variable.\n \n gvn_numb = 4\n \n # Take a variable to say rsltseries_summ and initialize its value to 0.0\n \n # (Floating point number)\n \n rsltseries_summ = 0.0\n \n # Loop from 1 to the given number using the for loop.\n \n for itr in range(1, gvn_numb+1):\n \n  # Inside the loop, calculate the value of the iterator raised to the power itself and\n \n  # divided by the iterator value using the pow() function.\n \n  # Store it in another variable.\n \n  a = pow(itr, itr) / itr\n \n  # Add the above result to the rsltseries_summ and store it in the same variable.\n \n  rsltseries_summ += a\n \n # Print the sum of series till the given number N.\n \n print(\n \n  \"The above series sum till the given number N{\", gvn_numb, \"} = \", rsltseries_summ)\n \n </pre>"}
{"nl": "Create a function that takes a list of numbers and returns a new list, sorted in ascending order (smallest to biggest).\nSort numbers list in ascending order.\nIf the function's argument is None or an empty list, return an empty list.\nReturn a new array of sorted numbers.\nExamples\nsort_nums_ascending([1, 2, 10, 50, 5]) \u279e [1, 2, 5, 10, 50]\n\nsort_nums_ascending([80, 29, 4, -95, -24, 85]) \u279e [-95, -24, 4, 29, 80, 85]\n\nsort_nums_ascending([]) \u279e []\nNotes\nTest input can be positive or negative.", "code": "def sort_nums_ascending(lst):\n  return sorted(lst)"}
{"nl": "Given a BST, transform it into a greater sum tree where each node contains sum of all nodes greater than that node.", "code": "# Python3 program to transform a BST to sum tree\n\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, x):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = x\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Recursive function to transform a BST to sum tree.\n# This function traverses the tree in reverse inorder so\n# that we have visited all greater key nodes of the currently\n# visited node\ndef transformTreeUtil(root):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0# Base case\n\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0# Recur for right subtree\n\u00a0\u00a0\u00a0transformTreeUtil(root.right)\n\u00a0\n\u00a0\u00a0\u00a0# Update sum\n\u00a0\u00a0\u00a0global sum\n\u00a0\u00a0\u00a0sum = sum + root.data\n\u00a0\n\u00a0\u00a0\u00a0# Store old sum in current node\n\u00a0\u00a0\u00a0root.data = sum - root.data\n\u00a0\n\u00a0\u00a0\u00a0# Recur for left subtree\n\u00a0\u00a0\u00a0transformTreeUtil(root.left)\n\u00a0\n# A wrapper over transformTreeUtil()\ndef transformTree(root):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# sum = 0 #Initialize sum\n\u00a0\u00a0\u00a0\u00a0transformTreeUtil(root)\n\u00a0\n# A utility function to prindorder traversal of a\n# binary tree\ndef printInorder(root):\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0printInorder(root.left)\n\u00a0\u00a0\u00a0\u00a0print(root.data, end = \" \")\n\u00a0\u00a0\u00a0\u00a0printInorder(root.right)\n\u00a0\n# Driver Program to test above functions\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0sum=0\n\u00a0\u00a0\u00a0\u00a0root = Node(11)\n\u00a0\u00a0\u00a0\u00a0root.left = Node(2)\n\u00a0\u00a0\u00a0\u00a0root.right = Node(29)\n\u00a0\u00a0\u00a0\u00a0root.left.left = Node(1)\n\u00a0\u00a0\u00a0\u00a0root.left.right = Node(7)\n\u00a0\u00a0\u00a0\u00a0root.right.left = Node(15)\n\u00a0\u00a0\u00a0\u00a0root.right.right = Node(40)\n\u00a0\u00a0\u00a0\u00a0root.right.right.left = Node(35)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Inorder Traversal of given tree\")\n\u00a0\u00a0\u00a0\u00a0printInorder(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0transformTree(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"\\nInorder Traversal of transformed tree\")\n\u00a0\u00a0\u00a0\u00a0printInorder(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by mohit kumar 29\n"}
{"nl": "You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.\nThe customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball. After the transaction, there are only 5 yellow balls left, so the next yellow ball is then valued at 5 (i.e., the value of the balls decreases as you sell more to the customer).\nYou are given an integer array, inventory, where inventory[i] represents the number of balls of the ith color that you initially own. You are also given an integer orders, which represents the total number of balls that the customer wants. You can sell the balls in any order.\nReturn the maximum total value that you can attain after selling orders colored balls. As the answer may be too large, return it modulo 109 + 7.\n \nExample 1:\n\n\nInput: inventory = [2,5], orders = 4\nOutput: 14\nExplanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14.\n\nExample 2:\n\nInput: inventory = [3,5], orders = 6\nOutput: 19\nExplanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n\n \nConstraints:\n\n1 <= inventory.length <= 105\n1 <= inventory[i] <= 109\n1 <= orders <= min(sum(inventory[i]), 109)", "code": "class Solution:\n  def maxProfit(self, inv: List[int], orders: int) -> int:\n  arr=sorted(Counter(inv).items(), reverse=True)+[(0,0)]\n  ans, ind, width=0,0,0\n  \n  while orders>0:\n  width += arr[ind][1]\n  sell=min(orders, width * (arr[ind][0] - arr[ind+1][0]))\n  whole, remainder= divmod(sell, width)\n  ans += width*(whole*(arr[ind][0]+arr[ind][0]-(whole-1)))//2 + remainder*(arr[ind][0]-whole)\n  orders -= sell\n  ind += 1\n  return ans % 1_000_000_007"}
{"nl": "Create a Class\r\nTo create a class, use the keyword class:", "code": "class MyClass:\r\n  x = 5"}
{"nl": "Given coordinates of four points in a plane, find if the four points form a square or not. \nTo check for square, we need to check for following. \na) All fours sides formed by points are the same. \nb) The angle between any two sides is 90 degree. (This condition is required as Quadrilateral also has same sides. \nc) Check both the diagonals have the same distance", "code": "# A Python3 program to check if\n# four given points form a square or not.\nclass Point:\n\t\n\t# Structure of a point in 2D space\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\n# A utility function to find square of\n# distance from point 'p' to point 'q'\ndef distSq(p, q):\n\treturn (p.x - q.x) * (p.x - q.x) +\\\n\t\t(p.y - q.y) * (p.y - q.y)\n\n# This function returns true if (p1, p2, p3, p4)\n# form a square, otherwise false\ndef isSquare(p1, p2, p3, p4):\n\n\td2 = distSq(p1, p2) # from p1 to p2\n\td3 = distSq(p1, p3) # from p1 to p3\n\td4 = distSq(p1, p4) # from p1 to p4\n\n\tif d2 == 0 or d3 == 0 or d4 == 0:\n\t\treturn False\n\n\t# If lengths if (p1, p2) and (p1, p3) are same, then\n\t# following conditions must be met to form a square.\n\t# 1) Square of length of (p1, p4) is same as twice\n\t# the square of (p1, p2)\n\t# 2) Square of length of (p2, p3) is same\n\t# as twice the square of (p2, p4)\n\n\tif d2 == d3 and 2 * d2 == d4 and \\\n\t\t\t\t\t2 * distSq(p2, p4) == distSq(p2, p3):\n\t\treturn True\n\n\t# The below two cases are similar to above case\n\tif d3 == d4 and 2 * d3 == d2 and \\\n\t\t\t\t\t2 * distSq(p3, p2) == distSq(p3, p4):\n\t\treturn True\n\n\tif d2 == d4 and 2 * d2 == d3 and \\\n\t\t\t\t\t2 * distSq(p2, p3) == distSq(p2, p4):\n\t\treturn True\n\n\treturn False\n\n# Driver Code\nif __name__==\"__main__\":\n\tp1 = Point(20, 10)\n\tp2 = Point(10, 20)\n\tp3 = Point(20, 20)\n\tp4 = Point(10, 10)\n\t\n\tif isSquare(p1, p2, p3, p4):\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n\n# This code is contributed by Mayank Chaudhary\n# aka chaudhary_19"}
{"nl": "A string r is a substring or subword of a string s if r is contained within s. A string r is a common substring of s and t if r is a substring of both s and t. A string r is a longest common substring or subword (LCW) of s and t if there is no string that is longer than r and is a common substring of s and t. The problem is to find an LCW of two given strings.", "code": "def lcw(u, v):\n    \"\"\"Return length of an LCW of strings u and v and its starting indexes.\n\u00a0\n    (l, i, j) is returned where l is the length of an LCW of the strings u, v\n    where the LCW starts at index i in u and index j in v.\n    \"\"\"\n    c = [[-1]*(len(v) + 1) for _ in range(len(u) + 1)]\n\u00a0\n    lcw_i = lcw_j = -1\n    length_lcw = 0\n    for i in range(len(u)):\n        for j in range(len(v)):\n            temp = lcw_starting_at(u, v, c, i, j)\n            if length_lcw < temp:\n                length_lcw = temp\n                lcw_i = i\n                lcw_j = j\n\u00a0\n    return length_lcw, lcw_i, lcw_j\n\u00a0\n\u00a0\ndef lcw_starting_at(u, v, c, i, j):\n    \"\"\"Return length of the LCW starting at u[i:] and v[j:] and fill table c.\n\u00a0\n    c[i][j] contains the length of the LCW at the start of u[i:] and v[j:].\n    This function fills in c as smaller subproblems for solving c[i][j] are\n    solved.\"\"\"\n    if c[i][j] >= 0:\n        return c[i][j]\n\u00a0\n    if i == len(u) or j == len(v):\n        q = 0\n    elif u[i] != v[j]:\n        q = 0\n    else:\n        q = 1 + lcw_starting_at(u, v, c, i + 1, j + 1)\n\u00a0\n    c[i][j] = q\n    return q\n\u00a0\n\u00a0\nu = input('Enter first string: ')\nv = input('Enter second string: ')\nlength_lcw, lcw_i, lcw_j = lcw(u, v)\nprint('Longest Common Subword: ', end='')\nif length_lcw > 0:\n    print(u[lcw_i:lcw_i + length_lcw])"}
{"nl": "There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.\n\nYou are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:\n\nThe first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').\nThe second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').\nFor example, \"R3G2B1\" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n\nReturn the number of rods that have all three colors of rings on them.", "code": "from collections import Counter\nclass Solution(object):\n    def countPoints(self, rings):\n        count=0\n        freq={}\n        final=[str(rings[i:i+2]) for i in range(0,len(rings),2)]\n        for i in range(len(final)):\n            if final[i][-1] in freq:\n                freq[final[i][-1]] += final[i][0]\n            else:\n                freq[final[i][-1]]=final[i][0]\n        for item,value in freq.items():\n            if len(Counter(value))==3:\n                count+=1    \n        return count"}
{"nl": "Given the number of rows of the right-angled Hollow triangle star pattern in C, C++, and python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven number of rows of the hollow right-angled triangle star pattern=11\nOutput:\n\n* \n*  * \n*  * \n*  * \n*  * \n*  * \n*  * \n*  * \n*  * \n*  * \n* * * * * * * * * * *\nExample2:\n\nInput:\n\ngiven number of rows of the hollow right-angled triangle star pattern=8\ngiven character to print =^\nOutput\n\n^ \n^  ^ \n^  ^ \n^  ^ \n^  ^ \n^  ^ \n^  ^ \n^ ^ ^ ^ ^ ^ ^ ^", "code": "# Give the number of rows of the hollow right-angled triangle star pattern\n# as static input and store it in a variable.\ntrianglerows = 7\n# Loop from 1 to the number of rows using For loop.\nfor m in range(1, trianglerows+1):\n  # Loop from 1 to first loop iterator value using another Nested For loop.\n  for n in range(1, m+1):\n  # If you closely examine the pattern, you will notice that the\n  # star is available on the first or last column or row.\n  # So, for the first or last column or row, print a star, otherwise, print space.\n  if(m == 1 or m == trianglerows or n == 1 or n == m):\n  print('*', end=' ')\n  else:\n  print(' ', end=' ')\n  # Print the newline character after ending of inner For loop.\n  print()"}
{"nl": "NetworkX is a Python language software package for the creation, manipulation, and study of the structure, dynamics, and function of complex networks. It is used to study large complex networks represented in form of graphs with nodes and edges. Using networkx we can load and store complex networks. We can generate many types of random and classic networks, analyze network structure, build network models, design new network algorithms and draw networks.\u00a0", "code": "# Python program to create an undirected\u00a0\n# graph and add nodes and edges to a graph\n\u00a0\u00a0\n# To import package\nimport networkx\n\u00a0\u00a0\u00a0\n# To create an empty undirected graph\nG = networkx.Graph()\n\u00a0\u00a0\u00a0\n# To add a node\nG.add_node(1)\nG.add_node(2)\nG.add_node(3)\nG.add_node(4)\nG.add_node(7)\nG.add_node(9)\n\u00a0\u00a0\u00a0\n# To add an edge\n# Note graph is undirected\n# Hence order of nodes in edge doesn't matter\nG.add_edge(1,2)\nG.add_edge(3,1)\nG.add_edge(2,4)\nG.add_edge(4,1)\nG.add_edge(9,1)\nG.add_edge(1,7)\nG.add_edge(2,9)\n\u00a0\u00a0\u00a0\n# To get all the nodes of a graph\nnode_list = G.nodes()\nprint(\"#1\")\nprint(node_list)\n\u00a0\u00a0\u00a0\n# To get all the edges of a graph\nedge_list = G.edges()\nprint(\"#2\")\nprint(edge_list)\n\u00a0\u00a0\u00a0\n# To remove a node of a graph\nG.remove_node(3)\nnode_list = G.nodes()\nprint(\"#3\")\nprint(node_list)\n\u00a0\u00a0\u00a0\n# To remove an edge of a graph\nG.remove_edge(1,2)\nedge_list = G.edges()\nprint(\"#4\")\nprint(edge_list)\n\u00a0\u00a0\u00a0\n# To find number of nodes\nn = G.number_of_nodes()\nprint(\"#5\")\nprint(n)\n\u00a0\u00a0\u00a0\n# To find number of edges\nm = G.number_of_edges()\nprint(\"#6\")\nprint(m)\n\u00a0\u00a0\u00a0\n# To find degree of a node\n# d will store degree of node 2\nd = G.degree(2)\nprint(\"#7\")\nprint(d)\n\u00a0\u00a0\n# To find all the neighbor of a node\nneighbor_list = G.neighbors(2)\nprint(\"#8\")\nprint(neighbor_list)\n\u00a0\u00a0\n#To delete all the nodes and edges\nG.clear()\n"}
{"nl": "Using the dir() Function\r\nThere is a built-in function to list all the function names (or variable names) in a module. The dir() function:", "code": "import platform\r\n\r\nx = dir(platform)\r\nprint(x)"}
{"nl": "Given a Binary tree and a number N, write a program to find the N-th node in the Postorder traversal of the given Binary tree.", "code": "\"\"\"Python3 program to find n-th node of\r\nPostorder Traversal of Binary Tree\"\"\"\r\n\r\n# A Binary Tree Node\r\n# Utility function to create a new tree node\r\nclass createNode:\r\n\r\n\t# Constructor to create a newNode\r\n\tdef __init__(self, data):\r\n\t\tself.data= data\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# function to find the N-th node\r\n# in the postorder traversal of\r\n# a given binary tree\r\nflag = [0]\r\ndef NthPostordernode(root, N):\r\n\r\n\tif (root == None):\r\n\t\treturn\r\n\r\n\tif (flag[0] <= N[0]):\r\n\t\t\r\n\t\t# left recursion\r\n\t\tNthPostordernode(root.left, N)\r\n\r\n\t\t# right recursion\r\n\t\tNthPostordernode(root.right, N)\r\n\r\n\t\tflag[0] += 1\r\n\r\n\t\t# prints the n-th node of\r\n\t\t# preorder traversal\r\n\t\tif (flag[0] == N[0]):\r\n\t\t\tprint(root.data)\r\n\t\t\t\t\t\t\r\n# Driver Code\r\nif __name__ == '__main__':\r\n\troot = createNode(25)\r\n\troot.left = createNode(20)\r\n\troot.right = createNode(30)\r\n\troot.left.left = createNode(18)\r\n\troot.left.right = createNode(22)\r\n\troot.right.left = createNode(24)\r\n\troot.right.right = createNode(32)\r\n\r\n\tN = [6]\r\n\r\n\t# prints n-th node found\r\n\tNthPostordernode(root, N)\r\n\r\n# This code is contributed by\r\n# SHUBHAMSINGH10\r"}
{"nl": "Harshad Number:\n\nA Harshad number is one whose original number is divisible by the sum of its digits.\n\nlike 5 , 18 , 156 etc.\n\nExample 1:\n\nInput:\n\nnumber=18\nOutput:\n\n18 is harshad number\nExplanation:\n\nHere sum_of_digits=9 i.e (1+8 ) and 18 is divisible by 9", "code": "# given number\nnum = 18\n# intiialize sum of digits to 0\nsum_of_digits = 0\n# copy the number in another variable(duplicate)\ndup_number = num\n# Traverse the digits of number using for loop\nwhile dup_number > 0:\n    sum_of_digits = sum_of_digits + dup_number % 10\n    dup_number = dup_number // 10\n# It is harshad number if sum of digits is equal to given number\n\nif(num % sum_of_digits == 0):\n    print(num, \"is harshad number\")\nelse:\n    print(num, \"is not harshad number\")"}
{"nl": "Write a regular expression that matches a string if it contains at least one digit.\nExamples\nhas_digit(\"c8\") \u279e True\n\nhas_digit(\"23cc4\") \u279e True\n\nhas_digit(\"abwekz\") \u279e False\n\nhas_digit(\"sdfkxi\") \u279e False\nNotes\nThis challenge is designed to use RegEx only.", "code": "import re\ndef has_digit(txt):\n  return bool(re.search(r'\\d', txt))"}
{"nl": "Given an array arr[]. Find the maximum value of prefix sum which is also suffix sum for index i in arr[].", "code": "# Python3 program to find\r\n# maximum equilibrium sum.\r\n\r\n# Function to find maximum\r\n# equilibrium sum.\r\ndef findMaxSum(arr, n):\r\n\r\n\t# Array to store prefix sum.\r\n\tpreSum = [0 for i in range(n)]\r\n\r\n\t# Array to store suffix sum.\r\n\tsuffSum = [0 for i in range(n)]\r\n\r\n\t# Variable to store maximum sum.\r\n\tans = -10000000\r\n\r\n\t# Calculate prefix sum.\r\n\tpreSum[0] = arr[0]\r\n\t\r\n\tfor i in range(1, n):\r\n\t\r\n\t\tpreSum[i] = preSum[i - 1] + arr[i]\r\n\r\n\t# Calculate suffix sum and compare\r\n\t# it with prefix sum. Update ans\r\n\t# accordingly.\r\n\tsuffSum[n - 1] = arr[n - 1]\r\n\tif (preSum[n - 1] == suffSum[n - 1]):\r\n\t\tans = max(ans, preSum[n - 1])\r\n\t\r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tsuffSum[i] = suffSum[i + 1] + arr[i]\r\n\t\tif (suffSum[i] == preSum[i]):\r\n\t\t\tans = max(ans, preSum[i])\r\n\t\r\n\treturn ans\r\n\r\n# Driver Code\r\nif __name__=='__main__':\r\n\r\n\tarr = [-2, 5, 3, 1,2, 6, -4, 2]\r\n\tn = len(arr)\r\n\tprint(findMaxSum(arr, n))\r\n\t\r\n# This code i contributed by pratham76\r"}
{"nl": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\n \n\nExample 1:\n\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3", "code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 0 or nums is None:\n            return 0\n\n        if len(nums) == 1:\n            return nums[0]\n\n        return max(self.rob_simple(nums[:-1]), self.rob_simple(nums[1:]))\n\n    def rob_simple(self, nums: List[int]) -> int:\n        t1 = 0\n        t2 = 0\n        for current in nums:\n            temp = t1\n            t1 = max(current + t2, t1)\n            t2 = temp\n\n        return t1"}
{"nl": "What is a Module?\r\nConsider a module to be the same as a code library.\r\n\r\nA file containing a set of functions you want to include in your application.\r\n\r\nCreate a Module\r\nTo create a module just save the code you want in a file with the file extension .py:", "code": "#Save this code in a file named mymodule.py\n\ndef greeting(name):\n  print(\"Hello, \" + name)\nimport mymodule\nmymodule.greeting(\"Jonathan\")"}
{"nl": "Create a function that takes a list and returns the most frequently occurring element contained within it.\r\n\r\nExamples\r\nfind_frequent([3, 7, 3]) \u279e 3\r\n\r\nfind_frequent([None, \"hello\", True, None]) \u279e None\r\n\r\nfind_frequent([False, \"up\", \"down\", \"left\", \"right\", True, False]) \u279e False", "code": "def find_frequent(lst):\r\n\treturn sorted(lst , key = lst.count)[-1];"}
{"nl": "Files In Python:\n\nA file is a piece of data or information stored on a computer\u2019s hard drive. You\u2019re already familiar with a variety of file kinds, including music, video, and text files. Manipulation of these files is trivial with Python. Text files and binary files are the two types of files that are commonly used. Binary files contain binary data that can only be read by a computer, whereas text files include plain text.\n\nFor programmers and automation testers, Python file handling (also known as File I/O) is a crucial topic. Working with files is required in order to write to or read data from them.\n\n\n\nIn addition, if you didn\u2019t know, I/O activities are the most expensive techniques via which software might fail. As a result, when implementing file processing for reporting or any other reason, you should proceed with caution. The construction of a high-performance application or a robust solution for automated software testing can benefit from optimizing a single file activity.\n\nGiven a file that contains duplicate lines the task is to remove the duplicate lines of the file and store them in another File using Python.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\nreadFile = open(givenFilename, 'r')\n# Make another variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system.\nwriteFileName = \"samplewritefile.txt\"\n# Open another file in write mode. In this case, we're simply writing the contents of the file.\nwritingFile = open(\"writeFileName\", 'w')\n# Take an empty list to store the unique lines of the file.\nlineslist = []\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nfor line in readFile:\n  # Iterate through the lines of the file using the For loop.\n  # Check if the line is not in the list using the if, not, in operators.\n  if line not in lineslist:\n  # If the condition is true then write the line in the second file using the write function.\n  writingFile.write(line)\n  # Add the line to the above list using the append() function.\n  lineslist.append(line)"}
{"nl": "Write a Python program to print right triangle of mirrored alphabets pattern using for loop.\n\n", "code": "rows = int(input(\"Enter Right Triangle Mirrored Alphabets Rows = \"))\n\nprint(\"====The Right Triangle of Mirrored Alphabets Pattern====\")\nalphabet = 65\n\nfor i in range(rows):\n    for j in range(i + 1):\n        print('%c' %(alphabet + j), end = '')\n    for k in range(i - 1, -1, -1):\n        print('%c' %(alphabet + k), end = '')\n    print()"}
{"nl": "Create a function that takes a list of dictionary like { name: \"John\", notes: [3, 5, 4]} and returns a list of dictionary like { name: \"John\", avgNote: 4 }. If student has no notes (an empty array) then avgNote is zero.\nExamples\n[\n  { name: \"John\", notes: [3, 5, 4]}\n] \u279e [\n  { name: \"John\", avgNote: 4 }\n]\nNotes\nRound the avgNote to a whole number.", "code": "def avg_note(students):\n    lst = students[0]['notes']\n    students[0]['avgNote'] = round(sum(lst) / len(lst)) if lst else 0\n    students[0].pop('notes')\n    return students"}
{"nl": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.", "code": "# Python program to find minimum depth of a given Binary Tree\n\n# Tree node\nclass Node:\n\tdef __init__(self , key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\ndef minDepth(root):\n\t# Corner Case.Should never be hit unless the code is\n\t# called on root = NULL\n\tif root is None:\n\t\treturn 0\n\t\n\t# Base Case : Leaf node.This accounts for height = 1\n\tif root.left is None and root.right is None:\n\t\treturn 1\n\t\n\t# If left subtree is Null, recur for right subtree\n\tif root.left is None:\n\t\treturn minDepth(root.right)+1\n\t\n\t# If right subtree is Null , recur for left subtree\n\tif root.right is None:\n\t\treturn minDepth(root.left) +1\n\t\n\treturn min(minDepth(root.left), minDepth(root.right))+1\n\n# Driver Program\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nprint (minDepth(root))\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\t\n"}
{"nl": "This python program reads temperature in Celsius from user and converts it to Fahrenheit and Kelvin.\r\nFollowing temperature conversion formula are used in this program:\r\n\r\nFahrenheit = 1.8 * Celsius + 32\r\n\r\nKelvin = 273.15 + Celsius", "code": "# Celsius to Fahrenheit & Kelvin\r\n\r\n# Reading temperature in Celsius\r\ncelsius = float(input('Enter temperature in celsius: '))\r\n\r\n# Converting\r\nfahrenheit = 1.8 * celsius + 32\r\nkelvin = 273.15 + celsius\r\n\r\n# Displaying output\r\nprint('%0.3f Celsius = %0.3f Fahrenheit.' % (celsius, fahrenheit))\r\nprint('%0.3f Celsius = %0.3f Kelvin.' % (celsius, kelvin))"}
{"nl": null, "code": null}
{"nl": "You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. A pair (c, d) can follow another pair (a, b) if b < c. Chain of pairs can be formed in this fashion. Find the longest chain which can be formed from a given set of pairs. \n\nFor example, if the given pairs are {{5, 24}, {39, 60}, {15, 28}, {27, 40}, {50, 90} }, then the longest chain that can be formed is of length 3, and the chain is {{5, 24}, {27, 40}, {50, 90}}", "code": "# Python program for above approach\n\n# Structure val\nclass val:\n\tdef __init__(self,first,second):\n\t\tself.first = first\n\t\tself.second = second\n\t\n# Memoisation function\ndef findMaxChainLen(p, n, prev, pos):\n\t\n\tglobal m\n\t\n\t# Check if pair { pos, prev } exists\n\t# in m\n\tif (val(pos, prev) in m):\n\t\treturn m[val(pos, prev)]\n\n\t# Check if pos is >=n\n\tif (pos >= n):\n\t\treturn 0\n\n\t# Check if p[pos].first is\n\t# less than prev\n\tif (p[pos].first <= prev):\n\t\treturn findMaxChainLen(p, n, prev, pos + 1)\n\n\telse:\n\t\tans = max(findMaxChainLen(p, n,\n\t\t\t\t\t\t\tp[pos].second, 0) + 1,\n\t\t\t\t\tfindMaxChainLen(p, n,\n\t\t\t\t\t\t\t\tprev, pos + 1))\n\t\tm[val(pos, prev)] = ans\n\t\treturn ans\n\n# Function to calculate maximum\n# chain length\ndef maxChainLen(p,n):\n\n\tglobal m\n\tm.clear()\n\n\t# Call memoisation function\n\tans = findMaxChainLen(p, n, 0, 0)\n\treturn ans\n\n# Driver Code\nn = 5\np = [0]*n\np[0] = val(5,24)\n\np[1] = val(39,60)\n\np[2] = val(15,28)\n\np[3] = val(27,40)\n\np[4] = val(50,90)\n\nm = {}\n\n# Function Call\nprint(maxChainLen(p, n))\n\n# This code is contributed by shinjanpatra"}
{"nl": "In this article, we are going to discuss how Divide and Conquer technique is helpful and how we can solve the problem with the DAC technique approach. In this section, we will discuss the following topics. \n\n1. Introduction to DAC.\n2. Algorithms under DAC techniques.\n3. Recurrence Relation for DAC algorithm.\n4. Problems using DAC technique.\nDivide And Conquer \nThis technique can be divided into the following three parts:\n\n\n\nDivide: This involves dividing the problem into smaller sub-problems.\nConquer: Solve sub-problems by calling recursively until solved.\nCombine: Combine the sub-problems to get the final solution of the whole problem.\n \nThe following are some standard algorithms that follow Divide and Conquer algorithm.  \n\nQuicksort is a sorting algorithm. The algorithm picks a pivot element and rearranges the array elements so that all elements smaller than the picked pivot element move to the left side of the pivot, and all greater elements move to the right side. Finally, the algorithm recursively sorts the subarrays on the left and right of the pivot element.\nMerge Sort is also a sorting algorithm. The algorithm divides the array into two halves, recursively sorts them, and finally merges the two sorted halves.\nClosest Pair of Points The problem is to find the closest pair of points in a set of points in the x-y plane. The problem can be solved in O(n^2) time by calculating the distances of every pair of points and comparing the distances to find the minimum. The Divide and Conquer algorithm solves the problem in O(N log N) time.\nStrassen\u2019s Algorithm is an efficient algorithm to multiply two matrices. A simple method to multiply two matrices needs 3 nested loops and is O(n^3). Strassen\u2019s algorithm multiplies two matrices in O(n^2.8974) time.\nCooley\u2013Tukey Fast Fourier Transform (FFT) algorithm is the most common algorithm for FFT. It is a divide and conquer algorithm which works in O(N log N) time.\nKaratsuba algorithm for fast multiplication does the multiplication of two n-digit numbers in at most\n3n^{log_{2}^{3}}\\approx 3n^{1.585}\nsingle-digit multiplications in general (and exactly n^{\\log_23}  when n is a power of 2). It is, therefore, faster than the classical algorithm, which requires n2 single-digit products. If n = 210 = 1024, in particular, the exact counts are 310 = 59, 049 and (210)2 = 1, 048, 576, respectively.\n\nWhat does not qualifies as Divide and Conquer:\n\nBinary Search is a searching algorithm. In each step, the algorithm compares the input element x with the value of the middle element in the array. If the values match, return the index of the middle. Otherwise, if x is less than the middle element, then the algorithm recurs for the left side of the middle element, else recurs for the right side of the middle element. Contrary to popular belief, this is not an example of Divide and Conquer because there is only one sub-problem in each step (Divide and conquer requires that there must be two or more sub-problems) and hence this is a case of Decrease and Conquer.", "code": "# Python3 code to demonstrate Divide and\n# Conquer Algorithm\n\n# Function to find the maximum no.\n# in a given array.\ndef DAC_Max(a, index, l):\n\tmax = -1;\n\n\tif (index >= l - 2):\n\t\tif (a[index] > a[index + 1]):\n\t\t\treturn a[index];\n\t\telse:\n\t\t\treturn a[index + 1];\n\n\t# Logic to find the Maximum element\n\t# in the given array.\n\tmax = DAC_Max(a, index + 1, l);\n\n\tif (a[index] > max):\n\t\treturn a[index];\n\telse:\n\t\treturn max;\n\n# Function to find the minimum no.\n# in a given array.\ndef DAC_Min(a, index, l):\n\tmin = 0;\n\tif (index >= l - 2):\n\t\tif (a[index] < a[index + 1]):\n\t\t\treturn a[index];\n\t\telse:\n\t\t\treturn a[index + 1];\n\n\t# Logic to find the Minimum element\n\t# in the given array.\n\tmin = DAC_Min(a, index + 1, l);\n\n\tif (a[index] < min):\n\t\treturn a[index];\n\telse:\n\t\treturn min;\n\n# Driver Code\nif __name__ == '__main__':\n\n\t# Defining the variables\n\tmin, max = 0, -1;\n\n\t# Initializing the array\n\ta = [70, 250, 50, 80, 140, 12, 14];\n\n\t# Recursion - DAC_Max function called\n\tmax = DAC_Max(a, 0, 7);\n\n\t# Recursion - DAC_Max function called\n\tmin = DAC_Min(a, 0, 7);\n\tprint(\"The minimum number in a given array is : \", min);\n\tprint(\"The maximum number in a given array is : \", max);\n\n# This code is contributed by 29AjayKumar"}
{"nl": "Given a string of lowercase letters. Find minimum characters to be inserted in the string so that it can become palindrome. We can change the positions of characters in the string.", "code": "# Python3 program to find minimum number\n# of insertions to make a string\n# palindrome\nimport math as mt\n\n# Function will return number of\n# characters to be added\ndef minInsertion(tr1):\n\n        # To store string length\n        n = len(str1)\n\n        # To store number of characters\n        # occurring odd number of times\n        res = 0\n\n        # To store count of each\n        # character\n        count = [0 for i in range(26)]\n\n        # To store occurrence of each\n        # character\n        for i in range(n):\n                count[ord(str1[i]) - ord('a')] += 1\n\n        # To count characters with odd\n        # occurrence\n        for i in range(26):\n                if (count[i] % 2 == 1):\n                        res += 1\n\n        # As one character can be odd return\n        # res - 1 but if string is already\n        # palindrome return 0\n        if (res == 0):\n                return 0\n        else:\n                return res - 1\n\n# Driver Code\nstr1 = \"geeksforgeeks\"\nprint(minInsertion(str1))\n\n# This code is contributed by\n# Mohit kumar 29\n"}
{"nl": "Let 1 represent \u2018A\u2019, 2 represents \u2018B\u2019, etc. Given a digit sequence, count the number of possible decodings of the given digit sequence. \n\nExamples: \n\nInput:  digits[] = \"121\"\nOutput: 3\n// The possible decodings are \"ABA\", \"AU\", \"LA\"\n\nInput: digits[] = \"1234\"\nOutput: 3\n// The possible decodings are \"ABCD\", \"LCD\", \"AWD\"", "code": "# Recursive implementation of numDecodings\ndef numDecodings(s: str) -> int:\n\tif len(s) == 0\n\tor (len(s) == 1\n\t\tand s[0] == '0'):\n\t\treturn 0\n\treturn numDecodingsHelper(s, len(s))\n\n\ndef numDecodingsHelper(s: str, n: int) -> int:\n\tif n == 0 or n == 1:\n\t\treturn 1\n\tcount = 0\n\tif s[n-1] > \"0\":\n\t\tcount = numDecodingsHelper(s, n-1)\n\tif (s[n - 2] == '1'\n\t\tor (s[n - 2] == '2'\n\t\t\tand s[n - 1] < '7')):\n\t\tcount += numDecodingsHelper(s, n - 2)\n\treturn count\n\n\n# Driver code\ndigits = \"1234\"\nprint(\"Count is \", numDecodings(digits))\n# This code is contributed by Frank Hu"}
{"nl": "Given a binary tree, check whether it is a mirror of itself without recursion.\n\nExamples: \n\nInput :   \n    \n     1\n   /   \\\n  2     2\n / \\   / \\\n3   4 4   3\n\nOutput : Symmetric", "code": "# Python3 program to program to check if a\n# given Binary Tree is symmetric or not\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pairs.\t\t\t\t\t\t\t\t\t\nclass newNode:\n\n\t# Constructor to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\n# function to check if a given\n# Binary Tree is symmetric or not\ndef isSymmetric( root) :\n\n\t# if tree is empty\n\tif (root == None) :\n\t\treturn True\n\t\n\t# If it is a single tree node,\n\t# then it is a symmetric tree.\n\tif(not root.left and not root.right):\n\t\treturn True\n\t\n\tq = []\t\n\t\n\t# Add root to queue two times so that\n\t# it can be checked if either one\n\t# child alone is NULL or not.\n\tq.append(root)\n\tq.append(root)\n\t\n\t# To store two nodes for checking\n\t# their symmetry.\n\tleftNode = 0\n\trightNode = 0\n\t\n\twhile(not len(q)):\n\t\t\n\t\t# Remove first two nodes to\n\t\t# check their symmetry.\n\t\tleftNode = q[0]\n\t\tq.pop(0)\n\t\t\n\t\trightNode = q[0]\n\t\tq.pop(0)\n\t\t\n\t\t# if both left and right nodes\n\t\t# exist, but have different\n\t\t# values-. inequality, return False\n\t\tif(leftNode.key != rightNode.key):\n\t\t\treturn False\n\t\t\n\t\t# append left child of left subtree\n\t\t# node and right child of right\n\t\t# subtree node in queue.\n\t\tif(leftNode.left and rightNode.right) :\n\t\t\tq.append(leftNode.left)\n\t\t\tq.append(rightNode.right)\n\t\t\n\t\t# If only one child is present\n\t\t# alone and other is NULL, then\n\t\t# tree is not symmetric.\n\t\telse if (leftNode.left or rightNode.right) :\n\t\t\treturn False\n\t\t\n\t\t# append right child of left subtree\n\t\t# node and left child of right subtree\n\t\t# node in queue.\n\t\tif(leftNode.right and rightNode.left):\n\t\t\tq.append(leftNode.right)\n\t\t\tq.append(rightNode.left)\n\t\t\n\t\t# If only one child is present\n\t\t# alone and other is NULL, then\n\t\t# tree is not symmetric.\n\t\telse if(leftNode.right or rightNode.left):\n\t\t\treturn False\n\t\n\treturn True\n\t\t\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# Let us construct the Tree\n\t# shown in the above figure\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(2)\n\troot.left.left = newNode(3)\n\troot.left.right = newNode(4)\n\troot.right.left = newNode(4)\n\troot.right.right = newNode(3)\n\tif (isSymmetric(root)) :\n\t\tprint(\"The given tree is Symmetric\")\n\telse:\n\t\tprint(\"The given tree is not Symmetric\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Definition and Usage\r\nThe items() method returns a view object. The view object contains the key-value pairs of the dictionary, as tuples in a list.\r\n\r\nThe view object will reflect any changes done to the dictionary, see example below.", "code": "car = {\r\n  \"brand\": \"Ford\",\r\n  \"model\": \"Mustang\",\r\n  \"year\": 1964\r\n}\r\n\r\nx = car.items()\r\n\r\nprint(x)"}
{"nl": "This python program calculates distance between two points or coordinates given by user using distance formula.\r\nThis program uses following formula for distance between two points:\r\n\r\nDistance Formula = ( (x2 - x1)2 + (y2 - y1)2 )\u00bd\r\n\r\nWhere: (x1, y1) = coordinates of the first point & (x2, y2) = coordinates of the second point", "code": "# Python Program to Calculate Distance \r\n\r\n# Reading co-ordinates\r\nx1 = float(input('Enter x1: '))\r\ny1 = float(input('Enter y1: '))\r\nx2 = float(input('Enter x2: '))\r\ny2 = float(input('Enter y2: '))\r\n\r\n# Calculating distance\r\nd = ( (x2-x1)**2 + (y2-y1)**2 ) ** 0.5\r\n\r\n# Displaying result\r\nprint('Distance = %f' %(d))"}
{"nl": "A circular sector, also known as a circle sector, is a portion of a disc bounded by two radii and an arc, with the smaller area known as the minor sector and the larger as the major sector.\r\n\r\nGiven the radius and angle of a circle, the task is to calculate the area of the circular sector in python.\r\n\r\nFormula:\r\n\r\nArea of sector = (angle/360)*(pi * radius\u00b2)\r\n\r\nwhere pi=3.1415\u2026.", "code": "# Give the radius as static input and store it in a variable.\r\ngvn_radiuss = 24\r\n# Give the angle as static input and store it in another variable.\r\ngvn_angl = 90\r\n# Take a variable and initialize its value to 22/7.\r\ngvn_pi = 22/7\r\n# Check if the given angle is greater than or equal to 360 degrees or not using the\r\n# if conditional statement.\r\nif gvn_angl >= 360:\r\n    # If it is true, then print \"Invalid Angle. Please enter the other\"\r\n    print(\"Invalid Angle. Please enter the other\")\r\nelse:\r\n    # Else, calculate the area of circular sector using the above given mathematical\r\n    # formula and store it in a variable.\r\n    area_of_sectr = (gvn_pi * gvn_radiuss ** 2) * (gvn_angl / 360)\r\n    # Print the area of circular sector for the given angle.\r\n    print(\"The area of circular sector for the given angle {\",\r\n          gvn_angl, \"} degrees = \", area_of_sectr)"}
{"nl": "You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.\n\nMore formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.\n\nReturn the maximum possible product of the lengths of the two non-intersecting palindromic substrings.\n\nA palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\n\n ", "code": "class Solution:\n    \n    def maxProduct(self, s: str) -> int:\n        mod = 10**9 + 7\n        base = 27\n        n = len(s)\n        forward_hash = [0] * (len(s) + 1)\n        backward_hash = [0] * (len(s) + 1)\n        for i in range(1, n+1):\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord('a'))) % mod\n        for i in range(n-1, -1, -1):\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord('a'))) % mod\n            \n        def is_parlin(s, center, l):\n            # check if it is a palin, with l being the radius\n            # [left, center-1] vs [center+1, right]\n            p = pow(base, l, mod)\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\n            return left_hash == right_hash\n        \n        # inclusive\n        before_idx_max_len = [1] * n\n        after_idx_max_len = [1] * n\n        \n        # for each center, expand\n        for i in range(1, n-1):\n            max_radius = 1\n            if s[i-1] != s[i+1]: # radius = 1 fails\n                continue\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\n            start, end = 1, min(i, n-i)\n            while start + 1 < end:\n                mid = (start + end) // 2\n                if is_parlin(s, i, mid):\n                    start = mid\n                else:\n                    end = mid\n            if i + end < n and is_parlin(s, i, end):\n                max_radius = end\n            else:\n                max_radius = start\n                \n            left = i - max_radius\n            right = i + max_radius\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\n        \n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\n        for i in range(n-2, -1, -1):\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\n        for i in range(1, n):\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\n        \n        # case2: find max till now using next array\n        for i in range(n-1, 0, -1):\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\n        for i in range(n-2, -1, -1):\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\n        \n        # print(before_idx_max_len, after_idx_max_len)\n        # find the best possible\n        res = 1\n        for i in range(n-1):\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\n            \n        return res"}
{"nl": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n\nEach of the digits 1-9 must occur exactly once in each row.\nEach of the digits 1-9 must occur exactly once in each column.\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\nThe '.' character indicates empty cells.\n\n \n\nExample 1:\n\n\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation: The input board is shown above and the only valid solution is shown below:\n\n\n \n\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit or '.'.\nIt is guaranteed that the input board has only one solution.", "code": "class Solution:\n    def solveSudoku(self, g: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        row, col, box, q = ['']*9, ['']*9, [['']*3 for _ in range(3)], []\n        for i in range(9):\n            for j in range(9):\n                if g[i][j]=='.':\n                    q.append((i,j))\n                else:\n                    row[i] += g[i][j]\n                    col[j] += g[i][j]\n                    box[i//3][j//3] += g[i][j]\n        \n        def backtrack():           \n            if not q:\n                return True\n            x, y = q[-1]\n            for n in '123456789':\n                if n not in row[x] and n not in col[y] and n not in box[x//3][y//3]:\n                    g[x][y] = n\n                    row[x] += n\n                    col[y] += n\n                    box[x//3][y//3] += n\n                    q.pop()\n                    if backtrack():\n                        return True\n                    else:\n                        g[x][y] = '.'\n                        row[x] = row[x][:-1]\n                        col[y] = col[y][:-1]\n                        box[x//3][y//3] = box[x//3][y//3][:-1]\n                        q.append((x, y))\n            return False\n        \n        backtrack()"}
{"nl": "Given a cost matrix cost[][] and a position (m, n) in cost[][], write a function that returns cost of minimum cost path to reach (m, n) from (0, 0). Each cell of the matrix represents a cost to traverse through that cell. The total cost of a path to reach (m, n) is the sum of all the costs on that path (including both source and destination). You can only traverse down, right and diagonally lower cells from a given cell, i.e., from a given cell (i, j), cells (i+1, j), (i, j+1), and (i+1, j+1) can be traversed. You may assume that all costs are positive integers.\n\nFor example, in the following figure, what is the minimum cost path to (2, 2)?  \n\n\n\n\n\nThe path with minimum cost is highlighted in the following figure. The path is (0, 0) \u2013> (0, 1) \u2013> (1, 2) \u2013> (2, 2). The cost of the path is 8 (1 + 2 + 2 + 3).  ", "code": "# Dynamic Programming Python implementation of Min Cost Path\n# problem\nR = 3\nC = 3\n\ndef minCost(cost, m, n):\n\n\t# Instead of following line, we can use int tc[m+1][n+1] or\n\t# dynamically allocate memoery to save space. The following\n\t# line is used to keep te program simple and make it working\n\t# on all compilers.\n\ttc = [[0 for x in range(C)] for x in range(R)]\n\n\ttc[0][0] = cost[0][0]\n\n\t# Initialize first column of total cost(tc) array\n\tfor i in range(1, m+1):\n\t\ttc[i][0] = tc[i-1][0] + cost[i][0]\n\n\t# Initialize first row of tc array\n\tfor j in range(1, n+1):\n\t\ttc[0][j] = tc[0][j-1] + cost[0][j]\n\n\t# Construct rest of the tc array\n\tfor i in range(1, m+1):\n\t\tfor j in range(1, n+1):\n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]\n\n\treturn tc[m][n]\n\n# Driver program to test above functions\ncost = [[1, 2, 3],\n\t\t[4, 8, 2],\n\t\t[1, 5, 3]]\nprint(minCost(cost, 2, 2))\n\n# This code is contributed by Bhavya Jain"}
{"nl": "Given an integer n, return any list containing n unique integers such that they add up to 0.\nExamples\nlist_with_zero_sum(5) \u279e [-7, -1, 1, 3, 4] or [-5, -1, 1, 2, 3] or [-3, -1, 2, -2, 4]\n\nlist_with_zero_sum(3) \u279e [-1, 0, 1]\n\nlist_with_zero_sum(1) \u279e [0]\nNotes\nN/A", "code": "def list_with_zero_sum(n):\n    return list(range(n - 1)) + [(1 - n) * (n - 2) // 2]"}
{"nl": "We will discuss how to remove duplicate items or elements from the list. In Python, there are many methods available on the list data type that help you remove elements from a given list. In this post, we are using native methods, list comprehension, list set(), enumerate(), OrderedDict.fromkeys(), NumPy function.", "code": "# Python program to remove duplicates from list # take list my_list = [1, 2, 3, 1, 5, 3, 4, 2, 7] # printing original list print('List:', my_list) # removed duplicates item using native method new_list = [] for i in my_list: if i not in new_list: new_list.append(i) # print list after item deletion print('New list:', new_list)"}
{"nl": "This python program prints (generates) inverted pyramid pattern made up of stars up to n lines.\r\nIn this python example, we first read number of row in inverted pyramid star pattern from user using built-in function input(). Since function input() returns string value, we need to convert given number to integer type using int(). And then we generate inverse pyramid pattern using loop.\r\n\r", "code": "# Generating Inverse Pyramid Pattern Using Stars\r\n\r\nrow = int(input('Enter number of rows required: '))\r\n\r\nfor i in range(row,0,-1):\r\n    for j in range(row-i):\r\n        print(' ', end='') # printing space and staying in same line\r\n    \r\n    for j in range(2*i-1):\r\n        print('*',end='') # printing * and staying in same line\r\n    print() # printing new line\r"}
{"nl": "Create a function to bridge shuffle two lists. To bridge shuffle, you interleave the elements from both lists in an alternating fashion, like so:\nList 1 = [\"A\", \"A\", \"A\"]\nList 2 = [\"B\", \"B\", \"B\"]\n\nShuffled List = [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"]\nThis can still work with two lists of uneven length. We simply tack on the extra elements from the longer list, like so:\nList 1 = [\"C\", \"C\", \"C\", \"C\"]\nList 2 = [\"D\"]\n\nShuffled List = [\"C\", \"D\", \"C\", \"C\", \"C\"]\nCreate a function that takes in two lists and returns the bridge-shuffled list.\nExamples\nbridge_shuffle([\"A\", \"A\", \"A\"], [\"B\", \"B\", \"B\"]) \u279e [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"]\n\nbridge_shuffle([\"C\", \"C\", \"C\", \"C\"], [\"D\"]) \u279e [\"C\", \"D\", \"C\", \"C\", \"C\"]\n\nbridge_shuffle([1, 3, 5, 7], [2, 4, 6]) \u279e [1, 2, 3, 4, 5, 6, 7]\nNotes\nElements in both lists can be strings or integers.\nIf two lists are of unequal length, add the additional elements of the longer list to the end of the shuffled list.\nAlways start your shuffle with the first element of List 1.", "code": "def bridge_shuffle(lst1, lst2):\n  step = 1\n  for x in lst2:\n    lst1.insert(step,x)\n    step += 2\n  return lst1"}
{"nl": "Given a matrix of N rows and M columns, consist of 0\u2019s and 1\u2019s. The task is to find the perimeter of subfigure consisting only 1\u2019s in the matrix. Perimeter of single 1 is 4 as it can be covered from all 4 side. Perimeter of double 11 is 6. \n\n|  1  |           |  1    1  |\n\nExamples:  \n\nInput : mat[][] = \n               {\n                 1, 0,\n                 1, 1,\n               }\nOutput : 8\nCell (1,0) and (1,1) making a L shape whose perimeter is 8.\n\nInput :  mat[][] = \n                {   \n                    0, 1, 0, 0, 0,\n                    1, 1, 1, 0, 0,\n                    1, 0, 0, 0, 0\n                }\nOutput : 12", "code": "# Python3 program to find perimeter of area\n# covered by 1 in 2D matrix consists of 0's and 1's.\n\u00a0\nR = 3\nC = 5\n\u00a0\n# Find the number of covered side for mat[i][j].\ndef numofneighbour(mat, i, j):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0count = 0;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# UP\n\u00a0\u00a0\u00a0\u00a0if (i > 0 and mat[i - 1][j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# LEFT\n\u00a0\u00a0\u00a0\u00a0if (j > 0 and mat[i][j - 1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# DOWN\n\u00a0\u00a0\u00a0\u00a0if (i < R-1 and mat[i + 1][j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# RIGHT\n\u00a0\u00a0\u00a0\u00a0if (j < C-1 and mat[i][j + 1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return count;\n\u00a0\n# Returns sum of perimeter of shapes formed with 1s\ndef findperimeter(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0perimeter = 0;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing the matrix and finding ones to\n\u00a0\u00a0\u00a0\u00a0# calculate their contribution.\n\u00a0\u00a0\u00a0\u00a0for i in range(0, R):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0, C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0perimeter += (4 - numofneighbour(mat, i, j));\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return perimeter;\n\u00a0\n# Driver Code\nmat = [ [0, 1, 0, 0, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 1, 0, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 0, 0, 0] ]\n\u00a0\nprint(findperimeter(mat), end=\"\\n\");\n\u00a0\n# This code is contributed by Akanksha Rai\n"}
{"nl": "isalnum() Method:\n\nThe isalnum() Method is a String Class pre-defined method that can be used on any String Object. It returns Boolean Values based on the following criteria.\n\nIf all of the characters in the given string are Alphanumerical, it returns True.\nIf any of the characters in the given string are not Alphanumerical, this function returns False.\n\nFor Example:\n\nGiven string = \u201cHellobtechgeeks123\u201d\n\nOutput: returns true since all the characters are alphabets and numbers.\n\nGiven string = \u201cgood morning@ #btechgeeks12345\u201d\n\nOutput: returns False since all the given String contains some special symbols like #,@, and spaces.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven string = \"Hellobtechgeeks123\"\nOutput:\n\nThe Given string { Hellobtechgeeks123 } is Alpha Numeric\nExample 2:\n\nInput:\n\nGiven string = \"good morning@ #btechgeeks12345\"\nOutput:\n\nThe Given string { good morning@ #btechgeeks12345 } is not Alpha Numeric", "code": "# Give the string as static input and store it in a variable.\ngvn_strng = \"Hellobtechgeeks123\"\n# Check whether the Given string is alphanumeric using built-in alnum() method\n# and store it in another variable.\nBol_val = gvn_strng.isalnum()\n# Check whether the above result is True or not using the if conditional statement.\nif(Bol_val == True):\n # If it is True, Print the given string is  alphanumeric.\n  print(\"The Given string {\", gvn_strng, \"} is Alpha Numeric\")\nelse:\n  # If it is False, Print the given string is not alphanumeric.\n  print(\"The Given string {\", gvn_strng, \"} is not Alpha Numeric\")"}
{"nl": "In the previous article, we have discussed Python Program For Division Two Numbers Operator Without Using Division(/) Operator\n Given a list and the task is to find the maximum and minimum elements in a given List using recursion in python\n Recursion:\n Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.\n Examples:\n Example1:\n Input:\n Given List = [1, 6, 3, 7, 8, 4]\n Output:\n The Maximum element in a given list [1, 6, 3, 7, 8, 4] = 8\n \n The Minimum element in a given list [1, 6, 3, 7, 8, 4] = 1\n Example2:\n Input:\n Given List = [20, 30, 40, 10, 50]\n Output:\n The Maximum element in a given list [20, 30, 40, 10, 50] = 50\n \n The Minimum element in a given list [20, 30, 40, 10, 50] = 10", "code": "# Create a recursive function to say max_elemnt which takes the given list and\n \n # length of the given list as the arguments and returns the maximum element in a\n \n # given list using recursion.\n \n \n \n \n \n def max_elemnt(gven_lst, len_lst):\n \n  # Check if the length of the given list is 1 using the if conditional statement.\n \n  if len_lst == 1:\n \n  # If the statement is true, then return the first element of the list.\n \n  return gven_lst[0]\n \n  # Return maximum of (gven_lst[len_lst - 1], max_elemnt(gven_lst, len_lst - 1)\n \n  # {Recursive logic}.\n \n  return max(gven_lst[len_lst - 1], max_elemnt(gven_lst, len_lst - 1))\n \n \n \n # Create a recursive function to say min_elemnt which takes the given list and\n \n # length of the given list as the arguments and returns the minimum element in a\n \n # given list using recursion.\n \n \n \n \n \n def min_elemnt(gven_lst, len_lst):\n \n  # Check if the length of the given list is 1 using the if conditional statement.\n \n  if len_lst == 1:\n \n  # If the statement is true, then return the first element of the list.\n \n  return gven_lst[0]\n \n  # Return minimum of (gven_lst[len_lst-1], min_elemnt(gven_lst, len_lst-1)\n \n  # {Recursive logic}.\n \n  return min(gven_lst[len_lst-1], min_elemnt(gven_lst, len_lst-1))\n \n \n \n \n \n # Give the list as static input and store it in a variable.\n \n gven_lst = [1, 6, 3, 7, 8, 4]\n \n # Calculate the length of the given list and store it in another variable.\n \n len_lst = len(gven_lst)\n \n # Pass the given list and length of the given list as the arguments to the max_elemnt,\n \n # min_elemnt functions.\n \n # Print the maximum element of the given list.\n \n print(\"The Maximum element in a given list\",\n \n  gven_lst, \"=\", max_elemnt(gven_lst, len_lst))\n \n # Print the minimum element of the given list.\n \n print(\"The Minimum element in a given list\",\n \n  gven_lst, \"=\", min_elemnt(gven_lst, len_lst))"}
{"nl": "Given a weighting scale and an array of different positive weights where we have an infinite supply of each weight. Our task is to put weights on left and right pans of scale one by one in such a way that pans move to that side where weight is put i.e. each time, pans of scale moves to alternate sides.", "code": "# Python3 program to print weights for\u00a0\u00a0\n# alternating the weighting scale\u00a0\n\u00a0\u00a0\n# DFS method to traverse among states\u00a0\n# of weighting scales\u00a0\ndef dfs(residue, curStep, wt, arr, N, steps):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If we reach to more than required\u00a0\n\u00a0\u00a0\u00a0\u00a0# steps, return true\u00a0\n\u00a0\u00a0\u00a0\u00a0if (curStep >= steps):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Try all possible weights and choose\u00a0\n\u00a0\u00a0\u00a0\u00a0# one which returns 1 afterwards\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Try this weight only if it is greater\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than current residueand not same as\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# previous chosen weight\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i] > residue and\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i] != wt[curStep - 1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# assign this weight to array and\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recur for next state\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wt[curStep] = arr[i]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dfs(arr[i] - residue, curStep + 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wt, arr, N, steps)):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if any weight is not possible,\n\u00a0\u00a0\u00a0\u00a0# return false\u00a0\n\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\n# method prints weights for alternating scale\u00a0\n# and if not possible prints 'not possible'\u00a0\ndef printWeightsOnScale(arr, N, steps):\n\u00a0\u00a0\u00a0\u00a0wt = [0] * (steps)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# call dfs with current residue as 0\u00a0\n\u00a0\u00a0\u00a0\u00a0# and current steps as 0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (dfs(0, 0, wt, arr, N, steps)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(steps):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(wt[i], end = \" \")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Not possible\")\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0arr = [2, 3, 5, 6]\u00a0\n\u00a0\u00a0\u00a0\u00a0N = len(arr)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0steps = 10\n\u00a0\u00a0\u00a0\u00a0printWeightsOnScale(arr, N, steps)\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Static Input: Remove Element from Tuple", "code": "# Give the tuple as static input and store it in a variable.\r\ngven_tup = (14, 32, 16, 85, 47, 65)\r\n# Give the number as static input and store it in another variable.\r\nnum = 3\r\n# Do out the Slicing from '0 ' to given 'n-1' and store it in a variable.\r\nfst_part = gven_tup[:num]\r\n# Again do out the Slicing from 'n+1' to given length of tuple (till end) and\r\n# store it in another variable.\r\nsecnd_part = gven_tup[num+1:]\r\n# Add the above two slicing parts using '+' operator and store it in a variable.\r\ngven_tup = fst_part + secnd_part\r\n# Print the final tuple after removal of given elements from the above given tuple.\r\nprint(\r\n    \"The above given tuple after removal of {\", num, \"} Element = \", gven_tup)"}
{"nl": "Given an integer n, return the number of trailing zeroes in n!.\n\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\n \n\nExample 1:\n\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\nExample 2:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\nExample 3:\n\nInput: n = 0\nOutput: 0", "code": "def trailingZeroes(self, n: int) -> int:\n        \n    # Calculate n!\n    n_factorial = 1\n    for i in range(2, n + 1):\n        n_factorial *= i\n    \n    # Count how many 0's are on the end.\n    zero_count = 0\n    while n_factorial % 10 == 0:\n        zero_count += 1\n        n_factorial //= 10\n        \n    return zero_count"}
{"nl": "Given the number of rows and columns, the task is to print 1 and 0 in alternative rows in C, C++, and Python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven number of rows =4\ngiven number of columns=3\nOutput:\n\n1 1 1 \n0 0 0 \n1 1 1 \n0 0 0\nExample2:\n\nInput:\n\ngiven number of rows =7\ngiven number of columns=15\nOutput:\n\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1", "code": "# Give the number of rows and number of columns as static input.\n# Store them in two separate variables row numbers and column numbers.\nrownumbs = 15\ncolnumbs = 11\n# Run an outer loop from 1 to rows to iterate through the rows using For loop.\nfor m in range(1, rownumbs+1):\n  # Iterate through the columns from 1 to cols using another For inner loop.\n  for n in range(1, colnumbs+1):\n  # Before printing any number, we must first check the condition inside the inner loop.\n  # This means that for every odd row, 1 is displayed, and for every even row, 0 is displayed.\n  # We check whether the row is odd or not using the if statement.\n  # If it is true then print 1 else print 0.\n  if(m % 2 == 1):\n  print('1', end=' ')\n  # If it is true then print 1 else print 0.\n  else:\n  print('0', end=' ')\n  print()"}
{"nl": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, and /. Each operand may be an integer or another expression.\n\nNote that division between two integers should truncate toward zero.\n\nIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.\n\n \n\nExample 1:\n\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\nExample 2:\n\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\nExample 3:\n\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22", "code": "def evalRPN(self, tokens: List[str]) -> int:\n        \n    operations = {\n        \"+\": lambda a, b: a + b,\n        \"-\": lambda a, b: a - b,\n        \"/\": lambda a, b: int(a / b),\n        \"*\": lambda a, b: a * b\n    }\n    \n    stack = []\n    for token in tokens:\n        if token in operations:\n            number_2 = stack.pop()\n            number_1 = stack.pop()\n            operation = operations[token]\n            stack.append(operation(number_1, number_2))\n        else:\n            stack.append(int(token))\n    return stack.pop()"}
{"nl": "There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each node's number denotes its unique genetic value (i.e. the genetic value of node x is x). The genetic difference between two genetic values is defined as the bitwise-XOR of their values. You are given the integer array parents, where parents[i] is the parent for node i. If node x is the root of the tree, then parents[x] == -1.\n\nYou are also given the array queries where queries[i] = [nodei, vali]. For each query i, find the maximum genetic difference between vali and pi, where pi is the genetic value of any node that is on the path between nodei and the root (including nodei and the root). More formally, you want to maximize vali XOR pi.\n\nReturn an array ans where ans[i] is the answer to the ith query.", "code": "class Solution:\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n        mp = {}\n        for i, (node, val) in enumerate(queries): \n            mp.setdefault(node, []).append([val, i])\n        \n        tree, root = {}, -1\n        for i, x in enumerate(parents): \n            if x == -1: root = i\n            else: tree.setdefault(x, []).append(i)\n        \n        ans = [0]*len(queries)\n        trie = Trie()\n        \n        def fn(x): \n            \"\"\"Collect query results while traversing the tree.\"\"\"\n            trie.insert(x)\n            for v, i in mp.get(x, []): ans[i] = trie.search(v)\n            for xx in tree.get(x, []): fn(xx)\n            trie.remove(x)\n        \n        fn(root)\n        return ans "}
{"nl": "Given a binary search tree and a key, your task to reverse path of the binary tree.", "code": "# Python3 code to demonstrate insert\n# operation in binary search tree\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# A utility function to\n# do inorder traversal of BST\ndef inorder(root):\n\u00a0\u00a0\u00a0\u00a0if root != None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(root.key, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.right)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# reverse tree path using queue\ndef reversePath(node, key, q1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty,\n\u00a0\u00a0\u00a0\u00a0# return a new node */\n\u00a0\u00a0\u00a0\u00a0if node == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the node key equal\n\u00a0\u00a0\u00a0\u00a0# to key then\n\u00a0\u00a0\u00a0\u00a0if node.key == key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push current node key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.insert(0, node.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# replace first node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# with last element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.key = q1[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# remove first element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if key smaller than node key then\n\u00a0\u00a0\u00a0\u00a0elif key < node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push node key into queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.insert(0, node.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursive call itself\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reversePath(node.left, key, q1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# replace queue front to node key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.key = q1[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# performe pop in queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if key greater than node key then\n\u00a0\u00a0\u00a0\u00a0elif (key > node.key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push node key into queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.insert(0, node.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursive call itself\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reversePath(node.right, key, q1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# replace queue front to node key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.key = q1[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# performe pop in queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return\n\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# A utility function to insert\n#a new node with given key in BST */\ndef insert(node, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty,\n\u00a0\u00a0\u00a0\u00a0# return a new node */\n\u00a0\u00a0\u00a0\u00a0if node == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Otherwise, recur down the tree */\n\u00a0\u00a0\u00a0\u00a0if key < node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.left = insert(node.left, key)\n\u00a0\u00a0\u00a0\u00a0elif key > node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.right = insert(node.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return the (unchanged) node pointer */\n\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us create following BST\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 50\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 /\u00a0\u00a0\u00a0\u00a0 \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 30\u00a0\u00a0\u00a0\u00a0 70\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 / \\ / \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 20 40 60 80 */\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0q1 = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# reverse path till k\n\u00a0\u00a0\u00a0\u00a0k = 80;\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 50)\n\u00a0\u00a0\u00a0\u00a0insert(root, 30)\n\u00a0\u00a0\u00a0\u00a0insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0insert(root, 40)\n\u00a0\u00a0\u00a0\u00a0insert(root, 70)\n\u00a0\u00a0\u00a0\u00a0insert(root, 60)\n\u00a0\u00a0\u00a0\u00a0insert(root, 80)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Before Reverse :\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# print inorder traversal of the BST\n\u00a0\u00a0\u00a0\u00a0inorder(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# reverse path till k\n\u00a0\u00a0\u00a0\u00a0reversePath(root, k, q1)\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0print(\"After Reverse :\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# print inorder of reverse path tree\n\u00a0\u00a0\u00a0\u00a0inorder(root)\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "You are given a 0-indexed integer array nums and a target element target.\n\nA target index is an index i such that nums[i] == target.\n\nReturn a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.\n\n ", "code": "class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        ans = [0, 0]\n        for num in nums:\n            if num<target:\n                ans[0]+=1\n            elif num==target:\n                ans[1]+=1\n        return list(range(ans[0],ans[0]+ans[1]))"}
{"nl": "Create a function which returns \"upper\" if all the letters in a word are uppercase, \"lower\" if lowercase and \"mixed\" for any mix of the two.\nExamples\nget_case(\"whisper...\") \u279e \"lower\"\n\nget_case(\"SHOUT!\") \u279e \"upper\"\n\nget_case(\"Indoor Voice\") \u279e \"mixed\"\nNotes\nIgnore punctuation, spaces and numbers.", "code": "def get_case(txt):\n  return 'upper' if txt.isupper() else 'lower' if txt.islower() else 'mixed'"}
{"nl": "In the previous article, we have discussed Python Program for Comma-separated String to Tuple\n Given a number, and the task is to find the greatest digit in a given number.\n Example: Let the number is 149.\n The greatest digit in a given number is \u20189\u2019\n Examples:\n Example1:\n Input:\n Given number = 639\n Output:\n The maximum digit in given number { 639 } = 9\n Example2:\n Input:\n Given number = 247\n Output:\n The maximum digit in given number { 247 } = 7", "code": "# Give the number as static input and store it in a variable.\n \n gvn_num = 154\n \n # Convert the given number into string using str() function and\n \n # store it in another variable. \n \n str_numbr = str(gvn_num)\n \n # Convert the above obtained string number into list of digits using bulit-in list()\n \n # method and store it in another variable.\n \n lst = list(str_numbr)\n \n # Find the maximum of list of digits using bulit-in max() function\n \n # and store it in another variable.\n \n maxim_digit = max(lst)\n \n # Print the greatest digit in a given number.\n \n print(\"The maximum digit in given number {\", gvn_num, \"} = \", maxim_digit)"}
{"nl": "Given an array, arr[0..n-1] of distinct elements and a range [low, high], find all numbers that are in a range, but not the array. The missing elements should be printed in sorted order.\n\nExamples:  \n\nInput: arr[] = {10, 12, 11, 15}, \n       low = 10, high = 15\nOutput: 13, 14\n\nInput: arr[] = {1, 14, 11, 51, 15}, \n       low = 50, high = 55\nOutput: 50, 52, 53, 54", "code": "# Python library for binary search\nfrom bisect import bisect_left\n\n# A sorting based C++ program to find missing\n# elements from an array\n\n# Print all elements of range [low, high] that\n# are not present in arr[0..n-1]\n\ndef printMissing(arr, n, low, high):\n\t\n\t# Sort the array\n\tarr.sort()\n\t\n\t# Do binary search for 'low' in sorted\n\t# array and find index of first element\n\t# which either equal to or greater than\n\t# low.\n\tptr = bisect_left(arr, low)\n\tindex = ptr\n\t\n\t# Start from the found index and linearly\n\t# search every range element x after this\n\t# index in arr[]\n\ti = index\n\tx = low\n\twhile (i < n and x <= high):\n\t# If x doesn't match with current element\n\t# print it\n\t\tif(arr[i] != x):\n\t\t\tprint(x, end =\" \")\n\n\t# If x matches, move to next element in arr[]\n\t\telse:\n\t\t\ti = i + 1\n\t# Move to next element in range [low, high]\n\t\tx = x + 1\n\n\t# Print range elements that are greater than the\n\t# last element of sorted array.\n\twhile (x <= high):\n\t\tprint(x, end =\" \")\n\t\tx = x + 1\n\n\n# Driver code\n\narr = [1, 3, 5, 4]\nn = len(arr)\nlow = 1\nhigh = 10\nprintMissing(arr, n, low, high);\n\n# This code is contributed by YatinGupta"}
{"nl": "Write a function that creates a dictionary with each (key, value) pair being the (lower case, upper case) versions of a letter, respectively.\nExamples\nmapping([\"p\", \"s\"]) \u279e { \"p\": \"P\", \"s\": \"S\" }\n\nmapping([\"a\", \"b\", \"c\"]) \u279e { \"a\": \"A\", \"b\": \"B\", \"c\": \"C\" }\n\nmapping([\"a\", \"v\", \"y\", \"z\"]) \u279e { \"a\": \"A\", \"v\": \"V\", \"y\": \"Y\", \"z\": \"Z\" }\nNotes\nAll of the letters in the input list will always be lowercase.", "code": "def mapping(letters):\n  return {i:i.upper() for i in letters}"}
{"nl": "Natural Language Processing (NLP) is a subfield of computer science, artificial intelligence, information engineering, and human-computer interaction. This field focuses on how to program computers to process and analyze large amounts of natural language data. It is difficult to perform as the process of reading and understanding languages is far more complex than it seems at first glance.\r\n\r\nTokenization is the process of tokenizing or splitting a string, text into a list of tokens. One can think of token as parts like a word is a token in a sentence, and a sentence is a token in a paragraph.", "code": "from nltk.tokenize import sent_tokenize\r\n  \r\ntext = \"Hello everyone. Welcome to GeeksforGeeks. You are studying NLP article\"\r\nsent_tokenize(text)"}
{"nl": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.\n\nA substring is a contiguous sequence of characters within the string.\n\n \n\nExample 1:\n\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\nExample 2:\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\nExample 3:\n\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n \n\nConstraints:\n\nm == s.length\nn == t.length\n1 <= m, n <= 105\ns and t consist of uppercase and lowercase English letters.\n \n\nFollow up: Could you find an algorithm that runs in O(m + n) time?", "code": "def minWindow(self, s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: str\n    \"\"\"\n    if not t or not s:\n        return \"\"\n\n    dict_t = Counter(t)\n\n    required = len(dict_t)\n\n    # Filter all the characters from s into a new list along with their index.\n    # The filtering criteria is that the character should be present in t.\n    filtered_s = []\n    for i, char in enumerate(s):\n        if char in dict_t:\n            filtered_s.append((i, char))\n\n    l, r = 0, 0\n    formed = 0\n    window_counts = {}\n\n    ans = float(\"inf\"), None, None\n\n    # Look for the characters only in the filtered list instead of entire s. This helps to reduce our search.\n    # Hence, we follow the sliding window approach on as small list.\n    while r < len(filtered_s):\n        character = filtered_s[r][1]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if window_counts[character] == dict_t[character]:\n            formed += 1\n\n        # If the current window has all the characters in desired frequencies i.e. t is present in the window\n        while l <= r and formed == required:\n            character = filtered_s[l][1]\n\n            # Save the smallest window until now.\n            end = filtered_s[r][0]\n            start = filtered_s[l][0]\n            if end - start + 1 < ans[0]:\n                ans = (end - start + 1, start, end)\n\n            window_counts[character] -= 1\n            if window_counts[character] < dict_t[character]:\n                formed -= 1\n            l += 1    \n\n        r += 1    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]"}
{"nl": "iven a stream of numbers, generate a random number from the stream. You are allowed to use only O(1) space and the input is in the form of a stream, so can\u2019t store the previously seen numbers. \nSo how do we generate a random number from the whole stream such that the probability of picking any number is 1/n. with O(1) extra space? This problem is a variation of Reservoir Sampling. Here the value of k is 1.\n1) Initialize \u2018count\u2019 as 0, \u2018count\u2019 is used to store count of numbers seen so far in stream. \n2) For each number \u2018x\u2019 from stream, do following \n\u2026..a) Increment \u2018count\u2019 by 1. \n\u2026..b) If count is 1, set result as x, and return result. \n\u2026..c) Generate a random number from 0 to \u2018count-1\u2019. Let the generated random number be i. \n\u2026..d) If i is equal to \u2018count \u2013 1\u2019, update the result as x. ", "code": "# An efficient python3 program\n# to randomly select a number\n# from stream of numbers.\nimport random\n\n# A function to randomly select a item\n# from stream[0], stream[1], .. stream[i-1]\n# The resultant random number\nres=0\n# Count of numbers visited\n# so far in stream\ncount=0\ndef selectRandom(x):\n\t\n\tglobal res\n\tglobal count\n\n\t# increment count of numbers\n\t# seen so far\n\tcount += 1;\n\n\t# If this is the first element\n\t# from stream, return it\n\tif (count == 1):\n\t\tres = x;\n\telse:\n\t\t\n\t\t# Generate a random number\n\t\t# from 0 to count - 1\n\t\ti = random.randrange(count);\n\n\t\t# Replace the prev random number\n\t\t# with new number with 1/count\n\t\t# probability\n\t\tif (i == count - 1):\n\t\t\tres = x;\n\treturn res;\n\n# Driver Code\nstream = [1, 2, 3, 4];\nn = len(stream);\n\n# Use a different seed value\n# for every run.\nfor i in range (n):\n\tprint(\"Random number from first\",\n\t\t(i + 1), \"numbers is\",\n\t\tselectRandom(stream[i]));\n\n# This code is contributed by mits"}
{"nl": "In mathematics, the Fibonacci numbers, commonly denoted Fn, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1:\nand\nfor n > 1\nThe beginning of the sequence is thus:\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\nThe function fib_fast(num) returns the fibonacci number Fn, of the given num as an argument.\nExamples\nfib_fast(5) \u279e 5\n\nfib_fast(10) \u279e 55\n\nfib_fast(20) \u279e 6765\n\nfib_fast(50) \u279e 12586269025\nNotes\nThe input number is always positive.\nEdabit would fail your code if it's not Fast enough.", "code": "def fibFast(num):\n    a, b = 0, 1\n    for _ in range(num - 1):\n        a, b = b, a + b\n    return b"}
{"nl": "Given a number n and a value k, turn off the k\u2019th bit in n. Please note that k = 1 means the rightmost bit.\nExamples: \n \n\nInput:  n = 15, k = 1\nOutput: 14\n\nInput:  n = 14, k = 1\nOutput: 14\nThe rightmost bit was already off, so no change.\n\nInput:  n = 15, k = 2\nOutput: 13\n\nInput:  n = 15, k = 3\nOutput: 11\n\nInput:  n = 15, k = 4\nOutput: 7\n\nInput:  n = 15, k >= 5\nOutput: 15 \nThe idea is to use bitwise <<, & and ~ operators. Using expression \u201c~(1 << (k \u2013 1))\u201c, we get a number which has all bits set, except the k\u2019th bit. If we do bitwise & of this expression with n, we get a number which has all bits same as n except the k\u2019th bit which is 0. ", "code": "# Returns a number that\n# has all bits same as n\n# except the k'th bit\n# which is made 0\n\ndef turnOffK(n,k):\n\n\t# k must be greater than 0\n\tif (k <= 0):\n\t\treturn n\n\n\t# Do & of n with a number\n\t# with all set bits except\n\t# the k'th bit\n\treturn (n & ~(1 << (k - 1)))\n\n\n# Driver code\nn = 15\nk = 4\nprint(turnOffK(n, k))\n\n# This code is contributed\n# by Anant Agarwal.\n"}
{"nl": "Method #1: Using For Loop (Star Character)\r\nApproach:\r\n\r\nGive the number of rows of the rhombus as static input and store it in a variable.\r\nUsing Nested For loops print the rhombus star pattern.\r\nThe Exit of the Program.", "code": "# Give the number of rows of the rhombus as static input and store it in a variable.\r\nrhombusrows = 19\r\n# Using Nested For loops print the rhombus star pattern.\r\nfor m in range(rhombusrows, 0, -1):\r\n    for n in range(1, m):\r\n        print(' ', end='')\r\n    for k in range(0, rhombusrows):\r\n        print('*', end='')\r\n    print()"}
{"nl": "Create Object\r\nNow we can use the class named myClass to create objects:", "code": "p1 = MyClass()\r\nprint(p1.x)"}
{"nl": "There are 2 sorted arrays A and B of size n each. Write an algorithm to find the median of the array obtained after merging the above 2 arrays(i.e. array of length 2n). The complexity should be O(log(n)). ", "code": "# A Simple Merge based O(n) Python 3 solution\n# to find median of two sorted lists\n\n# This function returns median of ar1[] and ar2[].\n# Assumptions in this function:\n# Both ar1[] and ar2[] are sorted arrays\n# Both have n elements\ndef getMedian( ar1, ar2 , n):\n\ti = 0 # Current index of i/p list ar1[]\n\t\n\tj = 0 # Current index of i/p list ar2[]\n\t\n\tm1 = -1\n\tm2 = -1\n\t\n\t# Since there are 2n elements, median\n\t# will be average of elements at index\n\t# n-1 and n in the array obtained after\n\t# merging ar1 and ar2\n\tcount = 0\n\twhile count < n + 1:\n\t\tcount += 1\n\t\t\n\t\t# Below is to handle case where all\n\t\t# elements of ar1[] are smaller than\n\t\t# smallest(or first) element of ar2[]\n\t\tif i == n:\n\t\t\tm1 = m2\n\t\t\tm2 = ar2[0]\n\t\t\tbreak\n\t\t\n\t\t# Below is to handle case where all\n\t\t# elements of ar2[] are smaller than\n\t\t# smallest(or first) element of ar1[]\n\t\telif j == n:\n\t\t\tm1 = m2\n\t\t\tm2 = ar1[0]\n\t\t\tbreak\n\t\t# equals sign because if two\n\t\t# arrays have some common elements\n\t\tif ar1[i] <= ar2[j]:\n\t\t\tm1 = m2 # Store the prev median\n\t\t\tm2 = ar1[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tm1 = m2 # Store the prev median\n\t\t\tm2 = ar2[j]\n\t\t\tj += 1\n\treturn (m1 + m2)/2\n\n# Driver code to test above function\nar1 = [1, 12, 15, 26, 38]\nar2 = [2, 13, 17, 30, 45]\nn1 = len(ar1)\nn2 = len(ar2)\nif n1 == n2:\n\tprint(\"Median is \", getMedian(ar1, ar2, n1))\nelse:\n\tprint(\"Doesn't work for arrays of unequal size\")\n\n# This code is contributed by \"Sharad_Bhardwaj\"."}
{"nl": "Given a number N and the task is to print the series (1,2,4,8,16,32\u2026N) till the given number N in Python.", "code": "# Give the number N as static input and store it in a variable.\r\ngvn_numb = 200\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\nwhile itr <= gvn_numb:\r\n  # If it is true then print the value of itr separated by spaces.\r\n    print(itr, end=\" \")\r\n    # Multiply the itr value with 2 and store it in the same variable itr.\r\n    itr *= 2"}
{"nl": null, "code": null}
{"nl": "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n\n0 <= i, j, k, l < n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0", "code": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        \n        # hashmap and final result count\n        nums12, res = defaultdict(int), 0\n        \n        # storing all possible combinations of sum\n        for i in nums1:\n            for j in nums2:\n                nums12[i+j] += 1\n        \n        # iterating the left out two array to find negation of same value\n        for k in nums3:\n            for l in nums4:\n                res += nums12[-(k+l)]\n        \n        return res"}
{"nl": "In Python, the operators == and is do very similar functions, yet they are extremely different and deal with a very important concept: how Python saves its variables in memory.\r\n\r\nThere is a small distinction between the Python identity operator (is) and the equality operator (==). When you use the Python is operator to compare numbers, your code may work great until it suddenly does not. You may have heard that the Python is operator is faster than the == operator, or you may believe that it appears more Pythonic. However, it is critical to remember that these operators do not behave in the same way.\r\n\r\nThe Python is operator checks if two variables link to the same object in memory, whereas the == operator compares the value or equality of two objects. Except when comparing to None, which means you should utilise the equality operators == and!= in the vast majority of situations.", "code": "listone = [\"this\", \"is\", \"BTechGeeks\"]\r\nlisttwo = [\"this\", \"is\", \"BTechGeeks\"]\r\nprint(listone == listtwo)\r\nprint(listone is listtwo)\r\n# assigning list two with list one\r\nlisttwo = listone\r\nprint(\"After assigning list two with list one:\")\r\n# using is\r\nprint(listone is listtwo)"}
{"nl": "In this program, we will create a circular linked list and remove duplicate nodes from the list. We will compare a node with the rest of the list and check for the duplicate. If the duplicate is found, delete the duplicate node from the list.\n\n1->2->2->4->3  \nIn the above list, we can see, node 2 is present twice in the list. So, we will have a node current that will iterate through the list. The index will point to the next node to current. Temp will be pointing to the node previous to index. When a duplicate is found, we delete it by pointing temp.next to index.next. Above list after removing duplicates:\n\n1->2->4->3  ", "code": "#Represents the node of list.    \n#Represents the node of list.    \nclass Node:    \n  def __init__(self,data):    \n    self.data = data;    \n    self.next = None;    \n    \nclass CreateList:    \n  #Declaring head and tail pointer as null.    \n  def __init__(self):    \n    self.head = Node(None);    \n    self.tail = Node(None);    \n    self.head.next = self.tail;    \n    self.tail.next = self.head;    \n      \n  #This function will add the new node at the end of the list.    \n  def add(self,data):    \n    newNode = Node(data);    \n    #Checks if the list is empty.    \n    if self.head.data is None:    \n      #If list is empty, both head and tail would point to new node.    \n      self.head = newNode;    \n      self.tail = newNode;    \n      newNode.next = self.head;    \n    else:    \n      #tail will point to new node.    \n      self.tail.next = newNode;    \n      #New node will become new tail.    \n      self.tail = newNode;    \n      #Since, it is circular linked list tail will point to head.    \n      self.tail.next = self.head;    \n      \n  #Removes duplicate from the list    \n  def removeDuplicate(self):    \n    #Current will point to head    \n    current = self.head;    \n    if(self.head == None):    \n      print(\"List is empty\");    \n    else:    \n      while(True):    \n        #Temp will point to previous node of index.    \n        temp = current;    \n        #Index will point to node next to current    \n        index = current.next;    \n        while(index != self.head):    \n          #If current node is equal to index data    \n          if(current.data == index.data):    \n            #Here, index node is pointing to the node which is duplicate of current node    \n            #Skips the duplicate node by pointing to next node    \n            temp.next = index.next;    \n          else:    \n            #Temp will point to previous node of index.    \n            temp = index;    \n          index= index.next;    \n        current =current.next;    \n        if(current.next == self.head):    \n          break;    \n              \n  #Displays all the nodes in the list    \n  def display(self):    \n    current = self.head;    \n    if self.head is None:    \n      print(\"List is empty\");    \n      return;    \n    else:    \n      #Prints each node by incrementing pointer.    \n      print(current.data);    \n      while(current.next != self.head):    \n        current = current.next;    \n        print(current.data);    \n    print(\"\\n\");    \n          \nclass CircularLinkedList:    \n  cl = CreateList();    \n  #Adds data to the list    \n  cl.add(1);    \n  cl.add(2);    \n  cl.add(3);    \n  cl.add(2);    \n  cl.add(2);    \n  cl.add(4);    \n      \n  print(\"Originals list: \");    \n  cl.display();    \n  #Removes duplicate nodes    \n  cl.removeDuplicate();    \n  print(\"List after removing duplicates: \");    \n  cl.display();    "}
{"nl": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\n \n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]", "code": "from collections import defaultdict\nclass Solution:\n\n    WHITE = 1\n    GRAY = 2\n    BLACK = 3\n\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n\n        # Create the adjacency list representation of the graph\n        adj_list = defaultdict(list)\n\n        # A pair [a, b] in the input represents edge from b --> a\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n\n        topological_sorted_order = []\n        is_possible = True\n\n        # By default all vertces are WHITE\n        color = {k: Solution.WHITE for k in range(numCourses)}\n        def dfs(node):\n            nonlocal is_possible\n\n            # Don't recurse further if we found a cycle already\n            if not is_possible:\n                return\n\n            # Start the recursion\n            color[node] = Solution.GRAY\n\n            # Traverse on neighboring vertices\n            if node in adj_list:\n                for neighbor in adj_list[node]:\n                    if color[neighbor] == Solution.WHITE:\n                        dfs(neighbor)\n                    elif color[neighbor] == Solution.GRAY:\n                         # An edge to a GRAY vertex represents a cycle\n                        is_possible = False\n\n            # Recursion ends. We mark it as black\n            color[node] = Solution.BLACK\n            topological_sorted_order.append(node)\n\n        for vertex in range(numCourses):\n            # If the node is unprocessed, then call dfs on it.\n            if color[vertex] == Solution.WHITE:\n                dfs(vertex)\n\n        return topological_sorted_order[::-1] if is_possible else []"}
{"nl": "The term duplicates mean the elements which are repeated.\n\nWhen working with Python dictionaries, you may encounter circumstances where there are duplicate values in the dictionary. In some cases, this can be harmful to your software. In this instance, you may need to remove the duplicates from your dictionary. When working with Python dictionaries, we may encounter a problem in which we need to delete all duplicate values from the dictionary, and we are unconcerned whether some keys are removed in the process. This type of application can be seen in both school programming and day-to-day programming. ", "code": "# Give the dictionary as static input and store it in a variable.\ngvn_dict ={1: 100, 2: 90, 3: 80, 4: 100, 5:80}\n# Print the given dictionary\nprint(\"The given dictionary:\",gvn_dict)\n# Take an empty list and store it in aother variable.\nnew_lst =[]\n# Create a new empty dictionary and store it in aother variable.\noutput_dict ={}\n# Loop in the key, value of the given dictionary using the for loop and the items() functions\nfor key, value in gvn_dict.items():\n    # Check if the corresponding value is not present in the above created new list using the \n    # if conditional statement\n    if value not in new_lst:\n        # If it is true then append that value to the above list \n        # Here it appends the value to the new list if it is a unique element\n        new_lst.append(value)\n        # Assign this unique key and value to the new dictionary\n        output_dict[key] = value\n# Print the result dictionary after the removal of duplicates\nprint(\"The result dictionary after the removal of duplicates:\",output_dict)"}
{"nl": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.\n\n \nExample 1:\n\n\nInput\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor\n \nConstraints:\n\n1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.", "code": "step = 15\n  def __init__(self, n, A):\n  A = dict(enumerate(A))\n  jump = [A]\n  for s in xrange(self.step):\n  B = {}\n  for i in A:\n  if A[i] in A:\n  B[i] = A[A[i]]\n  jump.append(B)\n  A = B\n  self.jump = jump\n\n  def getKthAncestor(self, x, k):\n  step = self.step\n  while k > 0 and x > -1:\n  if k >= 1 << step:\n  x = self.jump[step].get(x, -1)\n  k -= 1 << step\n  else:\n  step -= 1\n  return x"}
{"nl": null, "code": null}
{"nl": "Triangular Matchstick Number in Python :\n\nFind the total number of matchsticks required to build the overall triangle until there is a single triangle at the top, given the number of sub-triangles in the base layer of the bigger triangle. For more information, please see the image below.\n\nsolve triangular matchstick number in Python\n\nConsider each triangle in the above image to be made of three matchsticks. So the goal of the problem is to determine the total number of matchsticks required to construct the entire triangle.\n\nThe solution\u2019s concept is as follows:\n\nThe picture clearly shows that the number of triangles at each level decreases by one starting at the bottom. If the bottom layer contains N sub triangles, the layer above it contains N \u2013 1 sub triangles, and so on until the topmost layer contains 1 triangle. So the final triangle will have N + (N \u2013 1) + (N \u2013 2) +\u2026 + 1 sub triangles, which is also equal to (N* (N + 1)) / 2.\n\nMultiply it by the number of sticks needed for each sub triangle to get the final answer. As a result, the final solution is as simple as 3 * (N * (N + 1)) / 2.\n\nTherefore the Formula is \u2013 3 * (N * (N + 1)) / 2.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven no of sub triangle's in base layer = 4\nOutput:\n\nThe Total number of matchsticks needed to form a above given entire triangle =  30", "code": "# Give the number as user input using the int(input()) function and Store it in a variable.\nno_bse_subtringls = int(input(\"Enter some random number =  \"))\n# Calculate the total number of sub triangle's required by using above mathematical formula\n# (N * (N + 1)) / 2) and store it in another variable.\ntot_subtringle = (no_bse_subtringls * (no_bse_subtringls + 1)) // 2\n# Multiply the above obtained total sub triangle's with '3' to get the total number of\n# sticks required and Store it in another variable.\ntot_sticks = tot_subtringle * 3\n# Print the Total number of sticks required to form a above given entire triangle.\nprint(\"The Total number of matchsticks needed to form a above given entire triangle = \", tot_sticks)"}
{"nl": "Given a Binary Tree and a key, write a function that prints all the ancestors of the key in the given binary tree.\u00a0\n\n\nFor example, if the given tree is following Binary Tree and key is 7, then your function should print 4, 2 and 1.\n\n\n\u00a0", "code": "# Python program to print ancestors of given node in\n# binary tree\n\u00a0\n# A Binary Tree node\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# If target is present in tree, then prints the ancestors\n# and returns true, otherwise returns false\ndef printAncestors(root, target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if root.data == target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If target is present in either left or right subtree\n\u00a0\u00a0\u00a0\u00a0# of this node, then print this node\n\u00a0\u00a0\u00a0\u00a0if (printAncestors(root.left, target) or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printAncestors(root.right, target)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(root.data,end=' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Else return False\n\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.left.left.left = Node(7)\n\u00a0\nprintAncestors(root, 7)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Given a boolean 2D matrix, find the number of islands. A group of connected 1s forms an island. For example, the below matrix contains 5 islands\nExample: \nInput : mat[][] = {{1, 1, 0, 0, 0},\n                   {0, 1, 0, 0, 1},\n                   {1, 0, 0, 1, 1},\n                   {0, 0, 0, 0, 0},\n                   {1, 0, 1, 0, 1}}\nOutput : 5", "code": "# Program to count islands in boolean 2D matrix\nclass Graph:\n\n        def __init__(self, row, col, g):\n                self.ROW = row\n                self.COL = col\n                self.graph = g\n\n        # A function to check if a given cell\n        # (row, col) can be included in DFS\n        def isSafe(self, i, j, visited):\n                # row number is in range, column number\n                # is in range and value is 1\n                # and not yet visited\n                return (i >= 0 and i < self.ROW and\n                                j >= 0 and j < self.COL and\n                                not visited[i][j] and self.graph[i][j])\n                        \n\n        # A utility function to do DFS for a 2D\n        # boolean matrix. It only considers\n        # the 8 neighbours as adjacent vertices\n        def DFS(self, i, j, visited):\n\n                # These arrays are used to get row and\n                # column numbers of 8 neighbours\n                # of a given cell\n                rowNbr = [-1, -1, -1, 0, 0, 1, 1, 1];\n                colNbr = [-1, 0, 1, -1, 1, -1, 0, 1];\n                \n                # Mark this cell as visited\n                visited[i][j] = True\n\n                # Recur for all connected neighbours\n                for k in range(8):\n                        if self.isSafe(i + rowNbr[k], j + colNbr[k], visited):\n                                self.DFS(i + rowNbr[k], j + colNbr[k], visited)\n\n\n        # The main function that returns\n        # count of islands in a given boolean\n        # 2D matrix\n        def countIslands(self):\n                # Make a bool array to mark visited cells.\n                # Initially all cells are unvisited\n                visited = [[False for j in range(self.COL)]for i in range(self.ROW)]\n\n                # Initialize count as 0 and traverse\n                # through the all cells of\n                # given matrix\n                count = 0\n                for i in range(self.ROW):\n                        for j in range(self.COL):\n                                # If a cell with value 1 is not visited yet,\n                                # then new island found\n                                if visited[i][j] == False and self.graph[i][j] == 1:\n                                        # Visit all cells in this island\n                                        # and increment island count\n                                        self.DFS(i, j, visited)\n                                        count += 1\n\n                return count\n\n\ngraph = [[1, 1, 0, 0, 0],\n                [0, 1, 0, 0, 1],\n                [1, 0, 0, 1, 1],\n                [0, 0, 0, 0, 0],\n                [1, 0, 1, 0, 1]]\n\n\nrow = len(graph)\ncol = len(graph[0])\n\ng = Graph(row, col, graph)\n\nprint (\"Number of islands is:\")\nprint (g.countIslands())\n\n# This code is contributed by Neelam Yadav\n"}
{"nl": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\nReturn the shuffled string.\n \nExample 1:\n\n\nInput: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\nExplanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling.\n\nExample 2:\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"\nExplanation: After shuffling, each character remains in its position.\n\n \nConstraints:\n\ns.length == indices.length == n\n1 <= n <= 100\ns consists of only lowercase English letters.\n0 <= indices[i] < n\nAll values of indices are unique.", "code": "class Solution:\n  def restoreString(self, s: str, indices: List[int]) -> str:\n  res = [''] * len(s)\n  for index, char in enumerate(s):\n  res[indices[index]] = char\n  return \"\".join(res)"}
{"nl": "Given a string s, return true if s is a good string, or false otherwise.\n\nA string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).\n\n ", "code": "```class Solution:\n    def areOccurrencesEqual(self, s: str) -> bool:\n        \n        save = []\n        \n        news = list([str(x) for x in s])  # change s from string to a list  \n        \n        for i in set(news): # save the count of occurrances in save\n            save.append(news.count(i))\n        \n        for i in save: # if any number is not the same like save[0], return False\n            if i != save[0]:\n                return False\n            \n        return True"}
{"nl": "Given the upper limit and lower limit, the task is to generate n natural numbers which are not repeating in Python.", "code": "# Import the random module using the import keyword.\r\nimport random\r\n# Give the number n as static input and store it in a variable.\r\nnumbe = 13\r\n# Give the lower limit range and upper limit range as static input\r\n# and store them in two separate variables.\r\nlowerlimitrange = 19\r\nupperlimitrange = 45\r\n# Take an empty list (say rndmnumbs) and initialize it with an empty list\r\n# using [] or list().\r\nrndmnumbs = []\r\n# Loop till n times using For loop.\r\nfor m in range(numbe):\r\n        # Generate a random number using randint(lowerlimitrange,upperlimitrange)\r\n    # and store it in a variable.\r\n    randomnumbe = random.randint(lowerlimitrange, upperlimitrange)\r\n    # Check whether the above random number is present in the list or not\r\n    # using not in operator.\r\n    if randomnumbe not in rndmnumbs:\r\n        # If it is not in the list then append the element\r\n        # to the rndmnumbs list using the append() function.\r\n        rndmnumbs.append(randomnumbe)\r\n\r\n# Print the rndmnumbs\r\nprint('The random numbers present in the range from',\r\n      lowerlimitrange, 'to', upperlimitrange, 'are :')\r\nfor q in rndmnumbs:\r\n    print(q, end=' ')"}
{"nl": "Instructions\r\nCreate an implementation of the affine cipher, an ancient encryption system created in the Middle East.\r\n\r\nThe affine cipher is a type of monoalphabetic substitution cipher. Each character is mapped to its numeric equivalent, encrypted with a mathematical function and then converted to the letter relating to its new numeric value. Although all monoalphabetic ciphers are weak, the affine cipher is much stronger than the atbash cipher, because it has many more keys.\r\n\r\nEncryption\r\nThe encryption function is:\r\n\r\nE(x) = (ai + b) mod m\r\nWhere:\r\n\r\ni is the letter's index from 0 to the length of the alphabet - 1\r\nm is the length of the alphabet. For the Roman alphabet m is 26.\r\na and b are integers which make the encryption key\r\nValues a and m must be coprime (or, relatively prime) for automatic decryption to succeed, i.e., they have number 1 as their only common factor (more information can be found in the Wikipedia article about coprime integers). In case a is not coprime to m, your program should indicate that this is an error. Otherwise it should encrypt or decrypt with the provided key.\r\n\r\nFor the purpose of this exercise, digits are valid input but they are not encrypted. Spaces and punctuation characters are excluded. Ciphertext is written out in groups of fixed length separated by space, the traditional group size being 5 letters. This is to make it harder to guess encrypted text based on word boundaries.\r\n\r\nDecryption\r\nThe decryption function is:\r\n\r\nD(y) = (a^-1)(y - b) mod m\r\nWhere:\r\n\r\ny is the numeric value of an encrypted letter, i.e., y = E(x)\r\nit is important to note that a^-1 is the modular multiplicative inverse (MMI) of a mod m\r\nthe modular multiplicative inverse only exists if a and m are coprime.\r\nThe MMI of a is x such that the remainder after dividing ax by m is 1:\r\n\r\nax mod m = 1\r\nMore information regarding how to find a Modular Multiplicative Inverse and what it means can be found in the related Wikipedia article.\r\n\r\nGeneral Examples\r\nEncrypting \"test\" gives \"ybty\" with the key a = 5, b = 7\r\nDecrypting \"ybty\" gives \"test\" with the key a = 5, b = 7\r\nDecrypting \"ybty\" gives \"lqul\" with the wrong key a = 11, b = 7\r\nDecrypting \"kqlfd jzvgy tpaet icdhm rtwly kqlon ubstx\" gives \"thequickbrownfoxjumpsoverthelazydog\" with the key a = 19, b = 13\r\nEncrypting \"test\" with the key a = 18, b = 13 is an error because 18 and 26 are not coprime\r\nExample of finding a Modular Multiplicative Inverse (MMI)\r\nFinding MMI for a = 15:\r\n\r\n(15 * x) mod 26 = 1\r\n(15 * 7) mod 26 = 1, ie. 105 mod 26 = 1\r\n7 is the MMI of 15 mod 26\r\nException messages\r\nSometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.\r\n\r\nThis particular exercise requires that you use the raise statement to \"throw\" a ValueError. The tests will only pass if you both raise the exception and include a message with it.\r\n\r\nTo raise a ValueError with a message, write the message as an argument to the exception type:\r\n\r\nraise ValueError(\"a and m must be coprime.\")", "code": "import math\r\nimport string\r\ndef lookup(a, b, reverse=False):\r\n    if math.gcd(a, 26) > 1:\r\n        raise ValueError('a and m must be coprime.')\r\n    lookup = ''.join(chr(((ord(c)-ord('a'))*a+b)%26+ord('a'))\r\n                     for c in string.ascii_lowercase)\r\n    if reverse:\r\n        return str.maketrans(lookup, string.ascii_lowercase,\r\n                             string.whitespace)\r\n    else:\r\n        return str.maketrans(string.ascii_lowercase, lookup,\r\n                             string.whitespace+string.punctuation)\r\ndef encode(plain_text, a, b):\r\n    encoded = plain_text.lower().translate(lookup(a, b))\r\n    return ' '.join(encoded[i:i+5] for i in range(0,len(encoded),5))\r\ndef decode(ciphered_text, a, b):\r\n    return ciphered_text.lower().translate(lookup(a, b, reverse=True))"}
{"nl": "Write a Python program to print square of right decrement numbers pattern using for loop.\n\n", "code": "rows = int(input(\"Enter Square of Right Decrement Numbers Rows = \"))\n\nprint(\"====The Square of Right Decremented Numbers Pattern====\")\n\nfor i in range(rows, 0, -1):\n    for j in range(rows, i - 1, -1):\n        print(j, end = ' ')\n    for k in range(rows - i + 1, rows):\n        print(i, end = ' ')\n    print()"}
{"nl": "The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\n\nFor example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\nGiven an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\n\nReturn the maximum such product difference.", "code": "class Solution:\n    def maxProductDifference(self, nums: List[int]) -> int:\n        nums.sort()\n        return ((nums[len(nums)-1] * nums[len(nums)-2]) - (nums[0] * nums[1]))"}
{"nl": "A magic square of order n is an arrangement of n^2 numbers, usually distinct integers, in a square, such that the n numbers in all rows, all columns, and both diagonals sum to the same constant. A magic square contains the integers from 1 to n^2.\n\nThe constant sum in every row, column and diagonal is called the magic constant or magic sum, M. The magic constant of a normal magic square depends only on n and has the following value:\u00a0\n\nM = n (n^2 + 1) / 2.\n\n\n\u00a0", "code": "# Python program to print magic square of double order\n\u00a0\ndef DoublyEven(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2-D matrix with all entries as 0\n\u00a0\u00a0\u00a0\u00a0arr = [[(n*y)+x+1 for x in range(n)]for y in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Change value of array elements at fix location\n\u00a0\u00a0\u00a0\u00a0# as per the rule (n*n+1)-arr[i][[j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Corners of order (n/4)*(n/4)\n\u00a0\u00a0\u00a0\u00a0# Top left corner\n\u00a0\u00a0\u00a0\u00a0for i in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Top right corner\n\u00a0\u00a0\u00a0\u00a0for i in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Bottom Left corner\n\u00a0\u00a0\u00a0\u00a0for i in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Bottom Right corner\n\u00a0\u00a0\u00a0\u00a0for i in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Centre of matrix,order (n/2)*(n/2)\n\u00a0\u00a0\u00a0\u00a0for i in range(n//4,3 * (n//4)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n//4,3 * (n//4)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Printing the square\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print ('%2d ' %(arr[i][j]),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Program\nn = 8\nDoublyEven(n)\n\u00a0\n# Contributed by Harshit Agrawal\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n"}
{"nl": "The math.atanh() method returns the inverse hyperbolic tangent of a number.\r\n\r\nNote: The parameter passed in math.atanh() must lie between -0.99 to 0.99.", "code": "#Import math Library\r\nimport math\r\n\r\n#print the hyperbolic arctangent of different numbers\r\nprint(math.atanh(0.59))\r\nprint(math.atanh(-0.12))"}
{"nl": "Given two numbers a, b, the task is to find all x such that given a % x = b", "code": "# Import the math module using the import keyword.\nimport math\n\n# Create a function to say a_mod_xisb which takes the given two numbers as the arguments\n# and returns all the values of x such that given a % x = b.\n\n\ndef a_mod_xisb(gvn_a_val, gvn_b_val):\n    # Check if the given number a is less than the given b value using the if conditional\n    # statement.\n\n    if (gvn_a_val < gvn_b_val):\n      # If it is true then print \"There are no solutions possible\".\n        print(\"There are no solutions possible\")\n        # Return.\n        return\n    # Check if the given a value is equal to the given b value using the if conditional\n    # statement.\n    if (gvn_a_val == gvn_b_val):\n        # If it is true then print \"Infinite Solutions are possible for the equation\".\n        # Return.\n        print(\"Infinite Solutions are possible for the equation\")\n        return\n    # Take a variable say cnt and initialize its value to 0.\n    cnt = 0\n    # Subtract the given b value from the given a value and store it in another variable\n    # say rslt.\n\n    rslt = gvn_a_val - gvn_b_val\n    # Calculate the value of square root of (gvn_a_val - gvn_b_val) using the math.sqrt()\n    # function and convert result to an integer using the int() function.\n    # Store it in another variable say k.\n    k = (int)(math.sqrt(gvn_a_val - gvn_b_val))\n    # Loop from 1 to the above result k using the for loop.\n    for itr in range(1, k+1):\n      # Inside the loop, check if the above value of rslt modulus iterator value is equal\n      # to 0 using the if conditional statement.\n        if (rslt % itr == 0):\n          # Again check if the rslt divided by the iterator value greater than the given b value\n          # using the if conditional statement.\n            if (rslt / itr > gvn_b_val):\n              # If it is true, increment the count value by 1 and store it in the same variable.\n                cnt = cnt + 1\n      # Check if the iterator value is greater than the given b value using the if\n          # conditional statement.\n            if (itr > gvn_b_val):\n                # If it is true, increment the count value by 1 and store it in the same variable.\n                cnt = cnt + 1\n        # Check if the k multiplied with itself is equal to the rslt and k greater than the\n        # given b value using the if conditional statement.\n    if (k * k == rslt and k > gvn_b_val):\n        # If it is true, decrement the count value by 1 and store it in the same variable.\n        cnt = cnt - 1\n    # Print the value of x such that given a%x==b.\n    print(\n        \"The value of x such that given a%x==b {a,b =\", gvn_a_val, gvn_b_val, \"} = \", cnt)\n\n\n# Give the number as user input using the int(input()) function and\n# store it in a variable.\ngvn_a_val = int(input(\"Enter some random number = \"))\n# Give the other number as user input using the int(input()) function and\n# store it in another variable.\ngvn_b_val = int(input(\"Enter some random number = \"))\n# Pass the given number two numbers as the arguments to the a_mod_xisb function.\na_mod_xisb(gvn_a_val, gvn_b_val)"}
{"nl": "Clear nth Bit of a Number Using Bitwise &(and) Operator (User Input)", "code": "# Give the number as user input using the int(input()) function and \r\n# store it in a variable.\r\ngvn_numb = int(input(\"Enter some random number = \"))\r\n# Give the bit position as user input using the int(input()) function \r\n# and store it in another variable.\r\nbitpositin = int(input(\"Enter some random number = \"))\r\n# Apply the left shift operator to 1 and the above-given bit position and\r\n# store it in another variable.\r\nnumbr_bit = (1 << bitpositin)\r\n# Apply the complement operator (which converts 0 to 1 and vice-versa) to the above result\r\n# and store it in another variable.\r\ncomplemt = (~numbr_bit)\r\n# Apply bitwise & operation for the given number and the above result and store it in\r\n# another variable say rslt_numb.\r\nrslt_numb = gvn_numb & complemt\r\n# Print the number after clearing the bit at the given position for a given number.\r\nprint(\"The Number after clearing the bit at the given position{\",\r\n      bitpositin, \"} for a given number{\", gvn_numb, \"} =\", rslt_numb)"}
{"nl": "A number is said to be the Disarium number when the sum of its digit raised to the power of their respective positions becomes equal to the number itself.\n\nFor example, 175 is a Disarium number as follows:\n\n11+ 72 + 53 = 1+ 49 + 125 = 175", "code": "#calculateLength() will count the digits present in a number    \ndef calculateLength(n):    \n    length = 0;    \n    while(n != 0):    \n        length = length + 1;    \n        n = n//10;    \n    return length;    \n     \nnum = 175;    \nrem = sum = 0;    \nlen = calculateLength(num);    \n     \n#Makes a copy of the original number num    \nn = num;    \n     \n#Calculates the sum of digits powered with their respective position    \nwhile(num > 0):    \n    rem = num%10;    \n    sum = sum + int(rem**len);    \n    num = num//10;    \n    len = len - 1;    \n     \n#Checks whether the sum is equal to the number itself    \nif(sum == n):    \n    print(str(n) + \" is a disarium number\");    \nelse:    \n    print(str(n) + \" is not a disarium number\");    "}
{"nl": "The program sorts a list by insertion sort.", "code": "def insertion_sort(alist):\n    for i in range(1, len(alist)):\n        temp = alist[i]\n        j = i - 1\n        while (j >= 0 and temp < alist[j]):\n            alist[j + 1] = alist[j]\n            j = j - 1\n        alist[j + 1] = temp\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\ninsertion_sort(alist)\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "Write a Python program to print triangle of mirrored numbers pattern using for loop.\n\n", "code": "rows = int(input(\"Enter Triangle Mirrored Numbers Rows = \"))\n\nprint(\"====The Triangle of Mirrored Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(rows, i, -1):\n        print(end = ' ')\n    for k in range(1, i + 1):\n        print(k, end = '')\n    for l in range(i - 1, 0, -1):\n        print(l, end = '')\n    print()"}
{"nl": "Given an undirected graph, how to check if there is a cycle in the graph?\u00a0\nApproach: Run a DFS from every unvisited node. Depth First Traversal can be used to detect a cycle in a Graph. DFS for a connected graph produces a tree. There is a cycle in a graph only if there is a back edge present in the graph. A back edge is an edge that is joining a node to itself (self-loop) or one of its ancestor in the tree produced by DFS. \nTo find the back edge to any of its ancestors keep a visited array and if there is a back edge to any visited node then there is a loop and return true.\nAlgorithm: \n\nCreate the graph using the given number of edges and vertices.\nCreate a recursive function that have current index or vertex, visited array and parent node.\nMark the current node as visited .\nFind all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true return true.\nIf the adjacent node is not parent and already visited then return true.\nCreate a wrapper class, that calls the recursive function for all the vertices and if any function returns true, return true.\nElse if for all vertices the function returns false return false.", "code": "# Python Program to detect cycle in an undirected graph\nfrom collections import defaultdict\n\u00a0\u00a0\n# This class represents a undirected\n# graph using adjacency list representation\nclass Graph:\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self,vertices):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# No. of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V= vertices #No. of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Default dictionary to store graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to add an edge to graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,v,w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#Add w to v_s list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[v].append(w)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#Add v to w_s list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[w].append(v)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# A recursive function that uses\n\u00a0\u00a0\u00a0\u00a0# visited[] and parent to detect\n\u00a0\u00a0\u00a0\u00a0# cycle in subgraph reachable from vertex v.\n\u00a0\u00a0\u00a0\u00a0def isCyclicUtil(self,v,visited,parent):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark the current node as visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[v]= True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Recur for all the vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# adjacent to this vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in self.graph[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the node is not\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited then recurse on it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0 visited[i]==False :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(self.isCyclicUtil(i,visited,v)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If an adjacent vertex is\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited and not parent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# of current vertex,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then there is a cycle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif\u00a0 parent!=i:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if the graph\n\u00a0\u00a0\u00a0\u00a0# contains a cycle, else false.\n\u00a0\u00a0\u00a0\u00a0def isCyclic(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark all the vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as not visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited =[False]*(self.V)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Call the recursive helper\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# function to detect cycle in different\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# DFS trees\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(self.V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Don't recur for u if it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is already visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[i] ==False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(self.isCyclicUtil\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(i,visited,-1)) == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n# Create a graph given in the above diagram\ng = Graph(5)\ng.addEdge(1, 0)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(0, 3)\ng.addEdge(3, 4)\n\u00a0\nif g.isCyclic():\n\u00a0\u00a0\u00a0\u00a0print (\"Graph contains cycle\")\nelse :\n\u00a0\u00a0\u00a0\u00a0print (\"Graph does not contain cycle \")\ng1 = Graph(3)\ng1.addEdge(0,1)\ng1.addEdge(1,2)\n\u00a0\n\u00a0\nif g1.isCyclic():\n\u00a0\u00a0\u00a0\u00a0print (\"Graph contains cycle\")\nelse :\n\u00a0\u00a0\u00a0\u00a0print (\"Graph does not contain cycle \")\n\u00a0\u00a0\n#This code is contributed by Neelam Yadav\n"}
{"nl": "Create a function that takes two strings as arguments and returns the number of times the first string (the single character) is found in the second string.\nExamples\nchar_count(\"a\", \"edabit\") \u279e 1\n\nchar_count(\"c\", \"Chamber of secrets\") \u279e 1\n\nchar_count(\"b\", \"big fat bubble\") \u279e 4\nNotes\nYour output must be case-sensitive (see second example).", "code": "def char_count(txt1, txt2):\n  return txt2.count(txt1)"}
{"nl": "Given heights of n towers and a value k. We need to either increase or decrease the height of every tower by k (only once) where k > 0. The task is to minimize the difference between the heights of the longest and the shortest tower after modifications and output this difference.", "code": "# User function Template\r\ndef getMinDiff(arr, n, k):\r\n\tarr.sort()\r\n\tans = arr[n - 1] - arr[0] # Maximum possible height difference\r\n\r\n\ttempmin = arr[0]\r\n\ttempmax = arr[n - 1]\r\n\r\n\tfor i in range(1, n):\r\n\t\ttempmin = min(arr[0] + k, arr[i] - k)\r\n\t\t\r\n\t\t# Minimum element when we\r\n\t\t# add k to whole array\r\n\t\t# Maximum element when we\r\n\t\ttempmax = max(arr[i - 1] + k, arr[n - 1] - k)\r\n\t\t\r\n\t\t# subtract k from whole array\r\n\t\tans = min(ans, tempmax - tempmin)\r\n\r\n\treturn ans\r\n\r\n# Driver Code Starts\r\nk = 6\r\nn = 6\r\narr = [7, 4, 8, 8, 8, 9]\r\nans = getMinDiff(arr, n, k)\r\nprint(ans)\r\n\r\n# This code is contributed by ninja_hattori.\r"}
{"nl": "The Reversal Algorithm to  rotate(arr[], d, n) that rotates arr[] of size n by d elements. ", "code": "# Python program for reversal algorithm of array rotation\n\n# Function to reverse arr[] from index start to end\n\n\ndef reverseArray(arr, start, end):\n        while (start < end):\n                temp = arr[start]\n                arr[start] = arr[end]\n                arr[end] = temp\n                start += 1\n                end = end-1\n\n# Function to left rotate arr[] of size n by d\n\n\ndef leftRotate(arr, d):\n\n        if d == 0:\n                return\n        n = len(arr)\n        # in case the rotating factor is\n        # greater than array length\n        d = d % n\n        reverseArray(arr, 0, d-1)\n        reverseArray(arr, d, n-1)\n        reverseArray(arr, 0, n-1)\n\n# Function to print an array\n\n\ndef printArray(arr):\n        for i in range(0, len(arr)):\n                print (arr[i],end=' ')\n\n\n# Driver function to test above functions\narr = [1, 2, 3, 4, 5, 6, 7]\nn = len(arr)\nd = 2\n\nleftRotate(arr, d) # Rotate array by 2\nprintArray(arr)\n\n# This code is contributed by Devesh Agrawal\n"}
{"nl": "Given an array of N integers and an integer K, pick two distinct elements whose sum is K and find the maximum shortest distance of the picked elements from the endpoints.\nExamples: \n \n\nInput : a[] = {2, 4, 3, 2, 1}\n        k = 5.\nOutput :  2\nExplanation:\nSelect the pair(4, 1). \nShortest distance of 4 from ends = 2\nShortest distance of 1 from ends = 1\nHence, answer is max(2, 1) = 2      \n\nInput : a[] = {2, 4, 1, 9, 5}\n        k = 3\nOutput : 3\nExplanation:\nSelect the pair (2, 1)\nShortest distance of 2 from ends = 1\nShortest distance of 1 from ends = 3\nHence, answer is max(1, 3) = 3. ", "code": "# Python3 code to find maximum shortest\n# distance from endpoints\n\n# function to find maximum shortest distance\ndef find_maximum(a, n, k):\n\t\n\t# stores the shortest distance of every\n\t# element in original array.\n\tb = dict()\n\t\n\tfor i in range(n):\n\t\tx = a[i]\n\t\t\n\t\t# shortest distance from ends\n\t\td = min(1 + i, n - i)\n\t\tif x not in b.keys():\n\t\t\tb[x] = d\n\t\telse:\n\n\t\t\t# if duplicates are found, b[x]\n\t\t\t# is replaced with minimum of the\n\t\t\t# previous and current position's\n\t\t\t# shortest distance*/\n\t\t\tb[x] = min(d, b[x])\n\t\n\tans = 10**9\n\tfor i in range(n):\n\t\tx = a[i]\n\t\t\n\t\t# similar elements ignore them\n\t\t# cause we need distinct elements\n\t\tif (x != (k - x) and (k - x) in b.keys()):\t\t\n\t\t\tans = min(max(b[x], b[k - x]), ans)\n\n\treturn ans\n\n# Driver code\na = [3, 5, 8, 6, 7]\nK = 11\nn = len(a)\nprint(find_maximum(a, n, K))\n\n# This code is contributed by mohit kumar"}
{"nl": "Given an array, rotate the array to the right by k steps, where k is non-negative.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n \n\nConstraints:\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105", "code": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        n = len(nums)\n        a = [0] * n\n        for i in range(n):\n            a[(i + k) % n] = nums[i]\n            \n        nums[:] = a"}
{"nl": "Recursion in Python:\n\nWhen a function calls itself and loops until it reaches the intended end state, this is referred to as recursion. It is based on the mathematics idea of recursive definitions, which define elements in a set in terms of other members in the set.\n\nEach recursive implementation contains a base case in which the desired state is reached, and a recursive case in which the desired state is not reached and the function enters another recursive phase.\n\nOn each step, the behavior in the recursive situation before the recursive function call, the internal self-call, is repeated. Recursive structures are beneficial when a larger problem (the base case) can be solved by solving repeated subproblems (the recursive case) that incrementally advance the program to the base case.\nIt behaves similarly to for and while loops, with the exception that recursion moves closer to the desired condition, whereas for loops run a defined number of times and while loops run until the condition is no longer met.\n\nIn other words, recursion is declarative because you specify the desired state, whereas for/while loops are iterative because you provide the number of repeats.\n\nStrings in Python:\n\nA string is typically a piece of text (sequence of characters). To represent a string in Python, we use \u201d (double quotes) or \u2018 (single quotes).\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven string = \"btechgeeksskeeghcetb\"\nOutput:\n\nThe given string [ btechgeeksskeeghcetb ] is a palindrome", "code": "# function which checks the given string is palindrome or not using recursion\n# if th given string is palindrome then it is true else the string is false.\n\n\ndef checkPalindromeRecursion(givenstr):\n  # Calculate the length of the string using the len() function.\n    stringLen = len(givenstr)\n    # If the length of the string is less than 1, the function returns True.\n    if stringLen < 1:\n        return True\n    else:\n      # If the end letter is the same as the initial letter, execute the function\n      # recursively with the parameter as the sliced list\n      # with the first and last characters deleted, otherwise return False.\n      # Use an if statement to determine whether the given string is\n      # True or False and then print the result.\n        if givenstr[0] == givenstr[-1]:\n            return checkPalindromeRecursion(givenstr[1:-1])\n        else:\n            return False\n\n\n# Give some string as static input and store it in a variable.\ngiven_str = 'btechgeeksskeeghcetb'\n# Pass the string to a recursive function checkPalindromeRecursion function as an argument.\n# If the function returns true then the given string is a palindrome.\nif(checkPalindromeRecursion(given_str)):\n    print(\"The given string [\", given_str, '] is a palindrome')\n# Else the given string is not a palindrome.\nelse:\n    print(\"The given string\", given_str, 'is not a palindrome')"}
{"nl": "You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.\n\nFor each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.\n\nThe conversion operation is described in the following two steps:\n\nAppend any lowercase letter that is not present in the string to its end.\nFor example, if the string is \"abc\", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be \"abcd\".\nRearrange the letters of the new string in any arbitrary order.\nFor example, \"abcd\" can be rearranged to \"acbd\", \"bacd\", \"cbda\", and so on. Note that it can also be rearranged to \"abcd\" itself.\nReturn the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.\n\nNote that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.", "code": "class Solution:\n    def wordCount(self, sw: List[str], t: List[str]) -> int:\n        hash=set()\n        \n        for word in sw:\n            s=0\n            for x in word:\n                k=ord(x)-97\n                s=s|(1<<k)\n            hash.add(s)\n        ans=0\n        for word in t:\n            s=0\n            for x in word:\n                k=ord(x)-97\n                s=s|(1<<k)\n            for x in word:\n                k=ord(x)-97\n                if s^(1<<k) in hash:\n                    ans+=1\n                    break\n                \n                \n                    \n        return ans\n        "}
{"nl": "Given a singly linked list and a position, delete a linked list node at the given position.\n\nExample:  Input: position = 1, Linked List = 8->2->3->1->7\nOutput: Linked List =  8->3->1->7\n\nInput: position = 0, Linked List = 8->2->3->1->7\nOutput: Linked List = 2->3->1->7", "code": "# Python3 program to delete all\n# the nodes of singly linked list\n\n# Node class\n\n\nclass Node:\n\n        # Function to initialise the node object\n        def __init__(self, data):\n                self.data = data # Assign data\n                self.next = None # Initialize next as null\n\n\n# Constructor to initialize the node object\nclass LinkedList:\n\n        # Function to initialize head\n        def __init__(self):\n                self.head = None\n\n        def deleteList(self):\n\n                # initialize the current node\n                current = self.head\n                while current:\n                        prev = current.next # move next node\n\n                        # delete the current node\n                        del current.data\n\n                        # set current equals prev node\n                        current = prev\n\n                # In python garbage collection happens\n                # therefore, only\n                # self.head = None\n                # would also delete the link list\n\n        # push function to add node in front of llist\n        def push(self, new_data):\n\n                # Allocate the Node &\n                # Put in the data\n                new_node = Node(new_data)\n\n                # Make next of new Node as head\n                new_node.next = self.head\n\n                # Move the head to point to new Node\n                self.head = new_node\n\n\n# Use push() to construct below\n# list 1-> 12-> 1-> 4-> 1\nif __name__ == '__main__':\n\n        llist = LinkedList()\n        llist.push(1)\n        llist.push(4)\n        llist.push(1)\n        llist.push(12)\n        llist.push(1)\n\n        print(\"Deleting linked list\")\n        llist.deleteList()\n\n        print(\"Linked list deleted\")\n\n\n# This article is provided by Shrikant13\n"}
{"nl": "Check whether kth Bit of a Number is Set Using Right Shift Operator (Static Input)", "code": "# Give the number and the value of k as static input # and store it in a variable.\r\nnumb = 19\r\nk = 2\r\n# First, compute number>>(k-1) and store it in a variable called temp, resulting in temp=number>>(k-1).\r\n# If the kth bit is set, the last bit of temp will be 1, otherwise, it will be 0.\r\ntemp = numb >> (k-1)\r\n# You must execute a bitwise AND of 1 and temp in this step.\r\n# If this gives a non-zero integer,\r\n# the kth bit of the number is set, otherwise, it is not.\r\nif (1 & temp):\r\n        # If it is true then print the kth bit is set bit.\r\n    print('The', k, 'nd bit in the number ', numb,\r\n          '(binary representation =', bin(numb)[2:], ') is set bit')\r\n# Else print it is not set bit.\r\nelse:\r\n    print('The', k, 'nd bit in the number', numb,\r\n          '(binary representation =', bin(numb)[2:], ')is not a set bit')"}
{"nl": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...", "code": "class Solution:\n    # @return a string\n    def convertToTitle(self, num):\n        capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\n        result = []\n        while num > 0:\n            result.append(capitals[(num-1)%26])\n            num = (num-1) // 26\n        result.reverse()\n        return ''.join(result)"}
{"nl": "Given an array of N integers where Ai denotes the currency of note that the i-th person has. The possible currencies are 5, 10, and 20. All the N people are standing in a queue waiting to buy an ice cream from X which costs Rs 5. Initially, X has an initial balance of 0. Check if X will be able to provide change for all people who are waiting to buy ice cream.", "code": "# Python program to check whether X can\r\n# give change to every person in the Queue\r\n\r\n# Function to check if every person\r\n# will get the change from X\r\ndef isChangeable(notes, n):\r\n\t\r\n\t# To count the 5$ and 10& notes\r\n\tfiveCount = 0\r\n\ttenCount = 0\r\n\t\r\n\t# Serve the customer in order\r\n\tfor i in range(n):\r\n\t\t\r\n\t\t# Increase the number of 5$ note by one\r\n\t\tif (notes[i] == 5):\r\n\t\t\tfiveCount += 1\r\n\t\telif(notes[i] == 10):\r\n\t\t\t\r\n\t\t\t# decrease the number of note 5$\r\n\t\t\t# and increase 10$ note by one\r\n\t\t\tif (fiveCount > 0):\r\n\t\t\t\tfiveCount -= 1\r\n\t\t\t\ttenCount += 1\r\n\t\t\telse:\r\n\t\t\t\treturn 0\r\n\t\telse:\r\n\t\t\t\r\n\t\t\t# decrease 5$ and 10$ note by one\r\n\t\t\tif (fiveCount > 0 and tenCount > 0):\r\n\t\t\t\tfiveCount -= 1\r\n\t\t\t\ttenCount -= 1\r\n\t\t\t\t\r\n\t\t\t# decrease 5$ note by three\r\n\t\t\telif (fiveCount >= 3):\r\n\t\t\t\tfiveCount -= 3\r\n\t\t\telse:\r\n\t\t\t\treturn 0\r\n\treturn 1\r\n\r\n# Driver Code\r\n\r\n# queue of customers with available notes.\r\na = [5, 5, 5, 10, 20 ]\r\nn = len(a)\r\n\r\n# Calling function\r\nif (isChangeable(a, n)):\r\n\tprint(\"YES\")\r\nelse:\r\n\tprint(\"NO\")\r\n\r\n# This code is contributed by PrinciRaj1992\r"}
{"nl": "We recommend to read following post as a prerequisite for this.\nGreedy Algorithms | Set 3 (Huffman Coding)\n\nTime complexity of the algorithm discussed in above post is O(nLogn). If we know that the given array is sorted (by non-decreasing order of frequency), we can generate Huffman codes in O(n) time. Following is a O(n) algorithm for sorted input.\n1. Create two empty queues.\n2. Create a leaf node for each unique character and Enqueue it to the first queue in non-decreasing order of frequency. Initially second queue is empty.\n3. Dequeue two nodes with the minimum frequency by examining the front of both queues. Repeat following steps two times \n        1. If second queue is empty, dequeue from first queue. \n        2. If first queue is empty, dequeue from second queue. \n        3. Else, compare the front of two queues and dequeue the minimum. \n4. Create a new internal node with frequency equal to the sum of the two nodes frequencies. Make the first Dequeued node as its left child and the second Dequeued node as right child. Enqueue this node to second queue.\n5. Repeat steps#3 and #4 while there is more than one node in the queues. The remaining node is the root node and the tree is complete. ", "code": "# Python3 program for Efficient Huffman Coding\n# for Sorted input\n\n# Class for the nodes of the Huffman tree\nclass QueueNode:\n\t\n\tdef __init__(self, data = None, freq = None,\n\t\t\t\tleft = None, right = None):\n\t\tself.data = data\n\t\tself.freq = freq\n\t\tself.left = left\n\t\tself.right = right\n\n\t# Function to check if the following\n\t# node is a leaf node\n\tdef isLeaf(self):\n\t\treturn (self.left == None and\n\t\t\t\tself.right == None)\n\n# Class for the two Queues\nclass Queue:\n\t\n\tdef __init__(self):\n\t\tself.queue = []\n\n\t# Function for checking if the\n\t# queue has only 1 node\n\tdef isSizeOne(self):\n\t\treturn len(self.queue) == 1\n\n\t# Function for checking if\n\t# the queue is empty\n\tdef isEmpty(self):\n\t\treturn self.queue == []\n\n\t# Function to add item to the queue\n\tdef enqueue(self, x):\n\t\tself.queue.append(x)\n\n\t# Function to remove item from the queue\n\tdef dequeue(self):\n\t\treturn self.queue.pop(0)\n\n# Function to get minimum item from two queues\ndef findMin(firstQueue, secondQueue):\n\t\n\t# Step 3.1: If second queue is empty,\n\t# dequeue from first queue\n\tif secondQueue.isEmpty():\n\t\treturn firstQueue.dequeue()\n\n\t# Step 3.2: If first queue is empty,\n\t# dequeue from second queue\n\tif firstQueue.isEmpty():\n\t\treturn secondQueue.dequeue()\n\n\t# Step 3.3: Else, compare the front of\n\t# two queues and dequeue minimum\n\tif (firstQueue.queue[0].freq <\n\t\tsecondQueue.queue[0].freq):\n\t\treturn firstQueue.dequeue()\n\n\treturn secondQueue.dequeue()\n\n# The main function that builds Huffman tree\ndef buildHuffmanTree(data, freq, size):\n\t\n\t# Step 1: Create two empty queues\n\tfirstQueue = Queue()\n\tsecondQueue = Queue()\n\n\t# Step 2: Create a leaf node for each unique\n\t# character and Enqueue it to the first queue\n\t# in non-decreasing order of frequency.\n\t# Initially second queue is empty.\n\tfor i in range(size):\n\t\tfirstQueue.enqueue(QueueNode(data[i], freq[i]))\n\n\t# Run while Queues contain more than one node.\n\t# Finally, first queue will be empty and\n\t# second queue will contain only one node\n\twhile not (firstQueue.isEmpty() and\n\t\t\tsecondQueue.isSizeOne()):\n\t\t\t\t\t\n\t\t# Step 3: Dequeue two nodes with the minimum\n\t\t# frequency by examining the front of both queues\n\t\tleft = findMin(firstQueue, secondQueue)\n\t\tright = findMin(firstQueue, secondQueue)\n\n\t\t# Step 4: Create a new internal node with\n\t\t# frequency equal to the sum of the two\n\t\t# nodes frequencies. Enqueue this node\n\t\t# to second queue.\n\t\ttop = QueueNode(\"$\", left.freq + right.freq,\n\t\t\t\t\t\tleft, right)\n\t\tsecondQueue.enqueue(top)\n\n\treturn secondQueue.dequeue()\n\n# Prints huffman codes from the root of\n# Huffman tree. It uses arr[] to store codes\ndef printCodes(root, arr):\n\t\n\t# Assign 0 to left edge and recur\n\tif root.left:\n\t\tarr.append(0)\n\t\tprintCodes(root.left, arr)\n\t\tarr.pop(-1)\n\n\t# Assign 1 to right edge and recur\n\tif root.right:\n\t\tarr.append(1)\n\t\tprintCodes(root.right, arr)\n\t\tarr.pop(-1)\n\n\t# If this is a leaf node, then it contains\n\t# one of the input characters, print the\n\t# character and its code from arr[]\n\tif root.isLeaf():\n\t\tprint(f\"{root.data}: \", end = \"\")\n\t\tfor i in arr:\n\t\t\tprint(i, end = \"\")\n\t\t\t\n\t\tprint()\n\n# The main function that builds a Huffman\n# tree and print codes by traversing the\n# built Huffman tree\ndef HuffmanCodes(data, freq, size):\n\t\n\t# Construct Huffman Tree\n\troot = buildHuffmanTree(data, freq, size)\n\n\t# Print Huffman codes using the Huffman\n\t# tree built above\n\tarr = []\n\tprintCodes(root, arr)\n\n# Driver code\narr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\nfreq = [5, 9, 12, 13, 16, 45]\nsize = len(arr)\n\nHuffmanCodes(arr, freq, size)\n\n# This code is contributed by Kevin Joshi"}
{"nl": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind the maximum profit you can achieve. You may complete at most two transactions.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.", "code": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        t1_cost, t2_cost = float('inf'), float('inf')\n        t1_profit, t2_profit = 0, 0\n\n        for price in prices:\n            # the maximum profit if only one transaction is allowed\n            t1_cost = min(t1_cost, price)\n            t1_profit = max(t1_profit, price - t1_cost)\n            # reinvest the gained profit in the second transaction\n            t2_cost = min(t2_cost, price - t1_profit)\n            t2_profit = max(t2_profit, price - t2_cost)\n\n        return t2_profit"}
{"nl": "Instructions\r\nCorrectly determine the fewest number of coins to be given to a customer such that the sum of the coins' value would equal the correct amount of change.\r\n\r\nFor example\r\nAn input of 15 with [1, 5, 10, 25, 100] should return one nickel (5) and one dime (10) or [5, 10]\r\nAn input of 40 with [1, 5, 10, 25, 100] should return one nickel (5) and one dime (10) and one quarter (25) or [5, 10, 25]\r\nEdge cases\r\nDoes your algorithm work for any given set of coins?\r\nCan you ask for negative change?\r\nCan you ask for a change value smaller than the smallest coin value?\r\nException messages\r\nSometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.\r\n\r\nThis particular exercise requires that you use the raise statement to \"throw\" a ValueError when change cannot be made with the coins given. The tests will only pass if you both raise the exception and include a message with it.\r\n\r\nTo raise a ValueError with a message, write the message as an argument to the exception type:\r\n\r\n# example when change cannot be made with the coins passed in\r\nraise ValueError(\"can't make target with given coins\")", "code": "change = []\r\ndef find_fewest_coins(coins, target):\r\n    if target < 0:\r\n        raise ValueError(\"target can't be negative\")\r\n    if target == 0:\r\n        return []\r\n    if target < coins[0]:\r\n        raise ValueError(\"can't make target with given coins\")\r\n    global change\r\n    change = list()\r\n    for index in range(len(coins))[::-1]:\r\n        find_combination(0, coins, target, [], index)\r\n    if len(change) == 0:\r\n        raise ValueError(\"can't make target with given coins\")\r\n    return sorted(change)\r\ndef find_combination(balance, coins, target, p, index):\r\n    global change\r\n    p = list(p)\r\n    if balance == target:\r\n        change = list(p)\r\n        return\r\n    if len(p) >= len(change) > 0:\r\n        return\r\n    if index < 0:\r\n        return\r\n    if coins[index] + balance > target:\r\n        find_combination(balance, coins, target, p, index - 1)\r\n        return\r\n    balance = balance + coins[index]\r\n    p.append(coins[index])\r\n    find_combination(balance, coins, target, p, index)\r\n    find_combination(balance, coins, target, p, index - 1)"}
{"nl": "In the previous article, we have discussed Python Program for Exponential Squaring (Fast Modulo Multiplication)\n \n Given a square matrix, the task is to swap the major diagonal elements and minor diagonal elements of a given matrix.\n \n What is a matrix:\n \n A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.\n \n Diagonal Matrix:\n \n The entries outside the main diagonal of a diagonal matrix are all 0; the word usually refers to square matrices.\n \n Major Diagonal Matrix :\n \n The Major Diagonal Elements of a Matrix are those that occur from the top left corner of the matrix down to the bottom right corner. The Major Diagonal is also referred to as the Main Diagonal or the Primary Diagonal.\n \n Minor Diagonal Matrix :\n \n Minor Diagonal Elements are those that appear from the top right corner of the matrix down to the bottom left corner. Secondary Diagonal is another name for it.\n \n Example:\n \n \n \n Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.\n \n In this order, the dimensions of a matrix indicate the number of rows and columns.\n \n \n \n Here as there are 5 rows and 4 columns it is called a 5*4 matrix.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given Matrix : \n 6 2 0\n 1 4 2\n 3 7 5\n Output:\n \n The given matix after swapping the major and the minor diagonal elements: \n 0 2 6 \n 1 4 2 \n 5 7 3\n Example2:\n \n Input:\n \n Given Matrix : \n 1 2 3\n 4 5 6\n 7 8 9\n Output:\n \n The given matix after swapping the major and the minor diagonal elements: \n 3 2 1 \n 4 5 6 \n 9 8 7", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[6, 2, 0], [1, 4, 2], [3, 7, 5]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n print(\"The given matix after swapping the major and the minor diagonal elements: \")\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, swap mtrx[n][n], mtrx[n][mtrxrows-n-1] using the comma(,) operator\n  # ( where n is the iterator value and mtrxrows is the no of rows of matrix).\n  mtrx[n][n], mtrx[n][mtrxrows-n-1] = mtrx[n][mtrxrows-n-1], mtrx[n][n]\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of rows using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Print the element of the matrix by printing gvnmatrix[n][m] value\n  # where n is the iterator value of the parent For loop and m is the iterator\n  # value of the inner For loop.\n  print(mtrx[n][m], end=' ')\n  print()"}
{"nl": "Given a dictionary, and the task is to find the Product of values of elements in a dictionary.", "code": "# Take a dictionary and initialize it with an empty dictionary using dict() or {}.\ngvn_dict = {}\n# Give the number of keys as user input using int(input()) and store it in a variable.\nnumb_of_kys = int(\n    input('Enter some random number of keys of the dictionary = '))\n# Loop till the given number of keys using for loop.\nfor p in range(numb_of_kys):\n        # Inside the for loop scan the key and value as\n    # user input using input(),split() functions\n    # and store them in two separate variables.\n    keyy, valuee =  input(\n        'Enter key and value separated by spaces = ').split()\n    # Initialize the key with the value of the dictionary.\n    gvn_dict[keyy] = valuee\n\n# Get all the values of given dictionary using dictionary.values() method\n# and store it in another variable.\ndict_vlue = gvn_dict.values()\n# Take a variable say 'product' and initialize it's value with '1'\nfnl_prod = 1\n# Iterate in the above given dictionary values using using For loop.\nfor itrator in dict_vlue:\n  # Inside the loop, Multiply the above initialized product variable with the iterator\n  # and store it in a same variable.\n    fnl_prod = fnl_prod*int(itrator)\n# Print the product of values for the above given dictionary.\nprint(\"The Product of values in a given dictionary = \", fnl_prod)"}
{"nl": "Create a function that takes a string and replaces every letter with the letter following it in the alphabet (\"c\" becomes \"d\", \"z\" becomes \"a\", \"b\" becomes \"c\", etc). Then capitalize every vowel (a, e, i, o, u) and return the new modified string.\nExamples\nmangle(\"Fun times!\") \u279e \"GvO Ujnft!\"\n\nmangle(\"The quick brown fox.\") \u279e \"UIf rvjdl cspxO gpy.\"\n\nmangle(\"Omega\") \u279e \"Pnfhb\"\nNotes\nIf a letter is already uppercase, return it as uppercase (regardless of being a vowel).\n\"y\" is not considered a vowel.", "code": "def mangle(txt):\n  x = ['A' if i in 'zZ' else chr(ord(i)+1) if i.isalpha() else i for i in txt]\n  return ''.join(i.upper() if i in 'aeiou' else i for i in x)"}
{"nl": "In this example, you will learn to make a flattened list from a nested list in Python.", "code": "my_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = [num for sublist in my_list for num in sublist]\nprint(flat_list)\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = []\nfor sublist in my_list:\n    for num in sublist:\n        flat_list.append(num)\n\nprint(flat_list)\nimport itertools\n\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = list(itertools.chain(*my_list))\nprint(flat_list)\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = sum(my_list, [])\nprint(flat_list)\nfrom functools import reduce\n\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\nprint(reduce(lambda x, y: x+y, my_list))"}
{"nl": "Given two integers as arguments, create a function that finds the largest prime within the range of the two integers.\nExamples\nfat_prime(2, 10) \u279e 7\n# range [2, 3, 4, 5, 6, 7, 8, 9, 10] and the largest prime is 7.\n\nfat_prime(10, 2) \u279e 7\n# [10, 9, 8, 7, 6, 5, 4, 3, 2] and the largest prime is 7.\n\nfat_prime(4, 24) \u279e 23\n# range [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24] the largest prime is 23.\nNotes\nAll numbers will be positive integers.", "code": "def fat_prime(a, b):\n  s, e = min(a,b), max(a,b)\n  return max(i for i in range(s,e+1) if all(i%j for j in range(2,int(i**0.5)+1)))"}
{"nl": "Given a square matrix, turn it by 90 degrees in anti-clockwise direction without using any extra space.", "code": "# Python3 program to rotate a matrix by 90 degrees\r\nN = 4\r\n\r\n# An Inplace function to rotate\r\n# N x N matrix by 90 degrees in\r\n# anti-clockwise direction\r\ndef rotateMatrix(mat):\r\n\t\r\n\t# Consider all squares one by one\r\n\tfor x in range(0, int(N / 2)):\r\n\t\t\r\n\t\t# Consider elements in group\r\n\t\t# of 4 in current square\r\n\t\tfor y in range(x, N-x-1):\r\n\t\t\t\r\n\t\t\t# store current cell in temp variable\r\n\t\t\ttemp = mat[x][y]\r\n\r\n\t\t\t# move values from right to top\r\n\t\t\tmat[x][y] = mat[y][N-1-x]\r\n\r\n\t\t\t# move values from bottom to right\r\n\t\t\tmat[y][N-1-x] = mat[N-1-x][N-1-y]\r\n\r\n\t\t\t# move values from left to bottom\r\n\t\t\tmat[N-1-x][N-1-y] = mat[N-1-y][x]\r\n\r\n\t\t\t# assign temp to left\r\n\t\t\tmat[N-1-y][x] = temp\r\n\r\n\r\n# Function to print the matrix\r\ndef displayMatrix( mat ):\r\n\t\r\n\tfor i in range(0, N):\r\n\t\t\r\n\t\tfor j in range(0, N):\r\n\t\t\t\r\n\t\t\tprint (mat[i][j], end = ' ')\r\n\t\tprint (\"\")\r\n\t\r\n\t\r\n\r\n\r\n# Driver Code\r\nmat = [[0 for x in range(N)] for y in range(N)]\r\n\r\n# Test case 1\r\nmat = [ [1, 2, 3, 4 ],\r\n\t\t[5, 6, 7, 8 ],\r\n\t\t[9, 10, 11, 12 ],\r\n\t\t[13, 14, 15, 16 ] ]\r\n\t\t\r\n'''\r\n# Test case 2\r\nmat = [ [1, 2, 3 ],\r\n\t\t[4, 5, 6 ],\r\n\t\t[7, 8, 9 ] ]\r\n\r\n# Test case 3\r\nmat = [ [1, 2 ],\r\n\t\t[4, 5 ] ]\r\n\t\t\r\n'''\r\n\r\nrotateMatrix(mat)\r\n\r\n# Print rotated matrix\r\ndisplayMatrix(mat)\r\n\r\n\r\n# This code is contributed by saloni1297\r"}
{"nl": "You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). A package can be placed in a box if the size of the package is less than or equal to the size of the box.\n\nThe package sizes are given as an integer array packages, where packages[i] is the size of the ith package. The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the jth supplier produces.\n\nYou want to choose a single supplier and use boxes from them such that the total wasted space is minimized. For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes.\n\nFor example, if you have to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes [4,8], you can fit the packages of size-2 and size-3 into two boxes of size-4 and the package with size-5 into a box of size-8. This would result in a waste of (4-2) + (4-3) + (8-5) = 6.\nReturn the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. Since the answer may be large, return it modulo 109 + 7.", "code": "class Solution:\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\n        packages.sort()\n        largest_package = packages[-1]\n        all_boxes = []\n\n        for i, box in enumerate(boxes):\n            # Optional: ignore box lists that don't work at the start. \n            # Spends time finding max to save time sorting/iterating later.\n            if max(box) >= largest_package:\n                all_boxes.extend(((x, i) for x in box))\n\n        if not all_boxes:\n            return -1\n\n        all_boxes.sort(key=lambda j: j[0])\n\n        space_wasted_by_box = [0] * len(boxes)\n        last_package_handled = [-1] * len(boxes)\n        package_ptr, num_packages = 0, len(packages)\n\n        # Find smallest box that fits the smallest package\n        start_index = bisect.bisect_right(all_boxes, (packages[0], -1))\n\n        for box_size, orig_ind in all_boxes[start_index:]:\n            # Package_ptr always points to the largest package with size <= box_size\n            while package_ptr + 1 < num_packages and packages[package_ptr + 1] <= box_size:\n                package_ptr += 1\n\n            if last_package_handled[orig_ind] < package_ptr:\n                space_wasted_by_box[orig_ind] += (package_ptr - last_package_handled[orig_ind]) * box_size\n                last_package_handled[orig_ind] = package_ptr\n\n        smallest_waste = min(space_wasted_by_box[i] for i in range(len(boxes)) if last_package_handled[i] == num_packages - 1)\n        return (smallest_waste - sum(packages)) % 1000000007"}
{"nl": "In this post, we will write a Python program to compute the sum of digits in a string. The string will be given as input and the program compute the sum of digits using various methods. We are using the For Loop and if-else statementto compute the sum of digits.", "code": "# python program to compute sum of digits in a string # take input string = input(\"Enter any string: \") # find sum of digits sum_digit = 0 for x in string: if x.isdigit(): sum_digit += int(x) # display result print(\"Sum of digits =\", sum_digit)"}
{"nl": "Given a list that contains the negative and positive elements the task is to move all the negative elements to the end of the list.", "code": "# Give the list as static input and store it in a variable.\r\ngvnlst = [1, 9, -3, 6, 8, 11, 35, -5, -7, 10, -1, -2, -3]\r\n# Using list comprehension and if conditional statements\r\n# separate the positive numbers from the list\r\n# and store it in a variable to say the positive list.\r\npstivelist = [elemn for elemn in gvnlst if elemn >= 0]\r\n# Using list comprehension and if conditional statements\r\n# separate the negative numbers from the list and store it\r\n# in a variable to say the negative list.\r\nngtivelist = [elemn for elemn in gvnlst if elemn < 0]\r\n# Add the positive list and negative list using the + operator\r\n# and store it in another variable to say result list\r\n# (This operation moves all the negative list).\r\nresltlist = pstivelist+ngtivelist\r\n# Print the result list.\r\nprint('The given list after moving negative elements to the end is', resltlist)"}
{"nl": "The program creates a doubly linked list and finds the largest element in the list.", "code": "class Node:\n    def __init__(self, data):\n       self.data = data\n       self.next = None\n       self.prev = None\n\u00a0\n\u00a0\nclass DoublyLinkedList:\n    def __init__(self):\n        self.first = None\n        self.last = None\n\u00a0\n    def append(self, data):\n        self.insert_at_end(Node(data))\n\u00a0\n    def insert_at_end(self, new_node):\n        if self.last is None:\n            self.last = new_node\n            self.first = new_node\n        else:\n            new_node.prev = self.last\n            self.last.next = new_node\n            self.last = new_node\n\u00a0\n\u00a0\ndef find_largest(dllist):\n    if dllist.first is None:\n        return None\n    largest = dllist.first.data\n    current = dllist.first.next\n    while current:\n        if current.data > largest:\n            largest = current.data\n        current = current.next\n    return largest\n\u00a0\n\u00a0\na_dllist = DoublyLinkedList()\n\u00a0\ndata_list = input('Please enter the elements in the doubly linked list: ').split()\nfor data in data_list:\n    a_dllist.append(int(data))\n\u00a0\nlargest = find_largest(a_dllist)\nif largest:\n    print('The largest element is {}.'.format(largest))\nelse:\n    print('The list is empty.')"}
{"nl": "We will learn how to convert gray to binary code in Python in this tutorial. A binary number is a number written in the base-2 numeral system. As a result, a binary number is made up of only 0s and 1s. So, today, we\u2019ll learn how to represent binary and gray code numbers, how to convert a gray number to binary code, and how to use a Python program to convert a gray number to binary code.", "code": "# function which accepts the gray code  and returns the binary code  of the gray code\ndef grayToBin(grayCde):\n   # Converting the given gray code to integer\n    graynum = int(grayCde, 2)\n   # Taking a temporary variable which stores the the gray code integer number\n    tempnum = graynum\n    # using while loop\n    while tempnum != 0:\n        tempnum >>= 1\n        graynum ^= tempnum\n\n        # bin(n) returns n's binary representation with the prefix '0b' removed\n        # the slice operation removes the prefix.\n    return bin(graynum)[2:]\n\n\n# given gray code as static\ngraycode = input(\"Enter some random gray code string = \")\n# passing this graycode to grayToBin function\nresultbin = grayToBin(graycode)\nprint('The Binary string of the given gray code=', graycode, 'is', resultbin)"}
{"nl": "Given an array (or string), the task is to reverse the array/string.\nExamples : \n \n\nInput  : arr[] = {1, 2, 3}\nOutput : arr[] = {3, 2, 1}\n\nInput :  arr[] = {4, 5, 1, 2}\nOutput : arr[] = {2, 1, 5, 4}", "code": "# Iterative python program to reverse an array\n\n# Function to reverse A[] from start to end\ndef reverseList(A, start, end):\n\twhile start < end:\n\t\tA[start], A[end] = A[end], A[start]\n\t\tstart += 1\n\t\tend -= 1\n\n# Driver function to test above function\nA = [1, 2, 3, 4, 5, 6]\nprint(A)\nreverseList(A, 0, 5)\nprint(\"Reversed list is\")\nprint(A)\n# This program is contributed by Pratik Chhajer"}
{"nl": "Gradio is an open-source python library which allows you to quickly create easy to use, customizable UI components for your ML model, any API, or any arbitrary function in just a few lines of code. You can integrate the GUI directly into your Python notebook, or you can share the link to anyone.", "code": "\r\ndef factorial(integer):\r\n    \"\"\" Returns factorial of the given integer\"\"\"\r\n    n = int(integer)\r\n    if n<=1:\r\n        return 1\r\n    fact=1\r\n    for i in range(1, n+1):\r\n        fact*=i\r\n    return fact\r\nimport gradio\r\ngradio.Interface(factorial, inputs=\"text\", outputs=\"text\").launch(share=True)\r\n# imported necessary libraries\r\nimport gradio as gr\r\nimport tensorflow as tf\r\nimport numpy as np\r\nimport requests\r\n \r\n# loading the model\r\ninception_net = tf.keras.applications.InceptionV3()\r\n \r\n# Download human-readable labels.\r\nresponse = requests.get(\"https://git.io/JJkYN\")\r\nlabels = response.text.split(\"\\n\")\r\n \r\ndef classify_image(image):\r\n    \"\"\" Returns a dictionary with key as label and values\r\n    as the predicted confidence for that label\"\"\"\r\n    # reshaping the image\r\n    image = image.reshape((-1, 299, 299, 3))\r\n    # preprocessing the image for inception_v3\r\n    image = tf.keras.applications.inception_v3.preprocess_input(image)\r\n    # predicting the output\r\n    prediction = inception_net.predict(image).flatten()\r\n    return {labels[i]: float(prediction[i]) for i in range(1000)}\r\n \r\n# initializing the input component\r\nimage = gr.inputs.Image(shape = (299, 299, 3))\r\n# initializing the output component\r\nlabel = gr.outputs.Label(num_top_classes = 3)\r\n \r\n# launching the interface\r\ngr.Interface(fn = classify_image, inputs = image,\r\n             outputs = label, capture_session = True).launch()"}
{"nl": "Now in this post, we will count vowels in a string in python using various methods. The alphabets \u2018A\u2019, \u2018E\u2019, \u2018I\u2019, \u2018O\u2019, \u2018U\u2019 (in uppercase) and \u2018a\u2019, \u2018e\u2019, \u2018i\u2019, \u2018o\u2019, \u2018u\u2019 are vowels, and remaining alphabets are called consonants.", "code": "# Python program to count vowels in a string def countVowels(string): num_vowels=0 # to count the vowels for char in string: if char in \"aeiouAEIOU\": num_vowels = num_vowels+1 return num_vowels # take input string = input('Enter any string: ') # calling function and display result print('No of vowels =',countVowels(string))"}
{"nl": "Given a string consisting of opening and closing parenthesis, find the length of the longest valid parenthesis substring.", "code": "# Python program to find length of the longest valid\n# substring\n\u00a0\n\u00a0\ndef findMaxLen(string):\n\u00a0\u00a0\u00a0\u00a0n = len(string)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a stack and push -1\n\u00a0\u00a0\u00a0\u00a0# as initial index to it.\n\u00a0\u00a0\u00a0\u00a0stk = []\n\u00a0\u00a0\u00a0\u00a0stk.append(-1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize result\n\u00a0\u00a0\u00a0\u00a0result = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse all characters of given string\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If opening bracket, push index of it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if string[i] == '(':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If closing bracket, i.e., str[i] = ')'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pop the previous opening bracket's index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if len(stk) != 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if this length formed with base of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current valid substring is more than max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# so far\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if len(stk) != 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = max(result,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i - stk[len(stk)-1])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If stack is empty. push current index as\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# base for next valid substring (if any)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return result\n\u00a0\n\u00a0\n# Driver code\nstring = \"((()()\"\n\u00a0\n# Function call\nprint (findMaxLen(string))\n\u00a0\nstring = \"()(()))))\"\n\u00a0\n# Function call\nprint (findMaxLen(string))\n\u00a0\n# This code is contributed by Bhavya Jain\n"}
{"nl": "Write a function that returns the total number of integers covered from a list of intervals (inclusive). In other words, return the number of different integers in the lists.\nExamples\ncovered_integers([[80, 81], [1, 2], [9, 11]]) \u279e 7\n# Seven integers are covered: 1, 2, 9, 10, 11, 80, 81\n\ncovered_integers([[3, 6], [4, 6], [5, 6]]) \u279e 4\n\ncovered_integers([[1, 2], [1, 2]]) \u279e 2\nNotes\nIntervals may overlap, be subintervals of each other, or be identical.\nFor each interval [l, u], l and u will be integers, and l <= u will always be true.", "code": "def covered_integers(lst):\n  return len({i for l, u in lst for i in range(l, u+1)})"}
{"nl": "In this program, you'll learn to find the sum of n natural numbers using while loop and display it.", "code": "# Sum of natural numbers up to num\n\nnum = 16\n\nif num < 0:\n   print(\"Enter a positive number\")\nelse:\n   sum = 0\n   # use while loop to iterate until zero\n   while(num > 0):\n       sum += num\n       num -= 1\n   print(\"The sum is\", sum)"}
{"nl": "Method #1: Using For Loop (Static Input)\r\nApproach:\r\n\r\nGive the number of rows as static input and store it in a variable.\r\nLoop from 0 to the number of rows using For loop.\r\nInside the For, loop Take a variable(say Tempo) and initialize its value with 1.\r\nPrint the value of the Tempo variable with space.\r\nLoop from the number of rows -m-1 to 0 in decreasing order using another for loop(Nested For loop) where m is the iterator value of the parent For loop.\r\nPrint the Star Character with space.\r\nIncrement the value of Tempo by 1.\r\nPrint the value of the Tempo variable with space.\r\nPrint the Newline character after the end of the inner loop.\r\nThe Exit of the Program.", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumberOfRows = 8\r\n# Loop from 0 to the number of rows using For loop.\r\nfor m in range(0, numberOfRows):\r\n    # Inside the For, loop Take a variable(say Tempo) and initialize its value with 1.\r\n    Tempo = 1\r\n    # Print the value of the Tempo variable with space.\r\n    print(Tempo, end=' ')\r\n    # Loop from the number of rows -m-1 to 0 in decreasing order using another for loop(Nested For loop)\r\n    # where m is the iterator value of the parent For loop.\r\n    for n in range(numberOfRows-m-1, 0, -1):\r\n      # Print the Star Character with space.\r\n        print('*', end=' ')\r\n        # Increment the value of Tempo by 1.\r\n        Tempo = Tempo + 1\r\n        # Print the value of the Tempo variable with space.\r\n        print(Tempo, end=' ')\r\n\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "Strings in Python:\n In Python, a string may be a sequence of characters. It is an information type that has been derived. Strings are unchangeable. This means that when they have been defined, they can not be modified. Many Python functions change strings, like replace(), join(), and split(). They do not, however, alter the original string. They make a duplicate of a string, alter it, then return it to the caller.\n Given a string, the task is to write a python program to calculate the total number of lowercase characters in the given string.\n Examples:\n Example1:\n Input:\n given string = 'Hello this is BTechGeeks'\n Output:\n The total number of lower case letters present in the given string [ Hello this is BTechGeeks ] = 17\n Example2:\n Input:\n given string = BTechgeeks\n Output:\n The total number of lower case letters present in the given string [ BTechgeeks ] = 8", "code": "# Give the string as static input and save it in a variable.\n \n given_strng = 'Hello this is BTechGeeks'\n \n # Take a variable to say countlow that stores the total number of lowercase characters present in the given string.\n \n # Initialize the countlow to 0.\n \n countlow = 0\n \n # Traverse the given string using for loop.\n \n for charact in given_strng:\n \n  # Check if the iterator value is lowercase or not using islower() function.\n \n  if(charact.islower()):\n \n  # If the character is in lowercase then increment the countlow by 1.\n \n  countlow = countlow+1\n \n # Print the countlow.\n \n print(\n \n  'The total number of lower case letters present in the given string [', given_strng, '] = ', countlow)"}
{"nl": "Given two strings, s1 and s2, select only the characters in each string where the character in the same position in the other string is in uppercase. Return these as a single string.\nTo illustrate, given the strings s1 = \"heLLo\" and s2 = \"GUlp\", we select the letters \"he\" from s1, because \"G\" and \"U\" are uppercase. We then select \"lp\" from s2, because \"LL\" is in uppercase. Finally, we join these together and return \"help\".\nExamples\nselect_letters(\"heLLO\", \"GUlp\") \u279e \"help\"\n\nselect_letters(\"1234567\", \"XxXxX\")  \u279e \"135\"\n\nselect_letters(\"EVERYTHING\", \"SomeThings\") \u279e  \"EYSomeThings\"\nNotes\nThe strings don't have to be the same length.\nStrings can contain non-alphabetic characters.", "code": "def select_letters(s1, s2):\n    left = ''.join(a for a, b in zip(s1, s2) if b.isupper())\n    right = ''.join(b for a, b in zip(s1, s2) if a.isupper())\n    return left + right"}
{"nl": "Create a function that replaces \"the\" in the sentence with \"an\" or \"a\". Remember that if the next word begins with a vowel, use \"an\". In the case of a consonant, use \"a\".\nExamples\nreplace_the(\"the dog and the envelope\") \u279e \"a dog and an envelope\"\n\nreplace_the(\"the boy ran at the wall\") \u279e \"a boy ran at a wall\"\n\nreplace_the(\"the egg, the spoon and the espionage\") \u279e \"an egg, a spoon and an espionage\"\nNotes\nSentences will always be in lowercase.\nThe last word of the sentence will never be \"the\".\nThis won't cover edge cases such as \"an hour\" or \"a unique thing\" (since they sound differently to the rule).", "code": "import re\ndef replace_the(txt):\n  def repl(match):\n    a,b = match.group(1,2)\n    return ('an ' if b in 'aeiou' else 'a ') + b\n  return re.sub('(the) (\\w)', repl, txt)"}
{"nl": "In an unsorted array, the search operation can be performed by linear traversal from the first element to the last element. ", "code": "# Python program for searching in\r\n# unsorted array\r\n\r\ndef findElement(arr, n, key):\r\n\tfor i in range (n):\r\n\t\tif (arr[i] == key):\r\n\t\t\treturn i\r\n\treturn -1\r\n\r\narr = [12, 34, 10, 6, 40]\r\nkey = 40\r\nn = len(arr)\r\n\r\n#search operation\r\nindex = findElement(arr, n, key)\r\nif index != -1:\r\n\tprint (\"element found at position: \" + str(index + 1 ))\r\nelse:\r\n\tprint (\"element not found\")\r\n\t\r\n# Thanks to Aditi Sharma for contributing\r\n# this code\r\n"}
{"nl": "Create a function that takes a list of numbers or letters and returns a string.\nExamples\nlist_to_string([1, 2, 3, 4, 5, 6]) \u279e \"123456\"\n\nlist_to_string([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]) \u279e \"abcdef\"\n\nlist_to_string([1, 2, 3, \"a\", \"s\", \"dAAAA\"]) \u279e \"123asdAAAA\"\nNotes\nN/A", "code": "def list_to_string(lst):\n    return ''.join(map(str, lst))"}
{"nl": "Write a function that turns a comma-delimited list into an array of strings.\nExamples\nto_array(\"watermelon, raspberry, orange\")\n\u279e [\"watermelon\", \"raspberry\", \"orange\"]\n\nto_array(\"x1, x2, x3, x4, x5\")\n\u279e [\"x1\", \"x2\", \"x3\", \"x4\", \"x5\"]\n\nto_array(\"a, b, c, d\")\n\u279e [\"a\", \"b\", \"c\", \"d\"]\n\nto_array(\"\")\n\u279e []\nNotes\nReturn an empty list for an empty string.", "code": "def to_array(txt):\n  return txt.split(', ') if txt else []"}
{"nl": "A Bagging classifier is an ensemble meta-estimator that fits base classifiers each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it.\nEach base classifier is trained in parallel with a training set which is generated by randomly drawing, with replacement, N examples(or data) from the original training dataset \u2013 where N is the size of the original training set. Training set for each of the base classifiers is independent of each other. Many of the original data may be repeated in the resulting training set while others may be left out.\n\nBagging reduces overfitting (variance) by averaging or voting, however, this leads to an increase in bias, which is compensated by the reduction in variance though.\n\nHow Bagging works on training dataset ?\nHow bagging works on an imaginary training dataset is shown below. Since Bagging resamples the original training dataset with replacement, some instance(or data) may be present multiple times while others are left out.\n\nOriginal training dataset: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\nResampled training set 1: 2, 3, 3, 5, 6, 1, 8, 10, 9, 1\nResampled training set 2: 1, 1, 5, 6, 3, 8, 9, 10, 2, 7\nResampled training set 3: 1, 5, 8, 9, 2, 10, 9, 7, 5, 4\n\nAlgorithm for the Bagging classifier:\n\nClassifier generation:\n\nLet N be the size of the training set.\nfor each of t iterations:\n    sample N instances with replacement from the original training set.\n    apply the learning algorithm to the sample.\n    store the resulting classifier.\n\nClassification:\nfor each of the t classifiers:\n    predict class of instance using classifier.\nreturn class that was predicted most often.", "code": "from sklearn import model_selection\nfrom sklearn.ensemble import BaggingClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nimport pandas as pd\n\n# load the data\nurl = \"/home/debomit/Downloads/wine_data.xlsx\"\ndataframe = pd.read_excel(url)\narr = dataframe.values\nX = arr[:, 1:14]\nY = arr[:, 0]\n\nseed = 8\nkfold = model_selection.KFold(n_splits = 3,\n\t\t\t\t\trandom_state = seed)\n\n# initialize the base classifier\nbase_cls = DecisionTreeClassifier()\n\n# no. of base classifier\nnum_trees = 500\n\n# bagging classifier\nmodel = BaggingClassifier(base_estimator = base_cls,\n\t\t\t\t\t\tn_estimators = num_trees,\n\t\t\t\t\t\trandom_state = seed)\n\nresults = model_selection.cross_val_score(model, X, Y, cv = kfold)\nprint(\"accuracy :\")\nprint(results.mean())"}
{"nl": "Instructions\nWrite a robot simulator.\n\nA robot factory's test facility needs a program to verify robot movements.\n\nThe robots have three possible movements:\n\nturn right\nturn left\nadvance\nRobots are placed on a hypothetical infinite grid, facing a particular direction (north, east, south, or west) at a set of {x,y} coordinates, e.g., {3,8}, with coordinates increasing to the north and east.\n\nThe robot then receives a number of instructions, at which point the testing facility verifies the robot's new position, and in which direction it is pointing.\n\nThe letter-string \"RAALAL\" means:\nTurn right\nAdvance twice\nTurn left\nAdvance once\nTurn left yet again\nSay a robot starts at {7, 3} facing north. Then running this stream of instructions should leave it at {9, 4} facing west.", "code": "\"\"\"Robot Simulator.\"\"\"\r\n# Directions, complex polar mappings.\r\nEAST = 1\r\nNORTH = 1j\r\nWEST = -1\r\nSOUTH = -1j\r\nclass Robot:\r\n    \"\"\"A robot.\"\"\"\r\n    def __init__(self, direction: complex, x: int, y: int):\r\n        \"\"\"Initialize, mapping inputs to complex numbers.\"\"\"\r\n        self.direction = direction\r\n        self._coord = x + y * 1j\r\n    @property\r\n    def coordinates(self) -> tuple[int, int]:\r\n        \"\"\"Map complex coordinates to Cartesian.\"\"\"\r\n        return (int(self._coord.real), int(self._coord.imag))\r\n    def move(self, instructions: str) -> None:\r\n        \"\"\"Move the robot Right|Left|Advance.\"\"\"\r\n        for instruction in instructions:\r\n            if instruction not in \"RLA\":\r\n                raise ValueError(f\"invalid instruction {instruction}\")\r\n            if instruction == \"A\":\r\n                # Advance.\r\n                self._coord += self.direction\r\n            elif instruction == \"R\":\r\n                # Rotate -90 deg.\r\n                self.direction *= -1j\r\n            elif instruction == \"L\":\r\n                # Rotate 90 deg.\r\n                self.direction *= 1j\r\n"}
{"nl": "Files in Python:\n\nFiles are identified locations on the disc where associated data is stored. They\u2019re used to keep data in non-volatile memory for a long time (e.g. hard disk).\n\nWe use files for future usage of the data by permanently saving it because Random Access Memory (RAM) is volatile (it loses its contents when the machine is turned off).\n\n\n\nWe must first open a file before we can read from or write to it. When we\u2019re finished, it needs to be closed so that the file\u2019s resources may be released.\n\nAs a result, a file operation in Python is performed in the following order:\n\nCreate a new file\nYou can either read or write (perform the operations)\nClose the file.\n\nGiven a file, the task is to reverse the content of a given file and store it in another file in Python.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\nrevFile = \"reversed_file.txt\"\n# Open a file in write mode. In this case, we're writing the contents into the file.\nrev_File = open(revFile,'w')\n# Make another variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open another file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Read the above file using the read() function(get the content) and store it in a variable\n  gvn_data = givenfilecontent.read()\n# Reverse the content of the given file using negative indexing and store it in another variable.\nrevrse_data = gvn_data[::-1] \n# Write the above reversed data into the reversed file using the write() function\nrev_File.write(revrse_data) \n# Close the reversed file(rev_file) using the close() function\nrev_File.close()"}
{"nl": "A complex number is represented by a + bi or a + bj. Python handles complex numbers using complex data types. Python uses a+bj notation. Python programming language converts the real numbers a and b into complex using the function complex(a,b).\r\n\r\nPython handles simple operation like addition, subtraction, multiplication and division directly. For more advanced operation on complex numbers you can use cmath library.\r\n\r\nThis python program multiplies two complex number given by user and displays the output.", "code": "# Python program to multiply two complex number\r\n\r\n# Enter first complex number i.e. 3+4j not 3+4i\r\nfirst = complex(input('Enter first complex number: '))\r\nsecond = complex(input('Enter first complex number: '))\r\n\r\n# Multiplication of complex number\r\nproduct = first * second\r\n\r\n# Displaying Sum\r\nprint('PRODUCT = ', product)"}
{"nl": "Getting the Data Type\r\nYou can get the data type of any object by using the type() function:", "code": "x = 5\r\nprint(type(x))"}
{"nl": "Given a sequence of matrices, find the most efficient way to multiply these matrices together. The problem is not actually to perform the multiplications, but merely to decide in which order to perform the multiplications.\nWe have many options to multiply a chain of matrices because matrix multiplication is associative. In other words, no matter how we parenthesize the product, the result will be the same. For example, if we had four matrices A, B, C, and D, we would have: \n\n(ABC)D = (AB)(CD) = A(BCD) = ....\nHowever, the order in which we parenthesize the product affects the number of simple arithmetic operations needed to compute the product, or the efficiency. For example, suppose A is a 10 \u00d7 30 matrix, B is a 30 \u00d7 5 matrix, and C is a 5 \u00d7 60 matrix. Then,  \n\n\n\n(AB)C = (10\u00d730\u00d75) + (10\u00d75\u00d760) = 1500 + 3000 = 4500 operations\nA(BC) = (30\u00d75\u00d760) + (10\u00d730\u00d760) = 9000 + 18000 = 27000 operations.\nClearly the first parenthesization requires less number of operations.\nGiven an array p[] which represents the chain of matrices such that the ith matrix Ai is of dimension p[i-1] x p[i]. We need to write a function MatrixChainOrder() that should return the minimum number of multiplications needed to multiply the chain. \n\nInput: p[] = {40, 20, 30, 10, 30}   \nOutput: 26000  \nThere are 4 matrices of dimensions 40x20, 20x30, 30x10 and 10x30.\nLet the input 4 matrices be A, B, C and D.  The minimum number of \nmultiplications are obtained by putting parenthesis in following way\n(A(BC))D --> 20*30*10 + 40*20*10 + 40*10*30\n\nInput: p[] = {10, 20, 30, 40, 30} \nOutput: 30000 \nThere are 4 matrices of dimensions 10x20, 20x30, 30x40 and 40x30. \nLet the input 4 matrices be A, B, C and D.  The minimum number of \nmultiplications are obtained by putting parenthesis in following way\n((AB)C)D --> 10*20*30 + 10*30*40 + 10*40*30\n\nInput: p[] = {10, 20, 30}  \nOutput: 6000  \nThere are only two matrices of dimensions 10x20 and 20x30. So there \nis only one way to multiply the matrices, cost of which is 10*20*30", "code": "# Dynamic Programming Python implementation of Matrix\n# Chain Multiplication. See the Cormen book for details\n# of the following algorithm\nimport sys\nmaxint=int(1e9+7)\n# Matrix Ai has dimension p[i-1] x p[i] for i = 1..n\n\n\ndef MatrixChainOrder(p, n):\n\t# For simplicity of the program,\n\t# one extra row and one\n\t# extra column are allocated in m[][].\n\t# 0th row and 0th\n\t# column of m[][] are not used\n\tm = [[0 for x in range(n)] for x in range(n)]\n\n\t# m[i, j] = Minimum number of scalar\n\t# multiplications needed\n\t# to compute the matrix A[i]A[i + 1]...A[j] =\n\t# A[i..j] where\n\t# dimension of A[i] is p[i-1] x p[i]\n\n\t# cost is zero when multiplying one matrix.\n\tfor i in range(1, n):\n\t\tm[i][i] = 0\n\n\t# L is chain length.\n\tfor L in range(2, n):\n\t\tfor i in range(1, n-L + 1):\n\t\t\tj = i + L-1\n\t\t\tm[i][j] = maxint\n\t\t\tfor k in range(i, j):\n\n\t\t\t\t# q = cost / scalar multiplications\n\t\t\t\tq = m[i][k] + m[k + 1][j] + p[i-1]*p[k]*p[j]\n\t\t\t\tif q < m[i][j]:\n\t\t\t\t\tm[i][j] = q\n\n\treturn m[1][n-1]\n\n\n# Driver code\narr = [1, 2, 3, 4]\nsize = len(arr)\n\nprint(\"Minimum number of multiplications is \" +\n\tstr(MatrixChainOrder(arr, size)))\n# This Code is contributed by Bhavya Jain"}
{"nl": "Strings in Python:\n \u201cString is a character collection or array\u201d\n Well in Python too, for the string data type, we say the same definition. The string is a sequenced character array and is written within single, double, or three quotes. Also, Python does not have the data type character, thus it is used as a string of length 1 if we write \u2018r\u2019.\n Given a string, the task is to calculate the total number of digits and letters present in the given string in Python.\n Examples:\n Example1:\n Input:\n given string =Hel34lo18th3is9is38 BTech23Geeks\n Output:\n The total number of digits present in the given string [ Hel34lo18th3is9is38 BTech23Geeks ] = 10\n \n The total number of characters present in the given string [ Hel34lo18th3is9is38 BTech23Geeks ] = 32\n Example2:\n Input:\n given string =btechgeeks2online82platform92for1000geeks\n Output:\n Enter some random string = btechgeeks2online82platform92for1000geeks\n \n The total number of digits present in the given string [ btechgeeks2online82platform92for1000geeks ] = 9\n \n The total number of characters present in the given string [ btechgeeks2online82platform92for1000geeks ] = 41", "code": "# Give the string as static input and save it in a variable.\n \n given_strng = 'Hel34lo18th3is9is38 BTech23Geeks'\n \n # Take a variable to say stringdigits that stores the total digits in the given string.\n \n # Initialize the stringdigits to 0.\n \n stringdigits = 0\n \n # Take a variable to say stringcharacters that stores the total characters in the given string.\n \n # Initialize the stringcharacters to 0.\n \n stringcharacters = 0\n \n # Traverse the given string using for loop.\n \n for charact in given_strng:\n \n  # Check if the character is a numerical digit or not using the isdigit() function.\n \n  if(charact.isdigit()):\n \n  # If the character is a numerical digit then increment the value of stringdigits by 1.\n \n  stringdigits = stringdigits+1\n \n  # Increase the stringcharacters by 1.\n \n  stringcharacters = stringcharacters+1\n \n # Print the total count of digits and characters present in the given string.\n \n print(\n \n  'The total number of digits present in the given string [', given_strng, '] = ', stringdigits)\n \n print(\n \n  'The total number of characters present in the given string [', given_strng, '] = ', stringcharacters)"}
{"nl": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\nReturn the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.\n \nExample 1:\n\nInput: s = \"10101\"\nOutput: 4\nExplanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n\"1|010|1\"\n\"1|01|01\"\n\"10|10|1\"\n\"10|1|01\"\n\nExample 2:\n\nInput: s = \"1001\"\nOutput: 0\n\nExample 3:\n\nInput: s = \"0000\"\nOutput: 3\nExplanation: There are three ways to split s in 3 parts.\n\"0|0|00\"\n\"0|00|0\"\n\"00|0|0\"\n\n \nConstraints:\n\n3 <= s.length <= 105\ns[i] is either '0' or '1'.", "code": "def numWays(self, s: str) -> int:\n  ones, n, m = s.count('1'), len(s), 10 ** 9 + 7\n  if ones == 0:\n  return (n - 2) * (n - 1) // 2 % m\n  if ones % 3 != 0:\n  return 0\n  ones_in_each_splited_block = ones // 3\n  count = ways_of_first_cut = ways_of_second_cut = 0\n  for char in s:\n  if char == '1':\n  count += 1\n  if count == ones_in_each_splited_block:\n  ways_of_first_cut += 1\n  elif count == 2 * ones_in_each_splited_block:\n  ways_of_second_cut += 1\n  return ways_of_first_cut * ways_of_second_cut % m"}
{"nl": "A number n is a Harshad (also called Niven) number if it is divisible by the sum of its digits. For example, 666 is divisible by 6 + 6 + 6, so it is a Harshad number.\nWrite a function to determine whether the given number is a Harshad number.\nExamples\nis_harshad(209) \u279e True\n\nis_harshad(41) \u279e False\n\nis_harshad(12255) \u279e True\nNotes\nN/A", "code": "def is_harshad(num):\n  return num!= 0 and num % sum(int(x) for x in str(num)) == 0"}
{"nl": "Given a binary tree, print it vertically.\n", "code": "# Python program for printing vertical order of a given\r\n# binary tree\r\n \r\n# A binary tree node\r\nclass Node:\r\n    # Constructor to create a new node\r\n    def __init__(self, key):\r\n        self.key = key\r\n        self.left = None\r\n        self.right = None\r\n \r\n# Utility function to store vertical order in map 'm'\r\n# 'hd' is horizontal distance of current node from root\r\n# 'hd' is initially passed as 0\r\ndef getVerticalOrder(root, hd, m):\r\n \r\n    # Base Case\r\n    if root is None:\r\n        return\r\n     \r\n    # Store current node in map 'm'\r\n    try:\r\n        m[hd].append(root.key)\r\n    except:\r\n        m[hd] = [root.key]\r\n     \r\n    # Store nodes in left subtree\r\n    getVerticalOrder(root.left, hd-1, m)\r\n     \r\n    # Store nodes in right subtree\r\n    getVerticalOrder(root.right, hd+1, m)\r\n \r\n# The main function to print vertical order of a binary\r\n#tree ith given root\r\ndef printVerticalOrder(root):\r\n     \r\n    # Create a map and store vertical order in map using\r\n    # function getVerticalORder()\r\n    m = dict()\r\n    hd = 0\r\n    getVerticalOrder(root, hd, m)\r\n     \r\n    # Traverse the map and print nodes at every horizontal\r\n    # distance (hd)\r\n    for index, value in enumerate(sorted(m)):\r\n        for i in m[value]:\r\n            print (i,end=\" \")\r\n        print()\r\n \r\n \r\n# Driver program to test above function\r\nroot = Node(1)\r\nroot.left = Node(2)\r\nroot.right = Node(3)\r\nroot.left.left = Node(4)\r\nroot.left.right = Node(5)\r\nroot.right.left = Node(6)\r\nroot.right.right = Node(7)\r\nroot.right.left.right = Node(8)\r\nroot.right.right.right = Node(9)\r\nprint (\"Vertical order traversal is\")\r\nprintVerticalOrder(root)\r\n \r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)"}
{"nl": "Create a function that takes a string of 1's and 0's (binary) as an argument and return the equivalent decoded ASCII text. Characters can be in the range of \"00000000\" to \"11111111\", which means every eight digits of binary input represents a single character.\na = 01100001\nb = 01100010\nc = 01100011\nIf you were to combine these characters into the string \"abc\", the corresponding binary would be 011000010110001001100011. Use the resources tab for more info on how to approach this.\nExamples\nbinary_conversion(\"011001010110010001100001011000100110100101110100\") \u279e \"edabit\"\n\nbinary_conversion(\"001100010011001000110011\") \u279e \"123\"\n\nbinary_conversion(\"010010000110010101101100011011000110111100111111\") \u279e \"Hello?\"\nNotes\nIf you are given an empty string as input, you must also return an empty string. Otherwise, the input will always be a valid binary string.", "code": "def binary_conversion(txt):\n  return \"\".join([chr(int(txt[i:i+8],2)) for i in range(0,len(txt),8)])"}
{"nl": "In a sorted array, a search operation is performed for the possible position of the given element by using Binary search and then insert operation is performed followed by shifting the elements. ", "code": "# Python3 program to implement insert\r\n# operation in an sorted array.\r\n\r\n# Inserts a key in arr[] of given capacity.\r\n# n is current size of arr[]. This function\r\n# returns n+1 if insertion is successful, else n.\r\ndef insertSorted(arr, n, key, capacity):\r\n\t\r\n\t# Cannot insert more elements if n is\r\n\t# already more than or equal to capacity\r\n\tif (n >= capacity):\r\n\t\treturn n\r\n\r\n\ti = n - 1\r\n\twhile i >= 0 and arr[i] > key:\r\n\t\tarr[i + 1] = arr[i]\r\n\t\ti -= 1\r\n\r\n\tarr[i + 1] = key\r\n\r\n\treturn (n + 1)\r\n\r\n# Driver Code\r\narr = [12, 16, 20, 40, 50, 70]\r\n\r\nfor i in range(20):\r\n\tarr.append(0)\r\n\r\ncapacity = len(arr)\r\nn = 6\r\nkey = 26\r\n\r\nprint(\"Before Insertion: \", end = \" \");\r\nfor i in range(n):\r\n\tprint(arr[i], end = \" \")\r\n\t\r\n# Inserting key\r\nn = insertSorted(arr, n, key, capacity)\r\n\r\nprint(\"\\nAfter Insertion: \", end = \"\")\r\nfor i in range(n):\r\n\tprint(arr[i], end = \" \")\r\n\r\n# This code is contributed by Mohit Kumar\r\n"}
{"nl": "A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm is an algorithm that performs two useful operations on such a data structure:\n\nFind: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.\n\nUnion: Join two subsets into a single subset. Here first we have to check if the two subsets belong to same set. If no, then we cannot perform union.\n\nIn this post, we will discuss the application of Disjoint Set Data Structure. The application is to check whether a given graph contains a cycle or not.", "code": "# Python Program for union-find algorithm to detect cycle in a undirected graph\r\n# we have one egde for any two vertex i.e 1-2 is either 1-2 or 2-1 but not both\r\n  \r\nfrom collections import defaultdict\r\n  \r\n#This class represents a undirected graph using adjacency list representation\r\nclass Graph:\r\n  \r\n    def __init__(self,vertices):\r\n        self.V= vertices #No. of vertices\r\n        self.graph = defaultdict(list) # default dictionary to store graph\r\n  \r\n \r\n    # function to add an edge to graph\r\n    def addEdge(self,u,v):\r\n        self.graph[u].append(v)\r\n  \r\n    # A utility function to find the subset of an element i\r\n    def find_parent(self, parent,i):\r\n        if parent[i] == -1:\r\n            return i\r\n        if parent[i]!= -1:\r\n             return self.find_parent(parent,parent[i])\r\n \r\n    # A utility function to do union of two subsets\r\n    def union(self,parent,x,y):\r\n        parent[x] = y\r\n \r\n  \r\n  \r\n    # The main function to check whether a given graph\r\n    # contains cycle or not\r\n    def isCyclic(self):\r\n         \r\n        # Allocate memory for creating V subsets and\r\n        # Initialize all subsets as single element sets\r\n        parent = [-1]*(self.V)\r\n \r\n        # Iterate through all edges of graph, find subset of both\r\n        # vertices of every edge, if both subsets are same, then\r\n        # there is cycle in graph.\r\n        for i in self.graph:\r\n            for j in self.graph[i]:\r\n                x = self.find_parent(parent, i)\r\n                y = self.find_parent(parent, j)\r\n                if x == y:\r\n                    return True\r\n                self.union(parent,x,y)\r\n \r\n \r\n# Create a graph given in the above diagram\r\ng = Graph(3)\r\ng.addEdge(0, 1)\r\ng.addEdge(1, 2)\r\ng.addEdge(2, 0)\r\n \r\nif g.isCyclic():\r\n    print (\"Graph contains cycle\")\r\nelse :\r\n    print (\"Graph does not contain cycle \")\r\n  \r\n#This code is contributed by Neelam Yadav"}
{"nl": "Given a binary tree, print all the ancestors of a particular key existing in the tree without using recursion.", "code": "# Python program to print all ancestors of a given key\n\u00a0\n# A class to create a new tree node\nclass newNode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\n# Iterative Function to print all ancestors of a\n# given key\ndef printAncestors(root, key):\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a stack to hold ancestors\n\u00a0\u00a0\u00a0\u00a0st = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse the complete tree in postorder way till\n\u00a0\u00a0\u00a0\u00a0# we find the key\n\u00a0\u00a0\u00a0\u00a0while (1):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Traverse the left side. While traversing, push\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the nodes into the stack so that their right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# subtrees can be traversed later\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (root and root.data != key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.append(root) # push current node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = root.left # move to next node\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the node whose ancestors are to be printed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is found, then break the while loop.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (root and root.data == key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if right sub-tree exists for the node at top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If not then pop that node because we don't need\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# this node any more.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (st[-1].right == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = st[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the popped node is right child of top,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then remove the top as well. Left child of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the top must have processed before.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (len(st) != 0 and st[-1].right == root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = st[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if stack is not empty then simply set the root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as right child of top and start traversing right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sub-tree.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = None if len(st) == 0 else st[-1].right\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If stack is not empty, print contents of stack\n\u00a0\u00a0\u00a0\u00a0# Here assumption is that the key is there in tree\n\u00a0\u00a0\u00a0\u00a0while (len(st) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(st[-1].data,end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop()\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us construct a binary tree\n\u00a0\u00a0\u00a0\u00a0root = newNode(1)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(7)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(3)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(5)\n\u00a0\u00a0\u00a0\u00a0root.right.left = newNode(8)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(9)\n\u00a0\u00a0\u00a0\u00a0root.left.left.left = newNode(4)\n\u00a0\u00a0\u00a0\u00a0root.left.right.right = newNode(6)\n\u00a0\u00a0\u00a0\u00a0root.right.right.left = newNode(10)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0key = 6\n\u00a0\u00a0\u00a0\u00a0printAncestors(root, key)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by PranchalK.\n"}
{"nl": "Given a string, the task is to count the Number of Alphabets in a given String.", "code": "# Give the String as user input using the input()function and store it in the variable.\ngvn_str = input(\"Enter some random String = \")\n# Take a variable say 'count' and initialize it's value with '0'\ncount_no = 0\n# Loop from 0 to the length of the above given String using For Loop.\nfor itrtor in gvn_str:\n    # Inside the loop, check whether  if the value of iterator is alphabet or\n    # using built-in isalpha() method inside the if conditional statement.\n    if(itrtor.isalpha()):\n     # If the given condition is true ,then increment the above initialized count value by '1'.\n        count_no = count_no+1\n# Print the number of Alphabets in a given string by printing the above count value.\nprint(\n    \"The Number of Characters in a given string {\", gvn_str, \"} = \", count_no)"}
{"nl": "Given an array of elements, the task is to sort these elements using a stack.", "code": "# Python3 program to sort an array using stack\n\u00a0\n# This function return the sorted stack\ndef sortStack(input):\n\u00a0\u00a0\u00a0\u00a0tmpStack = []\n\u00a0\u00a0\u00a0\u00a0while (len(input) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop out the first element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmp = input[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0input.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# while temporary stack is not empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and top of stack is smaller than temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (len(tmpStack) > 0 and tmpStack[-1] < tmp):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop from temporary stack and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# append it to the input stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0input.append(tmpStack[-1])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmpStack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# append temp in temporary of stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmpStack.append(tmp)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return tmpStack\n\u00a0\ndef sortArrayUsingStacks(arr, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# append array elements to stack\n\u00a0\u00a0\u00a0\u00a0input = []\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0while ( i < n ):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0input.append(arr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Sort the temporary stack\n\u00a0\u00a0\u00a0\u00a0tmpStack = sortStack(input)\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Put stack elements in arrp[]\n\u00a0\u00a0\u00a0\u00a0while (i < n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i] = tmpStack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmpStack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return arr\n\u00a0\n# Driver code\narr = [10, 5, 15, 45]\nn = len(arr)\n\u00a0\narr = sortArrayUsingStacks(arr, n)\ni = 0\n\u00a0\nwhile (i < n):\n\u00a0\u00a0\u00a0\u00a0print(arr[i] ,end= \" \")\n\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\n# This code is contributed by Arnab Kundu\n"}
{"nl": "Given a Linked List of integers, write a function to modify the linked list such that all even numbers appear before all the odd numbers in the modified linked list. Also, keep the order of even and odd numbers same.\nExamples: \n \n\nInput: 17->15->8->12->10->5->4->1->7->6->NULL\nOutput: 8->12->10->4->6->17->15->5->1->7->NULL\n\nInput: 8->12->10->5->4->1->6->NULL\nOutput: 8->12->10->4->6->5->1->NULL\n\n// If all numbers are even then do not change the list\nInput: 8->12->10->NULL\nOutput: 8->12->10->NULL\n\n// If all numbers are odd then do not change the list\nInput: 1->3->5->7->NULL\nOutput: 1->3->5->7->NULL\n", "code": "# Python program to segregate even and odd nodes in a\n# Linked List\nhead = None # head of list\n\n# Node class\nclass Node:\n\t\n\t# Function to initialise the node object\n\tdef __init__(self, data):\n\t\tself.data = data # Assign data\n\t\tself.next =None\n\ndef segregateEvenOdd():\n\n\tglobal head\n\tend = head\n\tprev = None\n\tcurr = head\n\n\t# Get pointer to last Node\n\twhile (end.next != None):\n\t\tend = end.next\n\n\tnew_end = end\n\n\t# Consider all odd nodes before getting first even node\n\twhile (curr.data % 2 !=0 and curr != end):\n\t\t\n\t\tnew_end.next = curr\n\t\tcurr = curr.next\n\t\tnew_end.next.next = None\n\t\tnew_end = new_end.next\n\t\t\n\t# do following steps only if there is an even node\n\tif (curr.data % 2 == 0):\n\t\t\n\t\thead = curr\n\n\t\t# now curr points to first even node\n\t\twhile (curr != end):\n\t\t\t\n\t\t\tif (curr.data % 2 == 0):\n\t\t\t\t\n\t\t\t\tprev = curr\n\t\t\t\tcurr = curr.next\n\t\t\t\t\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t# Break the link between prev and curr\n\t\t\t\tprev.next = curr.next\n\n\t\t\t\t# Make next of curr as None\n\t\t\t\tcurr.next = None\n\n\t\t\t\t# Move curr to end\n\t\t\t\tnew_end.next = curr\n\n\t\t\t\t# Make curr as new end of list\n\t\t\t\tnew_end = curr\n\n\t\t\t\t# Update curr pointer\n\t\t\t\tcurr = prev.next\n\t\t\t\n\t# We have to set prev before executing rest of this code\n\telse:\n\t\tprev = curr\n\n\tif (new_end != end and end.data % 2 != 0):\n\t\t\n\t\tprev.next = end.next\n\t\tend.next = None\n\t\tnew_end.next = end\n\t\t\n# Given a reference (pointer to pointer) to the head\n# of a list and an int, push a new node on the front\n# of the list.\ndef push(new_data):\n\tglobal head\n\n\t# 1 & 2: Allocate the Node &\n\t#\t\t Put in the data\n\tnew_node = Node(new_data)\n\n\t# 3. Make next of new Node as head\n\tnew_node.next = head\n\n\t# 4. Move the head to point to new Node\n\thead = new_node\n\n# Utility function to print a linked list\ndef printList():\n\tglobal head\n\ttemp = head\n\twhile(temp != None):\n\t\t\n\t\tprint(temp.data, end = \" \")\n\t\ttemp = temp.next\n\t\t\n\tprint(\" \")\n\n# Driver program to test above functions\n\npush(11)\npush(10)\npush(8)\npush(6)\npush(4)\npush(2)\npush(0)\nprint(\"Original Linked List\")\nprintList()\n\nsegregateEvenOdd()\n\nprint(\"Modified Linked List\")\nprintList()\n\n# This code is contributed by Arnab Kundu\n"}
{"nl": "Write a function Add() that returns sum of two integers. The function should not use any of the arithmetic operators (+, ++, \u2013, -, .. etc).\nSum of two bits can be obtained by performing XOR (^) of the two bits. Carry bit can be obtained by performing AND (&) of two bits. ", "code": "# Python3 Program to add two numbers\n# without using arithmetic operator\ndef Add(x, y):\n\n\t# Iterate till there is no carry\n\twhile (y != 0):\n\t\n\t\t# carry now contains common\n\t\t# set bits of x and y\n\t\tcarry = x & y\n\n\t\t# Sum of bits of x and y where at\n\t\t# least one of the bits is not set\n\t\tx = x ^ y\n\n\t\t# Carry is shifted by one so that\n\t\t# adding it to x gives the required sum\n\t\ty = carry << 1\n\t\n\treturn x\n\nprint(Add(15, 32))\n\n# This code is contributed by\n# Smitha Dinesh Semwal\n"}
{"nl": "Given radius r and height h (in cm), calculate the mass of a cylinder when it's filled with water and the cylinder itself doesn't weigh anything. The desired output should be given in kg and rounded to two decimal places.\nHow to solve:\nCalculate the volume of the cylinder.\nConvert cm\u00b3 into dm\u00b3.\n1dm\u00b3 = 1L, 1L is 1Kg.\nExamples\nweight(4, 10) \u279e 0.5\n\nweight(30, 60) \u279e 169.65\n\nweight(15, 10) \u279e 7.07\nNotes\nI recommend importing math.\nIf you get stuck on a challenge, find help in Resources.", "code": "def weight(r, h):\n  from math import pi\n  return round((pi*r**2*h) / 1000, 2)"}
{"nl": "Find the number of negative numbers in a column-wise / row-wise sorted matrix M[][]. Suppose M has n rows and m columns.", "code": "# Python implementation of Naive method to count of\n# negative numbers in M[n][m]\n\u00a0\ndef countNegative(M, n, m):\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Follow the path shown using arrows above\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(m):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if M[i][j] < 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# no more negative numbers in this row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\n\u00a0\n# Driver code\nM = [\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[-3, -2, -1,\u00a0 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[-2,\u00a0 2,\u00a0 3,\u00a0 4],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 4,\u00a0 5,\u00a0 7,\u00a0 8]\n\u00a0\u00a0\u00a0\u00a0]\nprint(countNegative(M, 3, 4))\n"}
{"nl": "Find the largest rectangular area possible in a given histogram where the largest rectangle can be made of a number of contiguous bars. For simplicity, assume that all bars have same width and the width is 1 unit.\u00a0\nFor example, consider the following histogram with 7 bars of heights {6, 2, 5, 4, 5, 1, 6}. The largest possible rectangle possible is 12 (see the below figure, the max area rectangle is highlighted in red)\n\n\n\u00a0", "code": "# Python3 program to find maximum\n# rectangular area in linear time\n\u00a0\ndef max_area_histogram(histogram):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# This function calculates maximum\n\u00a0\u00a0\u00a0\u00a0# rectangular area under given\n\u00a0\u00a0\u00a0\u00a0# histogram with n bars\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an empty stack. The stack\n\u00a0\u00a0\u00a0\u00a0# holds indexes of histogram[] list.\n\u00a0\u00a0\u00a0\u00a0# The bars stored in the stack are\n\u00a0\u00a0\u00a0\u00a0# always in increasing order of\n\u00a0\u00a0\u00a0\u00a0# their heights.\n\u00a0\u00a0\u00a0\u00a0stack = list()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0max_area = 0 # Initialize max area\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Run through all bars of\n\u00a0\u00a0\u00a0\u00a0# given histogram\n\u00a0\u00a0\u00a0\u00a0index = 0\n\u00a0\u00a0\u00a0\u00a0while index < len(histogram):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this bar is higher\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than the bar on top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# stack, push it to stack\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not stack) or (histogram[stack[-1]] <= histogram[index]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(index)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this bar is lower than top of stack,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then calculate area of rectangle with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# stack top as the smallest (or minimum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# height) bar.'i' is 'right index' for\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the top and element before top in stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is 'left index'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop the top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0top_of_stack = stack.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate the area with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# histogram[top_of_stack] stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as smallest bar\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0area = (histogram[top_of_stack] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((index - stack[-1] - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if stack else index))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# update max area, if needed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_area = max(max_area, area)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Now pop the remaining bars from\n\u00a0\u00a0\u00a0\u00a0# stack and calculate area with\n\u00a0\u00a0\u00a0\u00a0# every popped bar as the smallest bar\n\u00a0\u00a0\u00a0\u00a0while stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop the top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0top_of_stack = stack.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate the area with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# histogram[top_of_stack]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# stack as smallest bar\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0area = (histogram[top_of_stack] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((index - stack[-1] - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if stack else index))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# update max area, if needed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_area = max(max_area, area)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return maximum area under\n\u00a0\u00a0\u00a0\u00a0# the given histogram\n\u00a0\u00a0\u00a0\u00a0return max_area\n\u00a0\n# Driver Code\nhist = [6, 2, 5, 4, 5, 1, 6]\nprint(\"Maximum area is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_area_histogram(hist))\n\u00a0\n# This code is contributed\n# by Jinay Shah\n"}
{"nl": "Python does not have a random() function to make a random number, but Python has a built-in module called random that can be used to make random numbers:\r\n\r\n", "code": "import random\r\n\r\nprint(random.randrange(1,10))"}
{"nl": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.\n\nThe steps of the insertion sort algorithm:\n\nInsertion sort iterates, consuming one input element each repetition and growing a sorted output list.\nAt each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\nIt repeats until no input elements remain.\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.", "code": "class Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        curr = head\n\n        while curr:\n            # At each iteration, we insert an element into the resulting list.\n            prev = dummy\n\n            # find the position to insert the current node\n            while prev.next and prev.next.val < curr.val:\n                prev = prev.next\n\n            next = curr.next\n            # insert the current node to the new list\n            curr.next = prev.next\n            prev.next = curr\n\n            # moving on to the next iteration\n            curr = next\n\n        return dummy.next"}
{"nl": "Elif\r\nThe elif keyword is pythons way of saying \"if the previous conditions were not true, then try this condition\".", "code": "a = 33\r\nb = 33\r\nif b > a:\r\n  print(\"b is greater than a\")\r\nelif a == b:\r\n  print(\"a and b are equal\")"}
{"nl": "Hangman is a simple word guessing game.\n\nFunctional Reactive Programming is a way to write interactive programs. It differs from the usual perspective in that instead of saying \"when the button is pressed increment the counter\", you write \"the value of the counter is the sum of the number of times the button is pressed.\"\n\nImplement the basic logic behind hangman using functional reactive programming. You'll need to install an FRP library for this, this will be described in the language/track specific files of the exercise.\n\nPython Special Instructions\nA third party library is not required for this exercise. Please ignore the instructions regarding FRP library.", "code": "# Game status categories\n# Change the values as you see fit\nSTATUS_WIN = 'win'\nSTATUS_LOSE = 'lose'\nSTATUS_ONGOING = 'ongoing'\nclass Hangman:\n    def __init__(self, word):\n        self.remaining_guesses = 9\n        self.status = STATUS_ONGOING\n        self.word = word\n        self.masked_word = ['_'] * len(word)\n        \n    def guess(self, char):\n        if self.remaining_guesses < 0 or self.status != STATUS_ONGOING:\n            raise ValueError(\"The game has already ended.\")\n        iscorrect = False\n        for i in range(len(self.word)):\n            if self.word[i] == char and self.masked_word[i] == '_':\n                self.masked_word[i] = self.word[i]\n                iscorrect = True\n        if not iscorrect:\n            self.remaining_guesses -= 1\n    def get_masked_word(self):\n        return ''.join(self.masked_word)\n    def get_status(self):\n        res = ''.join(self.masked_word)\n        if self.remaining_guesses < 0 and self.word != res:\n            self.status = STATUS_LOSE\n        if self.remaining_guesses >= 0 and self.word == res:\n            self.status = STATUS_WIN\n        return self.status"}
{"nl": "In this program, we will create a doubly linked list and delete a node from the end of the list. If the list is empty, print the message \"List is empty\". If the list is not empty, the tail's previous node will become the new tail of the list thus, deleting the last node from the list.", "code": "#Represent a node of doubly linked list    \nclass Node:    \n    def __init__(self,data):    \n        self.data = data;    \n        self.previous = None;    \n        self.next = None;    \n            \nclass DeleteEnd:    \n    #Represent the head and tail of the doubly linked list    \n    def __init__(self):    \n        self.head = None;    \n        self.tail = None;    \n            \n    #addNode() will add a node to the list    \n    def addNode(self, data):    \n        #Create a new node    \n        newNode = Node(data);    \n            \n        #If list is empty    \n        if(self.head == None):    \n            #Both head and tail will point to newNode    \n            self.head = self.tail = newNode;    \n            #head's previous will point to None    \n            self.head.previous = None;    \n            #tail's next will point to None, as it is the last node of the list    \n            self.tail.next = None;    \n        else:    \n            #newNode will be added after tail such that tail's next will point to newNode    \n            self.tail.next = newNode;    \n            #newNode's previous will point to tail    \n            newNode.previous = self.tail;    \n            #newNode will become new tail    \n            self.tail = newNode;    \n            #As it is last node, tail's next will point to None    \n            self.tail.next = None;    \n                \n    #deleteFromEnd() will delete a node from the end of the list    \n    def deleteFromEnd(self):    \n        #Checks whether list is empty    \n        if(self.head == None):    \n            return;    \n        else:    \n            #Checks whether the list contains only one node    \n            if(self.head != self.tail):    \n                #Previous node to the tail will become new tail    \n                self.tail = self.tail.previous;    \n                #Node next to current tail will be made None    \n                self.tail.next = None;    \n                    \n            #If the list contains only one element     \n            #Then it will remove the node, and now both head and tail will point to None    \n    \n            else:    \n                self.head = self.tail = None;    \n                    \n    #display() will print out the nodes of the list    \n    def display(self):    \n        #Node current will point to head    \n        current = self.head;    \n        if(self.head == None):    \n            print(\"List is empty\");    \n            return;    \n        while(current != None):    \n            #Prints each node by incrementing pointer.    \n            print(current.data),    \n            current = current.next;    \n        print();    \n           \ndList = DeleteEnd();    \n#Add nodes to the list    \ndList.addNode(1);    \ndList.addNode(2);    \ndList.addNode(3);    \ndList.addNode(4);    \ndList.addNode(5);    \n     \n#Printing original list    \nprint(\"Original List: \");    \ndList.display();    \nwhile(dList.head != None):    \n    dList.deleteFromEnd();    \n    #Printing updated list    \n    print(\"Updated List: \");    \n    dList.display();    "}
{"nl": "Given a directed graph, find out if a vertex v is reachable from another vertex u for all vertex pairs (u, v) in the given graph. Here reachable means that there is a path from vertex u to v. The reach-ability matrix is called transitive closure of a graph.", "code": "\r\n# Python program to print transitive\r\n# closure of a graph.\r\nfrom collections import defaultdict\r\n  \r\nclass Graph:\r\n  \r\n    def __init__(self,vertices):\r\n        # No. of vertices\r\n        self.V = vertices\r\n  \r\n        # default dictionary to store graph\r\n        self.graph = defaultdict(list)\r\n  \r\n        # To store transitive closure\r\n        self.tc = [[0 for j in range(self.V)] for i in range(self.V)]\r\n  \r\n    # function to add an edge to graph\r\n    def addEdge(self, u, v):\r\n        self.graph[u].append(v)\r\n  \r\n    # A recursive DFS traversal function that finds\r\n    # all reachable vertices for s\r\n    def DFSUtil(self, s, v):\r\n  \r\n        # Mark reachability from s to v as true.\r\n        if(s == v):\r\n            if( v in self.graph[s]):\r\n              self.tc[s][v] = 1\r\n        else:\r\n            self.tc[s][v] = 1\r\n  \r\n        # Find all the vertices reachable through v\r\n        for i in self.graph[v]:\r\n            if self.tc[s][i] == 0:\r\n                if s==i:\r\n                   self.tc[s][i]=1\r\n                else:\r\n                   self.DFSUtil(s, i)\r\n  \r\n    # The function to find transitive closure. It uses\r\n    # recursive DFSUtil()\r\n    def transitiveClosure(self):\r\n  \r\n        # Call the recursive helper function to print DFS\r\n        # traversal starting from all vertices one by one\r\n        for i in range(self.V):\r\n            self.DFSUtil(i, i)\r\n         \r\n        print(self.tc)\r\n  \r\n# Create a graph given in the above diagram\r\ng = Graph(4)\r\ng.addEdge(0, 1)\r\ng.addEdge(0, 2)\r\ng.addEdge(1, 2)\r\ng.addEdge(2, 0)\r\ng.addEdge(2, 3)\r\ng.addEdge(3, 3)\r\n  \r\ng.transitiveClosure()"}
{"nl": "Create a function which takes a number and returns the maximum value by rearranging its digits.\nExamples\nrotate_max_number(123) \u279e 321\n\nrotate_max_number(\"001\") \u279e 100\n\nrotate_max_number(999) \u279e 999\nNotes\nThe input number can be a digit or a string.", "code": "def rotate_max_number(num):\n  return int(''.join(sorted(str(num), reverse=True)))"}
{"nl": "Write a Python program to print 8 star pattern using for loop", "code": "rows = int(input(\"Enter 8 Star Pattern Rows = \"))\n\nprint(\"====The 8 Star Pattern====\")\n\nfor i in range(1, rows * 2):\n    if i == 1 or i == rows or i == rows * 2 - 1:\n        for j in range(1, rows + 1):\n            if j == 1 or j == rows:\n                print(end = ' ')\n            else:\n                print('*', end = '')\n    else:\n        for k in range(1, rows + 1):\n            if k == 1 or k == rows:\n                print('*', end = '')\n            else:\n                print(end = ' ')\n    print()"}
{"nl": "Write a function that returns True if you can use the letters of the first string to create the second string. Letters are case sensitive.\nExamples\ncan_build(\"aPPleAL\", \"PAL\") \u279e True\n\ncan_build(\"aPPleAL\", \"apple\") \u279e False\n\ncan_build(\"a\", \"\") \u279e True\n\ncan_build(\"aa\", \"aaa\") \u279e False\nNotes\nLetters in the first string can be used only once.", "code": "def can_build(s1, s2):\n  return all(s2.count(i)<=s1.count(i) for i in s2)"}
{"nl": "In the previous article, we have discussed Python Program to Find Sum of Geometric Progression Series\n Definition of Lucas sequence:\n We\u2019ve all heard of the Fibonacci sequence. It is a sequence in which each term is the sum of the two preceding terms. The Lucas sequence is the same as the previous one, but with different starting values. A Fibonacci sequence starts with 0 and 1, whereas a Lucas sequence starts with 2 and 1. The other terms in the Lucas sequence are 3, 4, 7, 11, and so on.\n Given a number \u2018n\u2019 and the task is to print the given nth iteration of Lucas Sequence.\n Examples:\n Example1:\n Input:\n n = 6\n Output:\n The above Given nth iteration of Lucas Sequence = 18\n Example 2:\n Input:\n n = 10\n Output:\n The above Given nth iteration of Lucas Sequence = 123", "code": "# Give the First term =2 (since the first term in Lucas Sequence is 2 which is a constant)\n \n # as static input and store it in a variable.\n \n fst_trm = 2\n \n # Give the Second term =1 (since the second term in Lucas Sequence is 1 which is a constant)\n \n # as static input and store it in another variable.\n \n secnd_trm = 1\n \n # Give the number as static input and store it in another variable.\n \n gvn_n_vlue = 6\n \n # Loop from '1' to the above given n+1 value (since doesn't include last term) range\n \n # using For loop.\n \n for i in range(1, gvn_n_vlue+1):\n \n  # Inside the loop , get the third term which is the sum of first and the second term\n \n  # and store it in a variable.\n \n  third_trm = fst_trm+secnd_trm\n \n  # Assign the value of second term to the first term.\n \n  fst_trm = secnd_trm\n \n  # Assign the value of the third term to the second term and come out of For Loop.\n \n  secnd_trm = third_trm\n \n # Print the Value of above given nth iteration of Lucas Sequence(i.e. first term).\n \n print(\"The above Given nth iteration of Lucas Sequence = \", fst_trm)\n \n </pre>"}
{"nl": "October 22nd is CAPS LOCK DAY. Apart from that day, every sentence should be lowercase, so write a function to normalize a sentence.\r\n\r\nCreate a function that takes a string. If the string is all uppercase characters, convert it to lowercase and add an exclamation mark at the end.", "code": "def normalize(txt):\r\n\t\treturn txt.capitalize() + ('!' if txt.isupper() else '')"}
{"nl": "Polynomial Regression is a form of linear regression in which the relationship between the independent variable x and dependent variable y is modeled as an nth degree polynomial. Polynomial regression fits a nonlinear relationship between the value of x and the corresponding conditional mean of y, denoted E(y |x)\nWhy Polynomial Regression: \n \n\nThere are some relationships that a researcher will hypothesize is curvilinear. Clearly, such types of cases will include a polynomial term.\nInspection of residuals. If we try to fit a linear model to curved data, a scatter plot of residuals (Y-axis) on the predictor (X-axis) will have patches of many positive residuals in the middle. Hence in such a situation, it is not appropriate.\nAn assumption in usual multiple linear regression analysis is that all the independent variables are independent. In polynomial regression model, this assumption is not satisfied.\nUses of Polynomial Regression: \nThese are basically used to define or describe non-linear phenomena such as: \n \n\nThe growth rate of tissues.\nProgression of disease epidemics\nDistribution of carbon isotopes in lake sediments\nThe basic goal of regression analysis is to model the expected value of a dependent variable y in terms of the value of an independent variable x. In simple regression, we used the following equation \u2013 \n \n\ny = a + bx + e\nHere y is a dependent variable, a is the y-intercept, b is the slope and e is the error rate.\nIn many cases, this linear model will not work out For example if we analyzing the production of chemical synthesis in terms of temperature at which the synthesis take place in such cases we use a quadratic model \n \n\ny = a + b1x + b2^2 + e\nHere y is the dependent variable on x, a is the y-intercept and e is the error rate.\nIn general, we can model it for nth value. \n \n\ny = a + b1x + b2x^2 +....+ bnx^n\nSince regression function is linear in terms of unknown variables, hence these models are linear from the point of estimation.\nHence through the Least Square technique, let\u2019s compute the response value that is y.\nPolynomial Regression in Python: \nTo get the Dataset used for the analysis of Polynomial Regression, click here.\nStep 1: Import libraries and dataset \nImport the important libraries and the dataset we are using to perform Polynomial Regression. ", "code": "# Importing the libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Importing the dataset\ndatas = pd.read_csv('data.csv')\nX = datas.iloc[:, 1:2].values\ny = datas.iloc[:, 2].values\n# Fitting Linear Regression to the dataset\nfrom sklearn.linear_model import LinearRegression\nlin = LinearRegression()\n\nlin.fit(X, y)\n# Fitting Polynomial Regression to the dataset\nfrom sklearn.preprocessing import PolynomialFeatures\n\npoly = PolynomialFeatures(degree = 4)\nX_poly = poly.fit_transform(X)\n\npoly.fit(X_poly, y)\nlin2 = LinearRegression()\nlin2.fit(X_poly, y)\n# Visualising the Linear Regression results\nplt.scatter(X, y, color = 'blue')\n\nplt.plot(X, lin.predict(X), color = 'red')\nplt.title('Linear Regression')\nplt.xlabel('Temperature')\nplt.ylabel('Pressure')\n\nplt.show()\n# Visualising the Polynomial Regression results\nplt.scatter(X, y, color = 'blue')\n\nplt.plot(X, lin2.predict(poly.fit_transform(X)), color = 'red')\nplt.title('Polynomial Regression')\nplt.xlabel('Temperature')\nplt.ylabel('Pressure')\n\nplt.show()\n# Predicting a new result with Linear Regression after converting predict variable to 2D array\npred = 110.0\npredarray = np.array([[pred]])\nlin.predict(predarray)\n# Predicting a new result with Polynomial Regression after converting predict variable to 2D array\npred2 = 110.0\npred2array = np.array([[pred2]])\nlin2.predict(poly.fit_transform(pred2array))\n\n"}
{"nl": "Although any implementation of the Asynchronous Advantage Actor Critic algorithm is bound to be complex, all the implementations will have the one thing in common \u2013 the presence of the Global Network and the worker class.\r\n\r\nGlobal Network class: This contains all the required Tensorflow operations to autonomously create the neural networks.\r\nWorker class: This class is used to simulate the learning process of a worker who has its own copy of the environment and a \u201cpersonal\u201d neural network.\r\nFor the following implementation, the following modules will be required:-\r\n\r\nNumpy\r\nTensorflow\r\nMultiprocessing", "code": "\n# Initializing the class\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n   \n            # Input and visually encoding the layers\n            self.inputs = tf.placeholder(shape =[None, s_size], \n                                         dtype = tf.float32)\n            self.imageIn = tf.reshape(self.inputs, shape =[-1, 84, 84, 1])\n            self.conv1 = slim.conv2d(activation_fn = tf.nn.elu,\n                                    inputs = self.imageIn, num_outputs = 16,\n                                    kernel_size =[8, 8],\n                                    stride =[4, 4], padding ='VALID')\n            self.conv2 = slim.conv2d(activation_fn = tf.nn.elu,\n                                    inputs = self.conv1, num_outputs = 32,\n                                    kernel_size =[4, 4],\n                                    stride =[2, 2], padding ='VALID')\n            hidden = slim.fully_connected(slim.flatten(self.conv2),\n                                          256, activation_fn = tf.nn.elu)\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n  \n            # Building the Recurrent network for temporal dependencies\n            lstm_cell = tf.nn.rnn_cell.BasicLSTMCell(256, state_is_tuple = True)\n            c_init = np.zeros((1, lstm_cell.state_size.c), np.float32)\n            h_init = np.zeros((1, lstm_cell.state_size.h), np.float32)\n            self.state_init = [c_init, h_init]\n            c_Init = tf.placeholder(tf.float32, [1, lstm_cell.state_size.c])\n            h_Init = tf.placeholder(tf.float32, [1, lstm_cell.state_size.h])\n            self.state_Init = (c_Init, h_Init)\n            rnn_init = tf.expand_dims(hidden, [0])\n            step_size = tf.shape(self.imageIn)[:1]\n            state_Init = tf.nn.rnn_cell.LSTMStateTuple(c_Init, h_Init)\n            lstm_outputs, lstm_state = tf.nn.dynamic_rnn(lstm_cell, rnn_init,\n                                                    initial_state = state_Init,\n                                                    sequence_length = step_size,\n                                                    time_major = False)\n            lstm_c, lstm_h = lstm_state\n            self.state_out = (lstm_c[:1, :], lstm_h[:1, :])\n            rnn_out = tf.reshape(lstm_outputs, [-1, 256])\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n  \n           # Building the output layers for value and policy estimations\n            self.policy = slim.fully_connected(rnn_out, a_size,\n                                               activation_fn = tf.nn.softmax,\n                   weights_initializer = normalized_columns_initializer(0.01),\n                                               biases_initializer = None)\n            self.value = slim.fully_connected(rnn_out, 1,\n                activation_fn = None,\n                weights_initializer = normalized_columns_initializer(1.0),\n                biases_initializer = None)\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n           with tf.device(\"/cpu:0\"): \n  \n              # Generating the global network\n               master_network = AC_Network(s_size, a_size, 'global', None)\n                 \n               # Keeping the number of workers\n               # as the number of available CPU threads\n               num_workers = multiprocessing.cpu_count()\n  \n               # Creating and deploying the workers\n               workers = []\n               for i in range(num_workers):\n                   workers.append(Worker(DoomGame(), i, s_size, a_size,\n                                 trainer, saver, model_path))\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n  \n           with tf.Session() as sess:\n               coord = tf.train.Coordinator()\n               if load_model == True:\n                   ckpt = tf.train.get_checkpoint_state(model_path)\n                   saver.restore(sess, ckpt.model_checkpoint_path)\n               else:\n                   sess.run(tf.global_variables_initializer())\n          \n               worker_threads = []\n               for worker in workers:\n                   worker_work = lambda: worker.work(max_episode_length,\n                                         gamma, master_network, sess, coord)\n                   t = threading.Thread(target =(worker_work))\n                   t.start()\n                   worker_threads.append(t)\n               coord.join(worker_threads)\r\ndef __init__(self, s_size, a_size, scope, trainer):\r\n        with tf.variable_scope(scope):\r\n           . . . . . . . . . . \r\n           . . . . . . . . . .\r\n           . . . . . . . . . .\r\n  \r\n           if scope != 'global':\r\n               self.actions = tf.placeholder(shape =[None], dtype = tf.int32)\r\n               self.actions_onehot = tf.one_hot(self.actions,\r\n                                                a_size, dtype = tf.float32)\r\n               self.target_v = tf.placeholder(shape =[None], dtype = tf.float32)\r\n               self.advantages = tf.placeholder(shape =[None], dtype = tf.float32)\r\n  \r\n               self.responsible_outputs = tf.reduce_sum(self.policy * \r\n                                                        self.actions_onehot, [1])\r\n  \r\n                # Computing the error\r\n                self.value_loss = 0.5 * tf.reduce_sum(tf.square(self.target_v -\r\n                                                    tf.reshape(self.value, [-1])))\r\n                self.entropy = - tf.reduce_sum(self.policy * tf.log(self.policy))\r\n                self.policy_loss = -tf.reduce_sum(tf.log(self.responsible_outputs)\r\n                                                         *self.advantages)\r\n                self.loss = 0.5 * self.value_loss + \r\n                self.policy_loss-self.entropy * 0.01\r\n  \r\n                # Get gradients from the local network\r\n                local_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES,\r\n                                               scope)\r\n                self.gradients = tf.gradients(self.loss, local_vars)\r\n                self.var_norms = tf.global_norm(local_vars)\r\n                grads, self.grad_norms = tf.clip_by_global_norm(self.gradients,\r\n                                                               40.0)\r\n  \r\n                # Apply the local gradients to the global network\r\n                global_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES,\r\n                                               'global')\r\n                self.apply_grads = trainer.apply_gradients(\r\n                        zip(grads, global_vars))\r\ndef update_target_graph(from_scope, to_scope):\r\n    from_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, from_scope)\r\n    to_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, to_scope)\r\n  \r\n    op_holder = []\r\n    for from_var, to_var in zip(from_vars, to_vars):\r\n        op_holder.append(to_var.assign(from_var))\r\n    return op_holder"}
{"nl": "Given a n x n matrix. The problem is to sort the given matrix in strict order. Here strict order means that matrix is sorted in a way such that all elements in a row are sorted in increasing order and for row \u2018i\u2019, where 1 <= i <= n-1, first element of row \u2018i\u2019 is greater than or equal to the last element of row \u2018i-1\u2019.", "code": "# Python3 implementation to sort\r\n# the given matrix\r\n\r\nSIZE = 10\r\n\r\n# Function to sort the given matrix\r\ndef sortMat(mat, n) :\r\n        \r\n        # Temporary matrix of size n^2\r\n        temp = [0] * (n * n)\r\n        k = 0\r\n\r\n        # Copy the elements of matrix\r\n        # one by one into temp[]\r\n        for i in range(0, n) :\r\n                \r\n                for j in range(0, n) :\r\n                        \r\n                        temp[k] = mat[i][j]\r\n                        k += 1\r\n\r\n        # sort temp[]\r\n        temp.sort()\r\n        \r\n        # copy the elements of temp[]\r\n        # one by one in mat[][]\r\n        k = 0\r\n        \r\n        for i in range(0, n) :\r\n                \r\n                for j in range(0, n) :\r\n                        mat[i][j] = temp[k]\r\n                        k += 1\r\n\r\n\r\n# Function to print the given matrix\r\ndef printMat(mat, n) :\r\n        \r\n        for i in range(0, n) :\r\n                \r\n                for j in range( 0, n ) :\r\n                        \r\n                        print(mat[i][j] , end = \" \")\r\n                        \r\n                print()\r\n        \r\n        \r\n# Driver program to test above\r\nmat = [ [ 5, 4, 7 ],\r\n                [ 1, 3, 8 ],\r\n                [ 2, 9, 6 ] ]\r\nn = 3\r\n\r\nprint( \"Original Matrix:\")\r\nprintMat(mat, n)\r\n\r\nsortMat(mat, n)\r\n\r\nprint(\"\\nMatrix After Sorting:\")\r\nprintMat(mat, n)\r\n\r\n\r\n# This code is contributed by Nikita Tiwari.\r"}
{"nl": "Creating a strong password is essential in everyone\u2019s life nowadays in order to keep your accounts safe and secure. Passwords that are simple and easy to guess can be readily hacked. To avoid this problem, we\u2019ll show you how to create your own safe and secure password using simple Python code.", "code": "# Take a variable(say secpassword) and create some random characters as tuple\r\n# (('s', '$'), ('and', '&'), ('a', '@'), ('o', '0'), ('i', '1'), ('I', '|')).\r\nsecpassword = (('s', '$'), ('and', '&'),\r\n               ('a', '@'), ('o', '0'), ('i', '1'),\r\n               ('I', '|'))\r\n# Create a function createSecurePassword() which accepts the given password\r\n# as an argument and returns the secure password.\r\n\r\n\r\ndef createSecurePassword(givenpassword):\r\n    # Loop using two variables in the secpassword using For loop.\r\n    for m, n in secpassword:\r\n      # Replace the password with the two variables.\r\n        givenpassword = givenpassword.replace(m, n)\r\n    # Return the modified Password.\r\n    return givenpassword\r\n\r\n\r\n# Give the password as static input and store it in a variable.\r\ngivenpassword = 'Italian'\r\nprint('The original Password = ', givenpassword)\r\n# Pass the given password as an argument to createSecurePassword() function.\r\nmodifiedpassword = createSecurePassword(givenpassword)\r\n# Print the New Modified Password.\r\n\r\nprint('The new modified password = ', modifiedpassword)"}
{"nl": "Given a two-dimensional list of maze and a list of directions. Your task is to follow the given directions.\nIf you can reach the endpoint before all your moves have gone, return \"Finish\".\nIf you hit any walls or go outside the maze border, return \"Dead\".\nIf you find yourself still in the maze after using all the moves, return \"Lost\".\nThe maze list will look like this:\nmaze = [\n  [1, 1, 1, 1, 1, 1, 1, 1, 0, 1],\n  [1, 3, 1, 0, 1, 0, 0, 0, 0, 1],\n  [1, 0, 1, 0, 0, 0, 1, 1, 0, 1],\n  [1, 0, 1, 1, 1, 1, 1, 0, 0, 1],\n  [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n  [1, 0, 1, 0, 1, 0, 1, 0, 0, 1],\n  [1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n  [1, 0, 1, 0, 1, 0, 1, 1, 0, 1],\n  [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n  [1, 1, 1, 0, 1, 1, 1, 1, 2, 1]\n]\n\n# 0 = Safe place to walk\n# 1 = Wall\n# 2 = Start Point\n# 3 = Finish Point\n# N = North, E = East, W = West and S = South\nSee the below examples for a better understanding:\nExamples\nexit_maze(maze, [\"N\", \"E\", \"E\"]) \u279e \"Dead\"\n# Hitting the wall should return \"Dead\".\n\nexit_maze(maze, [\"N\", \"N\", \"N\", \"E\"]) \u279e \"Lost\"\n# Couldn't reach the finish point.\n\nexit_maze(maze, [\"N\", \"W\", \"W\", \"W\", \"N\", \"N\", \"N\", \"N\", \"W\", \"W\", \"S\", \"S\", \"S\", \"S\", \"W\", \"W\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\"]) \u279e \"Finish\"\nNotes\nN/A", "code": "def exit_maze(maze, directions):\n  i = 9\n  j = 8\n  for direction in directions:\n    if direction == \"N\":\n      i -= 1\n    elif direction == \"S\":\n      i += 1\n    elif direction == \"E\":\n      j += 1\n    else:\n      j -= 1\n    if i < 0 or i > 9 or j < 0 or j > 9:\n      return \"Dead\"\n    elif maze[i][j] == 1:\n      return \"Dead\"\n    elif maze[i][j] == 3:\n      return \"Finish\"\n  return \"Lost\""}
{"nl": "Given a list of numbers , the task is to calculate the standard deviation of the given list in python.", "code": "# importing statistics\nimport statistics\n# given list\ngiven_list = [34, 14, 7, 13, 26, 22, 12, 19,\n              29, 33, 31, 30, 20, 10, 9, 27, 31, 24]\n# using stdev() fun to calculate standard devaition\nstandarddevList = statistics.stdev(given_list)\n# print the given list and standard deviation\nprint(\"The given list of numbers : \")\nfor i in given_list:\n    print(i, end=\" \")\n# printing new empty line\nprint()\n# printing the standard deviation of the given list of numbers\nprint(\"Standard deviation of the given list =\", standarddevList)"}
{"nl": "The Latin Alphabet Cipher Encryption Technique is one of the quickest and most straightforward methods of encoding data. It\u2019s essentially a replacement cipher method, in which each letter of a given input is replaced by its matching number as represented alphabetically.", "code": "# Give the string as user input(which consists of only alphabets and spaces)\n# using input() and store it in a variable.\ngivenstring = input('Enter some random string = ')\nprint('The encrypted message of the given string{', givenstring, '}is :')\n# Iterate through the characters of the string using For loop.\n# We can calculate the ASCII value of the character using the ord() function.\nfor m in givenstring:\n    # Now, transform each input string character to its ASCII value\n    # and subtract it from the ASCII\n    # value of alphabet A for uppercase characters and 'a' for lowercase ones.\n    if (m >= \"A\" and m <= \"Z\"):\n      # The operation is written as ord(givenstring[i])-ord(\u201cA\u201d)+1 for uppercase letters.\n        print(ord(m)-ord(\"A\")+1, end=\" \")\n    elif (m >= \"a\" and m <= 'z'):\n        # ord(givenstring[i])-ord(\u201ca\u201d)+1 for lowercase letters.\n        print(ord(m)-ord(\"a\")+1, end=\" \")\n    # If the character is space then print it(That is printing\n    # space character without endl which makes it to print in next line)\n    if m == (\" \"):\n        print(m)"}
{"nl": "The else keyword is used in conditional statements (if statements), and decides what to do if the condition is False.\r\n\r\nThe else keyword can also be use in try...except blocks, see example below.", "code": "x = 2\r\nif x > 3:\r\n  print(\"YES\")\r\nelse:\r\n  print(\"NO\")\r\n"}
{"nl": "In this challenge, you have to establish if a number is apocalyptic. A positive integer n greater than 0 is apocalyptic when 2 elevated to n contains one or more occurrences of 666 inside it.\nGiven an integer n, implement a function that returns:\n\"Safe\" if n is not apocalyptic.\n\"Single\" if inside 2^n there's a single occurrence of 666.\n\"Double\" if inside 2^n there are two occurrences of 666.\n\"Triple\" if inside 2^n there are three occurrences of 666.\nExamples\nis_apocalyptic(66) \u279e \"Safe\"\n# 2^66 = 73786976294838206464\n\nis_apocalyptic(157) \u279e \"Single\"\n# 2^157 =\n# 182687704|666|362864775460604089535377456991567872\n\nis_apocalyptic(220) \u279e \"Double\"\n# 2^220 =\n# 168499|666|66969149871|666|8844293872691710232152640 ...\n\nis_apocalyptic(931) \u279e \"Triple\"\n# 2^931 =\n# 181520618710|666|8777829|666|135436890332191479738353753001777065257954029122510259245050254290156440857653562895251700406555730694879815558725330603736697259064676478076718090|666| ...\nNotes\nAny given n will be a positive integer in the range of 1 to 1000.\nOccurrences have to be unique. You can't use digits that have already been matched again (see example #3, there are five adjacent 6s, but only one possible match).", "code": "def is_apocalyptic(number):\n  return ['Safe','Single','Double','Triple'][str(2**number).count('666')]"}
{"nl": "Given a Binary Tree, convert it into Doubly Linked List where the nodes are represented Spirally. The left pointer of the binary tree node should act as a previous node for created DLL and right pointer should act as next node. \nThe solution should not allocate extra memory for DLL nodes. It should use binary tree nodes for creating DLL i.e. only change of pointers is allowed ", "code": "# Python3 program to convert Binary Tree\n# into Doubly Linked List where the nodes\n# are represented spirally.\n\t\n# Binary tree node\nclass newNode:\n\n\t# Constructor to create a newNode\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\t\t\n\"\"\" Given a reference to the head of a list\n\tand a node, inserts the node on the front\n\tof the list. \"\"\"\ndef push(head_ref, node):\n\n\t# Make right of given node as\n\t# head and left as None\n\tnode.right = (head_ref)\n\tnode.left = None\n\n\t# change left of head node to\n\t# given node\n\tif ((head_ref) != None):\n\t\t(head_ref).left = node\n\n\t# move the head to point to\n\t# the given node\n\t(head_ref) = node\n\n# Function to prints contents of DLL\ndef printList(node):\n\ti = 0\n\twhile (i < len(node)):\n\t\n\t\tprint(node[i].data, end = \" \")\n\t\ti += 1\n\t\n\"\"\" Function to print corner node at each level \"\"\"\ndef spiralLevelOrder(root):\n\n\t# Base Case\n\tif (root == None):\n\t\treturn\n\n\t# Create an empty deque for doing spiral\n\t# level order traversal and enqueue root\n\tq = []\n\tq.append(root)\n\n\t# create a stack to store Binary\n\t# Tree nodes to insert into DLL later\n\tstk = []\n\n\tlevel = 0\n\twhile (len(q)):\n\t\n\t\t# nodeCount indicates number of\n\t\t# Nodes at current level.\n\t\tnodeCount = len(q)\n\t\t\n\t\t# Dequeue all Nodes of current level\n\t\t# and Enqueue all Nodes of next level\n\t\tif (level&1): # odd level\n\t\t\twhile (nodeCount > 0):\n\t\t\t\n\t\t\t\t# dequeue node from front &\n\t\t\t\t# push it to stack\n\t\t\t\tnode = q[0]\n\t\t\t\tq.pop(0)\n\t\t\t\tstk.append(node)\n\n\t\t\t\t# insert its left and right children\n\t\t\t\t# in the back of the deque\n\t\t\t\tif (node.left != None):\n\t\t\t\t\tq.append(node.left)\n\t\t\t\tif (node.right != None):\n\t\t\t\t\tq.append(node.right)\n\n\t\t\t\tnodeCount -= 1\n\t\t\t\n\t\telse:\t # even level\n\t\t\n\t\t\twhile (nodeCount > 0):\n\t\t\t\n\t\t\t\t# dequeue node from the back &\n\t\t\t\t# push it to stack\n\t\t\t\tnode = q[-1]\n\t\t\t\tq.pop(-1)\n\t\t\t\tstk.append(node)\n\n\t\t\t\t# inserts its right and left\n\t\t\t\t# children in the front of\n\t\t\t\t# the deque\n\t\t\t\tif (node.right != None):\n\t\t\t\t\tq.insert(0, node.right)\n\t\t\t\tif (node.left != None):\n\t\t\t\t\tq.insert(0, node.left)\n\t\t\t\tnodeCount -= 1\n\t\tlevel += 1\n\t\t\n\t# head pointer for DLL\n\thead = []\n\t\n\t# pop all nodes from stack and push\n\t# them in the beginning of the list\n\twhile (len(stk)):\n\t\n\t\thead.append(stk[0])\n\t\tstk.pop(0)\n\n\tprint(\"Created DLL is:\")\n\tprintList(head)\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t\"\"\"Let us create Binary Tree as\n\tshown in above example \"\"\"\n\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(6)\n\troot.right.right = newNode(7)\n\n\troot.left.left.left = newNode(8)\n\troot.left.left.right = newNode(9)\n\troot.left.right.left = newNode(10)\n\troot.left.right.right = newNode(11)\n\t#root.right.left.left = newNode(12)\n\troot.right.left.right = newNode(13)\n\troot.right.right.left = newNode(14)\n\t#root.right.right.right = newNode(15)\n\n\tspiralLevelOrder(root)\n\n# This code is contributed\n# by SHUBHAMSINGH10\n"}
{"nl": "You are given a 0-indexed string expression of the form \"<num1>+<num2>\" where <num1> and <num2> represent positive integers.\n\nAdd a pair of parentheses to expression such that after the addition of parentheses, expression is a valid mathematical expression and evaluates to the smallest possible value. The left parenthesis must be added to the left of '+' and the right parenthesis must be added to the right of '+'.\n\nReturn expression after adding a pair of parentheses such that expression evaluates to the smallest possible value. If there are multiple answers that yield the same result, return any of them.\n\nThe input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.", "code": "class Solution:\n    def minimizeResult(self, E: str) -> str:\n        idx=E.index('+') ; L=E[:idx] ; R=E[idx+1:] ; ans=[]\n        for i in range(len(L)):\n            for j in range(1,len(R)+1):\n                sm=(int(L[:i]) if L[:i] else 1)*((int(L[i:]) if L[i:] else 0)+(int(R[:j]) if R[:j] else 0))*(int(R[j:]) if R[j:] else 1)\n                exp=L[:i]+'('+L[i:]+'+'+R[:j]+')'+R[j:]\n                ans.append([sm, exp])\n        return sorted(ans, key=lambda x:x[0])[0][1]"}
{"nl": "Sort words in Alphabetic Order Using sort() Method (User Input)", "code": "# Give the string as user input using input() function and store it in a variable.\r\ngven_str = input(\"Enter some random string = \")\r\n# Split the given string into list of words using the split() function and store\r\n# it in another variable say \"wrd_lst\".\r\nwrd_lst = gven_str.split()\r\n# Sort the above obtained word list using the sort() method.\r\nwrd_lst.sort()\r\n# Loop in the above list \"wrd_lst\" using the for loop.\r\nprint(\"The all sorted words of given sentence in Alphabetic order :\")\r\nfor wrd in wrd_lst:\r\n  # Print the iterator value to sort all words in a given sentence in alphabetic order.\r\n    print(wrd)"}
{"nl": "Files in Python:\n\nOne of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.\n\nAlso, if you didn\u2019t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.\n\n\n\nConsider the following scenario: you\u2019re planning to construct a large Python project with a large number of workflows. Then it\u2019s unavoidable that you don\u2019t make a log file. You\u2019ll also be handling the log file\u2019s read and write activities. Debugging huge applications with log files is a terrific way to go. It\u2019s usually better to consider a scalable design from the start, as you won\u2019t be sorry later if you didn\u2019t.\n\nFile close() Method in Python:\n\nThe close() function is a built-in Python method that is used to flush and close the IO object (file). It has no effect if we close a closed file.\n\nSyntax:\n\nfileobject.close()\nParameters: This method has no arguments\n\nReturn Value: This method doesn\u2019t return anything. This method\u2019s return type is <class \u2018NoneType\u2019>, which means it returns nothing.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\ngvn_file = open(givenFilename, 'w') \n# Print some random text for acknowledgment\nprint(\"your file is opened now!\")\n# Print the given file\nprint(gvn_file)\n# Close the given file using the close() function\ngvn_file.close()\n# Print some random text for acknowledgment\nprint(\"your file is closed now!\")"}
{"nl": "Give the string the task is to print the least frequent character in a string in Python.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven string =zzzyyddddeeeee\nOutput:\n\nThe least frequency character in the given string zzzyyddddeeeee is [ y ]", "code": "# Import the Counter() function from collections using the import keyword.\nfrom collections import Counter\n# Give the string a static input and store it in a variable.\ngvnstrng = 'zzzyyddddeeeee'\n# Calculate the frequency of all the given string elements\n# using the Counter() function which returns the element\n# and its frequency as key-value pair and store this\n# dictionary in a variable(say elementsfrequency)\nelementsfrequency = Counter(gvnstrng)\n# Calculate the minimum frequency character in the given string\n# using the min() and \"get\" function and store it in a variable.\nminfreqchar = str(min(elementsfrequency, key=elementsfrequency.get))\n# Print the least frequency character in the given string\n# by printing the above variable.\nprint('The least frequency character in the given string',\n      gvnstrng, 'is [', minfreqchar, ']')"}
{"nl": "Two matrices must have an equal number of rows and columns to be subtracted. In which case, the subtracted of two matrices A and B will be a matrix which has the same number of rows and columns as A and B.\nThe result of the subtraction of A and B, denoted A - B is computed by subtracting corresponding elements of A and B.\nCreate a function that takes 2 x 2D lists lst1 and lst2 as an argument and returns a 2D list (matrix C). C = A-B.\nExamples\nsubtract_matrix([\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n], [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]) \u279e [\n  [0, 0, 0],\n  [0, 0, 0],\n  [0, 0, 0]\n]\nNotes\nTreat strings of numbers as integers.", "code": "def subtract_matrix(A, B):\n  return [\n    [float(i) - float(j) for i, j in zip(a, b)] \n    for a, b in zip(A, B)\n  ]"}
{"nl": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.\nAnswers within 10-5 of the actual answer will be considered accepted.\n \nExample 1:\n\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\nExplanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.\n\nExample 2:\n\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\n\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\n \nConstraints:\n\n20 <= arr.length <= 1000\narr.length is a multiple of 20.\n0 <= arr[i] <= 105", "code": "def trimMean(self, arr: List[int]) -> float:\n  n = len(arr)\n  return sum(sorted(arr)[n // 20 : -n // 20]) / (n * 9 // 10)"}
{"nl": "You can convert from one type to another with the int(), float(), and complex() methods:", "code": "x = 1 # int\r\ny = 2.8 # float\r\nz = 1j # complex\r\n\r\n#convert from int to float:\r\na = float(x)\r\n\r\n#convert from float to int:\r\nb = int(y)\r\n\r\n#convert from int to complex:\r\nc = complex(x)\r\n\r\nprint(a)\r\nprint(b)\r\nprint(c)\r\n\r\nprint(type(a))\r\nprint(type(b))\r\nprint(type(c))"}
{"nl": "Arithmetic progression:\n\nAn Arithmetic progression is a mathematical sequence of numbers in which the difference between the consecutive terms is constant.\n\n\n\nIn general, an arithmetic sequence looks like this:  a, a+d, a+2d, a+3d,\u2026\u2026\u2026\u2026\u2026.\n\nwhere a = first term\n\nd= common difference\n\nn= number of terms in series\n\nFormula : d= second term \u2013 first term\n\nThe sum of Arithmetic progression Series : Sn = n/2(2a + (n \u2013 1) d)\nThe Tn (nth term) of Arithmetic progression Series : Tn = a + (n \u2013 1) d\n\nGiven a, n, d values and the task is to find the sum of the Arithmetic progression Series.\n\nExamples:\n\nExample 1:\n\nInput:\n\nGiven first term = 3\nGiven total terms = 9\nGiven common difference = 4\nOutput:\n\nGiven Arithmetic Progression Series Sum with [a,n,d]:( 3 9 4 ) = 171.0\nThe Given Arithmetic Progression Series nth Term with [a,n,d]:( 3 9 4 ) = 35\nExample 2:\n\nInput:\n\nGiven first term = 7\nGiven total terms = 15\nGiven common difference = 2\nOutput:\n\nGiven Arithmetic Progression Series Sum with [a,n,d]:( 7 15 2 ) =  315.0\nThe Given Arithmetic Progression Series nth Term with [a,n,d]:( 7 15 2 ) =  35", "code": "# Give the first term of arithmetic progression series as static input\n # and store it in a variable.\n fst_trm = 2\n # Give the total number of terms of the A.P. series as static input and\n # store it in another variable.\n total_terms = 6\n # Give the common difference of the A.P. series as static input and store it\n # in another variable.\n common_diff = 4\n # Calculate the sum of the given arithmetic progression series using the above given\n # mathematical formula(n/2(2a + (n \u2013 1) d)) and store it in a variable.\n sum_ap = (total_terms * (2 * fst_trm + (total_terms - 1) * common_diff)) / 2\n # Calculate the nth term of the given arithmetic progression series using the above\n # given mathematical formula ( Tn = a + (n \u2013 1) d) and store it in another variable.\n nth_trm_ap = fst_trm + (total_terms - 1) * common_diff\n # Print the sum and nth term of the given Arithmetic Progression series.\n print(\"Given Arithmetic Progression Series Sum with [a,n,d]:(\",\n  fst_trm, total_terms, common_diff, \") = \", sum_ap)\n print(\"The Given Arithmetic Progression Series nth Term with [a,n,d]:(\",\n  fst_trm, total_terms, common_diff, \") = \", nth_trm_ap)"}
{"nl": "If today was Monday, in two days, it would be Wednesday.\nCreate a function that takes in a list of days as input and the number of days to increment by. Return a list of days after n number of days has passed.\nExamples\nafter_n_days([\"Thursday\", \"Monday\"], 4) \u279e [\"Monday\", \"Friday\"]\n\nafter_n_days([\"Sunday\", \"Sunday\", \"Sunday\"], 1) \u279e [\"Monday\", \"Monday\", \"Monday\"]\n\nafter_n_days([\"Monday\", \"Tuesday\", \"Friday\"], 1) \u279e [\"Tuesday\", \"Wednesday\", \"Saturday\"]\nNotes\nReturn as a list.\nAll test cases will have the first letter of each day capitalized.\nn number of days may be greater than 7.", "code": "def afterNdays(days, n):\n  weekdays = ['Monday','Tuesday','Wednesday','Thursday','Friday',\n  'Saturday','Sunday']\n  return [weekdays[(weekdays.index(day) + n) % 7] for day in days]"}
{"nl": "You are currently designing a dynamic array. You are given a 0-indexed integer array nums, where nums[i] is the number of elements that will be in the array at time i. In addition, you are given an integer k, the maximum number of times you can resize the array (to any size).\n\nThe size of the array at time t, sizet, must be at least nums[t] because there needs to be enough space in the array to hold all the elements. The space wasted at time t is defined as sizet - nums[t], and the total space wasted is the sum of the space wasted across every time t where 0 <= t < nums.length.\n\nReturn the minimum total space wasted if you can resize the array at most k times.\n\nNote: The array can have any size at the start and does not count towards the number of resizing operations.", "code": "class Solution:\n    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\n        # imagine I know the min space wasted for the first i cases\n        # i+1, either we do a resize at i+1 or we skip it\n        n = len(nums)\n        cumsum = list(accumulate(nums))\n        revsum = list(accumulate(nums[::-1]))[::-1]\n        cummax = [nums[0]]\n        for i in range(1,n):\n            cummax.append(max(cummax[-1], nums[i]))\n        revmax = [nums[-1]]\n        for i in range(n-2, -1, -1):\n            revmax.append(max(revmax[-1], nums[i]))\n        revmax = revmax[::-1]\n        revmax = revmax+[0]\n        revsum = revsum+[0]\n        max_arr = [[0]*n for _ in range(n)]\n        for i in range(n):\n            curmax = nums[i]\n            for j in range(i, n):\n                curmax = max(curmax, nums[j])\n                max_arr[i][j] = curmax\n                    \n        @lru_cache(None)\n        def dp(i,p):\n            if(p == 0): # if there are no more resizes available,\n                return cummax[i]*(i+1)-cumsum[i] #correct\n            if(i==0): # at index 0 no matter what p, we can finish up to i\n                return 0\n            ansr = float('Inf')\n            for j in range(i): \n                cusum = revsum[j+1]-revsum[i+1]\n                revmax_c= max_arr[j+1][i]#max(nums[j+1:i+1])\n                ansr = min(ansr, dp(j, p-1) + (revmax_c*(i-j)-cusum))  \n            return ansr\n        \n        return dp(n-1, k)\n            "}
{"nl": "Print Numbers, that contain 1, 2 and 3, in Ascending Order (Static Input)", "code": "# Give the list as static input and store it in a variable.\r\ngven_lst = [67123, 1234, 985, 126, 1011]\r\n# Take a new empty list say \"numb\" and store it in another variable.\r\nnumb = []\r\n# Loop in the given list using the for loop.\r\nfor itr in gven_lst:\r\n # Inside the loop, convert the iterator value to the string using the str() function\r\n    # and store it in another variable.\r\n    strng_number = str(itr)\r\n# Check if 1 and 2 and 3 are present in the string number using the if conditional\r\n# statement and 'and' keyword.\r\n    if '1' in strng_number and '2' in strng_number and '3' in strng_number:\r\n        # If the statement is true, then append the iterator value to the above initialized\r\n        # new empty list \"numb\".\r\n        numb.append(itr)\r\n # Sort the above list \"numb\" using the sort() function.\r\nnumb.sort()\r\n# print the list \"numb\" to print the numbers with the digits 1, 2, and 3 in ascending order,\r\n# which is separated by commas.\r\nprint(\"The numbers with the digits 1, 2, and 3 in ascending order, which is separated by commas= \", numb)"}
{"nl": "Armstrong Number Program in Python | In this post, we will discuss how to check Armstrong numbers in python with the explanation. Armstrong number is a number that when raised to the power of a number of its own digits is equal to the sum of that number.", "code": "# Python program to check armstrong number def digits_count(n): i = 0 while n > 0: n //= 10 i += 1 return i def sum(n): i = digits_count(n) s = 0 while n > 0: digit = n%10 n //= 10 s += pow(digit,i) return s # take inputs num = int(input(\"Enter number: \")) # calling function s = sum(num) # check armstrong number or not if s == num: print(\"The number is an Armstrong number.\") else: print(\"The number is not an Armstrong number.\")"}
{"nl": "Perform XOR on Two Lists (User Input)", "code": "# Give the first list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\nlstt1 = list(map(int, input(\r\n    'Enter some random List Elements separated by spaces = ').split()))\r\n# Give the second list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\nlstt2 = list(map(int, input(\r\n    'Enter some random List Elements separated by spaces = ').split()))\r\nprint('The given First list elements are =', lstt1)\r\nprint('The given Second list elements are =', lstt2)\r\n# Calculate the length of the first list using the len()\r\n# function(as both lists have same length) and store it in a variable.\r\nlenlst = len(lstt1)\r\n# Loop till the above length using the For loop.\r\nfor p in range(lenlst):\r\n    # Inside the for loop initialize the list 1 element as xor operation\r\n    # between list1 and list2 using xor operator i.e lst1[p]=lst1[p]^lst2[p]\r\n    # where p is the iterator value of the For loop.\r\n    lstt1[p] = lstt1[p] ^ lstt2[p]\r\n# Print the list1 which is the result.\r\nprint('The result after applying xor operation on both lists is', lstt1)"}
{"nl": "The math.asinh() method returns the inverse hyperbolic sine of a number.\r\n\r\n", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the inverse hyperbolic sine of numbers\r\nprint(math.asinh(7))\r\nprint(math.asinh(56))\r\nprint(math.asinh(2.45))\r\nprint(math.asinh(1))"}
{"nl": "Given a Binary Search Tree (BST) and a range [min, max], remove all keys which are outside the given range. The modified tree should also be BST.", "code": "# Python3 program to remove BST keys\n# outside the given range\n\u00a0\n# A BST node has key, and left and right\u00a0\n# pointers. A utility function to create\n# a new BST node with key as given num\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Removes all nodes having value outside\n# the given range and returns the root\n# of modified tree\ndef removeOutsideRange(root, Min, Max):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# First fix the left and right\n\u00a0\u00a0\u00a0\u00a0# subtrees of root\n\u00a0\u00a0\u00a0\u00a0root.left = removeOutsideRange(root.left,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Min, Max)\n\u00a0\u00a0\u00a0\u00a0root.right = removeOutsideRange(root.right,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Min, Max)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Now fix the root. There are 2\n\u00a0\u00a0\u00a0\u00a0# possible cases for root\n\u00a0\u00a0\u00a0\u00a0# 1.a) Root's key is smaller than\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0 min value (root is not in range)\n\u00a0\u00a0\u00a0\u00a0if root.key < Min:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rChild = root.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return rChild\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# 1.b) Root's key is greater than max\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0 value (root is not in range)\n\u00a0\u00a0\u00a0\u00a0if root.key > Max:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lChild = root.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return lChild\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2. Root is in range\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\n# A utility function to insert a given\n# key to BST\ndef insert(root, key):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return newNode(key)\n\u00a0\u00a0\u00a0\u00a0if root.key > key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, key)\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, key)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# Utility function to traverse the binary\n# tree after conversion\ndef inorderTraversal(root):\n\u00a0\u00a0\u00a0\u00a0if root:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorderTraversal( root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(root.key, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorderTraversal( root.right)\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 6)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, -13)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 14)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, -8)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 13)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 7)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Inorder traversal of the given tree is:\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end = \" \")\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0root = removeOutsideRange(root, -10, 13)\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0print(\"Inorder traversal of the modified tree is:\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end = \" \")\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Exercise 1: Convert two lists into a dictionary", "code": "keys = ['Ten', 'Twenty', 'Thirty']\r\nvalues = [10, 20, 30]\r\n\r\nres_dict = dict(zip(keys, values))\r\nprint(res_dict)\r"}
{"nl": "Given a number n , the task is to calculate the value of n+ nn +nnn in C++ and Python.", "code": "# given number numb\nnumb = 8\n# converting the given number to string\nstrnum = str(numb)\n# Add the string twice to concatenate it and store it in another variable.\nstrnum1 = strnum+strnum\n# Add the string thrice  to concatenate it and store it in another variable.\nstrnum2 = strnum+strnum+strnum\n# converting the strnum1 and strnum2 from string to integer using int() function\nintnum1 = int(strnum1)\nintnum2 = int(strnum2)\n# Calculating the result value\nresultVal = numb+intnum1+intnum2\nprint(\"The value of\", strnum, \"+\", strnum1, \"+\", strnum2, \"=\", resultVal)"}
{"nl": "You are given a string that represent an expression of digits and operands. E.g. 1+2*3, 1-2+4. You need to evaluate the string or the expression. NO BODMAS is followed. If the expression is of incorrect syntax return -1. ", "code": "# Python3 program to evaluate a\r\n# given expression\r\n \r\n# A utility function to check if\r\n# a given character is operand\r\ndef isOperand(c):\r\n  \r\n    return (c >= '0' and c <= '9');\r\n \r\n# utility function to find\r\n# value of and operand\r\ndef value(c):\r\n    return ord(c) - ord('0');\r\n \r\n# This function evaluates simple\r\n# expressions. It returns -1 if the\r\n# given expression is invalid.\r\ndef evaluate(exp):\r\n \r\n    len1 = len(exp);\r\n     \r\n    # Base Case: Given expression is empty\r\n    if (len1 == 0):\r\n        return -1;\r\n \r\n    # The first character must be\r\n    # an operand, find its value\r\n    res = value(exp[0]);\r\n \r\n    # Traverse the remaining\r\n    # characters in pairs\r\n    for i in range(1,len1,2):\r\n        # The next character must be\r\n        # an operator, and next to\r\n        # next an operand\r\n        opr = exp[i];\r\n        opd = exp[i + 1];\r\n \r\n        # If next to next character\r\n        # is not an operand\r\n        if (isOperand(opd)==False):\r\n            return -1;\r\n \r\n        # Update result according\r\n        # to the operator\r\n        if (opr == '+'):\r\n            res += value(opd);\r\n        elif (opr == '-'):\r\n            res -= int(value(opd));\r\n        elif (opr == '*'):\r\n            res *= int(value(opd));\r\n        elif (opr == '/'):\r\n            res /= int(value(opd));\r\n \r\n        # If not a valid operator\r\n        else:\r\n            return -1;\r\n     \r\n    return res;\r\n \r\n# Driver Code\r\nexpr1 = \"1+2*5+3\";\r\nres = evaluate(expr1);\r\nprint(expr1,\"is Invalid\") if (res == -1) else print(\"Value of\",expr1,\"is\",res);\r\n \r\nexpr2 = \"1+2*3\";\r\nres = evaluate(expr2);\r\nprint(expr2,\"is Invalid\") if (res == -1) else print(\"Value of\",expr2,\"is\",res);\r\n \r\nexpr3 = \"4-2+6*3\";\r\nres = evaluate(expr3);\r\nprint(expr3,\"is Invalid\") if (res == -1) else print(\"Value of\",expr3,\"is\",res);\r\n \r\nexpr4 = \"1++2\";\r\nres = evaluate(expr4);\r\nprint(expr4,\"is Invalid\") if (res == -1) else print(\"Value of\",expr4,\"is\",res);\r\n \r\n# This code is contributed by mits"}
{"nl": "Write a function that returns True if a given name can generate an array of words.\nExamples\nanagram(\"Justin Bieber\", [\"injures\", \"ebb\", \"it\"]) \u279e True\n\nanagram(\"Natalie Portman\", [\"ornamental\", \"pita\"]) \u279e True\n\nanagram(\"Chris Pratt\", [\"chirps\", \"rat\"]) \u279e False\n# Not all letters are used\n\nanagram(\"Jeff Goldblum\", [\"jog\", \"meld\", \"bluffs\"]) \u279e False\n# \"s\" does not exist in the original name\nNotes\nEach letter in the name may only be used once.\nAll letters in the name must be used.", "code": "def anagram(name, words):\n  return sorted(''.join(words) + ' ') == sorted(name.lower())"}
{"nl": "Given two matrices A and B. The task is to multiply matrix A and matrix B recursively. If matrix A and matrix B are not multiplicative compatible, then generate output \u201cNot Possible\u201d.\n\nExamples : \n \n\nInput: A = 12 56\n           45 78\n       B = 2 6\n           5 8\nOutput: 304 520\n        480 894\n\nInput: A = 1 2 3\n           4 5 6\n           7 8 9\n       B = 1 2 3\n           4 5 6\n           7 8 9\n\nOutput: 30  36  42  \n        66  81  96  \n       102 126 150  \n\u00a0", "code": "# Recursive code for Matrix Multiplication\nMAX = 100\ni = 0\nj = 0\nk = 0\n\u00a0\ndef multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Note that below variables are static\n\u00a0\u00a0\u00a0\u00a0# i and j are used to know current cell of\n\u00a0\u00a0\u00a0\u00a0# result matrix C[][]. k is used to know\n\u00a0\u00a0\u00a0\u00a0# current column number of A[][] and row\n\u00a0\u00a0\u00a0\u00a0# number of B[][] to be multiplied\n\u00a0\u00a0\u00a0\u00a0global i\n\u00a0\u00a0\u00a0\u00a0global j\n\u00a0\u00a0\u00a0\u00a0global k\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If all rows traversed.\n\u00a0\u00a0\u00a0\u00a0if (i >= row1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If i < row1\n\u00a0\u00a0\u00a0\u00a0if (j < col2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k < col1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C[i][j] += A[i][k] * B[k][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2,B, C)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0j = 0\n\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C)\n\u00a0\n# Function to multiply two matrices\n# A[][] and B[][]\ndef multiplyMatrix(row1, col1, A, row2, col2, B):\n\u00a0\u00a0\u00a0\u00a0if (row2 != col1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Not Possible\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0C = [[0 for i in range(MAX)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(MAX)]\n\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the result\n\u00a0\u00a0\u00a0\u00a0for i in range(row1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(col2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print( C[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\nA = [[1, 2, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0[4, 5, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0[7, 8, 9]]\nB = [[1, 2, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0[4, 5, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0[7, 8, 9]]\n\u00a0\nrow1 = 3\ncol1 = 3\nrow2 = 3\ncol2 = 3\nmultiplyMatrix(row1, col1, A, row2, col2, B)\n\u00a0\n# This code is contributed by sahilshelangia\n"}
{"nl": "Given a n x n matrix. The problem is to sort the matrix row-wise and column wise.\nExamples: \n \n\nInput : mat[][] = { {4, 1, 3},\n                    {9, 6, 8},\n                    {5, 2, 7} }\nOutput : 1 3 4\n         2 5 7\n         6 8 9\n\nInput : mat[][] = { {12, 7, 1, 8},\n                    {20, 9, 11, 2},\n                    {15, 4, 5, 13},\n                    {3, 18, 10, 6} } \nOutput : 1 5 8 12\n         2 6 10 15\n         3 7 11 18\n         4 9 13 20\n\u00a0", "code": "# Python 3 implementation to\n# sort the matrix row-wise\n# and column-wise\nMAX_SIZE = 10\n\u00a0\n# function to sort each\n# row of the matrix\ndef sortByRow(mat, n):\n\u00a0\u00a0\u00a0\u00a0for i in range (n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sorting row number 'i'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if mat[i][j] > mat[i][j + 1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = mat[i][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = mat[i][j + 1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j + 1] = temp\n\u00a0\n# function to find\n# transpose of the matrix\ndef transpose(mat, n):\n\u00a0\u00a0\u00a0\u00a0for i in range (n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(i + 1, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# swapping element at\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# index (i, j) by element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# at index (j, i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = mat[i][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = mat[j][i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[j][i] = t\n\u00a0\n# function to sort\n# the matrix row-wise\n# and column-wise\ndef sortMatRowAndColWise(mat, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# sort rows of mat[][]\n\u00a0\u00a0\u00a0\u00a0sortByRow(mat, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# get transpose of mat[][]\n\u00a0\u00a0\u00a0\u00a0transpose(mat, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# again sort rows of mat[][]\n\u00a0\u00a0\u00a0\u00a0sortByRow(mat, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# again get transpose of mat[][]\n\u00a0\u00a0\u00a0\u00a0transpose(mat, n)\n\u00a0\n# function to print the matrix\ndef printMat(mat, n):\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(str(mat[i][j] ), end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\nmat = [[ 4, 1, 3 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 9, 6, 8 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 5, 2, 7 ]]\nn = 3\n\u00a0\nprint(\"Original Matrix:\")\nprintMat(mat, n)\n\u00a0\nsortMatRowAndColWise(mat, n)\n\u00a0\nprint(\"\\nMatrix After Sorting:\")\nprintMat(mat, n)\n\u00a0\n# This code is contributed\n# by ChitraNayal\n"}
{"nl": "Given lower limit and upper limit, the task is to print all the odd numbers in the given range in Python.\n Examples:\n Example1:\n Input:\n given lower limit range = 25\n \n given upper limit range = 79\n Output:\n 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79\n Example2:\n Input:\n given lower limit range = 23\n \n given upper limit range = 143\n Output:\n Odd numbers from 23 to 143 are :\n \n 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95\n \n 97 99 101 103 105 107 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143", "code": "# Give the lower limit and upper limit as static input\n \n # and store them in two separate variables.\n \n # given lower limit range\n \n lowLimitRange = 23\n \n # given upper limit range\n \n uppLimitRange = 143\n \n print('Odd numbers from', lowLimitRange, 'to', uppLimitRange, 'are :')\n \n # Loop from lower limit range to upper limit range using For loop.\n \n for iterval in range(lowLimitRange, uppLimitRange+1):\n \n  # Check if the iterator value is even or odd using if statement and modulus operator.\n \n  if(iterval % 2 != 0):\n \n  # If the iterator value is odd then print it.\n \n  print(iterval, end=\" \")\n \n </pre>"}
{"nl": "Create a function that takes a number and returns one digit that is the result of summing all the digits of the input number. When the sum of the digits consists of more than one digit, repeat summing until you get one digit.\nExamples\nroot_digit(123) \u279e 6\n# 1 + 2 + 3 = 6\n\nroot_digit(999888777) \u279e 9\n\nroot_digit(1238763636555555555555) \u279e 6\nNotes\nRecursion is allowed.", "code": "def root_digit(n):\n  while n > 9:\n    n = sum(int(i) for i in str(n))\n  return n"}
{"nl": "Given a number x in degrees and number of terms, the task is to print the sum of sine series in  python", "code": "# importing math module\nimport math\n# function which returns sum of sine series\n\n\ndef sumsine(degrees, terms):\n  # taking a variable which stores sum of sine series\n    sumSeries = 0\n    for i in range(terms):\n      # getting sign\n        signofNum = (-1)**i\n        # pie value\n        pievalue = 22/7\n        # degree value of given number\n        degval = degrees*(pievalue/180)\n        sumSeries = sumSeries + ((degval**(2.0*i+1)) /\n                                 math.factorial(2*i+1))*signofNum\n     # returning the sum of sine series\n    return sumSeries\n\n\ndegrees = int(input(\"enter the number of degrees = \"))\nterms = int(input(\"enter number of terms = \"))\nprint(\"The sum of sine series of \", degrees, \"degrees\", \"of\",\n      terms, \"terms =\", round(sumsine(degrees, terms), 2))"}
{"nl": "Alphametics is a puzzle where letters in words are replaced with numbers.\n\nFor example SEND + MORE = MONEY:\n\n  S E N D\n  M O R E +\n-----------\nM O N E Y\nReplacing these with valid numbers gives:\n\n  9 5 6 7\n  1 0 8 5 +\n-----------\n1 0 6 5 2\nThis is correct because every letter is replaced by a different number and the words, translated into numbers, then make a valid sum.\n\nEach letter must represent a different digit, and the leading digit of a multi-digit number must not be zero.\n\nWrite a function to solve alphametics puzzles.", "code": "from itertools import permutations\nfrom operator import mul\nimport re\ndef solve(puzzle):\n    words = re.findall(r\"\\w+\", puzzle)[::-1]\n    d = {w[0]: 0 for w in words}\n    knz = len(d)\n    d.update({c: 0 for c in filter(str.isalpha, puzzle)})\n    for i, w in enumerate(words):\n        for j, c in enumerate(w[::-1]):\n            d[c] = d[c] + 10**j * (bool(i) * 2 - 1)\n    factors = d.values()\n    for p in permutations(range(10), len(d)):\n        if 0 in p[:knz]:\n            continue\n        if not sum(map(mul, factors, p)):\n            return dict(zip(d.keys(), p))"}
{"nl": "Write a function that removes all capital letters from a sentence except the first letter, puts quotation marks around the sentence and adds \", whispered Edabit.\" at the end.\nExamples\nshhh(\"HI THERE!\") \u279e '\"Hi there!\", whispered Edabit.'\n\nshhh(\"tHaT'S Pretty awesOme\") \u279e '\"That's pretty awesome\", whispered Edabit.'\n\nshhh(\"\") \u279e '\"\", whispered Edabit.'\nNotes\nDon't forget to surround the original string with double quotation marks \"\".", "code": "def shhh(txt):\n  return '\"{}\", whispered Edabit.'.format(txt.capitalize())"}
{"nl": "Give an algorithm for reversing a queue Q. Only following standard operations are allowed on queue.\u00a0\nenqueue(x) : Add an item x to rear of queue.\ndequeue() : Remove an item from front of queue.\nempty() : Checks if a queue is empty or not.\n\n\n\u00a0", "code": "# Python3 program to reverse a queue\nfrom queue import Queue\n\u00a0\n# Utility function to print the queue\ndef Print(queue):\n\u00a0\u00a0\u00a0\u00a0while (not queue.empty()):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(queue.queue[0], end = \", \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.get()\n\u00a0\n# Function to reverse the queue\ndef reversequeue(queue):\n\u00a0\u00a0\u00a0\u00a0Stack = []\n\u00a0\u00a0\u00a0\u00a0while (not queue.empty()):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Stack.append(queue.queue[0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.get()\n\u00a0\u00a0\u00a0\u00a0while (len(Stack) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.put(Stack[-1])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Stack.pop()\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0queue = Queue()\n\u00a0\u00a0\u00a0\u00a0queue.put(10)\n\u00a0\u00a0\u00a0\u00a0queue.put(20)\n\u00a0\u00a0\u00a0\u00a0queue.put(30)\n\u00a0\u00a0\u00a0\u00a0queue.put(40)\n\u00a0\u00a0\u00a0\u00a0queue.put(50)\n\u00a0\u00a0\u00a0\u00a0queue.put(60)\n\u00a0\u00a0\u00a0\u00a0queue.put(70)\n\u00a0\u00a0\u00a0\u00a0queue.put(80)\n\u00a0\u00a0\u00a0\u00a0queue.put(90)\n\u00a0\u00a0\u00a0\u00a0queue.put(100)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0reversequeue(queue)\n\u00a0\u00a0\u00a0\u00a0Print(queue)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Files In Python:\n\nA file is a piece of data or information stored on a computer\u2019s hard drive. You\u2019re already familiar with a variety of file kinds, including music, video, and text files. Manipulation of these files is trivial with Python. Text files and binary files are the two types of files that are commonly used. Binary files contain binary data that can only be read by a computer, whereas text files include plain text.\n\nFor programmers and automation testers, Python file handling (also known as File I/O) is a crucial topic. Working with files is required in order to write to or read data from them.\n\n\n\nIn addition, if you didn\u2019t know, I/O activities are the most expensive techniques via which software might fail. As a result, when implementing file processing for reporting or any other reason, you should proceed with caution. The construction of a high-performance application or a robust solution for automated software testing can benefit from optimizing a single file activity.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  print('The Characters in the given file : ')\n  for gvnfileline in givenfilecontent:\n  # Split the words of the line using the split() function and store them in a variable(it is of type list).\n  gvnfilewords = gvnfileline.split()\n  # Loop in the above list using another Nested For loop.\n  for words in gvnfilewords:\n  # Print all the characters of the word using another Nested For loop and print function.\n  for charactrs in words:\n  print(charactrs)"}
{"nl": "Python For Loops\r\nA for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).\r\n\r\nThis is less like the for keyword in other programming languages, and works more like an iterator method as found in other object-orientated programming languages.\r\n\r\nWith the for loop we can execute a set of statements, once for each item in a list, tuple, set etc.", "code": "fruits = [\"apple\", \"banana\", \"cherry\"]\r\nfor x in fruits:\r\n  print(x)"}
{"nl": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\n\nReturn the sum of all subarray ranges of nums.\n\nA subarray is a contiguous non-empty sequence of elements within an array.", "code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        sm=0\n        n=len(nums)\n        for i in range(n-1):\n            mx=nums[i]\n            mn=nums[i]\n            for j in range(i+1,n):\n                \n                mx=max(mx,nums[j])\n                mn=min(mn,nums[j])\n                sm+=(mx-mn)\n        return sm\n        "}
{"nl": "Write a function that returns True if exactly one word in the list differs in length from the rest. Return False in all other cases.\r\n\r\nExamples\r\nodd_one_out([\"silly\", \"mom\", \"let\", \"the\"]) \u279e True\r\n\r\nodd_one_out([\"swanky\", \"rhino\", \"moment\"]) \u279e True\r\n\r\nodd_one_out([\"the\", \"them\", \"theme\"]) \u279e False\r\n\r\nodd_one_out([\"very\", \"to\", \"an\", \"some\"]) \u279e False\r\nNotes\r\nThe length of the list will always have at least three or more words.", "code": "def odd_one_out(lst):\r\n  lst = [len(item) for item in lst]\r\n  counts = [lst.count(i) for i in set(lst)]\r\n  return len(set(lst)) == 2 and 1 in counts"}
{"nl": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\n\nYou are given an array of strings sentences, where each sentences[i] represents a single sentence.\n\nReturn the maximum number of words that appear in a single sentence.", "code": "class Solution:\n    def mostWordsFound(self, sentences: List[str]) -> int:\n        max=0\n        for i in sentences:\n            temp=i.split(\" \")\n            res=len(temp)\n            if res>max:\n                max=res\n        return max"}
{"nl": "In this program, you'll learn to print the Fibonacci sequence using while loop.", "code": "# Program to display the Fibonacci sequence up to n-th term\n\nnterms = int(input(\"How many terms? \"))\n\n# first two terms\nn1, n2 = 0, 1\ncount = 0\n\n# check if the number of terms is valid\nif nterms <= 0:\n   print(\"Please enter a positive integer\")\n# if there is only one term, return n1\nelif nterms == 1:\n   print(\"Fibonacci sequence upto\",nterms,\":\")\n   print(n1)\n# generate fibonacci sequence\nelse:\n   print(\"Fibonacci sequence:\")\n   while count < nterms:\n       print(n1)\n       nth = n1 + n2\n       # update values\n       n1 = n2\n       n2 = nth\n       count += 1"}
{"nl": "Given a string, and the task is to determine whether one string is a rotation of another.", "code": "# Give the first string as user input using input() function and store it in a variable.\nfst_str = input(\"Enter some random string = \")\n# Give the second string as user input using input() function and store it in another variable.\nsecnd_str = input(\"Enter some random string = \")\n# Check if the length of the first string is not equal to the length of the second\n# string using the if conditional statement and using the len() function.\nif(len(fst_str) != len(secnd_str)):\n    # If the statement is true, print \"The given second string is not the rotation of the given first string\".\n    print(\"The given second string is not the rotation of the given first string\")\nelse:\n    # Else concat the first string with the first string itself using the '+ ' operator\n    # and store it in a variable say \"conat_str\".\n    conct_str = fst_str + fst_str\n# Check if the second string is present in the \"conca_str\" using the if\n# conditional statement.\n    if(secnd_str in conct_str):\n        # If the statement is true, print  \"The given second string is the rotation of the given first string\".\n        print(\"The given second string is the rotation of the given first string\")\n    else:\n        # Else print  \"The given second string is not the rotation of the given first string\".\n        print(\"The given second string is not the rotation of the given first string\")"}
{"nl": "The Sieve of Eratosthenes is a very old and conventional algorithm for finding all prime numbers that are less or equal to a given number. If the number is less than or equal to 10 million or so, the Eratosthenes sieve is highly effective. You may get a thorough explanation of the algorithm on Wikipedia.\n Given the lower limit and upper limit the task is to print prime numbers in the given range using sieve of Eratosthenes in Python.\n Examples:\n Example1:\n Input:\n Enter some random upper limit range = 529\n Output:\n The prime numbers from 1 to 529 are :\n \n 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 \n \n 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281\n \n 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443\n \n 449 457 461 463 467 479 487 491 499 503 509 521 523\n Example2:\n Input:\n Enter some random upper limit range = 129\n Output:\n The prime numbers from 1 to 129 are :\n \n 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127", "code": "# Give the value of the upper limit n as static input.\n \n numb = 20\n \n print('The prime numbers from 1 to', numb, 'are :')\n \n # Fill the sieve with numbers ranging from 2 to n.\n \n sievearray = set(range(2, numb+1))\n \n # Use a while loop that checks to see if the sieve is empty.\n \n while sievearray:\n \n  # Find the smallest prime number.\n \n  primenum = min(sievearray)\n \n  # printing the primenum\n \n  print(primenum, end=\" \")\n \n  sievearray -= set(range(primenum, numb+1, primenum))\n \n </pre>"}
{"nl": "Pascal\u2019s triangle is a triangular array of the binomial coefficients. Write a function that takes an integer value n as input and prints first n lines of the Pascal\u2019s triangle. Following are the first 6 rows of Pascal\u2019s Triangle.\n \n\n1  \n1 1 \n1 2 1 \n1 3 3 1 \n1 4 6 4 1 \n1 5 10 10 5 1 ", "code": "# Python 3 code for Pascal's Triangle\n# A simple O(n^3)\n# program for\n# Pascal's Triangle\n\n# Function to print\n# first n lines of\n# Pascal's Triangle\ndef printPascal(n) :\n\t\n\t# Iterate through every line\n\t# and print entries in it\n\tfor line in range(0, n) :\n\t\t\n\t\t# Every line has number of\n\t\t# integers equal to line\n\t\t# number\n\t\tfor i in range(0, line + 1) :\n\t\t\tprint(binomialCoeff(line, i),\n\t\t\t\t\" \", end = \"\")\n\t\tprint()\n\t\n\n# See https://www.geeksforgeeks.org/space-and-time-efficient-binomial-coefficient/\n# for details of this function\ndef binomialCoeff(n, k) :\n\tres = 1\n\tif (k > n - k) :\n\t\tk = n - k\n\tfor i in range(0 , k) :\n\t\tres = res * (n - i)\n\t\tres = res // (i + 1)\n\t\n\treturn res\n\n# Driver program\nn = 7\nprintPascal(n)\n\n\n# This code is contributed by Nikita Tiwari."}
{"nl": "Multiply Two Numbers Without Using Multiplication(*) Operator Using For loop (User Input)", "code": "# Give the first number as user input using the int(input()) function and\r\n# store it in a variable.\r\nfst_numb = int(input(\"Enter some random number = \"))\r\n# Give the second number as user input using the int(input()) function and\r\n# store it in another variable.\r\nscnd_numb = int(input(\"Enter some random number = \"))\r\n# Take a variable say rslt_sum and initialize its value to 0.\r\nrslt_sum = 0\r\n# Loop from 1 to the given first number using the for loop.\r\nfor itr in range(1, fst_numb+1):\r\n    # Inside the loop, add the given second number to the above-initialized variable\r\n    # rslt_sum and store it in the same variable rslt_sum.\r\n    rslt_sum = rslt_sum+scnd_numb\r\n# Print the variable rslt_sum to get the multiplication of given two numbers without\r\n# using the multiplication(*) Operator.\r\nprint(\"The multiplication of given two numbers{\",\r\n      fst_numb, \"*\", scnd_numb, \"} = \", rslt_sum)"}
{"nl": "Write a Python program to print triangle of alphabets in reverse pattern using for loop.\n\n", "code": "rows = int(input(\"Enter Triangle of Reverse Alphabets Rows = \"))\n\nprint(\"====The Triangle of Alphabets in Reverse Pattern====\")\nalphabet = 65\n\nfor i in range(rows - 1, -1, -1):\n    for j in range(i):\n        print(end = ' ')\n    for k in range(i, rows):\n        print('%c' %(alphabet + k), end = ' ')\n    print()"}
{"nl": "Given a square boolean matrix mat[n][n], find k such that all elements in k\u2019th row are 0 and all elements in k\u2019th column are 1. The value of mat[k][k] can be anything (either 0 or 1). If no such k exists, return -1.\n\n\u00a0", "code": "''' Python program to find k such that all elements in k'th row\n\u00a0\u00a0\u00a0\u00a0are 0 and k'th column are 1'''\n\u00a0\ndef find(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# store length of the array\n\u00a0\u00a0\u00a0\u00a0n = len(arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# start from top right-most corner\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0j = n - 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# initialise result\n\u00a0\u00a0\u00a0\u00a0res = -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# find the index (This loop runs at most 2n times, we\n\u00a0\u00a0\u00a0\u00a0# either increment row number or decrement column number)\n\u00a0\u00a0\u00a0\u00a0while i < n and j >= 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if the current element is 0, then this row may be a solution\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr[i][j] == 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check for all the elements in this row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while j >= 0 and (arr[i][j] == 0 or i == j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if all values are 0, update result as row number\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if found a 1 in current row, the row can't be a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# solution, increment row number\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else: i += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if the current element is 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#check for all the elements in this column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while i < n and (arr[i][j] == 1 or i == j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i +=1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if all elements are 1, update result as col number\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == n:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = j\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if found a 0 in current column, the column can't be a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# solution, decrement column number\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else: j -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if we couldn't find result in above loop, result doesn't exist\n\u00a0\u00a0\u00a0\u00a0if res == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# check if the above computed res value is valid\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if res != i and arr[i][res] != 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\u00a0\u00a0for j in range(0, j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if res != j and arr[res][j] != 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\n# test find(arr) function\narr = [ [0,0,1,1,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0,0,0,1,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1,1,1,1,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0,0,0,0,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1,1,1,1,1] ]\n\u00a0\nprint (find(arr))\n"}
{"nl": "Given two numbers base value and the exponential value, the task is to find the power of base and exponent modular 10^9+7\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven base value =  5\nGiven exponent value = 3\nOutput:\n\nThe value of the power of base and exponent modular 10^9+7 =  125\nExample2:\n\nInput:\n\nGiven base value =  3\nGiven exponent value = 10000\nOutput:\n\nThe value of the power of base and exponent modular 10^9+7 =  895629451", "code": "# Take a variable to say numb and initialize its value with 1000000007(10^9+7).\n numb = 1000000007\n # Create a function to say exponentl_squaring() which takes the given two base and\n # exponential values as the arguments and returns the value of the power of base and\n # exponent modular 10^9+7.\n def exponentl_squaring(gvn_baseval, gvn_exponentlval):\n  # Inside the function, take a variable say p, and initialize its value to 1.\n  p = 1\n  # Loop until the given exponential value is greater than 0 using the while loop.\n  while(gvn_exponentlval > 0):\n  # Check if the given exponential value is odd using the if conditional statement.\n  if (gvn_exponentlval % 2 != 0):\n  # If it is true, multiply p with the given base value and store it in another\n  # variable.\n  k = p * gvn_baseval\n  # Calculate the value of the above result modulus numb(10^9+7) and store it in the\n  # same variable p.\n  p = k % numb\n  # Multiply the given base value with itself and apply the modulus operator with\n  # 10^9+7(numb).\n  # Store it in the same variable given base value.\n  gvn_baseval = (gvn_baseval * gvn_baseval) % numb\n  # Divide the given exponential value by 2 and convert it to an integer using the\n  # int() function.\n  # Store it in the same variable given exponential value.\n  gvn_exponentlval = int(gvn_exponentlval / 2)\n  # Return the value of p modulus 10^9+7.\n  return p % numb\n # Give the base value as static input and store it in a variable.\n gvn_baseval = 5\n # Give the exponential value as static input and store it in another variable.\n gvn_exponentlval = 3\n # Pass the given base and exponential values as the arguments to the exponentl_squaring()\n # function and store it in a variable.\n rslt = exponentl_squaring(gvn_baseval, gvn_exponentlval)\n # Print the value of the power of base and exponent modular 10^9+7.\n print(\"The value of the power of base and exponent modular 10^9+7 = \", rslt)"}
{"nl": "Strings in Python:\n\n\u201cString is a character collection or array\u201d\n\nWell in Python too, for the string data type, we say the same definition. The string is a sequenced character array and is written within single, double, or three quotes. Also, Python does not have the data type character, thus it is used as a string of length 1 if we write \u2018r\u2019.\n\nGiven a string, the task is to calculate the total number of digits and letters present in the given string in Python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven string =Hel34lo18th3is9is38 BTech23Geeks\nOutput:\n\nThe total number of digits present in the given string [ Hel34lo18th3is9is38 BTech23Geeks ] =  10\nThe total number of characters present in the given string [ Hel34lo18th3is9is38 BTech23Geeks ] =  32", "code": "# Give the string as static input and save it in a variable.\ngiven_strng = 'Hel34lo18th3is9is38 BTech23Geeks'\n# Take a variable to say stringdigits that stores the total digits in the given string.\n# Initialize the stringdigits to 0.\nstringdigits = 0\n# Take a variable to say stringcharacters that stores the total characters in the given string.\n# Initialize the stringcharacters to 0.\nstringcharacters = 0\n# Traverse the given string using for loop.\nfor charact in given_strng:\n    # Check if the character is a numerical digit or not using the isdigit() function.\n    if(charact.isdigit()):\n        # If the character is a numerical digit then increment the value of stringdigits by 1.\n        stringdigits = stringdigits+1\n    # Increase the stringcharacters by 1.\n    stringcharacters = stringcharacters+1\n# Print the total count of digits and characters present in the given string.\nprint(\n    'The total number of digits present in the given string [', given_strng, '] = ', stringdigits)\nprint(\n    'The total number of characters present in the given string [', given_strng, '] = ', stringcharacters)"}
{"nl": "Instructions\r\nInsert and search for numbers in a binary tree.\r\n\r\nWhen we need to represent sorted data, an array does not make a good data structure.\r\n\r\nSay we have the array [1, 3, 4, 5], and we add 2 to it so it becomes [1, 3, 4, 5, 2] now we must sort the entire array again! We can improve on this by realizing that we only need to make space for the new item [1, nil, 3, 4, 5], and then adding the item in the space we added. But this still requires us to shift many elements down by one.\r\n\r\nBinary Search Trees, however, can operate on sorted data much more efficiently.\r\n\r\nA binary search tree consists of a series of connected nodes. Each node contains a piece of data (e.g. the number 3), a variable named left, and a variable named right. The left and right variables point at nil, or other nodes. Since these other nodes in turn have other nodes beneath them, we say that the left and right variables are pointing at subtrees. All data in the left subtree is less than or equal to the current node's data, and all data in the right subtree is greater than the current node's data.\r\n\r\nFor example, if we had a node containing the data 4, and we added the data 2, our tree would look like this:\r\n\r\n  4\r\n /\r\n2\r\nIf we then added 6, it would look like this:\r\n\r\n  4\r\n / \\\r\n2   6\r\nIf we then added 3, it would look like this\r\n\r\n   4\r\n /   \\\r\n2     6\r\n \\\r\n  3\r\nAnd if we then added 1, 5, and 7, it would look like this\r\n\r\n      4\r\n    /   \\\r\n   /     \\\r\n  2       6\r\n / \\     / \\\r\n1   3   5   7\r", "code": "\r\nfrom __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import Any, Generic, Iterable, Iterator, List, Optional, Protocol, TypeVar\r\nclass Comparable(Protocol):\r\n    def __lt__(self, other: Any) -> bool:\r\n        ...\r\nT = TypeVar(\"T\", bound=Comparable)\r\n@dataclass\r\nclass TreeNode(Generic[T]):\r\n    data: T\r\n    left: Optional[TreeNode[T]]\r\n    right: Optional[TreeNode[T]]\r\nclass BinarySearchTree(Generic[T]):\r\n    def __init__(self, tree_data: Iterable[T]) -> None:\r\n        self.root = None\r\n        for data in tree_data:\r\n            self.root = insert(self.root, data)\r\n    def data(self) -> Optional[TreeNode[T]]:\r\n        return self.root\r\n    def sorted_data(self) -> List[T]:\r\n        return list(visit(self.root))\r\ndef insert(node: Optional[TreeNode[T]], data: T) -> TreeNode[T]:\r\n    if node is None:\r\n        node = TreeNode(data, None, None)\r\n    elif node.data < data:\r\n        node.right = insert(node.right, data)\r\n    else:\r\n        node.left = insert(node.left, data)\r\n    return node\r\ndef visit(node: Optional[TreeNode[T]]) -> Iterator[T]:\r\n    if node is not None:\r\n        yield from visit(node.left)\r\n        yield node.data\r\n        yield from visit(node.right\r\n"}
{"nl": "Make comment in python", "code": "#Use # to start a line comment"}
{"nl": null, "code": null}
{"nl": "In this post search, insert, and delete operations in an unsorted array are discussed.\r\n\r", "code": "# Python program for inserting\n# an element in an unsorted array\n \n# method to insert element\ndef insert(arr, element):\n    arr.append(element)\n \n# declaring array and key to insert\narr = [12, 16, 20, 40, 50, 70]\nkey = 26\n  \n# array before inserting an element\nprint (\"Before Inserting: \")\nprint (arr)\n  \n# array after Inserting element\ninsert(arr, key)\nprint(\"After Inserting: \")\nprint (arr)\n \n# Thanks to Aditi Sharma for contributing\n# this code\n# Python program for inserting\n# an element in an unsorted array\n \n# method to insert element\ndef insert(arr, element):\n    arr.append(element)\n \n# declaring array and key to insert\narr = [12, 16, 20, 40, 50, 70]\nkey = 26\n  \n# array before inserting an element\nprint (\"Before Inserting: \")\nprint (arr)\n  \n# array after Inserting element\ninsert(arr, key)\nprint(\"After Inserting: \")\nprint (arr)\n \n# Thanks to Aditi Sharma for contributing\n# this code \n# Python program to delete an element\n# from an unsorted array\n \n# Declaring array and key to delete\narr = [10, 50, 30, 40, 20]\nkey = 30\n  \nprint(\"Array before deletion:\")\nprint (arr)\n  \n# deletes key if found in the array\n# otherwise shows error not in list\narr.remove(key)\nprint(\"Array after deletion\")\nprint(arr)\n  \n# This code is contributed by Aditi Sharma.\"\n# python 3  program to implement\n# binary search in sorted array\n  \ndef binarySearch(arr, low, high, key):\n    # low + (high - low)/2\n    mid = (low + high)/2\n  \n    if (key == arr[int(mid)]):\n        return mid\n  \n    if (key > arr[int(mid)]):\n        return binarySearch(arr,\n           (mid + 1), high, key)\n  \n    if (key < arr[int(mid)]):\n        return binarySearch(arr,low, (mid-1), key)\n      \n    return 0\n  \n# Driver program to check above functions \n# Let us search 3 in below array\narr = [5, 6, 7, 8, 9, 10]\nn = len(arr)\nkey = 10\nprint(\"\"Index:\"\", int(binarySearch(arr, 0, n-1, key) ))\n  \n# This code is contributed by\n# Smitha Dinesh Semwal\"\n# Python program to implement delete operation in a \n# sorted array \n  \n#/* Function to delete an element */\ndef deleteElement(arr, n, key):\n      \n    # Find position of element to be deleted \n    pos = binarySearch(arr, 0, n - 1, key) \n      \n    if (pos == -1):\n        print(\"Element not found\")\n        return n \n          \n    # Deleting element \n    for i in range(pos,n - 1):\n        arr[i] = arr[i + 1] \n      \n    return n - 1 \n      \n# To search a key to be deleted \ndef binarySearch(arr, low, high, key):\n      \n    if (high < low):\n        return -1 \n    mid = (low + high) // 2 \n      \n    if (key == arr[mid]):\n        return mid \n    if (key > arr[mid]):\n        return binarySearch(arr, (mid + 1), high, key) \n      \n    return binarySearch(arr, low, (mid - 1), key) \n   \n# Driver code \narr = [10, 20, 30, 40, 50 ]\n  \nn = len(arr)\nkey = 30 \n  \nprint(\"Array before deletion\")\n  \nfor i in range(n):\n    print(arr[i],end=\" \")\n      \nn = deleteElement(arr, n, key) \nprint(\"\\n\\nArray after deletion\")\nfor i in range(n):\n    print(arr[i],end=\" \")\n  \n# This code is contributed by shubhamsingh10   "}
{"nl": "Swap nodes in a linked list without swapping data", "code": "\n# Python program to swap two given nodes of a linked list\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n \n    # head of list\n    class Node(object):\n        def __init__(self, d):\n            self.data = d\n            self.next = None\n \n    # Function to swap Nodes x and y in linked list by\n    # changing links\n    def swapNodes(self, x, y):\n \n        # Nothing to do if x and y are same\n        if x == y:\n            return\n \n        # Search for x (keep track of prevX and CurrX)\n        prevX = None\n        currX = self.head\n        while currX != None and currX.data != x:\n            prevX = currX\n            currX = currX.next\n \n        # Search for y (keep track of prevY and currY)\n        prevY = None\n        currY = self.head\n        while currY != None and currY.data != y:\n            prevY = currY\n            currY = currY.next\n \n        # If either x or y is not present, nothing to do\n        if currX == None or currY == None:\n            return\n        # If x is not head of linked list\n        if prevX != None:\n            prevX.next = currY\n        else:  # make y the new head\n            self.head = currY\n \n        # If y is not head of linked list\n        if prevY != None:\n            prevY.next = currX\n        else:  # make x the new head\n            self.head = currX\n \n        # Swap next pointers\n        temp = currX.next\n        currX.next = currY.next\n        currY.next = temp\n "}
{"nl": "Given a number, return the total sum of that number multiplied by every number between 1 and 10. Do not use the sum() built-in function.\nExamples\nmulti_sum(1) \u279e 55\n# 1 x 1 + 1 x 2 + 1 x 3 ...... 1 x 9 + 1 x 10 = 55\n\nmulti_sum(6) \u279e 330\n# 6 x 1 + 6 x 2 + 6 x 3 ...... 6 x 9 + 6 x 10 = 330\n\nmulti_sum(10) \u279e 550\n\nmulti_sum(8) \u279e 440\n\nmulti_sum(2) \u279e 110\nNotes\nUse recursion to solve this challenge.", "code": "def multi_sum(n, ten=10):\n  return ten and n * ten + multi_sum(n, ten - 1)"}
{"nl": "There is a hidden integer array arr that consists of n non-negative integers.\nIt was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].\nYou are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].\nReturn the original array arr. It can be proved that the answer exists and is unique.\n \nExample 1:\n\nInput: encoded = [1,2,3], first = 1\nOutput: [1,0,2,1]\nExplanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n\nExample 2:\n\nInput: encoded = [6,2,7,3], first = 4\nOutput: [4,2,0,7,4]\n\n \nConstraints:\n\n2 <= n <= 104\nencoded.length == n - 1\n0 <= encoded[i] <= 105\n0 <= first <= 105", "code": "def decode(self, A, first):\n  res = [first]\n  for a in A:\n  res.append(res[-1] ^ a)\n  return res"}
{"nl": "Create a function that takes an integer and returns the factorial of that integer. That is, the integer multiplied by all positive lower integers.\nExamples\nfactorial(3) \u279e 6\n\nfactorial(5) \u279e 120\n\nfactorial(13) \u279e 6227020800\nNotes\nAssume all inputs are greater than or equal to 0.", "code": "def factorial(num):\n  return 1 if num < 2 else num * factorial(num - 1)"}
{"nl": "Files in Python:\n\nPython File handling is a method that allows you to save the program\u2019s output to a file or read data from a file. In the programming world, file handling is a critical notion. File management is employed in practically every type of project. For example, suppose you\u2019re developing an inventory management system. You have data connected to sales and purchases in the inventory management system, thus you must save that data somewhere. You can save that data to a file using Python file management. If you want to undertake data analysis, you must be given data in the form of a comma-separated file or a Microsoft Excel file. You can read data from a file and also store output back into it using file handling.\n\nGiven a file, the task is to count the entire number of lines within the given file in Python.", "code": "# Take a variable that stores the count of a number of lines in a given file and initialize it to 0.\nlinecount = 0\n# Enter the file name of the  file using the input() function and store it in a variable.\nfilename = input(\"Enter the file name = \")\n# In read mode, open the file with the entered file name.\nwith open(filename, 'r') as givenfile:\n    # Using for loop, Traverse the lines in the file.\n    # Increment the value of line count by 1.\n    for line in givenfile:\n        linecount = linecount+1\n# Print the line count.\nprint('The total number of lines in the given file = ', linecount)"}
{"nl": "Given a number N having only one \u20181\u2019 and all other \u20190\u2019s in its binary representation, find position of the only set bit. If there are 0 or more than 1 set bit the answer should be -1. Position of set bit \u20181\u2019 should be counted starting with 1 from the LSB side in the binary representation of the number.\n\n Source: Microsoft Interview | 18\n\nExamples:-\n\nInput:\nN = 2\nOutput:\n2\nExplanation:\n2 is represented as \"10\" in Binary.\nAs we see there's only one set bit\nand it's in Position 2 and thus the\nOutput 2.", "code": "# Python3 program to find position of\n# only set bit in a given number\n\n# A utility function to check\n# whether n is power of 2 or\n# not.\ndef isPowerOfTwo(n):\n\treturn (True if(n > 0 and\n\t\t\t\t((n & (n - 1)) > 0))\n\t\t\t\telse False);\n\t\n# Returns position of the\n# only set bit in 'n'\ndef findPosition(n):\n\tif (isPowerOfTwo(n) == True):\n\t\treturn -1;\n\n\ti = 1;\n\tpos = 1;\n\n\t# Iterate through bits of n\n\t# till we find a set bit i&n\n\t# will be non-zero only when\n\t# 'i' and 'n' have a set bit\n\t# at same position\n\twhile ((i & n) == 0):\n\t\t\n\t\t# Unset current bit and\n\t\t# set the next bit in 'i'\n\t\ti = i << 1;\n\n\t\t# increment position\n\t\tpos += 1;\n\n\treturn pos;\n\n# Driver Code\nn = 16;\npos = findPosition(n);\nif (pos == -1):\n\tprint(\"n =\", n, \", Invalid number\");\nelse:\n\tprint(\"n =\", n, \", Position \", pos);\n\nn = 12;\npos = findPosition(n);\nif (pos == -1):\n\tprint(\"n =\", n, \", Invalid number\");\nelse:\n\tprint(\"n =\", n, \", Position \", pos);\n\nn = 128;\npos = findPosition(n);\nif (pos == -1):\n\tprint(\"n =\", n, \", Invalid number\");\nelse:\n\tprint(\"n =\", n, \", Position \", pos);\n\n# This code is contributed by mits"}
{"nl": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers which has negative and positive numbers.\n\nExamples: \n\n\n\nInput: a[] = {20, -5, -1} \n         k = 3\nOutput: 14\nExplanation: All sum of contiguous \nsubarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40} \n         k = 6\nOutput: -10 \nExplanation: The 6th largest sum among \nsum of all contiguous subarrays is -10.", "code": "# Python program to find the k-th largest sum\n# of subarray\nimport heapq\n\n# function to calculate kth largest element\n# in contiguous subarray sum\ndef kthLargestSum(arr, n, k):\n\t\n\t# array to store prefix sums\n\tsum = []\n\tsum.append(0)\n\tsum.append(arr[0])\n\tfor i in range(2, n + 1):\n\t\tsum.append(sum[i - 1] + arr[i - 1])\n\t\t\n\t# priority_queue of min heap\n\tQ = []\n\theapq.heapify(Q)\n\t\n\t# loop to calculate the contiguous subarray\n\t# sum position-wise\n\tfor i in range(1, n + 1):\n\t\t\n\t\t# loop to traverse all positions that\n\t\t# form contiguous subarray\n\t\tfor j in range(i, n + 1):\n\t\t\tx = sum[j] - sum[i - 1]\n\t\t\t\n\t\t\t# if queue has less then k elements,\n\t\t\t# then simply push it\n\t\t\tif len(Q) < k:\n\t\t\t\theapq.heappush(Q, x)\n\t\t\telse:\n\t\t\t\t# it the min heap has equal to\n\t\t\t\t# k elements then just check\n\t\t\t\t# if the largest kth element is\n\t\t\t\t# smaller than x then insert\n\t\t\t\t# else its of no use\n\t\t\t\tif Q[0] < x:\n\t\t\t\t\theapq.heappop(Q)\n\t\t\t\t\theapq.heappush(Q, x)\n\t\n\t# the top element will be then kth\n\t# largest element\n\treturn Q[0]\n\n# Driver program to test above function\na = [10,-10,20,-40]\nn = len(a)\nk = 6\n\n# calls the function to find out the\n# k-th largest sum\nprint(kthLargestSum(a,n,k))\n\n\n# This code is contributed by Kumar Suman"}
{"nl": "Write a function that squishes a list from the left or the right.\r\n\r\nExamples\r\nsquish([1, 2, 3, 4, 5], \"left\") \r\n\u279e [[1, 2, 3, 4, 5], [3, 3, 4, 5], [6, 4, 5], [10, 5], [15]]\r\n\r\nsquish([1, 2, 3, 4, 5], \"right\")\r\n\u279e [[1, 2, 3, 4, 5], [1, 2, 3, 9], [1, 2, 12], [1, 14], [15]]\r\n\r\nsquish([1, 0, 2, -3], \"left\")\r\n\u279e [[1, 0, 2, -3], [1, 2, -3], [3, -3], [0]]\r\n\r\nsquish([1, 0, 2, -3], \"right\")\r\n\u279e [[1, 0, 2, -3], [1, 0, -1], [1, -1], [0]]\r\nNotes\r\nSquishing from the left is to successively sum the first two elements of a list (shortening the list in the process).\r\nSquishing from the right is to successively sum the last two elements of a list.\r\nInclude the original list as the first element in either squish.\r\nReturn an empty list if the input is an empty list.", "code": "def squish(lst, d):\r\n  if d == 'left':\r\n    return [[sum(lst[:i])] + lst[i:] for i in range(1, len(lst) + 1)]\r\n  return [lst[:-i] + [sum(lst[-i:])] for i in range(1, len(lst) + 1)]"}
{"nl": "Darts is a target game played by throwing feathered darts at a circular board with numbered spaces. Our darts game is the simplest of all games. The score of a single turn is calculated based on the distance from the middle. You need to create a function that takes the dart location as two cartesian coordinates (x, y) and returns a score based on the distance from the middle, aka Bullseye (x=0, y=0).\nBullseye and inner circle scores = 10 points\nMiddle ring scores = 5 points\nOuter ring scores = 1 point\nOutside the target = 0 points\nWe play it simple so a dart in the double or treble ring counts as usual and does not affect the segment score.\nBoard and circle radius is as follows:\nBoard radius and outer circle radius = 10 units\nMiddle circle radius = 5 units\nInner circle radius = 1 unit\nShort Description\nConvert cartesian coordinates (x, y) to polar coordinates (R, phi) and return the score based on the R value. R > 10 gives 0 points, 10 >= R > 5 gives 1 point, 5 >= R > 1 gives 5 points, R <= 1 gives 10 points.\nExamples\ndarts_scoring(0, 0) \u279e 10\n\ndarts_scoring(3, 2) \u279e 5\n\ndarts_scoring(0, -0.8) \u279e 10\nNotes\nX, Y values can be both positive and negative.\nX, Y values can be int and float.\nNo wrong type values will be given.", "code": "def darts_scoring(x, y):\n  dist = (x ** 2 + y ** 2) ** 0.5\n  return (dist <= 10) + (dist <= 5) * 4 + (dist <= 1) * 5"}
{"nl": "Static Input: Find the Sum of Series 1^1+2^2+3^3\u2026+N^N using For loop and pow() function", "code": "# Give the number N as static input and store it in a variable.\r\ngvnNumbr = 3\r\n# Take a variable say resltsum which gives the sum of\r\n# the given series till N and initialize its value to 0.\r\nresltsum = 0\r\n# Loop from 1 to given number using the For loop.\r\nfor k in range(1, gvnNumbr+1):\r\n        # Inside the For loop, Calculate the value of iterator value ^ iterator value\r\n    # using the pow function and store it in a variable.\r\n    powervl = pow(k, k)\r\n    # Add the above variable to the resltsum\r\n    resltsum = resltsum+powervl\r\n\r\n# Print the resltsum value which is the result of the series till the given Number N.\r\nprint(\r\n    'The sum of the series till the given number {', gvnNumbr, '} is :', resltsum)"}
{"nl": "Given a matrix of 2D array of n rows and m columns. Print this matrix in ZIG-ZAG fashion as shown in figure.\u00a0\n\n\n\u00a0", "code": "# Program to print matrix in Zig-zag pattern\n\u00a0\nmatrix =[\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 2, 3,],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 4, 5, 6 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 7, 8, 9 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\nrows=3\ncolumns=3\n\u00a0\u00a0\u00a0\nsolution=[[] for i in range(rows+columns-1)]\n\u00a0\nfor i in range(rows):\n\u00a0\u00a0\u00a0\u00a0for j in range(columns):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum=i+j\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(sum%2 ==0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#add at beginning\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0solution[sum].insert(0,matrix[i][j])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#add at end of the list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0solution[sum].append(matrix[i][j])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# print the solution as it as\nfor i in solution:\n\u00a0\u00a0\u00a0\u00a0for j in i:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(j,end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n"}
{"nl": "A string s is called good if there are no two different characters in s that have the same frequency.\nGiven a string s, return the minimum number of characters you need to delete to make s good.\nThe frequency of a character in a string is the number of times it appears in the string. For example, in the string \"aab\", the frequency of 'a' is 2, while the frequency of 'b' is 1.\n \nExample 1:\n\nInput: s = \"aab\"\nOutput: 0\nExplanation: s is already good.\n\nExample 2:\n\nInput: s = \"aaabbbcc\"\nOutput: 2\nExplanation: You can delete two 'b's resulting in the good string \"aaabcc\".\nAnother way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\nExample 3:\n\nInput: s = \"ceabaacb\"\nOutput: 2\nExplanation: You can delete both 'c's resulting in the good string \"eabaab\".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n\n \nConstraints:\n\n1 <= s.length <= 105\ns contains only lowercase English letters.", "code": "class Solution:\n  def minDeletions(self, s: str) -> int:\n  cnt, res, used = collections.Counter(s), 0, set()\n  for ch, freq in cnt.items():\n  while freq > 0 and freq in used:\n  freq -= 1\n  res += 1\n  used.add(freq)\n  return res"}
{"nl": "Scrapy is an open source framework for web-crawling. This framework is written in python and originally made for web scraping. Web scraping can also be used to extract data using API. ScrapingHub provides the whole service to crawl the data from web pages, even for complex web pages.", "code": "# importing scrapy module\r\nimport scrapy\r\n  \r\n  \r\nclass ExtractUrls(scrapy.Spider):\r\n      \r\n    # Name of the spider\r\n    crawled = set()\r\n      \r\n    # Set to avoiding duplicate url\r\n    name = \"extract\"\r\n  \r\n    def start_requests(self):\r\n  \r\n        # Starting url mentioned\r\n        urls = ['https://www.geeksforgeeks.org', ]\r\n        for url in urls:\r\n            yield scrapy.Request(url = url,\r\n                     callback = self.parse)\r\n  \r\n    def parse(self, response):\r\n        title = response.css('title::text').extract_first()\r\n        links = response.css('a::attr(href)').extract()\r\n        for link in links:\r\n            yield\r\n        {\r\n            'title': title,\r\n            'links': link\r\n        }\r\n  \r\n        if ('geeksforgeeks' in link and\r\n               link not in self.crawled):\r\n            self.crawled.update(link)\r\n            yield scrapy.Request(url = link,\r\n                      callback = self.parse)"}
{"nl": "Given a number, the task is to find the smallest number which divides the given number in Python.", "code": "# Give the number as static input and store it in a variable.\ngvnNumb = 91\n# Loop from 2 to given number using For loop.\nfor itervalue in range(2, gvnNumb+1):\n    # Check if the iterator value divides the given number\n    # perfectly using the if statement and modulus operator.\n    if(gvnNumb % itervalue == 0):\n        # Print the iterator value.\n\n        print(\n            'The smallest which divides the given number [', gvnNumb, '] =', itervalue)\n        # Break the loop using the break statement.\n        break"}
{"nl": "This tutorial will show you how to use Python to count the number of words in a file. One Python program will be written to count the total number of words in a text file. The path to the file will be passed to the application as an input. This tutorial will teach you how to open a file and read its contents in Python. You\u2019ll also learn how to get a list of all the words in a string.\n\n\n \nPython provides a wide range of useful techniques for working with files. We don\u2019t require any additional modules to work on any file. Using these methods, you may quickly read from a file, write to a file, or even append any content to a file.", "code": "# taking a variable which stores count and initializing it to 0\nword_count = 0\n# given file name\ngiven_filename = \"wordsfile.txt\"\n# opening the file in reading mode\nwith open(given_filename, 'r') as givenfile:\n    # traversing the lines of file using for loop\n    for fileline in givenfile:\n      # split the line into words using split() function.\n      # increasing the word count by counting the number of words in the file\n        word_count += len(fileline.split())\n\nprint(\"The total number of files present in the given file = \", word_count)"}
{"nl": "Given an N x N matrix, find a k x k submatrix where k <= N and k >= 1, such that sum of all the elements in submatrix is maximum. The input matrix can contain zero, positive and negative numbers.\n\n\n\u00a0", "code": "# An efficient Python3 program to find maximum sum\n# sub-square matrix\n\u00a0\n# Size of given matrix\nN = 5\n\u00a0\n# A O(n^2) function to the maximum sum sub-\n# squares of size k x k in a given square\n# matrix of size n x n\ndef printMaxSumSub(mat, k):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# k must be smaller than or equal to n\n\u00a0\u00a0\u00a0\u00a0if (k > N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 1: PREPROCESSING\n\u00a0\u00a0\u00a0\u00a0# To store sums of all strips of size k x 1\n\u00a0\u00a0\u00a0\u00a0stripSum = [[0 for j in range(N)] for i in range(N)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Go column by column\n\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum of first k x 1 rectangle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in this column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += mat[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stripSum[0][j] = sum;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum of remaining rectangles\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(1,N-k+1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += (mat[i+k-1][j] - mat[i-1][j]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stripSum[i][j] = sum;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# max_sum stores maximum sum and its\n\u00a0\u00a0\u00a0\u00a0# position in matrix\n\u00a0\u00a0\u00a0\u00a0max_sum = -1000000000\n\u00a0\u00a0\u00a0\u00a0i_ind = 0\n\u00a0\u00a0\u00a0\u00a0j_ind = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2: CALCULATE SUM of Sub-Squares using stripSum[][]\n\u00a0\u00a0\u00a0\u00a0for i in range(N-k+1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate and print sum of first subsquare\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in this row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += stripSum[i][j];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update max_sum and position of result\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sum > max_sum):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_sum = sum;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i_ind = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j_ind = 0\n\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum of remaining squares in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current row by removing the leftmost\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# strip of previous sub-square and adding\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# a new strip\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(1,N-k+1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += (stripSum[i][j+k-1] - stripSum[i][j-1]);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update max_sum and position of result\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sum > max_sum):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_sum = sum;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i_ind = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j_ind = j\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the result matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i+i_ind][j+j_ind], end = ' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver program to test above function\nmat = [[1, 1, 1, 1, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 2, 2, 2, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[3, 8, 6, 7, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 4, 4, 4, 4],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[5, 5, 5, 5, 5],\n\u00a0\u00a0\u00a0\u00a0];\nk = 3;\nprint(\"Maximum sum 3 x 3 matrix is\");\nprintMaxSumSub(mat, k);\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "Given a binary search tree which is also a complete binary tree. The problem is to convert the given BST into a Min Heap with the condition that all the values in the left subtree of a node should be less than all the values in the right subtree of the node. This condition is applied on all the nodes in the so converted Min Heap.\u00a0\n\n\n\u00a0", "code": "# C++ implementation to convert the\n# given BST to Min Heap\n\u00a0\n# structure of a node of BST\n\u00a0\n\u00a0\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# function for the inorder traversal\n# of the tree so as to store the node\n# values in 'arr' in sorted order\n\u00a0\n\u00a0\ndef inorderTraversal(root, arr):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# first recur on left subtree\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root.left, arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# then copy the data of the node\n\u00a0\u00a0\u00a0\u00a0arr.append(root.data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# now recur for right subtree\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root.right, arr)\n\u00a0\n# function to convert the given\n# BST to MIN HEAP performs preorder\n# traversal of the tree\n\u00a0\n\u00a0\ndef BSTToMinHeap(root, arr, i):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# first copy data at index 'i' of\n\u00a0\u00a0\u00a0\u00a0# 'arr' to the node\n\u00a0\u00a0\u00a0\u00a0i[0] += 1\n\u00a0\u00a0\u00a0\u00a0root.data = arr[i[0]]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# then recur on left subtree\n\u00a0\u00a0\u00a0\u00a0BSTToMinHeap(root.left, arr, i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# now recur on right subtree\n\u00a0\u00a0\u00a0\u00a0BSTToMinHeap(root.right, arr, i)\n\u00a0\n# utility function to convert the\n# given BST to MIN HEAP\n\u00a0\n\u00a0\ndef convertToMinHeapUtil(root):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# vector to store the data of\n\u00a0\u00a0\u00a0\u00a0# all the nodes of the BST\n\u00a0\u00a0\u00a0\u00a0arr = []\n\u00a0\u00a0\u00a0\u00a0i = [-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# inorder traversal to populate 'arr'\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root, arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# BST to MIN HEAP conversion\n\u00a0\u00a0\u00a0\u00a0BSTToMinHeap(root, arr, i)\n\u00a0\n# function for the preorder traversal\n# of the tree\n\u00a0\n\u00a0\ndef preorderTraversal(root):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# first print the root's data\n\u00a0\u00a0\u00a0\u00a0print(root.data, end=\" \")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# then recur on left subtree\n\u00a0\u00a0\u00a0\u00a0preorderTraversal(root.left)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# now recur on right subtree\n\u00a0\u00a0\u00a0\u00a0preorderTraversal(root.right)\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# BST formation\n\u00a0\u00a0\u00a0\u00a0root = Node(4)\n\u00a0\u00a0\u00a0\u00a0root.left = Node(2)\n\u00a0\u00a0\u00a0\u00a0root.right = Node(6)\n\u00a0\u00a0\u00a0\u00a0root.left.left = Node(1)\n\u00a0\u00a0\u00a0\u00a0root.left.right = Node(3)\n\u00a0\u00a0\u00a0\u00a0root.right.left = Node(5)\n\u00a0\u00a0\u00a0\u00a0root.right.right = Node(7)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0convertToMinHeapUtil(root)\n\u00a0\u00a0\u00a0\u00a0print(\"Preorder Traversal:\")\n\u00a0\u00a0\u00a0\u00a0preorderTraversal(root)\n\u00a0\n# This code is contributed\n# by PranchalK\n"}
{"nl": "Given a decimal number and the task is to get the respective binary number for a given number.", "code": "# Give the number as user input using the int(input()) function and store it in a variable.\ngvn_numb = int(input(\"Enter some random Number = \"))\n# Take a variable say 'a 'and initialize its value with 1.\na = 1\n# Take another variable say binry_num and initialize its value with 0.\nbinry_num = 0\nprint(\"The Binary value of the given decimal number {\", gvn_numb, \"} is: \")\n# Loop till the given number is not equal to zero using the while loop.\nwhile (gvn_numb != 0):\n  # Inside the loop, calculate the value of the given number modulus 2 and\n    # store it in a variable remdr.\n    remdr = gvn_numb % 2\n  # Divide the given number by 2 and store it in the same variable gvn_numb.\n    gvn_numb = gvn_numb // 2\n    # Multiply a with the remdr and store it in another variable b\n    b = (remdr * a)\n    # Add b to the binry_num and convert to int using the int() function.\n    # Store it in the same variable binry_num.\n    binry_num = int(binry_num + b)\n    # Multiply a with 10 and Store it in the same variable 'a'.\n    a = int(a * 10)\n # Print the binry_num to get the binary value of the given decimal number.\nprint(binry_num)"}
{"nl": "Write a function detectAndRemoveLoop() that checks whether a given Linked List contains loop and if loop is present then removes the loop and returns true. If the list doesn\u2019t contain loop then it returns false. ", "code": "\n# Python program to detect and remove loop in linked list\n \n# Node class\nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    def detectAndRemoveLoop(self):\n        slow_p = fast_p = self.head\n         \n        while(slow_p and fast_p and fast_p.next):\n            slow_p = slow_p.next\n            fast_p = fast_p.next.next\n \n            # If slow_p and fast_p meet at some point then\n            # there is a loop\n            if slow_p == fast_p:\n                self.removeLoop(slow_p)\n         \n                # Return 1 to indicate that loop is found\n                return 1\n         \n        # Return 0 to indicate that there is no loop\n        return 0\n \n    # Function to remove loop\n    # loop_node --> pointer to one of the loop nodes\n    # head --> Pointer to the start node of the linked list\n    def removeLoop(self, loop_node):\n        ptr1 = loop_node\n        ptr2 = loop_node\n         \n        # Count the number of nodes in loop\n        k = 1\n        while(ptr1.next != ptr2):\n            ptr1 = ptr1.next\n            k += 1\n \n        # Fix one pointer to head\n        ptr1 = self.head\n         \n        # And the other pointer to k nodes after head\n        ptr2 = self.head\n        for i in range(k):\n            ptr2 = ptr2.next\n \n        # Move both pointers at the same place\n        # they will meet at loop starting node\n        while(ptr2 != ptr1):\n            ptr1 = ptr1.next\n            ptr2 = ptr2.next\n \n        # Get pointer to the last node\n        while(ptr2.next != ptr1):\n            ptr2 = ptr2.next\n \n        # Set the next node of the loop ending node\n        # to fix the loop\n        ptr2.next = None\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data, end = ' ')\n            temp = temp.next\n "}
{"nl": "You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\nFind any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.\nReturn a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.\n \nExample 1:\n\nInput: rowSum = [3,8], colSum = [4,7]\nOutput: [[3,0],\n  [1,7]]\nExplanation: \n0th row: 3 + 0 = 3 == rowSum[0]\n1st row: 1 + 7 = 8 == rowSum[1]\n0th column: 3 + 1 = 4 == colSum[0]\n1st column: 0 + 7 = 7 == colSum[1]\nThe row and column sums match, and all matrix elements are non-negative.\nAnother possible matrix is: [[1,2],\n  [3,5]]\n\nExample 2:\n\nInput: rowSum = [5,7,10], colSum = [8,6,8]\nOutput: [[0,5,0],\n  [6,1,0],\n  [2,0,8]]\n\n \nConstraints:\n\n1 <= rowSum.length, colSum.length <= 500\n0 <= rowSum[i], colSum[i] <= 108\nsum(rows) == sum(columns)", "code": "def restoreMatrix(self, row, col):\n  m, n = len(row), len(col)\n  A = [[0] * n for i in xrange(m)]\n  for i in xrange(m):\n  for j in xrange(n):\n  A[i][j] = min(row[i], col[j])\n  row[i] -= A[i][j]\n  col[j] -= A[i][j]\n  return A"}
{"nl": "You are given a sequence of N integers and Q queries. In each query, you are given two parameters L and R. You have to find the smallest integer X such that 0 <= X < 2^31 and the sum of XOR of x with all elements is range [L, R] is maximum possible.", "code": "# Python3 program to find smallest integer X\r\n# such that sum of its XOR with range is\r\n# maximum.\r\nimport math\r\n\r\none = [[0 for x in range(32)]\r\n\tfor y in range(100001)]\r\nMAX = 2147483647\r\n\r\n# Function to make prefix array\r\n# which counts 1's of each bit\r\n# up to that number\r\ndef make_prefix(A, n) :\r\n\tglobal one, MAX\r\n\t\r\n\tfor j in range(0 , 32) :\r\n\t\tone[0][j] = 0\r\n\r\n\t# Making a prefix array which\r\n\t# sums number of 1's up to\r\n\t# that position\r\n\tfor i in range(1, n+1) :\r\n\t\ta = A[i - 1]\r\n\t\tfor j in range(0 , 32) :\r\n\t\t\r\n\t\t\tx = int(math.pow(2, j))\r\n\r\n\t\t\t# If j-th bit of a number\r\n\t\t\t# is set then add one to\r\n\t\t\t# previously counted 1's\r\n\t\t\tif (a & x) :\r\n\t\t\t\tone[i][j] = 1 + one[i - 1][j]\r\n\t\t\telse :\r\n\t\t\t\tone[i][j] = one[i - 1][j]\r\n\t\t\r\n# Function to find X\r\ndef Solve(L, R) :\r\n\r\n\tglobal one, MAX\r\n\tl = L\r\n\tr = R\r\n\ttot_bits = r - l + 1\r\n\r\n\t# Initially taking maximum\r\n\t# value all bits 1\r\n\tX = MAX\r\n\r\n\t# Iterating over each bit\r\n\tfor i in range(0, 31) :\r\n\t\r\n\t\t# get 1's at ith bit between the\r\n\t\t# range L-R by subtracting 1's till\r\n\t\t# Rth number - 1's till L-1th number\r\n\t\t\r\n\t\tx = one[r][i] - one[l - 1][i]\r\n\r\n\t\t# If 1's are more than or equal\r\n\t\t# to 0's then unset the ith bit\r\n\t\t# from answer\r\n\t\tif (x >= (tot_bits - x)) :\r\n\t\t\t\r\n\t\t\tith_bit = pow(2, i)\r\n\r\n\t\t\t# Set ith bit to 0 by\r\n\t\t\t# doing Xor with 1\r\n\t\t\tX = X ^ ith_bit\r\n\treturn X\r\n\r\n# Driver Code\r\nn = 5\r\nq = 3\r\nA = [ 210, 11, 48, 22, 133 ]\r\nL = [ 1, 4, 2 ]\r\nR = [ 3, 14, 4 ]\r\n\r\nmake_prefix(A, n)\r\n\r\nfor j in range(0, q) :\r\n\tprint (Solve(L[j], R[j]),end=\"\\n\")\r\n\t\r\n# This code is contributed by\r\n# Manish Shaw(manishshaw1)\r"}
{"nl": "Create a checker board generator, which takes as inputs n and 2 elements to generate an n x n checkerboard with those two elements as alternating squares.\nExamples\nchecker_board(2, 7, 6) \u279e [\n  [7, 6],\n  [6, 7]\n]\n\nchecker_board(3, \"A\", \"B\") \u279e [\n  [\"A\", \"B\", \"A\"],\n  [\"B\", \"A\", \"B\"],\n  [\"A\", \"B\", \"A\"]\n]\n\nchecker_board(4, \"c\", \"d\") \u279e [\n  [\"c\", \"d\", \"c\", \"d\"],\n  [\"d\", \"c\", \"d\", \"c\"],\n  [\"c\", \"d\", \"c\", \"d\"],\n  [\"d\", \"c\", \"d\", \"c\"]\n]\n\nchecker_board(4, \"c\", \"c\") \u279e \"invalid\"\nNotes\nBoth elements can be either strings or integers.\nThe first element should be on the upper left corner of the checker board. e.g. \"c\", not \"d\" should be element [0][0] for example 3.\nReturn \"invalid\" if both inputs are identical (see example 4).", "code": "def checker_board(n, el1, el2):\n    if el1==el2: return 'invalid'\n    return [[el2 if (i+j)%2 else el1 for i in range(n)] for j in range(n)]"}
{"nl": "This program checks whether given three sides of a triangle forms a valid triangle or not.\r\nIn mathematics, the triangle inequality states that for any triangle to be valid, the sum of the lengths of any two sides must be greater than or equal to the length of the remaining side.\r\nIf a, b and c are three sides of triangle then following conditions must be satisfied for a valid triangle.\r\n\r\na + b \u2264 c\r\n\r\nb + c \u2264 a\r\n\r\nc + a \u2264 b", "code": "# Validity of Triangle given sides\r\n\r\n# Function definition to check validity\r\ndef is_valid_triangle(a,b,c):\r\n    if a+b>=c and b+c>=a and c+a>=b:\r\n        return True\r\n    else:\r\n        return False\r\n\r\n# Reading Three Sides\r\nside_a = float(input('Enter length of side a: '))\r\nside_b = float(input('Enter length of side b: '))\r\nside_c = float(input('Enter length of side c: '))\r\n\r\n# Function call & making decision\r\n\r\nif is_valid_triangle(side_a, side_b, side_c):\r\n    print('Triangle is Valid.')\r\nelse:\r\n    print('Triangle is Invalid.')"}
{"nl": "Given a function foo() that returns integers from 1 to 5 with equal probability, write a function that returns integers from 1 to 7 with equal probability using foo() only. Minimize the number of calls to foo() method. Also, use of any other library function is not allowed and no floating point arithmetic allowed.", "code": "# Python3 code to demonstrate\n# expression returns each integer\n# from 1 to 25 exactly once\n\nif name == '__main__':\n\t\n\tfor first in range(1, 6):\n\t\tfor second in range(1, 6):\n\t\t\t\tprint(5 * first + second - 5)\n\n# This code is contributed by Smitha Dinesh Semwal.\n"}
{"nl": "Given a list, the task is to print the Degrees and Radians value of every element in the given list in Python.\r\n\r\nIn this article, you will learn about Python\u2019s degrees() and radians() methods. The data will be converted to degrees() and radians() in Python by using the math module. Ship position, etc., will be used for mathematical solving.\r\n\r\nDegrees:\r\n\r\nThe degrees are a unit of angle measurement, and all angels utilize them. If you learn that a circle has 360 degrees, you will be able to use it.\r\n\r\nThe degree symbol will be obtained by using the Chr(176) technique.\r\n\r\nRadians:\r\n\r\nIn trigonometry, it is a unit of measure of angels that will be used instead of degrees, whereas the circle contains only 360 degrees, a full circle is just over 6 radians. A complete circle has two pi radians.", "code": "# Import the math function using the import function.\r\nimport math\r\n# Give the list as static input and store it in a variable.\r\ngivenlist = [8, 1, 9, 12, 45, 1, 7, 3]\r\n# Traverse the given list using For loop.\r\nfor elementval in givenlist:\r\n    # Calculate the value of the degree of the given iterator\r\n    # value using math.degrees() function.\r\n    degreevalu = math.degrees(elementval)\r\n    # Calculate the value of the radians of the given iterator value\r\n    # using math.radians () function.\r\n    radianvalu = math.radians(elementval)\r\n    # Print the degree and radians value of the element.\r\n    print('The degree value of the element', elementval, ' = ', degreevalu)\r\n    print('The radians value of the element', elementval, ' = ', radianvalu)"}
{"nl": "The best and excellent way to learn a java programming language is by practicing Simple Java Program Examples as it includes basic to advanced levels of concepts.\n \n Recursion:\n \n Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.\n \n Given a string and a character the task is to count the occurrence of the given letter in the string using recursive approach in Python.\n \n Examples:\n \n Example1:\n \n Input:\n \n Enter some random string= btechgeeks\n Enter some random character= e\n Output:\n \n Priting the count of e in the given string btechgeeks = 3\n Example2:\n \n Input:\n \n Enter some random string= symphony \n Enter some random character= y\n Output:\n \n Printing the count of y in the given string symphony = 2", "code": "# function which returns count of the given character in the string recursively.\n def checkCountRecursively(given_string, character):\n  # Pass the fundamental constraint that the string is not empty.\n  if not given_string:\n  return 0\n  # If the initial character of the string is the same as the character\n  # taken from the user, increment the count.\n  elif given_string[0] == character:\n  return 1+checkCountRecursively(given_string[1:], character)\n  # The string is progressed in either direction, and the number of times\n  # the letter appears in the string is printed.\n  else:\n  return checkCountRecursively(given_string[1:], character)\n # given string as static input\n given_string = 'btechgeeks'\n # given character as static input\n given_character = 'e'\n # passing the given character and given string to checkCountRecursively function\n print('Priting the count of', given_character, 'in the given string',\n  given_string, '=', checkCountRecursively(given_string, given_character))"}
{"nl": "A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.\n\nThe customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.\n\nFor example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.\nGiven a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.", "code": "class Solution:\n    def minimumCost(self, cost: List[int]) -> int:\n        save = []\n        cost.sort()  # sort the list cost and since you buy two expensive ones get one for free you always get the one close to the two expensive for free\n        lencost = len(cost)\n        \n        if lencost%3 == 0: # if the length of cost is a product of 3, then first set mincost to 0, then add each number with index that's divisible by 3 and the min cost would be sum(cost) - sum of each freebie\n            mincost = 0\n            for i in range(lencost):\n                if i%3 == 0:\n                    mincost += cost[i]\n            mincost = sum(cost) - mincost\n            return mincost\n        \n        elif lencost >= 3: # if lencost is bigger than 3, then only need to start counting the items that's not in the first indexes\n            mincost = 0\n            for i in range(lencost%3, lencost):\n                if (i-lencost%3)%3 == 0:\n                    mincost += cost[i]\n            mincost = sum(cost) - mincost\n            return mincost\n        \n        else: # if lencost is less than 3, the cost if the sum of cost\n            lencost <3\n            return sum(cost)"}
{"nl": "Given two expressions in the form of strings. The task is to compare them and check if they are similar. Expressions consist of lowercase alphabets, \u2018+\u2019, \u2018-\u2018 and \u2018( )\u2019.\n\n\u00a0", "code": "# Python3 program to check if two expressions\n# evaluate to same.\nMAX_CHAR = 26;\n\u00a0\n# Return local sign of the operand. For example,\n# in the expr a-b-(c), local signs of the operands\n# are +a, -b, +c\ndef adjSign(s, i):\n\u00a0\u00a0if (i == 0):\n\u00a0\u00a0\u00a0\u00a0return True;\n\u00a0\u00a0if (s[i - 1] == '-'):\n\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0return True;\n\u00a0\n# Evaluate expressions into the count vector of\n# the 26 alphabets.If add is True, then add count\n# to the count vector of the alphabets, else remove\n# count from the count vector.\ndef eval(s, v, add):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# stack stores the global sign\n\u00a0\u00a0# for operands.\n\u00a0\u00a0stk = []\n\u00a0\u00a0stk.append(True);\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# + means True\n\u00a0\u00a0# global sign is positive initially\n\u00a0\u00a0i = 0;\n\u00a0\n\u00a0\u00a0while (i < len(s)):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (s[i] == '+' or s[i] == '-'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (s[i] == '('):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# global sign for the bracket is\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pushed to the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (adjSign(s, i)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(stk[-1]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(not stk[-1]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# global sign is popped out which\n\u00a0\u00a0\u00a0\u00a0# was pushed in for the last bracket\n\u00a0\u00a0\u00a0\u00a0elif (s[i] == ')'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.pop();\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# global sign is positive (we use different\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# values in two calls of functions so that\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# we finally check if all vector elements\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# are 0.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (stk[-1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v[ord(s[i]) - ord('a')] += (1 if add else -1) if adjSign(s, i) else (-1 if add else 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# global sign is negative here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v[ord(s[i]) - ord('a')] += (-1 if add else 1) if adjSign(s, i) else (1 if add else -1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\n# Returns True if expr1 and expr2 represent\n# same expressions\ndef areSame(expr1, expr2):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# Create a vector for all operands and\n\u00a0\u00a0# initialize the vector as 0.\n\u00a0\u00a0v = [0 for i in range(MAX_CHAR)];\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# Put signs of all operands in expr1\n\u00a0\u00a0eval(expr1, v, True);\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# Subtract signs of operands in expr2\n\u00a0\u00a0eval(expr2, v, False);\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# If expressions are same, vector must\n\u00a0\u00a0# be 0.\n\u00a0\u00a0for i in range(MAX_CHAR):\n\u00a0\u00a0\u00a0\u00a0if (v[i] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0return True;\n\u00a0\n# Driver Code\nif __name__=='__main__':\n\u00a0\u00a0expr1 = \"-(a+b+c)\"\n\u00a0\u00a0expr2 = \"-a-b-c\";\n\u00a0\u00a0if (areSame(expr1, expr2)):\n\u00a0\u00a0\u00a0\u00a0print(\"Yes\");\n\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0print(\"No\");\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by rutvik_56.\n"}
{"nl": "The tricky thing here is that a leap year in the Gregorian calendar occurs:\n\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\nFor example, 1997 is not a leap year, but 1996 is. 1900 is not a leap year, but 2000 is.", "code": "def leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)"}
{"nl": "Files in Python:\n\nOne of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.\n\nAlso, if you didn\u2019t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.\n\n\n\nConsider the following scenario: you\u2019re planning to construct a large Python project with a large number of workflows. Then it\u2019s unavoidable that you don\u2019t make a log file. You\u2019ll also be handling the log file\u2019s read and write activities. Debugging huge applications with log files is a terrific way to go. It\u2019s usually better to consider a scalable design from the start, as you won\u2019t be sorry later if you didn\u2019t.\n\nGiven a file, the task is to read a random line from the given File in Python", "code": "# Import random module using the import keyword\nimport random\n# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Get all the lines of the file using the read(), splitlines() functions and \n  # Store it in a variable\n  file_lines = givenfilecontent.read().splitlines()\n  # Print a random line from the given file using the random.choice() function\n  # by passing the above lines as an argument to it\n  print(random.choice(file_lines))"}
{"nl": "Find the Total Number of Bits Needed to be Flipped to Convert One Number into Another Using XOR Operator and Built-in Count function(Static Input)", "code": "# function which accepts the two numbers as arguments\r\n# and return the number of bits to be flipped\r\n\r\n\r\ndef countFlipbits(firstnumber, secondnumber):\r\n    # Calculate the xor value of the two numbers and store it in a result say resultnum.\r\n    resultnum = firstnumber ^ secondnumber\r\n    # Convert this resultnum to binary and calculate the total\r\n    # number of sets bits in it using the count() function.\r\n    binNumber = bin(resultnum)\r\n    setbitCounter = binNumber.count('1')\r\n    return setbitCounter\r\n\r\n\r\n# Driver Code\r\n\r\n# Driver Code\r\n# Give the two numbers as static input and store them in two separate variables.\r\nfirstnumber = 18\r\nsecondnumber = 68\r\n# Pass the given two numbers as arguments to the ( function which calculates the total number\r\n# of bits to be flipped to convert one number into another.\r\nprint('Binary representations of the given two numbers are :')\r\nprint(firstnumber, '=', bin(firstnumber)[2:])\r\nprint(secondnumber, '=', bin(secondnumber)[2:])\r\nprint('The total number of bits to be flipped =',\r\n      countFlipbits(firstnumber, secondnumber))"}
{"nl": "Given an integer, create a function that returns the next prime. If the number is prime, return the number itself.\nExamples\nnext_prime(12) \u279e 13\n\nnext_prime(24) \u279e 29\n\nnext_prime(11) \u279e 11\n# 11 is a prime, so we return the number itself.\nNotes\nN/A", "code": "def next_prime(num):\n  while [i for i in range(2, num) if num%i==0]:\n    num+=1\n  return num"}
{"nl": "Definition and Usage\r\nThe pop() method removes a random item from the set.\r\n\r\nThis method returns the removed item.", "code": "fruits = {\"apple\", \"banana\", \"cherry\"}\r\n\r\nfruits.pop()\r\n\r\nprint(fruits)"}
{"nl": "Let's say that there exists a machine that gives out free coins, but with a twist!\nSeparating two people is a wall, and this machine is placed in such a way that both people are able to access it. Spending a coin in this machine will give the person on the other side 3 coins and vice versa.\nIf both people continually spend coins for each other (SHARING), then they'll both gain a net profit of 2 coins per turn. However, there is always the possibility for someone to act selfishly (STEALING): they spend no coins, yet they still receive the generous 3 coin gift from the other person!\nHere's an example of Red taking advantage of Green!\nThe Challenge\nAssuming that both people start with 3 coins each, create a function that calculates both people's final number of coins. You will be given two lists of strings, with each string being the words 'share' or 'steal'.\nExamples\nget_coin_balances([\"share\"], [\"share\"]) \u279e [5, 5]\n# Both people spend one coin, and receive 3 coins each.\n\nget_coin_balances([\"steal\"], [\"share\"]) \u279e [6, 2]\n# Person 1 gains 3 coins, while person 2 loses a coin.\n\nget_coin_balances([\"steal\"], [\"steal\"]) \u279e [3, 3]\n# Neither person spends any coins and so no one gets rewarded.\n\nget_coin_balances([\"share\", \"share\", \"share\"], [\"steal\", \"share\", \"steal\"]) \u279e [3, 11]\nNotes\nNo tests will include a negative number of coins.\nAll words will be given in lowercase.\nThis challenge is adapted from a famous game theory example called the Prisoner's Dilemma, which you can learn more about in the Resources tab.", "code": "def get_coin_balances(lst1, lst2):\n  a, b = 3, 3\n  for i, j in zip(lst1, lst2):\n    if i == 'share':  a, b = a-1, b+3\n    if j == 'share':  a, b = a+3, b-1\n  return [a, b]"}
{"nl": "You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.\nThe array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.\nReturn the minimum number of moves required to make nums complementary.\n \nExample 1:\n\nInput: nums = [1,2,4,3], limit = 4\nOutput: 1\nExplanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).\nnums[0] + nums[3] = 1 + 3 = 4.\nnums[1] + nums[2] = 2 + 2 = 4.\nnums[2] + nums[1] = 2 + 2 = 4.\nnums[3] + nums[0] = 3 + 1 = 4.\nTherefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.\n\nExample 2:\n\nInput: nums = [1,2,2,1], limit = 2\nOutput: 2\nExplanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.\n\nExample 3:\n\nInput: nums = [1,2,1,2], limit = 2\nOutput: 0\nExplanation: nums is already complementary.\n\n \nConstraints:\n\nn == nums.length\n2 <= n <= 105\n1 <= nums[i] <= limit <= 105\nn is even.", "code": "class Solution:\n  def minMoves(self, nums: List[int], limit: int) -> int:\n  delta = collections.Counter()\n  n = len(nums)\n  for i in range(n // 2):\n  a, b = nums[i], nums[n - 1 - i]\n  delta[2] += 2\n  delta[min(a, b) + 1] -= 1\n  delta[a + b] -= 1\n  delta[a + b + 1] += 1\n  delta[max(a, b) + limit + 1] += 1\n  \n  curr = 0  \n  res = math.inf\n  for i in range(2, 2 * limit + 1):\n  curr += delta[i]\n  res = min(res, curr)\n  return res"}
{"nl": "Access Items\r\nYou access the list items by referring to the index number:", "code": "#Print the second item of the list:\r\n\r\nthislist = [\"apple\", \"banana\", \"cherry\"]\r\nprint(thislist[1])"}
{"nl": "Find the Greatest Digit in a Number Using list() Function (User input)", "code": "#Give the number as user input using int(input()) and store it in a variable.\r\ngvn_num = int(input(\"Enter some random number = \"))\r\n# Convert the given number into string using str() function and\r\n# store it in another variable. \r\nstr_numbr = str(gvn_num)\r\n# Convert the above obtained string number into list of digits using bulit-in list()\r\n# method and store it in another variable.\r\nlst = list(str_numbr)\r\n# Find the maximum of list of digits using bulit-in max() function\r\n# and store it in another variable.\r\nmaxim_digit = max(lst)\r\n# Print the greatest digit in a given number.\r\nprint(\"The maximum digit in given number {\", gvn_num, \"} = \", maxim_digit)"}
{"nl": "Consider a binary tree whose nodes have ids from 1 to n where n is number of nodes in the tree. The tree is given as a collection of n pairs, where every pair represents node id and sum of children ids.\nExamples: \n \n\nInput : 1 5\n        2 0\n        3 0\n        4 0\n        5 5\n        6 5\nOutput: 6\nExplanation: In this case, two trees can \nbe made as follows and 6 is the root node.\n   6          6\n   \\         / \\\n    5       1   4\n   / \\       \\\n  1   4       5\n / \\         / \\\n2   3       2   3\n\nInput : 4 0\nOutput: 4\nExplanation: Clearly 4 does \nnot have any children and is the\nonly node i.e., the root node.", "code": "\"\"\"Find root of tree where children\nsum for every node id is given\"\"\"\n\ndef findRoot(arr, n) :\n\n\t# Every node appears once as an id, and\n\t# every node except for the root appears\n\t# once in a sum. So if we subtract all\n\t# the sums from all the ids, we're left\n\t# with the root id.\n\troot = 0\n\tfor i in range(n):\n\t\troot += (arr[i][0] - arr[i][1])\n\treturn root\n\t\t\t\t\t\t\n# Driver Code\nif __name__ == '__main__':\n\n\tarr = [[1, 5], [2, 0],\n\t\t[3, 0], [4, 0],\n\t\t[5, 5], [6, 5]]\n\tn = len(arr)\n\tprint(findRoot(arr, n))\n\n# This code is contributed\n# by SHUBHAMSINGH10\n"}
{"nl": "Sort a List According to the Length of the Elements", "code": "def lengthSort(given_list):\r\n    # sorting the given list by length of elements of the given list\r\n    given_list = sorted(given_list, key=len)\r\n    # return the list\r\n    return given_list\r\n\r\n\r\n# given list\r\ngiven_list = list(\r\n    input(\"Enter the elements of the given list separated by spaces\").split())\r\n# printing the given list before sorting according to length\r\nprint(\"printing the given list before sorting according to length : \")\r\nprint(given_list)\r\n# passing the given_list to lengthSort function to sort\r\n# the list according to the length of the elements of the given list\r\n# printing the given list before sorting according to length\r\nprint(\"printing the given list after sorting according to length : \")\r\nprint(lengthSort(given_list))"}
{"nl": "Files in Python:\n\nOne of the most important subjects for programmers and automation testers is Python file handling (also known as File I/O). It is necessary to work with files in order to write to or read data from them.\n\nAlso, if you didn\u2019t know, I/O operations are the most expensive processes where a programme can go wrong. As a result, you must use extreme caution while implementing file processing for reporting or any other reason. Optimizing a single file action can help in the creation of a high-performing application or a reliable automated software testing solution.\n\n\n\nConsider the following scenario: you\u2019re planning to construct a large Python project with a large number of workflows. Then it\u2019s unavoidable that you don\u2019t make a log file. You\u2019ll also be handling the log file\u2019s read and write activities. Debugging huge applications with log files is a terrific way to go. It\u2019s usually better to consider a scalable design from the start, as you won\u2019t be sorry later if you didn\u2019t.\n\nGiven a file, the task is to count the number of digits in a given file in Python.", "code": "# Make a single variable to store the path of the file. This is a constant value. \n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Pass the given filename, r (represents read only) as arguments to the open() function\n# to open the given file\nfile = open(givenFilename,\"r\")\n# Read the above file using the read() function(get the content) and store it in a variable\nfiletext = file.read()\n# Take a variable(which gives the count of digits in a file) and initialize its value with zero.\ndigit_cnt = 0\n# Iterate in the above text of the file using the for loop\nfor chr in filetext:\n  # Check if each character of the file text is digit or not using the isdigit() function\n  # and if conditional statement\n  if chr.isdigit():\n  # If it is true, then increment the value of the above initialized \n  # variable(digit_cnt) by 1\n  digit_cnt += 1\n# Print the count of number of digits in a given file\nprint(\"The count of number of digits in a given file = \",digit_cnt)\n# Close the above file\nfile.close()"}
{"nl": "This python program finds smallest of two numbers given by user.\r\nFirst, two numbers are read from user and stored in variable first and second. After that decision of smallest in the program is made using python's if else statement using relational operators like <,>, <=, <= , etc", "code": "# Finding smallest of two numbers\r\n\r\n# Reading numbers\r\nfirst = float(input('Enter first number: '))\r\nsecond = float(input('Enter second number: '))\r\n\r\n# Making decision and displaying\r\nif first < second:\r\n    small = first\r\nelse:\r\n    small = second\r\n\r\nprint('Smallest = %d' %(small))"}
{"nl": "Given the area(a) and the base(b) of the triangle, the task is to find the minimum height so that a triangle of least area a and base b can be formed.\r\n\r\nKnowing the relationship between the three allows you to calculate the minimum height of a triangle with base \u201cb\u201d and area \u201ca.\u201d\r\n\r\nThe relationship between area, base, and height:\r\n\r\narea = (1/2) * base * height\r\n\r\nAs a result, height can be calculated as follows:\r\n\r\nheight = (2 * area)/ base", "code": "# Import math module using the import keyword.\r\nimport math\r\n\r\n# Create a function to say Smallest_height() which takes the given area and base\r\n# of the triangle as the arguments and returns the minimum height so that a\r\n# triangle of least area and base can be formed.\r\n\r\n\r\ndef Smallest_height(gvn_areaoftri, gvn_baseoftri):\r\n    # Inside the function, calculate the value of (2*gvn_areaoftri)/gvn_baseoftri using\r\n    # the above mathematical formula and store it in another variable.\r\n    rslt = (2*gvn_areaoftri)/gvn_baseoftri\r\n    # Apply math.ceil() function to the above result and return the minimum height.\r\n    return math.ceil(rslt)\r\n\r\n\r\n# Give the area as static input and store it in a variable.\r\ngvn_areaoftri = 6\r\n# Give the base as static input and store it in another variable.\r\ngvn_baseoftri = 3\r\n# Pass the given area and base of the triangle as the arguments to the Smallest_height()\r\n# function and store it in a variable.\r\nmin_heigt = Smallest_height(gvn_areaoftri, gvn_baseoftri)\r\n# Print the above result i.e, minimum height so that a triangle of the least area\r\n# and base can be formed.\r\nprint(\"The minimum height so that a triangle of the least area and base can be formed = \", min_heigt)"}
{"nl": "Exercise 4: Unpack the tuple into 4 variables", "code": "tuple1 = (10, 20, 30, 40)\r\n\r\n# unpack tuple into 4 variables\r\na, b, c, d = tuple1\r\nprint(a)\r\nprint(b)\r\nprint(c)\r\nprint(d)"}
{"nl": "Write a GetNth() function that takes a linked list and an integer index and returns the data value stored in the node at that index position. \n\nExample: Input:  1->10->30->14,  index = 2\nOutput: 30  \nThe node at index 2 is 30", "code": "# Python program to find n'th node from end using slow\n# and fast pointer\n\n# Node class\nclass Node:\n\n        # Constructor to initialize the node object\n        def __init__(self, data):\n                self.data = data\n                self.next = None\n\nclass LinkedList:\n\n        # Function to initialize head\n        def __init__(self):\n                self.head = None\n\n        # Function to insert a new node at the beginning\n        def push(self, new_data):\n                new_node = Node(new_data)\n                new_node.next = self.head\n                self.head = new_node\n\n        def printNthFromLast(self, n):\n                main_ptr = self.head\n                ref_ptr = self.head\n        \n                count = 0\n                if(self.head is not None):\n                        while(count < n ):\n                                if(ref_ptr is None):\n                                        print (\"% d is greater than the no. pf nodes in list\" %(n))\n                                        return\n                                ref_ptr = ref_ptr.next\n                                count += 1\n        \n                if(ref_ptr is None):\n                        self.head = self.head.next\n                        if(self.head is not None):\n                                print(\"Node no. % d from last is % d \"\n                                                                %(n, main_ptr.data))\n                else:\n                \n\n                while(ref_ptr is not None):\n                        main_ptr = main_ptr.next\n                        ref_ptr = ref_ptr.next\n\n                print (\"Node no. % d from last is % d \"\n                                                                        %(n, main_ptr.data))\n\n\nif __name__ == '__main__':\n        llist = LinkedList()\n        llist.push(20)\n        llist.push(4)\n        llist.push(15)\n        llist.push(35)\n\n        llist.printNthFromLast(4)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Write a function that determines if a list is circular. A list is circular if its sublists can be reordered such that each sublist's last element is equal to the next sublist's first element.\nFor example, the list [[1, 1, 1], [9, 2, 3, 4], [4, 1], [1, 2, 5, 7, 9]] is circular because we can re-arrange the elements to create the following list:\n[[9, 2, 3, 4], [4, 1], [1, 1, 1], [1, 2, 5, 7, 9]]\nExamples\nis_circular([[9, 8], [6, 9, 1], [8, 4, 2], [1, 9], [2, 1, 6]]) \u279e True\n# Can be reordered: [[9, 8], [8, 4, 2], [2, 1, 6], [6, 9, 1], [1, 9]]\n\nis_circular([[1, 1], [1, 2]]) \u279e False\n\nis_circular([[2, 1], [1, 2]]) \u279e True\n\nis_circular([[2, 1], [1, 2], [2, 1], [1, 3, 1], [1, 4, 4]]) \u279e False\nNotes\nIn a circular re-ordering, the last sublist's last element must be identical to the first sublist's first element.\nSublists will contain at least one element.", "code": "def is_circular(lst):\n  return sorted(i[0] for i in lst)==sorted(i[-1] for i in lst)"}
{"nl": "Given A binary Tree, how do you count all the full nodes (Nodes which have both children as not NULL) without using recursion and with recursion? Note leaves should not be touched as they have both children as NULL.", "code": "# Python program to count\n# full nodes in a Binary Tree\n# using iterative approach\n\n# A node structure\nclass Node:\n\t# A utility function to create a new node\n\tdef __init__(self ,key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# Iterative Method to count full nodes of binary tree\ndef getfullCount(root):\n\t# Base Case\n\tif root is None:\n\t\treturn 0\n\t\n\t# Create an empty queue for level order traversal\n\tqueue = []\n\n\t# Enqueue Root and initialize count\n\tqueue.append(root)\n\t\t\n\tcount = 0 #initialize count for full nodes\n\twhile(len(queue) > 0):\n\t\tnode = queue.pop(0)\n\n\t\t# if it is full node then increment count\n\t\tif node.left is not None and node.right is not None:\n\t\t\tcount = count+1\n\n\t\t# Enqueue left child\n\t\tif node.left is not None:\n\t\t\tqueue.append(node.left)\n\n\t\t# Enqueue right child\n\t\tif node.right is not None:\n\t\t\tqueue.append(node.right)\n\t\t\t\n\treturn count\n\n# Driver Program to test above function\nroot = Node(2)\nroot.left = Node(7)\nroot.right = Node(5)\nroot.left.right = Node(6)\nroot.left.right.left = Node(1)\nroot.left.right.right = Node(11)\nroot.right.right = Node(9)\nroot.right.right.left = Node(4)\n\n\nprint(getfullCount(root))\n"}
{"nl": "What is a matrix:\n \n A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.\n \n Example:\n \n \n \n Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.\n \n In this order, the dimensions of a matrix indicate the number of rows and columns.\n \n \n \n Here as there are 5 rows and 4 columns it is called as 5*4 matrix.\n \n What is matrix subtraction:\n \n Given two matrices of same order(dimensions) then we can easily add the two matrices by doing the difference of corresponding elements in both the matrices.\n \n Example:\n \n \n \n  \n \n Here Matrix C is matrix subtraction of the matrices A and B.\n \n Examples for matrix addition:\n \n Input:\n \n Matrix 1 = 2 3 1\n  1 2 3\n  -3 0 2 \n Matrix 2 = 1 4 2\n  -4 5 -1\n  2 1 4\n Output:\n \n Printing the difference of matrices : \n 1 -1 -1\n 5 -3 4\n -5 -1 -2\n Explanation:\n \n  Here we subtracted the corresponding elements in both matrices", "code": "# given matrix A\n A = [[2, 3, 1],\n  [1, 2, 3],\n  [-3, 0, 2]]\n # given matrix B\n B = [[1, 4, 2],\n  [-4, 5, -1],\n  [2, 1, 4]]\n # Initialize the difference of matrices elements to 0\n matrixDiff = [[0, 0, 0],\n  [0, 0, 0],\n  [0, 0, 0]]\n # Traverse the rows\n for rows in range(len(A)):\n  # Traverse the columns\n  for columns in range(len(A[0])):\n  matrixDiff[rows][columns] = A[rows][columns] - B[rows][columns]\n # printing the difference of matrices\n print(\"Printing the difference of matrices : \")\n for rows in matrixDiff:\n  print(*rows)"}
{"nl": "Create a function that will find all primes below a given number. Return the result as a list.\nExamples\nprimes_below_num(5) \u279e [2, 3, 5]\n\nprimes_below_num(10) \u279e [2, 3, 5, 7]\n\nprimes_below_num(20) \u279e [2, 3, 5, 7, 11, 13, 17, 19]\nNotes\nIf n is a prime, include it in the list.", "code": "def primes_below_num(n):\n  return [i for i in range(2,n+1) if all(i%j for j in range(2,i))]"}
{"nl": "Write a function that returns the minimum number of swaps to convert the first binary string into the second.\nExamples\nmin_swaps(\"1100\", \"1001\") \u279e 1\n\nmin_swaps(\"110011\", \"010111\") \u279e 1\n\nmin_swaps(\"10011001\", \"01100110\") \u279e 4\nNotes\nBoth binary strings will be of equal length.\nBoth binary strings will have an equal number of zeroes and ones.\nA swap is switching two elements in a string (swaps do not have to be adjacent).", "code": "def min_swaps(s1, s2):\n  return sum(a != b for a, b in zip(s1, s2)) // 2"}
{"nl": "Program for Set max() Method in Python. One of the set methods in Python is the set max function, which is used to find the maximum value within a given set.", "code": "# Give the set as static input and initialize it with some random values.\n# Store it in a variable.\ngven_set = {20, 40, 50, 10, 20, 60, 50}\n# Print the above-given set.\nprint(\"The given set is :\")\nprint(gven_set)\n# Apply max() method to the given set to get the maximum value in the given set.\n# Store it in another variable.\nmaxim_val = max(gven_set)\n# Print the maximum value in the above-given set.\nprint(\"The above Given set's maximum value = \", maxim_val)"}
{"nl": "Given two matrices of same order(dimensions) then we can easily add the two matrices by doing the difference of corresponding elements in both the matrices.", "code": "# given matrix A\r\nA = [[2, 3, 1],\r\n     [1, 2, 3],\r\n     [-3, 0, 2]]\r\n# given matrix B\r\nB = [[1, 4, 2],\r\n     [-4, 5, -1],\r\n     [2, 1, 4]]\r\n# Initialize the difference of matrices elements to 0\r\nmatrixDiff = [[0, 0, 0],\r\n              [0, 0, 0],\r\n              [0, 0, 0]]\r\n# Traverse the rows\r\nfor rows in range(len(A)):\r\n    # Traverse the  columns\r\n    for columns in range(len(A[0])):\r\n        matrixDiff[rows][columns] = A[rows][columns] - B[rows][columns]\r\n# printing the difference of matrices\r\nprint(\"Printing the difference of matrices : \")\r\nfor rows in matrixDiff:\r\n    print(*rows)"}
{"nl": "Given a number N and the task is to find the sum of series (1/2!+2/3!+3/5!+\u2026..N/(N+1)!) till the given number N in Python.", "code": "# Import math module using the import keyword.\r\nimport math\r\n# Give the number N(limit) as static input and store it in a variable.\r\ngvn_numb = 6\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Take a variable to say rsltseries_summ and initialize its value to 0.0\r\n# (Floating point number)\r\nrsltseries_summ = 0.0\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nwhile(itr <= gvn_numb):\r\n    # Calculate the factorial of itr+1 using the math.factorial() method and\r\n    # store it in another variable.\r\n    factrl = math.factorial(itr+1)\r\n    # Calculate the value of itr divided by the above result factorial and convert it\r\n    # into float using the float() function.\r\n    # Store it in another variable.\r\n    p = float(itr/factrl)\r\n    # Add the above result to the rsltseries_summ and store it in the same variable.\r\n    rsltseries_summ += p\r\n    # Increment the above itr value by 1.\r\n    itr += 1\r\n# Print the sum of series till the given number N.\r\nprint(\r\n    \"The above series sum till the given number N{\", gvn_numb, \"} = \", rsltseries_summ)"}
{"nl": "There are two methods of sparse matrix representation:\n1. List of Lists\n2. Dictionary\n \nList of Lists (LIL) \n\nOne of the possible representation of sparse matrix is List of Lists (LIL). Where one list is used to represent the rows and each row contains the list of triples: Column index, Value(non \u2013 zero element) and address field, for non \u2013 zero elements. For the best performance both lists should be stored in order of ascending keys.\n\nDictionary of Keys\n\nAn alternative representation of sparse matrix is Dictionary. For the key field of the dictionary, pair of row and column index is used that maps with the non \u2013 zero element of the matrix. This method saves space but sequential access of items is costly. \nIn C++, dictionary is defined as map class of STL(Standard Template Library). To know more about map click the link below: \n\n\u00a0", "code": "# Python program for Sparse Matrix Representation\n# using Dictionary\nR = 4\nC = 5\n\u00a0\n# Driver of the program\n\u00a0\n# Assume 4x5 sparse matrix\nSparse_Matrix=[[0 , 0 , 3 , 0 , 4] ,\n\u00a0\u00a0\u00a0\u00a0[0 , 0 , 5 , 7 , 0] ,\n\u00a0\u00a0\u00a0\u00a0[0 , 0 , 0 , 0 , 0] ,\n\u00a0\u00a0\u00a0\u00a0[0 , 2 , 6 , 0 , 0]]\n\u00a0\n\u00a0\n''' Declaration of map where first field(pair of\n\u00a0\u00a0\u00a0row and column) represent key and second\n\u00a0\u00a0\u00a0field represent value '''\nnew_matrix = {}\n\u00a0\nfor i in range(R):\n\u00a0\u00a0\u00a0\u00a0for j in range(C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (Sparse_Matrix[i][j] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new_matrix[(i + 1, j + 1)] = Sparse_Matrix[i][j]\nc = 0\n\u00a0\n# Iteration over map\nfor i in new_matrix:\n\u00a0\u00a0\u00a0\u00a0if (c != i[0]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"row =\", i[0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c = i[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"column =\", i[1], end = \" \")\n\u00a0\u00a0\u00a0\u00a0print(\"value =\", new_matrix[i])\n\u00a0\n# This code is contributed by Shubham Singh\n"}
{"nl": "Create a function that takes an initial word and extracts any words that start with the same letters as the initial word.\nExamples\ndictionary(\"bu\", [\"button\", \"breakfast\", \"border\"]) \u279e [\"button\"]\n\ndictionary(\"tri\", [\"triplet\", \"tries\", \"trip\", \"piano\", \"tree\"]) \u279e [\"triplet\", \"tries\", trip\"]\n\ndictionary(\"beau\", [\"pastry\", \"delicious\", \"name\", \"boring\"]) \u279e []\nNotes\nIf none of the words match, return an empty list.\nKeep the filtered list in the same relative order as the original list of words.", "code": "def dictionary(initial, words):\n  return [i for i in words if i.startswith(initial)]"}
{"nl": "Instructions\r\nGiven a phrase, count the occurrences of each word in that phrase.\r\n\r\nFor the purposes of this exercise you can expect that a word will always be one of:\r\n\r\nA number composed of one or more ASCII digits (ie \"0\" or \"1234\") OR\r\nA simple word composed of one or more ASCII letters (ie \"a\" or \"they\") OR\r\nA contraction of two simple words joined by a single apostrophe (ie \"it's\" or \"they're\")\r\nWhen counting words you can assume the following rules:\r\n\r\nThe count is case insensitive (ie \"You\", \"you\", and \"YOU\" are 3 uses of the same word)\r\nThe count is unordered; the tests will ignore how words and counts are ordered\r\nOther than the apostrophe in a contraction all forms of punctuation are ignored\r\nThe words can be separated by any form of whitespace (ie \"\\t\", \"\\n\", \" \")\r\nFor example, for the phrase \"That's the password: 'PASSWORD 123'!\", cried the Special Agent.\\nSo I fled. the count would be:\r\n\r\nthat's: 1\r\nthe: 2\r\npassword: 2\r\n123: 1\r\ncried: 1\r\nspecial: 1\r\nagent: 1\r\nso: 1\r\ni: 1\r\nfled: 1", "code": "import re\r\nfrom collections import Counter\r\ndef count_words(sentence):\r\n    return Counter(re.findall(r\"[a-z0-9]+(?:'[a-z]+)?\", sentence.lower()))\r"}
{"nl": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\n \n\nExample 1:\n\n\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2:\n\n\nInput: head = [1,2]\nOutput: [2,1]\nExample 3:\n\nInput: head = []\nOutput: []", "code": "class Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n            \n        return prev"}
{"nl": "Print Neon numbers in a Range (Static Input)", "code": "# Create a function checkNeonNumb() which accepts the number as an argument and\r\n# returns true if it is Neon number else returns False.\r\n\r\n\r\ndef checkNeonNumb(numb):\r\n    # Calculate the square of the given number/argument using the ** operator or multiply\r\n    # the given number by itself and store it in a variable.\r\n    squarnumb = numb**2\r\n    # Convert this squared number into a list of digits\r\n    # using list(),int(),map(),str() functions.\r\n    # Store this list in a variable.\r\n    numbedigit = list(map(int, str(squarnumb)))\r\n    # Calculate the sum of digits of this list using the sum() function.\r\n    sumdigi = sum(numbedigit)\r\n    # Check if this sum is equal to the given number\r\n    # or not using the If conditional statement.\r\n    # If it is true then the given number is a Neon Number so return True\r\n    if(sumdigi == numb):\r\n        return True\r\n    # Else the given number is not a Neon Number so return False.\r\n    else:\r\n        return False\r\n\r\n\r\n# Give the lower limit range as static input and store it in a variable.\r\nlowlimrange = 1\r\n# Give the upper limit range as static input and store it in another variable.\r\nupplimrange = 7\r\nprint('The Neon numbers in the given range',\r\n      lowlimrange, 'and', upplimrange, 'are:')\r\n# Loop from lower limit range to upper limit range using For loop.\r\nfor p in range(lowlimrange, upplimrange+1):\r\n        # Inside the for loop pass the iterator value to checkNeonnumb() function.\r\n    if(checkNeonNumb(p)):\r\n        # If it returns true then print the iterator value.\r\n        print(p, end=' ')"}
{"nl": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n\nA height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\n\n \n\nExample 1:\n\n\nInput: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:\n\nExample 2:\n\n\nInput: nums = [1,3]\nOutput: [3,1]\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs.", "code": "class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            # always choose right middle node as a root\n            p = (left + right) // 2 \n            if (left + right) % 2:\n                p += 1 \n\n            # preorder traversal: node -> left -> right\n            root = TreeNode(nums[p])\n            root.left = helper(left, p - 1)\n            root.right = helper(p + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}
{"nl": "A disconnected Graph with N vertices and K edges is given. The task is to find the count of singleton sub-graphs. A singleton graph is one with only single vertex.\n\n\u00a0", "code": "# Python code to count the singleton sub-graphs\n# in a disconnected graph\n\u00a0\u00a0\n# Function to compute the count\ndef compute(graph, N):\n\u00a0\u00a0\u00a0\u00a0# Storing intermediate result\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing the Nodes\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N+1):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Singleton component\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(graph[i]) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count += 1\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returning the result\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\u00a0\n# Driver\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Number of nodes\n\u00a0\u00a0\u00a0\u00a0N = 6\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Adjacency list for edges 1..6\n\u00a0\u00a0\u00a0\u00a0graph = [[] for i in range(7)]\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Representing edges\n\u00a0\u00a0\u00a0\u00a0graph[1].append(2)\n\u00a0\u00a0\u00a0\u00a0graph[2].append(1)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0graph[2].append(3)\n\u00a0\u00a0\u00a0\u00a0graph[3].append(2)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0graph[5].append(6)\n\u00a0\u00a0\u00a0\u00a0graph[6].append(5)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(compute(graph, N))\n"}
{"nl": "Check whether a given graph contains a cycle or not.\n\n\u00a0", "code": "# Python3 program to implement Union-Find\u00a0\n# with union by rank and path compression.\n\u00a0\u00a0\n# set parent of every node to itself\u00a0\n# and size of node to one\u00a0\ndef initialize(n):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0for i in range(n + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[i] = i\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size[i] = 1\n\u00a0\u00a0\n# Each time we follow a path, find\u00a0\n# function compresses it further\u00a0\n# until the path length is greater\u00a0\n# than or equal to 1.\u00a0\ndef find(i):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# while we reach a node whose\u00a0\n\u00a0\u00a0\u00a0\u00a0# parent is equal to itself\u00a0\n\u00a0\u00a0\u00a0\u00a0while (Arr[i] != i):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[i] = Arr[Arr[i]] # Skip one level\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = Arr[i] # Move to the new level\n\u00a0\u00a0\u00a0\u00a0return i\n\u00a0\u00a0\n# A function that does union of two\u00a0\n# nodes x and y where xr is root node\u00a0\n# of x and yr is root node of y\u00a0\ndef _union(xr, yr):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0if (size[xr] < size[yr]): # Make yr parent of xr\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[xr] = Arr[yr]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size[yr] += size[xr]\n\u00a0\u00a0\u00a0\u00a0else: # Make xr parent of yr\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[yr] = Arr[xr]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size[xr] += size[yr]\n\u00a0\u00a0\n# The main function to check whether\u00a0\n# a given graph contains cycle or not\u00a0\ndef isCycle(adj, V):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Itexrte through all edges of gxrph,\u00a0\n\u00a0\u00a0\u00a0\u00a0# find nodes connecting them.\u00a0\n\u00a0\u00a0\u00a0\u00a0# If root nodes of both are same,\u00a0\n\u00a0\u00a0\u00a0\u00a0# then there is cycle in gxrph.\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(adj[i])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x = find(i) # find root of i\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y = find(adj[i][j]) # find root of adj[i][j]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (x == y):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1 # If same parent\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_union(x, y) # Make them connect\n\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\n# Driver Code\nMAX_VERTEX = 101\n\u00a0\u00a0\n# Arr to represent parent of index i\u00a0\nArr = [None] * MAX_VERTEX\u00a0\n\u00a0\u00a0\n# Size to represent the number of nodes\u00a0\n# in subgxrph rooted at index i\u00a0\nsize = [None] * MAX_VERTEX\u00a0\n\u00a0\u00a0\nV = 3\n\u00a0\u00a0\n# Initialize the values for arxry\u00a0\n# Arr and Size\u00a0\ninitialize(V)\u00a0\n\u00a0\u00a0\n# Let us create following gxrph\u00a0\n#\u00a0\u00a0\u00a0\u00a0 0\u00a0\n# | \\\u00a0\n# | \\\u00a0\n# 1-----2\u00a0\n\u00a0\u00a0\n# Adjacency list for graph\u00a0\nadj = [[] for i in range(V)]\u00a0\n\u00a0\u00a0\nadj[0].append(1)\u00a0\nadj[0].append(2)\u00a0\nadj[1].append(2)\u00a0\n\u00a0\u00a0\n# call is_cycle to check if it\u00a0\n# contains cycle\u00a0\nif (isCycle(adj, V)):\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Graph contains Cycle.\")\u00a0\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"Graph does not contain Cycle.\")\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "You are given an array of integers nums (0-indexed) and an integer k.\nThe score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.\nReturn the maximum possible score of a good subarray.\n \nExample 1:\n\nInput: nums = [1,4,3,7,4,5], k = 3\nOutput: 15\nExplanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. \n\nExample 2:\n\nInput: nums = [5,5,4,5,4,1,1,1], k = 0\nOutput: 20\nExplanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 2 * 104\n0 <= k < nums.length", "code": "def maximumScore(self, A, k):\n  res = mini = A[k]\n  i, j, n = k, k, len(A)\n  while i > 0 or j < n - 1:\n  if (A[i - 1] if i else 0) < (A[j + 1] if j < n - 1 else 0):\n  j += 1\n  else:\n  i -= 1\n  mini = min(mini, A[i], A[j])\n  res = max(res, mini * (j - i + 1))\n  return res"}
{"nl": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\n\nanswer[0] is a list of all distinct integers in nums1 which are not present in nums2.\nanswer[1] is a list of all distinct integers in nums2 which are not present in nums1.\nNote that the integers in the lists may be returned in any order.", "code": "class Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        nums1, nums2 = set(nums1), set(nums2)\n        \n        def iterator(nums1, nums2):\n            temp = []\n            for i in nums1:\n                if i not in nums2:\n                    temp.append(i)\n            return temp\n                \n        return [iterator(nums1, nums2), iterator(nums2, nums1)]"}
{"nl": "In this program, we need to rotate the elements of array towards its right by the specified number of times. An array is said to be right rotated if all elements of the array are moved to its right by one position. One approach is to loop through the array by shifting each element of the array to its next position. The last element of the array will become the first element of the rotated array.", "code": "#Initialize array     \narr = [1, 2, 3, 4, 5];     \n#n determine the number of times an array should be rotated    \nn = 3;    \n     \n#Displays original array    \nprint(\"Original array: \");    \nfor i in range(0, len(arr)):    \n    print(arr[i]),     \n     \n#Rotate the given array by n times toward right    \nfor i in range(0, n):    \n    #Stores the last element of array    \n    last = arr[len(arr)-1];    \n        \n    for j in range(len(arr)-1, -1, -1):    \n        #Shift element of array by one    \n        arr[j] = arr[j-1];    \n            \n    #Last element of the array will be added to the start of the array.    \n    \n    arr[0] = last;    \n     \nprint();    \n     \n#Displays resulting array after rotation    \nprint(\"Array after right rotation: \");    \nfor i in range(0, len(arr)):    \n    print(arr[i]),  "}
{"nl": "Here, we will discuss how to create a matrix in python? A matrix is a rectangular table arranged in the form of rows and columns. In the programming world, we implement a matrix by using arrays by classifying them as 1D and 2D arrays. In this section, there are some examples to create a matrix in python.", "code": "import numpy as np num = np.array([[1, 1, 2], [3, 5, 3], [5, 6, 9]]) print(num)"}
{"nl": "Create a data structure twoStacks that represents two stacks. Implementation of twoStacks should use only one array, i.e., both stacks should use the same array for storing elements. Following functions must be supported by twoStacks.\r\npush1(int x) \u2013> pushes x to first stack \r\npush2(int x) \u2013> pushes x to second stack\r\npop1() \u2013> pops an element from first stack and return the popped element \r\npop2() \u2013> pops an element from second stack and return the popped element\r\nImplementation of twoStack should be space efficient.", "code": "# Python Script to Implement two stacks in a list\r\nclass twoStacks:\r\n\t\r\n\tdef __init__(self, n):\t # constructor\r\n\t\tself.size = n\r\n\t\tself.arr = [None] * n\r\n\t\tself.top1 = -1\r\n\t\tself.top2 = self.size\r\n\t\t\r\n\t# Method to push an element x to stack1\r\n\tdef push1(self, x):\r\n\t\t\r\n\t\t# There is at least one empty space for new element\r\n\t\tif self.top1 < self.top2 - 1 :\r\n\t\t\tself.top1 = self.top1 + 1\r\n\t\t\tself.arr[self.top1] = x\r\n\r\n\t\telse:\r\n\t\t\tprint(\"Stack Overflow \")\r\n\t\t\texit(1)\r\n\r\n\t# Method to push an element x to stack2\r\n\tdef push2(self, x):\r\n\r\n\t\t# There is at least one empty space for new element\r\n\t\tif self.top1 < self.top2 - 1:\r\n\t\t\tself.top2 = self.top2 - 1\r\n\t\t\tself.arr[self.top2] = x\r\n\r\n\t\telse :\r\n\t\tprint(\"Stack Overflow \")\r\n\t\texit(1)\r\n\r\n\t# Method to pop an element from first stack\r\n\tdef pop1(self):\r\n\t\tif self.top1 >= 0:\r\n\t\t\tx = self.arr[self.top1]\r\n\t\t\tself.top1 = self.top1 -1\r\n\t\t\treturn x\r\n\t\telse:\r\n\t\t\tprint(\"Stack Underflow \")\r\n\t\t\texit(1)\r\n\r\n\t# Method to pop an element from second stack\r\n\tdef pop2(self):\r\n\t\tif self.top2 < self.size:\r\n\t\t\tx = self.arr[self.top2]\r\n\t\t\tself.top2 = self.top2 + 1\r\n\t\t\treturn x\r\n\t\telse:\r\n\t\t\tprint(\"Stack Underflow \")\r\n\t\t\texit()\r\n\r\n# Driver program to test twoStacks class\r\nts = twoStacks(5)\r\nts.push1(5)\r\nts.push2(10)\r\nts.push2(15)\r\nts.push1(11)\r\nts.push2(7)\r\n\r\nprint(\"Popped element from stack1 is \" + str(ts.pop1()))\r\nts.push2(40)\r\nprint(\"Popped element from stack2 is \" + str(ts.pop2()))\r\n\r\n# This code is contributed by Sunny Karira\r\n"}
{"nl": "Given the root of a binary tree, turn the tree upside down and return the new root.\n\nYou can turn a binary tree upside down with the following steps:\n\nThe original left child becomes the new root.\nThe original root becomes the new right child.\nThe original right child becomes the new left child.\n\nThe mentioned steps are done level by level. It is guaranteed that every right node has a sibling (a left node with the same parent) and has no children.\n\n ", "code": "def upsideDownBinaryTree(self, root):\n    if not root or not root.left:\n        return root\n    lRoot = self.upsideDownBinaryTree(root.left)\n    rMost = lRoot\n    while rMost.right:\n        rMost = rMost.right\n    root, rMost.left, rMost.right = lRoot, root.right, TreeNode(root.val)\n    return root"}
{"nl": "Method #1: Using For Loop (Static Input)\nApproach:\n\nGive the number of rows as static input and store it in a variable.\nLoop from 1 to the number of rows using For loop.\nLoop from 1 to the number of rows using another for loop(Nested For loop).\nCheck if the iterator value of the inner For loop is less than or equal to the parent loop iterator value of theFor Loop using the If conditional Statement.\nIf it is true then print the iterator value of the parent For loop.\nElse print the iterator value of the inner For loop.\nPrint the Newline character after the end of the inner loop.\nThe Exit of the Program.", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumbrrows = 9\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numbrrows+1):\r\n    # Loop from 1 to the number of rows using another for loop(Nested For loop).\r\n    for n in range(1, numbrrows+1):\r\n        ''' Check if the iterator value of the inner For loop is less than or equal \r\n            to the parent loop iterator value of the\r\n            For Loop using the If conditional Statement.'''\r\n        if(n <= m):\r\n            # If it is true then print the iterator value of the parent For loop.\r\n            print(m, end=' ')\r\n        else:\r\n            print(n, end=' ')\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "String Literals\r\n", "code": "print(\"Hello\")\r\nprint('Hello')\r\n"}
{"nl": "In this program, the given ternary tree will be converted into a corresponding doubly linked list.\n\nThe ternary tree is a hierarchical data structure in which each node can have at most three children. This can be accomplished by traversing the ternary tree in a pre-order fashion that is, root -> left the child -> middle child -> right child. First, traverse root node and add it to the list. Then, add its left, middle and right sub-trees respectively.", "code": "#Represent a node of ternary tree    \nclass Node:    \n    def __init__(self,data):    \n        self.data = data;    \n        self.left = None;    \n        self.middle = None;    \n        self.right = None;    \n            \nclass TernaryTreeToDLL:    \n    def __init__(self):    \n        #Represent the root of ternary tree    \n        self.root = None;    \n        #Represent the head and tail of the doubly linked list    \n        self.head = None;    \n        self.tail = None;    \n            \n    #convertTernaryToDLL() will convert the given ternary tree to corresponding doubly linked list    \n    def convertTernaryToDLL(self, node):    \n        #Checks whether node is None    \n        if(node == None):    \n            return;    \n                \n        #Keep three pointers to all three children    \n        left = node.left;    \n        middle = node.middle;    \n        right = node.right;    \n            \n        #If list is empty then, add node as head of the list    \n        if(self.head == None):    \n            #Both head and tail will point to node    \n            self.head = self.tail = node;    \n            node.middle = None;    \n            #head's left will point to None    \n            self.head.left = None;    \n            #tail's right will point to None, as it is the last node of the list    \n            self.tail.right = None;    \n        #Otherwise, add node to the end of the list    \n        else:    \n            #node will be added after tail such that tail's right will point to node    \n            self.tail.right = node;    \n            #node's left will point to tail    \n            node.left = self.tail;    \n            node.middle = None;    \n            #node will become new tail    \n            self.tail = node;    \n            #As it is last node, tail's right will point to None    \n            self.tail.right = None;    \n                \n        #Add left child of current node to the list    \n        self.convertTernaryToDLL(left);    \n        #Then, add middle child of current node to the list    \n        self.convertTernaryToDLL(middle);    \n        #Then, add right child of current node to the list    \n        self.convertTernaryToDLL(right);    \n        \n    #displayDLL() will print out the nodes of the list    \n    def displayDLL(self):    \n        #Node current will point to head    \n        current = self.head;    \n        if(self.head == None):    \n            print(\"List is empty\");    \n            return;    \n        print(\"Nodes of generated doubly linked list: \");    \n        while(current != None):    \n            #Prints each node by incrementing pointer.    \n            print(current.data),    \n            current = current.right;    \n                \ntree = TernaryTreeToDLL();    \n#Add nodes to the ternary tree    \ntree.root = Node(5);    \ntree.root.left = Node(10);    \ntree.root.middle = Node(12);    \ntree.root.right = Node(15);    \ntree.root.left.left = Node(20);    \ntree.root.left.middle = Node(40);    \ntree.root.left.right = Node(50);    \ntree.root.middle.left = Node(24);    \ntree.root.middle.middle = Node(36);    \ntree.root.middle.right = Node(48);    \ntree.root.right.left = Node(30);    \ntree.root.right.middle = Node(45);    \ntree.root.right.right = Node(60);    \n     \n#Converts the given ternary tree to doubly linked list    \ntree.convertTernaryToDLL(tree.root);    \n     \n#Displays the nodes present in the list    \ntree.displayDLL();    "}
{"nl": "There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.\n\nYou are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.\n\nThe number of collisions can be calculated as follows:\n\nWhen two cars moving in opposite directions collide with each other, the number of collisions increases by 2.\nWhen a moving car collides with a stationary car, the number of collisions increases by 1.\nAfter a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\n\nReturn the total number of collisions that will happen on the road.", "code": "class Solution:\n    def countCollisions(self, directions: str) -> int:\n        l, r = 0, 0\n        ans = 0\n        \n        for i in directions:\n            if i == \"L\":\n                ans += l\n            else:\n                l = 1\n        \n        for i in directions[::-1]:\n            if i == \"R\":\n                ans += r\n            else:\n                r = 1\n        \n        return ans"}
{"nl": "You are given a function rand(a, b) which generates equiprobable random numbers between [a, b] inclusive. Generate 3 numbers x, y, z with probability P(x), P(y), P(z) such that P(x) + P(y) + P(z) = 1 using the given rand(a,b) function.\nThe idea is to utilize the equiprobable feature of the rand(a,b) provided. Let the given probabilities be in percentage form, for example P(x)=40%, P(y)=25%, P(z)=35%..\n\nFollowing are the detailed steps. \n1) Generate a random number between 1 and 100. Since they are equiprobable, the probability of each number appearing is 1/100. \n2) Following are some important points to note about generated random number \u2018r\u2019. \na) \u2018r\u2019 is smaller than or equal to P(x) with probability P(x)/100. \nb) \u2018r\u2019 is greater than P(x) and smaller than or equal P(x) + P(y) with P(y)/100. \nc) \u2018r\u2019 is greater than P(x) + P(y) and smaller than or equal 100 (or P(x) + P(y) + P(z)) with probability P(z)/100.", "code": "import random\n\n# This function generates 'x' with probability px/100, 'y' with\n# probability py/100 and 'z' with probability pz/100:\n# Assumption: px + py + pz = 100 where px, py and pz lie\n# between 0 to 100\ndef random(x, y, z, px, py, pz):\n\t\n\t# Generate a number from 1 to 100\n\tr = random.randint(1, 100)\n\t\n\t# r is smaller than px with probability px/100\n\tif (r <= px):\n\t\treturn x\n\t\n\t# r is greater than px and smaller than\n\t# or equal to px+py with probability py/100\n\tif (r <= (px+py)):\n\t\treturn y\n\t\t\n\t# r is greater than px+py and smaller than\n\t# or equal to 100 with probability pz/100\n\telse:\n\t\treturn z\n\t\n# This code is contributed by rohan07"}
{"nl": "Mirror of a Tree: Mirror of a Binary Tree T is another Binary Tree M(T) with left and right children of all non-leaf nodes interchanged. ", "code": "# Python3 program to convert a binary\n# tree to its mirror\n\n# Utility function to create a new\n# tree node\nclass newNode:\n\tdef __init__(self,data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\n\"\"\" Change a tree so that the roles of the\n\tleft and right pointers are swapped at\n\tevery node.\n\nSo the tree...\n\t\t4\n\t\t/ \\\n\t2 5\n\t/ \\\n\t1 3\n\nis changed to...\n\t4\n\t/ \\\n\t5 2\n\t/ \\\n\t3 1\n\"\"\"\ndef mirror(node):\n\n\tif (node == None):\n\t\treturn\n\telse:\n\n\t\ttemp = node\n\t\t\n\t\t\"\"\" do the subtrees \"\"\"\n\t\tmirror(node.left)\n\t\tmirror(node.right)\n\n\t\t\"\"\" swap the pointers in this node \"\"\"\n\t\ttemp = node.left\n\t\tnode.left = node.right\n\t\tnode.right = temp\n\n\"\"\" Helper function to print Inorder traversal.\"\"\"\ndef inOrder(node) :\n\n\tif (node == None):\n\t\treturn\n\t\t\n\tinOrder(node.left)\n\tprint(node.data, end = \" \")\n\tinOrder(node.right)\n\n# Driver code\nif __name__ ==\"__main__\":\n\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\n\t\"\"\" Print inorder traversal of\n\t\tthe input tree \"\"\"\n\tprint(\"Inorder traversal of the\",\n\t\t\t\"constructed tree is\")\n\tinOrder(root)\n\t\n\t\"\"\" Convert tree to its mirror \"\"\"\n\tmirror(root)\n\n\t\"\"\" Print inorder traversal of\n\t\tthe mirror tree \"\"\"\n\tprint(\"\\nInorder traversal of\",\n\t\t\t\"the mirror treeis \")\n\tinOrder(root)\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "In the previous article, we have discussed Python Program to Get nth Bit of a Number\n Given a number and the bit position, the task is to set the nth bit of the given Number.\n For example:\n Let the number = 5\n Bit position=1\n To set the 1st-bit position(0 indexing):\n Its binary form = 101\n When we set the 0 at the 1st index becomes 1 that is 111 which is equal to the number 7.\n Bitwise or (|) operator:\n If one of two bits is 1, sets each bit to 1.\n Examples:\n Example1:\n Input:\n Given Number = 5 \n \n Bit position(in range 0-31)= 1\n Output:\n The given number { 5 } after set the { 1 } bit position = 7\n Example2:\n Input:\n Given Number = 8\n \n Bit position(in range 0-31)= 2\n Output:\n The given number { 8 } after set the { 2 } bit position = 12", "code": "# Give the number as static input and store it in a variable.\n \n gvn_numb = 5\n \n # Give the bit position as static input and store it in another variable.\n \n bitpositin = 1\n \n # Apply the left shift operator to 1 and the above-given bit position and\n \n # store it in another variable.\n \n numbr_bit = (1 &lt;&lt; bitpositin)\n \n # Apply bitwise | operation for the given number and the above result and\n \n # store it in another variable say set_numb.\n \n set_numb = gvn_numb | numbr_bit\n \n # Print the given number after set the nth bit of the given Number.\n \n print(\"The given number {\", gvn_numb,\n \n  \"} after set the {\", bitpositin, \"} bit position = \", set_numb)\n \n </pre>"}
{"nl": "Write a Python program to print right arrow alphabets pattern using for loop.\n\n", "code": "rows = int(input(\"Enter Right Arrow Alphabets Pattern Rows = \"))\n\nprint(\"====The Right Arrow Alphabets Pattern====\")\nalphabet = 65\n\nfor i in range(rows):\n    for j in range(i):\n        print(end = ' ')\n    for k in range(i, rows):\n        print('%c' %(alphabet + k), end = '')\n    print()\n\nfor i in range(rows - 2, -1, -1):\n    for j in range(i):\n        print(end = ' ')\n    for k in range(i, rows):\n        print('%c' %(alphabet + k), end = '')\n    print()"}
{"nl": "In the previous article, we have discussed Python Program to Find the sum of all Highest Occurring Elements in an Array/List\n Given a list, the task is to find the sum of the elements which are having an even frequency in the given array/List.\n Examples:\n Example1:\n Input:\n Given List = [6, 1, 4, 1, 1, 6, 4, 4, 2, 2]\n Output:\n The sum of all even frequency elements in the given list [6, 1, 4, 1, 1, 6, 4, 4, 2, 2] is:\n \n 8\n Explanation:\n Here 6,2 are the elements in the given list which are having even frequency\n \n sum=6+2=8\n Example2:\n Input:\n Given List = [7, 6, 8, 8, 1, 4, 1, 5, 4, 7]\n Output:\n The sum of all even frequency elements in the given list [7, 6, 8, 8, 1, 4, 1, 5, 4, 7] is:\n \n 20", "code": "# Take a dictionary and initialize it to empty\n \n # using the {} or dict() say freqncyDictionary.\n \n freqncyDictionary = {}\n \n # Give the list as static input and store it in a variable.\n \n gvnlst = [6, 1, 4, 1, 1, 6, 4, 4, 2, 2]\n \n # Loop in the given list using the For loop.\n \n for i in gvnlst:\n \n  # Inside the For loop,\n \n  # Check if the list element is present in the dictionary\n \n  # or not using the if conditional statement and 'in' keyword.\n \n  if i in freqncyDictionary.keys():\n \n  # If it is true then increment the count of the list element\n \n  # in the dictionary by 1.\n \n  freqncyDictionary[i] = freqncyDictionary[i]+1\n \n  # Else initialize the dictionary with the list element as key and value as 1.\n \n  else:\n \n  freqncyDictionary[i] = 1\n \n \n \n # Take a variable say evenfreqncycnt and initialize its value to 0.\n \n evenfreqncycnt = 0\n \n # Loop in the freqncyDictionary using the For loop.\n \n for elemnt in freqncyDictionary:\n \n  # Check if the key in the freqncyDictionary having value even\n \n  # using the if conditional statement.\n \n  if(freqncyDictionary[elemnt] % 2 == 0):\n \n  # If it is true then increment the evenfreqncycnt by the key\n \n  # and store it in the same variable.\n \n  evenfreqncycnt += elemnt\n \n # After the end of For loop then print the evenfreqncycnt value.\n \n print('The sum of all even frequency elements in the given list', gvnlst, 'is:')\n \n print(evenfreqncycnt)"}
{"nl": "In the previous article, we have discussed Python Program to Find the Sum of a Lower Triangular Matrix\n \n Given a matrix and the task is to check if the given matrix is a scalar matrix or not in Python.\n \n What is a matrix:\n \n A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.\n \n Example:\n \n \n \n Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.\n \n In this order, the dimensions of a matrix indicate the number of rows and columns.\n \n \n \n Here as there are 5 rows and 4 columns it is called a 5*4 matrix.\n \n Scalar Matrix :\n \n A scalar matrix is a square matrix with all of its primary diagonal members equal and all off-diagonal elements equal. It\u2019s an identity matrix\u2019s multiplicative constant.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given Matrix :\n 5 0 0\n 0 5 0\n 0 0 5\n Output:\n \n The Matrix given is a Scalar Matrix.\n Example2:\n \n Input:\n \n Given Matrix :\n 0 8\n 2 5\n Output:\n \n The Matrix given is not a Scalar Matrix.", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[5, 0, 0], [0, 5, 0], [0, 0, 5]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n # Take a variable and initialize its value to zero.\n tempo = 0\n # To print all the elements of the given matrix.\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Check if the condition n is not equal to m and gvnmatrix[n][m] not equal to 0 using the\n  # if conditional statement where n is the iterator value of the parent For loop and m\n  # is the iterator value of the inner For loop.\n  if n != m and mtrx[n][m] != 0:\n  # If the statement is true, then make the value of tempo as 1.\n  tempo = 1\n  # Break the statement.\n  break\n  # Check if the condition n is equal to m and gvnmatrix[n][m] not equal to gvnmatrix[n][m]\n  # using the if conditional statement where n is the iterator value of the parent For loop\n  # and m is the iterator value of the inner For loop.\n  if n == m and mtrx[n][m] != mtrx[n][m]:\n  # If the statement is true, then make the value of tempo as 1.\n  tempo = 1\n  # Break the statement.\n  break\n # Check if the value of tempo is equal to 1 using the if conditional statement.\n if tempo == 1:\n  # If the statement is true, then print \"The Matrix given is not a Scalar Matrix.\"\n  print(\"The Matrix given is not a Scalar Matrix.\")\n else:\n  # Else print \"The Matrix given is a Scalar Matrix.\"\n  print(\"The Matrix given is a Scalar Matrix.\")"}
{"nl": "Exercise 6: Add a week (7 days) and 12 hours to a given date", "code": "from datetime import datetime, timedelta\r\n\r\ngiven_date = datetime(2020, 3, 22, 10, 00, 00)\r\nprint(\"Given date\")\r\nprint(given_date)\r\n\r\ndays_to_add = 7\r\nres_date = given_date + timedelta(days=days_to_add, hours=12)\r\nprint(\"New Date\")\r\nprint(res_date)"}
{"nl": "The program creates a singly linked list and presents the user with a menu to perform various operations on the list.", "code": "class Node:\n    def __init__(self, data):\n       self.data = data\n       self.next = None\n\u00a0\n\u00a0\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\u00a0\n    def get_node(self, index):\n        current = self.head\n        for i in range(index):\n            if current is None:\n                return None\n            current = current.next\n        return current\n\u00a0\n    def get_prev_node(self, ref_node):\n        current = self.head\n        while (current and current.next != ref_node):\n            current = current.next\n        return current\n\u00a0\n    def insert_after(self, ref_node, new_node):\n        new_node.next = ref_node.next\n        ref_node.next = new_node\n\u00a0\n    def insert_before(self, ref_node, new_node):\n        prev_node = self.get_prev_node(ref_node)\n        self.insert_after(prev_node, new_node)\n\u00a0\n    def insert_at_beg(self, new_node):\n        if self.head is None:\n            self.head = new_node\n        else:\n            new_node.next = self.head\n            self.head = new_node\n\u00a0\n    def insert_at_end(self, new_node):\n        if self.head is None:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next is not None:\n                current = current.next\n            current.next = new_node\n\u00a0\n    def remove(self, node):\n        prev_node = self.get_prev_node(node)\n        if prev_node is None:\n            self.head = self.head.next\n        else:\n            prev_node.next = node.next\n\u00a0\n    def display(self):\n        current = self.head\n        while current:\n            print(current.data, end = ' ')\n            current = current.next\n\u00a0\n\u00a0\na_llist = LinkedList()\n\u00a0\nprint('Menu')\nprint('insert <data> after <index>')\nprint('insert <data> before <index>')\nprint('insert <data> at beg')\nprint('insert <data> at end')\nprint('remove <index>') \nprint('quit')\n\u00a0\nwhile True:\n    print('The list: ', end = '')\n    a_llist.display()\n    print()\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n\u00a0\n    if operation == 'insert':\n        data = int(do[1])\n        position = do[3].strip().lower()\n        new_node = Node(data)\n        suboperation = do[2].strip().lower() \n        if suboperation == 'at':\n            if position == 'beg':\n                a_llist.insert_at_beg(new_node)\n            elif position == 'end':\n                a_llist.insert_at_end(new_node)\n        else:\n            index = int(position)\n            ref_node = a_llist.get_node(index)\n            if ref_node is None:\n                print('No such index.')\n                continue\n            if suboperation == 'after':\n                a_llist.insert_after(ref_node, new_node)\n            elif suboperation == 'before':\n                a_llist.insert_before(ref_node, new_node)\n\u00a0\n    elif operation == 'remove':\n        index = int(do[1])\n        node = a_llist.get_node(index)\n        if node is None:\n            print('No such index.')\n            continue\n        a_llist.remove(node)\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Given a linked list and two keys in it, swap nodes for two given keys. Nodes should be swapped by changing links. Swapping data of nodes may be expensive in many situations when data contains many fields. \n\nIt may be assumed that all keys in the linked list are distinct.\n\nExamples: \n\nInput : 10->15->12->13->20->14,  x = 12, y = 20\nOutput: 10->15->20->13->12->14\n\nInput : 10->15->12->13->20->14,  x = 10, y = 20\nOutput: 20->15->12->13->10->14\n\nInput : 10->15->12->13->20->14,  x = 12, y = 13\nOutput: 10->15->13->12->20->14", "code": "# Python program to swap two given nodes of a linked list\nclass LinkedList(object):\n\tdef __init__(self):\n\t\tself.head = None\n\n\t# head of list\n\tclass Node(object):\n\t\tdef __init__(self, d):\n\t\t\tself.data = d\n\t\t\tself.next = None\n\n\t# Function to swap Nodes x and y in linked list by\n\t# changing links\n\tdef swapNodes(self, x, y):\n\n\t\t# Nothing to do if x and y are same\n\t\tif x == y:\n\t\t\treturn\n\n\t\t# Search for x (keep track of prevX and CurrX)\n\t\tprevX = None\n\t\tcurrX = self.head\n\t\twhile currX != None and currX.data != x:\n\t\t\tprevX = currX\n\t\t\tcurrX = currX.next\n\n\t\t# Search for y (keep track of prevY and currY)\n\t\tprevY = None\n\t\tcurrY = self.head\n\t\twhile currY != None and currY.data != y:\n\t\t\tprevY = currY\n\t\t\tcurrY = currY.next\n\n\t\t# If either x or y is not present, nothing to do\n\t\tif currX == None or currY == None:\n\t\t\treturn\n\t\t# If x is not head of linked list\n\t\tif prevX != None:\n\t\t\tprevX.next = currY\n\t\telse: # make y the new head\n\t\t\tself.head = currY\n\n\t\t# If y is not head of linked list\n\t\tif prevY != None:\n\t\t\tprevY.next = currX\n\t\telse: # make x the new head\n\t\t\tself.head = currX\n\n\t\t# Swap next pointers\n\t\ttemp = currX.next\n\t\tcurrX.next = currY.next\n\t\tcurrY.next = temp\n\n\t# Function to add Node at beginning of list.\n\tdef push(self, new_data):\n\n\t\t# 1. alloc the Node and put the data\n\t\tnew_Node = self.Node(new_data)\n\n\t\t# 2. Make next of new Node as head\n\t\tnew_Node.next = self.head\n\n\t\t# 3. Move the head to point to new Node\n\t\tself.head = new_Node\n\n\t# This function prints contents of linked list starting\n\t# from the given Node\n\tdef printList(self):\n\t\ttNode = self.head\n\t\twhile tNode != None:\n\t\t\tprint tNode.data,\n\t\t\ttNode = tNode.next\n\n\n# Driver program to test above function\nllist = LinkedList()\n\n# The constructed linked list is:\n# 1->2->3->4->5->6->7\nllist.push(7)\nllist.push(6)\nllist.push(5)\nllist.push(4)\nllist.push(3)\nllist.push(2)\nllist.push(1)\nprint \"Linked list before calling swapNodes() \"\nllist.printList()\nllist.swapNodes(4, 3)\nprint \"\\nLinked list after calling swapNodes() \"\nllist.printList()\n\n# This code is contributed by BHAVYA JAIN\n"}
{"nl": "Files in Python:\n\nPython file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python\u2019s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.\n\nGiven a file, the task is to read a given file and count the number of words whose length is greater than 5 in the given file in python", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Read the above file using the read() function(get the content) and store it in a variable\n  filetext = givenfilecontent.read()\n# Take a variable(which gives the count of words with length>5 in a file) and initialize its value with zero.\ncnt = 0\n# Split the above file text lines into list of words using the split() function and \n# iterate in that list using the for loop\nfor wrd in filetext.split():\n  # Get the length of each word is using the len() function and check if the length of\n  # each word is greater than 5 using the if conditional statement.\n  if len(wrd) > 5:\n  # If it is true, then increment the above count value by 1.\n  cnt += 1\n# Print the count of words with length greater than 5 in a given file.\nprint(\"The count of words with length greater than 5 in a given file = \", cnt)"}
{"nl": "Given two numbers , the task is to print their quotient and Remainder in  Python.", "code": "# scanning the given two numbers using int(input()) function\n# first number\nnumb1 = int(input(\"Enter some random number = \"))\n# second number\nnumb2 = int(input(\"Enter some random number = \"))\n# Calculate the quotient by using the syntax first number /second number\n# and store it in a variable.\nquotie = numb1/numb2\n# Calculate the remainder by using the syntax first number %second number\n# and store it in a variable.\nremain = numb1 % numb2\n# Print the above two variables which are the result of the program\nprint(\"The value of quotient after dividing\", numb1, \"/\", numb2, \" = \", quotie)\nprint(\"The value of remainder after dividing\",\n      numb1, \"/\", numb2, \" = \", remain)"}
{"nl": "Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0.\n\n \n\nExample 1:\n\nInput: nums = [21,4,7]\nOutput: 32\nExplanation: \n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\nExample 2:\n\nInput: nums = [21,21]\nOutput: 64\nExample 3:\n\nInput: nums = [1,2,3,4,5]\nOutput: 0\n \n\nConstraints:\n\n1 <= nums.length <= 104\n1 <= nums[i] <= 105", "code": "class Solution:\n  def sumFourDivisors(self, nums: List[int]) -> int:\n  res = 0\n  for num in nums:\n  divisor = set() \n  for i in range(1, floor(sqrt(num)) + 1):\n  if num % i == 0:\n  divisor.add(num//i)\n  divisor.add(i)\n  if len(divisor) > 4:  \n  break\n  \n  if len(divisor) == 4:\n  res += sum(divisor)\n  return res"}
{"nl": "Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL) In-Place. The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be same as Inorder of the given Binary Tree. The first node of Inorder traversal (left most node in BT) must be head node of the DLL.", "code": "# Python3 program to convert a given Binary Tree to Doubly Linked List\nclass Node:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\nclass BinaryTree:\n\t# A simple recursive function to convert a given\n\t# Binary tree to Doubly Linked List\n\t# root --> Root of Binary Tree\n\t# head --> Pointer to head node of created doubly linked list\n\troot, head = None, None\n\t\n\tdef BToDll(self, root: Node):\n\t\tif root is None:\n\t\t\treturn\n\n\t\t# Recursively convert right subtree\n\t\tself.BToDll(root.right)\n\n\t\t# Insert root into doubly linked list\n\t\troot.right = self.head\n\n\t\t# Change left pointer of previous head\n\t\tif self.head is not None:\n\t\t\tself.head.left = root\n\n\t\t# Change head of doubly linked list\n\t\tself.head = root\n\n\t\t# Recursively convert left subtree\n\t\tself.BToDll(root.left)\n\n\t@staticmethod\n\tdef print_list(head: Node):\n\t\tprint('Extracted Double Linked list is:')\n\t\twhile head is not None:\n\t\t\tprint(head.data, end = ' ')\n\t\t\thead = head.right\n\n# Driver program to test above function\nif __name__ == '__main__':\n\t\n\t\"\"\"\n\tConstructing below tree\n\t\t\t5\n\t\t// \\\\\n\t\t3 6\n\t\t// \\\\ \\\\\n\t\t1 4 8\n\t// \\\\ // \\\\\n\t0 2 7 9\n\t\"\"\"\n\ttree = BinaryTree()\n\ttree.root = Node(5)\n\ttree.root.left = Node(3)\n\ttree.root.right = Node(6)\n\ttree.root.left.left = Node(1)\n\ttree.root.left.right = Node(4)\n\ttree.root.right.right = Node(8)\n\ttree.root.left.left.left = Node(0)\n\ttree.root.left.left.right = Node(2)\n\ttree.root.right.right.left = Node(7)\n\ttree.root.right.right.right = Node(9)\n\n\ttree.BToDll(tree.root)\n\ttree.print_list(tree.head)\n\n# This code is contributed by Rajat Srivastava\n"}
{"nl": "The problem is to find the shortest distance to all vertices from a source vertex in a weighted directed graph that can have negative edge weights. For the problem to be well-defined, there should be no cycles in the graph with a negative total weight.", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def __len__(self):\n        return len(self.vertices)\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef bellman_ford(g, source):\n    \"\"\"Return distance where distance[v] is min distance from source to v.\n\u00a0\n    This will return a dictionary distance.\n\u00a0\n    g is a Graph object which can have negative edge weights.\n    source is a Vertex object in g.\n    \"\"\"\n    distance = dict.fromkeys(g, float('inf'))\n    distance[source] = 0\n\u00a0\n    for _ in range(len(g) - 1):\n        for v in g:\n            for n in v.get_neighbours():\n                distance[n] = min(distance[n], distance[v] + v.get_weight(n))\n\u00a0\n    return distance\n\u00a0\n\u00a0\ng = Graph()\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('bellman-ford <source vertex key>')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'bellman-ford':\n        key = int(do[1])\n        source = g.get_vertex(key)\n        distance = bellman_ford(g, source)\n        print('Distances from {}: '.format(key))\n        for v in distance:\n            print('Distance to {}: {}'.format(v.get_key(), distance[v]))\n        print()\n\u00a0\n    elif operation == 'display':\n        print('Vertices: ', end='')\n        for v in g:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in g:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": null, "code": null}
{"nl": null, "code": null}
{"nl": "The main condition of matrix multiplication is that the number of columns of the 1st matrix must equal to the number of rows of the 2nd one.\nAs a result of multiplication you will get a new matrix that has the same quantity of rows as the 1st one has and the same quantity of columns as the 2nd one.\nFor example if you multiply a matrix of \"n\" * \"k\" by \"k\" * \"m\" size you\"ll get a new one of \"n\" * \"m\" dimensions.\nCreate a function that takes 2 x 2D lists m1 and m2 as arguments and returns a 2D list (matrix C). C = A*B.\nIf the number of columns of the 1st matrix isn't equal to the number of rows of the 2nd: return \"ERROR\".\nExamples\nmultiply_matrix([\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n], [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]) \u279e [\n  [30, 36, 42],\n  [66, 81, 96],\n  [102, 126, 150]\n]\nNotes\nN/A", "code": "import numpy as np\ndef multiply_matrix(m1, m2):\n  try:\n    return np.dot(m1, m2).tolist()\n  except:\n    return \"ERROR\""}
{"nl": "Given a binary tree, task is to find subtree with maximum sum in tree.\nExamples: \n \n\nInput :       1\n            /   \\\n           2      3\n          / \\    / \\\n         4   5  6   7\nOutput : 28\nAs all the tree elements are positive,\nthe largest subtree sum is equal to\nsum of all tree elements.\n\nInput :       1\n            /    \\\n          -2      3\n          / \\    /  \\\n         4   5  -6   2\nOutput : 7\nSubtree with largest sum is :  -2\n                             /  \\ \n                            4    5\nAlso, entire tree sum is also 7.", "code": "# Python3 program to find largest subtree\n# sum in a given binary tree.\n\n# Function to create new tree node.\nclass newNode:\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = self.right = None\n\n# Helper function to find largest\n# subtree sum recursively.\ndef findLargestSubtreeSumUtil(root, ans):\n\t\n\t# If current node is None then\n\t# return 0 to parent node.\n\tif (root == None):\n\t\treturn 0\n\t\n\t# Subtree sum rooted at current node.\n\tcurrSum = (root.key +\n\t\t\tfindLargestSubtreeSumUtil(root.left, ans) +\n\t\t\tfindLargestSubtreeSumUtil(root.right, ans))\n\n\t# Update answer if current subtree\n\t# sum is greater than answer so far.\n\tans[0] = max(ans[0], currSum)\n\n\t# Return current subtree sum to\n\t# its parent node.\n\treturn currSum\n\n# Function to find largest subtree sum.\ndef findLargestSubtreeSum(root):\n\t\n\t# If tree does not exist,\n\t# then answer is 0.\n\tif (root == None):\t\n\t\treturn 0\n\t\n\t# Variable to store maximum subtree sum.\n\tans = [-999999999999]\n\n\t# Call to recursive function to\n\t# find maximum subtree sum.\n\tfindLargestSubtreeSumUtil(root, ans)\n\n\treturn ans[0]\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t#\n\t#\t\t 1\n\t#\t\t / \\\n\t#\t /\t \\\n\t#\t -2\t 3\n\t#\t / \\\t / \\\n\t#\t / \\ / \\\n\t# 4\t 5 -6\t 2\n\troot = newNode(1)\n\troot.left = newNode(-2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(-6)\n\troot.right.right = newNode(2)\n\n\tprint(findLargestSubtreeSum(root))\n\n# This code is contributed by PranchalK\n"}
{"nl": "Given a number x, which is the floor of the matchstick pyramid and the task is to find the number of matchsticks needed to form a pyramid of matchsticks of x floors.\r\n\r\nFormula:\r\n\r\n(3*x*(x+1))/2", "code": "# Create a function to say count_MatchSticks() which takes the given number as an\r\n# argument and returns the count of the number of matchsticks needed to form a\r\n# pyramid of matchsticks for a given number of floors.\r\n\r\n\r\ndef count_MatchSticks(no_floors):\r\n    # Inside the function, calculate the number of matchsticks needed using the above\r\n    # given mathematical formula and store it in a variable.\r\n    no_sticks = (3 * no_floors * (no_floors + 1)) / 2\r\n    # Return the above result.\r\n    return no_sticks\r\n\r\n\r\n# Give the number as static input and store it in a variable.\r\nno_floors = 3\r\nprint(\"The Number of matchsticks needed to form a pyramid of matchsticks :\")\r\n# Pass the given number as an argument to the count_MatchSticks() function, convert\r\n# it into an integer using the int() function and print it.\r\nprint(int(count_MatchSticks(no_floors)))"}
{"nl": "Create a function that determines whether it is possible to build a palindrome from the characters in a string.\nExamples\npossible_palindrome(\"acabbaa\") \u279e True\n# Can make the following palindrome: \"aabcbaa\"\n\npossible_palindrome(\"aacbdbc\") \u279e True\n# Can make the following palindrome: \"abcdcba\"\n\npossible_palindrome(\"aacbdb\") \u279e False\n\npossible_palindrome(\"abacbb\") \u279e False\nNotes\nN/A", "code": "def possible_palindrome(txt):\n  return sum(txt.count(i)%2 for i in set(txt)) <= 1"}
{"nl": "We have given a spiral matrix of odd-order, in which we start with the number 1 as center and moving to the right in a clockwise direction.\n\u00a0", "code": "# Python3 program to find sum of\n# diagonals of spiral matrix\n\u00a0\n# function returns sum of diagonals\ndef spiralDiaSum(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if n == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# as order should be only odd\n\u00a0\u00a0\u00a0\u00a0# we should pass only odd\n\u00a0\u00a0\u00a0\u00a0# integers\n\u00a0\u00a0\u00a0\u00a0return (4 * n*n - 6 * n + 6 +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spiralDiaSum(n-2))\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver program\nn = 7;\nprint(spiralDiaSum(n))\n\u00a0\n# This code is contributed by Anant Agarwal.\n"}
{"nl": "Given two values k1 and k2 (where k1 < k2) and a root pointer to a Binary Search Tree. Print all the keys of the tree in range k1 to k2. i.e. print all x such that k1<=x<=k2 and x is a key of given BST. Print all the keys in increasing order.\u00a0\n", "code": "# Python program to find BST keys in given range\n\u00a0\n# A binary tree node\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# The function prints all the keys in the given range\n# [k1..k2]. Assumes that k1 < k2\ndef Print(root, k1, k2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Since the desired o/p is sorted, recurse for left\n\u00a0\u00a0\u00a0\u00a0# subtree first. If root.data is greater than k1, then\n\u00a0\u00a0\u00a0\u00a0# only we can get o/p keys in left subtree\n\u00a0\u00a0\u00a0\u00a0if k1 < root.data :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Print(root.left, k1, k2)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If root's data lies in range, then prints root's data\n\u00a0\u00a0\u00a0\u00a0if k1 <= root.data and k2 >= root.data:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (root.data,end=' ')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# recursively call the right subtree\n\u00a0\u00a0\u00a0\u00a0Print(root.right, k1, k2)\n\u00a0\n# Driver function to test above function\nk1 = 10 ; k2 = 25 ;\nroot = Node(20)\nroot.left = Node(8)\nroot.right = Node(22)\nroot.left.left = Node(4)\nroot.left.right = Node(12)\n\u00a0\nPrint(root, k1, k2)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Given a non-empty binary tree, print the average value of the nodes on each level.", "code": "# Python3 program to find averages of\r\n# all levels in a binary tree.\r\n\r\n# Importing Queue\r\nfrom queue import Queue\r\n\r\n# Helper class that allocates a\r\n# new node with the given data and\r\n# None left and right pointers.\r\nclass newNode:\r\n\tdef __init__(self, data):\r\n\t\tself.val = data\r\n\t\tself.left = self.right = None\r\n\t\r\n# Function to print the average value\r\n# of the nodes on each level\r\ndef averageOfLevels(root):\r\n\r\n\t# Traversing level by level\r\n\tq = Queue()\r\n\tq.put(root)\r\n\twhile (not q.empty()):\r\n\r\n\t\t# Compute Sum of nodes and\r\n\t\t# count of nodes in current\r\n\t\t# level.\r\n\t\tSum = 0\r\n\t\tcount = 0\r\n\t\ttemp = Queue()\r\n\t\twhile (not q.empty()):\r\n\t\t\tn = q.queue[0]\r\n\t\t\tq.get()\r\n\t\t\tSum += n.val\r\n\t\t\tcount += 1\r\n\t\t\tif (n.left != None):\r\n\t\t\t\ttemp.put(n.left)\r\n\t\t\tif (n.right != None):\r\n\t\t\t\ttemp.put(n.right)\r\n\t\tq = temp\r\n\t\tprint((Sum * 1.0 / count), end = \" \")\r\n\r\n# Driver code\r\nif __name__ == '__main__':\r\n\r\n\t# Let us construct a Binary Tree\r\n\t#\t 4\r\n\t# / \\\r\n\t# 2 9\r\n\t# / \\ \\\r\n\t# 3 5 7\r\n\troot = None\r\n\troot = newNode(4)\r\n\troot.left = newNode(2)\r\n\troot.right = newNode(9)\r\n\troot.left.left = newNode(3)\r\n\troot.left.right = newNode(8)\r\n\troot.right.right = newNode(7)\r\n\taverageOfLevels(root)\r\n\r\n# This code is contributed by PranchalK\r"}
{"nl": "Given two arrays: arr1[0..m-1] and arr2[0..n-1]. Find whether arr2[] is a subset of arr1[] or not. Both the arrays are not in sorted order. It may be assumed that elements in both array are distinct.\n\nExamples: \n\nInput: arr1[] = {11, 1, 13, 21, 3, 7}, arr2[] = {11, 3, 7, 1} \nOutput: arr2[] is a subset of arr1[]\n\nInput: arr1[] = {1, 2, 3, 4, 5, 6}, arr2[] = {1, 2, 4} \nOutput: arr2[] is a subset of arr1[]\n\nInput: arr1[] = {10, 5, 2, 23, 19}, arr2[] = {19, 5, 3} \nOutput: arr2[] is not a subset of arr1[] ", "code": "# Python 3 program to find whether an array\n# is subset of another array\n\n# Return 1 if arr2[] is a subset of\n# arr1[]\ndef isSubset(arr1, arr2, m, n):\n\ti = 0\n\tj = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif(arr2[i] == arr1[j]):\n\t\t\t\tbreak\n\t\t\n\t\t# If the above inner loop was\n\t\t# not broken at all then arr2[i]\n\t\t# is not present in arr1[]\n\t\tif (j == m):\n\t\t\treturn 0\n\t\n\t# If we reach here then all\n\t# elements of arr2[] are present\n\t# in arr1[]\n\treturn 1\n\n# Driver code\nif __name__ == \"__main__\":\n\t\n\tarr1 = [11, 1, 13, 21, 3, 7]\n\tarr2 = [11, 3, 7, 1]\n\n\tm = len(arr1)\n\tn = len(arr2)\n\n\tif(isSubset(arr1, arr2, m, n)):\n\t\tprint(\"arr2[] is subset of arr1[] \")\n\telse:\n\t\tprint(\"arr2[] is not a subset of arr1[]\")\n\n# This code is contributed by ita_c"}
{"nl": "Given a binary tree, a complete path is defined as a path from root to a leaf. The sum of all nodes on that path is defined as the sum of that path. Given a number K, you have to remove (prune the tree) all nodes which don\u2019t lie in any path with sum>=k. \n\nNote: A node can be part of multiple paths. So we have to delete it only in case when all paths from it have sum less than K.\n\nConsider the following Binary Tree\n          1 \n      /      \\\n     2        3\n   /   \\     /  \\\n  4     5   6    7\n / \\    /       /\n8   9  12      10\n   / \\           \\\n  13  14         11\n      / \n     15 \n\nFor input k = 20, the tree should be changed to following\n(Nodes with values 6 and 8 are deleted)\n          1 \n      /      \\\n     2        3\n   /   \\        \\\n  4     5        7\n   \\    /       /\n    9  12      10\n   / \\           \\\n  13  14         11\n      / \n     15 \n\nFor input k = 45, the tree should be changed to following.\n      1 \n    / \n   2   \n  / \n 4  \n  \\   \n   9    \n    \\   \n     14 \n     /\n    15 ", "code": "# A class to create a new Binary Tree\n# node with given data\nclass newNode:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\n# print the tree in LVR (Inorder traversal) way.\ndef Print(root):\n\tif (root != None):\n\t\tPrint(root.left)\n\t\tprint(root.data, end = \" \")\n\t\tPrint(root.right)\n\n# Main function which truncates\n# the binary tree.\ndef pruneUtil(root, k, Sum):\n\t\n\t# Base Case\n\tif (root == None):\n\t\treturn None\n\n\t# Initialize left and right Sums as\n\t# Sum from root to this node\n\t# (including this node)\n\tlSum = [Sum[0] + (root.data)]\n\trSum = [lSum[0]]\n\n\t# Recursively prune left and right\n\t# subtrees\n\troot.left = pruneUtil(root.left, k, lSum)\n\troot.right = pruneUtil(root.right, k, rSum)\n\n\t# Get the maximum of left and right Sums\n\tSum[0] = max(lSum[0], rSum[0])\n\n\t# If maximum is smaller than k,\n\t# then this node must be deleted\n\tif (Sum[0] < k[0]):\n\t\troot = None\n\treturn root\n\n# A wrapper over pruneUtil()\ndef prune(root, k):\n\tSum = [0]\n\treturn pruneUtil(root, k, Sum)\n\n# Driver Code\nif __name__ == '__main__':\n\tk = [45]\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(6)\n\troot.right.right = newNode(7)\n\troot.left.left.left = newNode(8)\n\troot.left.left.right = newNode(9)\n\troot.left.right.left = newNode(12)\n\troot.right.right.left = newNode(10)\n\troot.right.right.left.right = newNode(11)\n\troot.left.left.right.left = newNode(13)\n\troot.left.left.right.right = newNode(14)\n\troot.left.left.right.right.left = newNode(15)\n\n\tprint(\"Tree before truncation\")\n\tPrint(root)\n\tprint()\n\troot = prune(root, k) # k is 45\n\n\tprint(\"Tree after truncation\")\n\tPrint(root)\n\n# This code is contributed by PranchalK\n"}
{"nl": "There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day.\n\nInitially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n:\n\nAssuming that on a day, you visit room i,\nif you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by nextVisit[i] where 0 <= nextVisit[i] <= i;\nif you have been in room i an even number of times (including the current visit), on the next day you will visit room (i + 1) mod n.\nReturn the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7.", "code": "class Solution:\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\n        time_taken = 0\n        n = len(nextVisit)\n        arrival_time = [0]*n\n        MOD = 10**9 + 7\n        \n        for i, next_room in enumerate(nextVisit):\n            if i != 0:\n                arrival_time[i] = 1 + arrival_time[i-1] + time_taken\n            time_taken = (arrival_time[i] - arrival_time[next_room])+1\n        \n        return (arrival_time[-1])%MOD"}
{"nl": "The current article would deal with the concepts surrounding the complex networks using the python library Networkx. It is a Python language software package for the creation, manipulation, and study of the structure, dynamics, and function of complex networks. With NetworkX you can load and store networks in standard and nonstandard data formats, generate many types of random and classic networks, analyze network structure, build network models, design new network algorithms, draw networks, and much more.\n\nThe current article would deal with the algorithm for generating random scale free networks for using preferential attachment model. The reason of interest behind this model dates back to the 1990s when Albert Lazlo Barabasi and Reka Albert came out with the path breaking research describing the model followed by the scale free networks around the world. They suggested that several natural and human-made systems, including the Internet, the World Wide Web, citation networks, and some social networks are thought to be approximately scale-free networks.\nA scale-free network is a network whose degree distribution follows a power law, at least asymptotically. That is, the fraction P (k) of nodes in the network having k connections to other nodes goes for large values of k as\n\nP(k)=ck^{-\\gamma }\nWhere \\gamma is a parameter whose value is typically in the range 2 < \\gamma < 3, although occasionally it may lie outside these bounds and c is a proportionality constant.\n\nThe Barab\u00e1si\u2013Albert model is one of several proposed models that generate scale-free networks. It incorporates two important general concepts: growth and preferential attachment. Both growth and preferential attachment exist widely in real networks. Growth means that the number of nodes in the network increases over time.\nPreferential attachment means that the more connected a node is, the more likely it is to receive new links. Nodes with higher degree have stronger ability to grab links added to the network. Intuitively, the preferential attachment can be understood if we think in terms of social networks connecting people. Here a link from A to B means that person A \"knows\" or \"is acquainted with\" person B. Heavily linked nodes represent well-known people with lots of relations. When a newcomer enters the community, s/he is more likely to become acquainted with one of those more visible people rather than with a relative unknown. The BA model was proposed by assuming that in the World Wide Web, new pages link preferentially to hubs, i.e. very well-known sites such as Google, rather than to pages that hardly anyone knows. If someone selects a new page to link to by randomly choosing an existing link, the probability of selecting a particular page would be proportional to its degree.", "code": "def barabasi_albert_graph(n, m, seed=None):\n    \"\"\"Returns a random graph according to the Barab\u00e1si\u2013Albert preferential\n    Attachment model.\n  \n    A graph of ``n`` nodes is grown by attaching new nodes each with ``m``\n    Edges that are preferentially attached to existing nodes with high degree.\n  \n    Parameters\n    ----------\n    n : int\n        Number of nodes\n    m : int\n        Number of edges to attach from a new node to existing nodes\n    seed : int, optional\n        Seed for random number generator (default=None).\n  \n    Returns\n    -------\n    G : Graph\n  \n    Raises\n    ------\n    NetworkXError\n        If ``m`` does not satisfy ``1 <= m < n``.\n  \n      \n    if m < 1 or  m >=n:\n        raise nx.NetworkXError(\"Barab\u00e1si\u2013Albert network must have m >= 1\"\n                               \" and m < n, m = %d, n = %d\" % (m, n))\n    if seed is not None:\n        random.seed(seed)\n  \n    # Add m initial nodes (m0 in barabasi-speak)\n    G=empty_graph(m)\n    G.name=\"barabasi_albert_graph(%s,%s)\"%(n,m)\n    # Target nodes for new edges\n    targets=list(range(m))\n    # List of existing nodes, with nodes repeated once for each adjacent edge\n    repeated_nodes=[]\n    # Start adding the other n-m nodes. The first node is m.\n    source=m\n    while source<n:\n        # Add edges to m nodes from the source.\n        G.add_edges_from(zip(*m,targets))\n        # Add one node to the list for each new edge just created.\n        repeated_nodes.extend(targets)\n        # And the new node \"source\" has m edges to add to the list.\n        repeated_nodes.extend(*m)\n        # Now choose m unique nodes from the existing nodes\n        # Pick uniformly from repeated_nodes (preferential attachement)\n        targets = _random_subset(repeated_nodes,m)\n        source += 1\n    return G"}
{"nl": "This article discusses the basics of Softmax Regression and its implementation in Python using TensorFlow library.\n\nWhat is Softmax Regression?\n\nSoftmax regression (or multinomial logistic regression) is a generalization of logistic regression to the case where we want to handle multiple classes.", "code": "import tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tensorflow.examples.tutorials.mnist import input_data\nmnist = input_data.read_data_sets(\"MNIST_data/\", one_hot=True)\nprint(\"Shape of feature matrix:\", mnist.train.images.shape)\nprint(\"Shape of target matrix:\", mnist.train.labels.shape)\nprint(\"One-hot encoding for 1st observation:\\n\", mnist.train.labels[0])\n\n# visualize data by plotting images\nfig,ax = plt.subplots(10,10)\nk = 0\nfor i in range(10):\n\tfor j in range(10):\n\t\tax[i][j].imshow(mnist.train.images[k].reshape(28,28), aspect='auto')\n\t\tk += 1\nplt.show()\n# number of features\nnum_features = 784\n# number of target labels\nnum_labels = 10\n# learning rate (alpha)\nlearning_rate = 0.05\n# batch size\nbatch_size = 128\n# number of epochs\nnum_steps = 5001\n\n# input data\ntrain_dataset = mnist.train.images\ntrain_labels = mnist.train.labels\ntest_dataset = mnist.test.images\ntest_labels = mnist.test.labels\nvalid_dataset = mnist.validation.images\nvalid_labels = mnist.validation.labels\n\n# initialize a tensorflow graph\ngraph = tf.Graph()\n\nwith graph.as_default():\n\t\"\"\"\n\tdefining all the nodes\n\t\"\"\"\n\n\t# Inputs\n\ttf_train_dataset = tf.placeholder(tf.float32, shape=(batch_size, num_features))\n\ttf_train_labels = tf.placeholder(tf.float32, shape=(batch_size, num_labels))\n\ttf_valid_dataset = tf.constant(valid_dataset)\n\ttf_test_dataset = tf.constant(test_dataset)\n\n\t# Variables.\n\tweights = tf.Variable(tf.truncated_normal([num_features, num_labels]))\n\tbiases = tf.Variable(tf.zeros([num_labels]))\n\n\t# Training computation.\n\tlogits = tf.matmul(tf_train_dataset, weights) + biases\n\tloss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(\n\t\t\t\t\t\tlabels=tf_train_labels, logits=logits))\n\n\t# Optimizer.\n\toptimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)\n\n\t# Predictions for the training, validation, and test data.\n\ttrain_prediction = tf.nn.softmax(logits)\n\tvalid_prediction = tf.nn.softmax(tf.matmul(tf_valid_dataset, weights) + biases)\n\ttest_prediction = tf.nn.softmax(tf.matmul(tf_test_dataset, weights) + biases)\n# utility function to calculate accuracy\ndef accuracy(predictions, labels):\n\tcorrectly_predicted = np.sum(np.argmax(predictions, 1) == np.argmax(labels, 1))\n\taccu = (100.0 * correctly_predicted) / predictions.shape[0]\n\treturn accu\n\nwith tf.Session(graph=graph) as session:\n\t# initialize weights and biases\n\ttf.global_variables_initializer().run()\n\tprint(\"Initialized\")\n\n\tfor step in range(num_steps):\n\t\t# pick a randomized offset\n\t\toffset = np.random.randint(0, train_labels.shape[0] - batch_size - 1)\n\n\t\t# Generate a minibatch.\n\t\tbatch_data = train_dataset[offset:(offset + batch_size), :]\n\t\tbatch_labels = train_labels[offset:(offset + batch_size), :]\n\n\t\t# Prepare the feed dict\n\t\tfeed_dict = {tf_train_dataset : batch_data,\n\t\t\t\t\ttf_train_labels : batch_labels}\n\n\t\t# run one step of computation\n\t\t_, l, predictions = session.run([optimizer, loss, train_prediction],\n\t\t\t\t\t\t\t\t\t\tfeed_dict=feed_dict)\n\n\t\tif (step % 500 == 0):\n\t\t\tprint(\"Minibatch loss at step {0}: {1}\".format(step, l))\n\t\t\tprint(\"Minibatch accuracy: {:.1f}%\".format(\n\t\t\t\taccuracy(predictions, batch_labels)))\n\t\t\tprint(\"Validation accuracy: {:.1f}%\".format(\n\t\t\t\taccuracy(valid_prediction.eval(), valid_labels)))\n\n\tprint(\"\\nTest accuracy: {:.1f}%\".format(\n\t\taccuracy(test_prediction.eval(), test_labels)))\n"}
{"nl": "Given a sentence, return the number of words which have the same first and last letter.\nExamples\ncount_same_ends(\"Pop! goes the balloon\") \u279e 1\n\ncount_same_ends(\"And the crowd goes wild!\") \u279e 0\n\ncount_same_ends(\"No I am not in a gang.\") \u279e 1\nNotes\nDon't count single character words (such as \"I\" and \"A\" in example #3).\nThe function should not be case sensitive, meaning a capital \"P\" should match with a lowercase one.\nMind the punctuation!\nBonus points indeed for using regex!", "code": "import re\ndef count_same_ends(txt):\n  return len(re.findall(r'\\b(\\w)\\w*\\1\\b', txt.lower()))"}
{"nl": "Write a function that counts how many concentric layers a rug has.\nExamples\ncount_layers([\n  \"AAAA\",\n  \"ABBA\",\n  \"AAAA\"\n]) \u279e 2\n\ncount_layers([\n  \"AAAAAAAAA\",\n  \"ABBBBBBBA\",\n  \"ABBAAABBA\",\n  \"ABBBBBBBA\",\n  \"AAAAAAAAA\"\n]) \u279e 3\n\ncount_layers([\n  \"AAAAAAAAAAA\",\n  \"AABBBBBBBAA\",\n  \"AABCCCCCBAA\",\n  \"AABCAAACBAA\",\n  \"AABCADACBAA\",\n  \"AABCAAACBAA\",\n  \"AABCCCCCBAA\",\n  \"AABBBBBBBAA\",\n  \"AAAAAAAAAAA\"\n]) \u279e 5\nNotes\nMultiple layers can share the same component so count them separately (example #2).\nLayers will be horizontally and vertically symmetric.\nThere will be at least one layer for each rug.", "code": "def count_layers(rug):\n  return len(set(rug))"}
{"nl": "Armstrong Number:\n\nBeginners sometimes ask what the Armstrong number, also known as the narcissist number, is. Because of the way the number behaves in a given number base, it is particularly interesting to new programmers and those learning a new programming language. The Armstrong number meaning in numerical number theory is the number in any given number base that forms the sum of the same number when each of its digits is raised to the power of the number\u2019s digits.\n\nItertools count() function:\n\nThe count(start, step) method generates an iterator that is used to generate equally spaced numbers, where the step argument defines the space between them. The start argument specifies the iterator\u2019s starting value, which is set by default to start=0 and step=1.\n\nIn the absence of a breaking condition, the count() method will continue counting indefinitely (on a system with infinite memory)\n\n\n\nGiven a number, the task is to print the previous Armstrong number in Python.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven Number =67\nOutput:\n\nThe previous armstrong number of { 67 } is : 9\nExample2:\n\nInput:\n\nGiven Number =450\nOutput:\n\nThe previous armstrong number of { 450 } is : 407", "code": "# Import the count from the itertools module using the import and from keyword.\n from itertools import count\n # Give the number n as static input and store it in a variable.\n gvnnumb = 67\n # Loop till the given number in decreasing order using the For loop\n # and the count() function.\n for m in count(gvnnumb, -1):\n  # Convert the given number to the string using the str() function\n  # and store it in a variable say strngnumb.\n  strngnumb = str(m)\n  # Take a variable say cuntsum and initialize its value to 0.\n  cuntsum = 0\n  # Calculate the length of the string using the len() function\n  # and store it in a variable to say\n  strnglengt = len(strngnumb)\n  # Loop in the strngnumb using the nested For loop(Inner For loop).\n  for dgtval in strngnumb:\n  # Convert the inner loop iterator value to an integer using the int() function\n  # and store it as a new variable say intitr.\n  intitr = int(dgtval)\n  # Inside the for loop, increment the value of cuntsum with intitr**strnglengt(where ** is power operator).\n  cuntsum += intitr**strnglengt\n  # After the end of For loop check if cuntsum is equal to the iterator value\n  # of the inner for loop using the if conditional statement.\n  if(cuntsum == m):\n  # If it is true then print the value of cuntsum.\n  print('The previous armstrong number of {', gvnnumb, '} is :', cuntsum)\n  # Break the parent for loop using the break keyword.\n  break"}
{"nl": "Given an array of length N that contains only integers, the task is to print the special numbers of array. A number in this array is called Special number if it is divisible by at least one other number in the array.\nExamples : \n \n\nInput : 1 2 3 \nOutput : 2 3 \nExplanation : both 2 and 3 are divisible by 1.", "code": "# Python3 program to find special numbers\n# in an array\nimport math as mt\n\n# Function to find special numbers\ndef divisibilityCheck(arr, n):\n\n        # Storing all array elements in a hash\n        # and finding maximum element in array\n        s = dict()\n        max_ele = -10**9\n        for i in range(n):\n                s[arr[i]] = 1\n\n                # finding maximum element of array\n                max_ele = max(max_ele, arr[i])\n        \n        # traversing array element and storing\n        # the array multiples that are present\n        # in s in res.\n        res = dict()\n        for i in range(n):\n\n                # Check for non-zero values only\n                if (arr[i] != 0):\n\n                        # checking the factor of current element\n                        for j in range(arr[i] * 2,\n                                                max_ele + 1, arr[i]):\n                                \n                                # if factor is already part of\n                                # array element then store it\n                                if (j in s.keys()):\n                                        res[j] = 1\n                        \n        # displaying elements that are divisible\n        # by at least one other in array\n        for x in res:\n                print(x, end = \" \")\n\n# Driver code\narr = [ 2, 3, 8, 6, 9, 10]\nn = len(arr)\ndivisibilityCheck(arr, n)\n\n# This code is contributed by\n# Mohit Kumar 29\n"}
{"nl": "Given an array of n numbers. Your task is to read numbers from the array and keep at-most K numbers at the top (According to their decreasing frequency) every time a new number is read. We basically need to print top k numbers sorted by frequency when input stream has included k distinct elements, else need to print all distinct elements sorted by frequency.\nExamples: \n \n\nInput : arr[] = {5, 2, 1, 3, 2} \nk = 4 \nOutput : 5 2 5 1 2 5 1 2 3 5 2 1 3 5 \nExplanation: \n \n\nAfter reading 5, there is only one element 5 whose frequency is max till now. \nso print 5.\nAfter reading 2, we will have two elements 2 and 5 with the same frequency. \nAs 2, is smaller than 5 but their frequency is the same so we will print 2 5.\nAfter reading 1, we will have 3 elements 1, 2 and 5 with the same frequency, \nso print 1 2 5.\nSimilarly after reading 3, print 1 2 3 5\nAfter reading last element 2 since 2 has already occurred so we have now a \nfrequency of 2 as 2. So we keep 2 at the top and then rest of the element \nwith the same frequency in sorted order. So print, 2 1 3 5.\nInput : arr[] = {5, 2, 1, 3, 4} \nk = 4 \nOutput : 5 2 5 1 2 5 1 2 3 5 1 2 3 4 \nExplanation:\n\nAfter reading 5, there is only one element 5 whose frequency is max till now. \nso print 5.\nAfter reading 2, we will have two elements 2 and 5 with the same frequency. \nAs 2, is smaller than 5 but their frequency is the same so we will print 2 5.\nAfter reading 1, we will have 3 elements 1, 2 and 5 with the same frequency, \nso print 1 2 5. \nSimilarly after reading 3, print 1 2 3 5\nAfter reading last element 4, All the elements have same frequency \nSo print, 1 2 3 4.", "code": "# Python program to find top k elements in a stream\n\n# Function to print top k numbers\ndef kTop(a, n, k):\n\n\t# list of size k + 1 to store elements\n\ttop = [0 for i in range(k + 1)]\n\n\t# dictionary to keep track of frequency\n\tfreq = {i:0 for i in range(k + 1)}\n\n\t# iterate till the end of stream\n\tfor m in range(n):\n\n\t\t# increase the frequency\n\t\tif a[m] in freq.keys():\n\t\t\tfreq[a[m]] += 1\n\t\telse:\n\t\t\tfreq[a[m]] = 1\n\n\t\t# store that element in top vector\n\t\ttop[k] = a[m]\n\n\t\ti = top.index(a[m])\n\t\ti -= 1\n\t\t\n\t\twhile i >= 0:\n\n\t\t\t# compare the frequency and swap if higher\n\t\t\t# frequency element is stored next to it\n\t\t\tif (freq[top[i]] < freq[top[i + 1]]):\n\t\t\t\tt = top[i]\n\t\t\t\ttop[i] = top[i + 1]\n\t\t\t\ttop[i + 1] = t\n\t\t\t\n\t\t\t# if frequency is same compare the elements\n\t\t\t# and swap if next element is high\n\t\t\telse if ((freq[top[i]] == freq[top[i + 1]]) and (top[i] > top[i + 1])):\n\t\t\t\tt = top[i]\n\t\t\t\ttop[i] = top[i + 1]\n\t\t\t\ttop[i + 1] = t\n\t\t\telse:\n\t\t\t\tbreak\n\t\t\ti -= 1\n\t\t\n\t\t# print top k elements\n\t\ti = 0\n\t\twhile i < k and top[i] != 0:\n\t\t\tprint(top[i],end=\" \")\n\t\t\ti += 1\n\tprint()\n\n# Driver program to test above function\nk = 4\narr = [ 5, 2, 1, 3, 2 ]\nn = len(arr)\nkTop(arr, n, k)\n\n# This code is contributed by Sachin Bisht"}
{"nl": "In Prim\u2019s algorithm, two sets are maintained, one set contains list of vertices already included in MST, other set contains vertices not yet included. With adjacency list representation, all vertices of a graph can be traversed in O(V+E) time using BFS. The idea is to traverse all vertices of graph using BFS and use a Min Heap to store the vertices not yet included in MST. Min Heap is used as a priority queue to get the minimum weight edge from the cut. Min Heap is used as time complexity of operations like extracting minimum element and decreasing key value is O(LogV) in Min Heap.\nFollowing are the detailed steps. \n1) Create a Min Heap of size V where V is the number of vertices in the given graph. Every node of min heap contains vertex number and key value of the vertex. \n2) Initialize Min Heap with first vertex as root (the key value assigned to first vertex is 0). The key value assigned to all other vertices is INF (infinite). \n3) While Min Heap is not empty, do following \n    a) Extract the min value node from Min Heap. Let the extracted vertex be u. \n    b) For every adjacent vertex v of u, check if v is in Min Heap (not yet included in MST). If v is in Min Heap and its key value is more than weight of u-v, then update the key value of v as weight of u-v.", "code": "# A Python program for Prims's MST for\n# adjacency list representation of graph\n\nfrom collections import defaultdict\nimport sys\n\nclass Heap():\n\n        def __init__(self):\n                self.array = []\n                self.size = 0\n                self.pos = []\n\n        def newMinHeapNode(self, v, dist):\n                minHeapNode = [v, dist]\n                return minHeapNode\n\n        # A utility function to swap two nodes of\n        # min heap. Needed for min heapify\n        def swapMinHeapNode(self, a, b):\n                t = self.array[a]\n                self.array[a] = self.array[b]\n                self.array[b] = t\n\n        # A standard function to heapify at given idx\n        # This function also updates position of nodes\n        # when they are swapped. Position is needed\n        # for decreaseKey()\n        def minHeapify(self, idx):\n                smallest = idx\n                left = 2 * idx + 1\n                right = 2 * idx + 2\n\n                if left < self.size and self.array[left][1] < \\\n                                                                self.array[smallest][1]:\n                        smallest = left\n\n                if right < self.size and self.array[right][1] < \\\n                                                                self.array[smallest][1]:\n                        smallest = right\n\n                # The nodes to be swapped in min heap\n                # if idx is not smallest\n                if smallest != idx:\n\n                        # Swap positions\n                        self.pos[ self.array[smallest][0] ] = idx\n                        self.pos[ self.array[idx][0] ] = smallest\n\n                        # Swap nodes\n                        self.swapMinHeapNode(smallest, idx)\n\n                        self.minHeapify(smallest)\n\n        # Standard function to extract minimum node from heap\n        def extractMin(self):\n\n                # Return NULL wif heap is empty\n                if self.isEmpty() == True:\n                        return\n\n                # Store the root node\n                root = self.array[0]\n\n                # Replace root node with last node\n                lastNode = self.array[self.size - 1]\n                self.array[0] = lastNode\n\n                # Update position of last node\n                self.pos[lastNode[0]] = 0\n                self.pos[root[0]] = self.size - 1\n\n                # Reduce heap size and heapify root\n                self.size -= 1\n                self.minHeapify(0)\n\n                return root\n\n        def isEmpty(self):\n                return True if self.size == 0 else False\n\n        def decreaseKey(self, v, dist):\n\n                # Get the index of v in heap array\n\n                i = self.pos[v]\n\n                # Get the node and update its dist value\n                self.array[i][1] = dist\n\n                # Travel up while the complete tree is not\n                # hepified. This is a O(Logn) loop\n                while i > 0 and self.array[i][1] < \\\n                                        self.array[(i - 1) // 2][1]:\n\n                        # Swap this node with its parent\n                        self.pos[ self.array[i][0] ] = (i-1)/2\n                        self.pos[ self.array[(i-1)//2][0] ] = i\n                        self.swapMinHeapNode(i, (i - 1)//2 )\n\n                        # move to parent index\n                        i = (i - 1) // 2;\n\n        # A utility function to check if a given vertex\n        # 'v' is in min heap or not\n        def isInMinHeap(self, v):\n\n                if self.pos[v] < self.size:\n                        return True\n                return False\n\n\ndef printArr(parent, n):\n        for i in range(1, n):\n                print(\"% d - % d\" % (parent[i], i))\n\n\nclass Graph():\n\n        def __init__(self, V):\n                self.V = V\n                self.graph = defaultdict(list)\n\n        # Adds an edge to an undirected graph\n        def addEdge(self, src, dest, weight):\n\n                # Add an edge from src to dest. A new node is\n                # added to the adjacency list of src. The node\n                # is added at the beginning. The first element of\n                # the node has the destination and the second\n                # elements has the weight\n                newNode = [dest, weight]\n                self.graph[src].insert(0, newNode)\n\n                # Since graph is undirected, add an edge from\n                # dest to src also\n                newNode = [src, weight]\n                self.graph[dest].insert(0, newNode)\n\n        # The main function that prints the Minimum\n        # Spanning Tree(MST) using the Prim's Algorithm.\n        # It is a O(ELogV) function\n        def PrimMST(self):\n                # Get the number of vertices in graph\n                V = self.V\n                \n                # key values used to pick minimum weight edge in cut\n                key = []\n                \n                # List to store constructed MST\n                parent = []\n\n                # minHeap represents set E\n                minHeap = Heap()\n\n                # Initialize min heap with all vertices. Key values of all\n                # vertices (except the 0th vertex) is is initially infinite\n                for v in range(V):\n                        parent.append(-1)\n                        key.append(1e7)\n                        minHeap.array.append( minHeap.newMinHeapNode(v, key[v]) )\n                        minHeap.pos.append(v)\n\n                # Make key value of 0th vertex as 0 so\n                # that it is extracted first\n                minHeap.pos[0] = 0\n                key[0] = 0\n                minHeap.decreaseKey(0, key[0])\n\n                # Initially size of min heap is equal to V\n                minHeap.size = V;\n\n                # In the following loop, min heap contains all nodes\n                # not yet added in the MST.\n                while minHeap.isEmpty() == False:\n\n                        # Extract the vertex with minimum distance value\n                        newHeapNode = minHeap.extractMin()\n                        u = newHeapNode[0]\n\n                        # Traverse through all adjacent vertices of u\n                        # (the extracted vertex) and update their\n                        # distance values\n                        for pCrawl in self.graph[u]:\n\n                                v = pCrawl[0]\n\n                                # If shortest distance to v is not finalized\n                                # yet, and distance to v through u is less than\n                                # its previously calculated distance\n                                if minHeap.isInMinHeap(v) and pCrawl[1] < key[v]:\n                                        key[v] = pCrawl[1]\n                                        parent[v] = u\n\n                                        # update distance value in min heap also\n                                        minHeap.decreaseKey(v, key[v])\n\n                printArr(parent, V)\n\n\n# Driver program to test the above functions\ngraph = Graph(9)\ngraph.addEdge(0, 1, 4)\ngraph.addEdge(0, 7, 8)\ngraph.addEdge(1, 2, 8)\ngraph.addEdge(1, 7, 11)\ngraph.addEdge(2, 3, 7)\ngraph.addEdge(2, 8, 2)\ngraph.addEdge(2, 5, 4)\ngraph.addEdge(3, 4, 9)\ngraph.addEdge(3, 5, 14)\ngraph.addEdge(4, 5, 10)\ngraph.addEdge(5, 6, 2)\ngraph.addEdge(6, 7, 1)\ngraph.addEdge(6, 8, 6)\ngraph.addEdge(7, 8, 7)\ngraph.PrimMST()\n\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "Given a polygon and a point \u2018p\u2019, find if \u2018p\u2019 lies inside the polygon or not. ", "code": "# A Python3 program to check if a given point\n# lies inside a given polygon\n# Refer https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# for explanation of functions onSegment(),\n# orientation() and doIntersect()\n\n# Define Infinite (Using INT_MAX\n# caused overflow problems)\nINT_MAX = 10000\n\n# Given three collinear points p, q, r,\n# the function checks if point q lies\n# on line segment 'pr'\ndef onSegment(p:tuple, q:tuple, r:tuple) -> bool:\n\t\n\tif ((q[0] <= max(p[0], r[0])) &\n\t\t(q[0] >= min(p[0], r[0])) &\n\t\t(q[1] <= max(p[1], r[1])) &\n\t\t(q[1] >= min(p[1], r[1]))):\n\t\treturn True\n\t\t\n\treturn False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are collinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p:tuple, q:tuple, r:tuple) -> int:\n\t\n\tval = (((q[1] - p[1]) *\n\t\t\t(r[0] - q[0])) -\n\t\t((q[0] - p[0]) *\n\t\t\t(r[1] - q[1])))\n\t\t\t\n\tif val == 0:\n\t\treturn 0\n\tif val > 0:\n\t\treturn 1 # Collinear\n\telse:\n\t\treturn 2 # Clock or counterclock\n\ndef doIntersect(p1, q1, p2, q2):\n\t\n\t# Find the four orientations needed for\n\t# general and special cases\n\to1 = orientation(p1, q1, p2)\n\to2 = orientation(p1, q1, q2)\n\to3 = orientation(p2, q2, p1)\n\to4 = orientation(p2, q2, q1)\n\n\t# General case\n\tif (o1 != o2) and (o3 != o4):\n\t\treturn True\n\t\n\t# Special Cases\n\t# p1, q1 and p2 are collinear and\n\t# p2 lies on segment p1q1\n\tif (o1 == 0) and (onSegment(p1, p2, q1)):\n\t\treturn True\n\n\t# p1, q1 and p2 are collinear and\n\t# q2 lies on segment p1q1\n\tif (o2 == 0) and (onSegment(p1, q2, q1)):\n\t\treturn True\n\n\t# p2, q2 and p1 are collinear and\n\t# p1 lies on segment p2q2\n\tif (o3 == 0) and (onSegment(p2, p1, q2)):\n\t\treturn True\n\n\t# p2, q2 and q1 are collinear and\n\t# q1 lies on segment p2q2\n\tif (o4 == 0) and (onSegment(p2, q1, q2)):\n\t\treturn True\n\n\treturn False\n\n# Returns true if the point p lies\n# inside the polygon[] with n vertices\ndef is_inside_polygon(points:list, p:tuple) -> bool:\n\t\n\tn = len(points)\n\t\n\t# There must be at least 3 vertices\n\t# in polygon\n\tif n < 3:\n\t\treturn False\n\t\t\n\t# Create a point for line segment\n\t# from p to infinite\n\textreme = (INT_MAX, p[1])\n\tcount = i = 0\n\t\n\twhile True:\n\t\tnext = (i + 1) % n\n\t\t\n\t\t# Check if the line segment from 'p' to\n\t\t# 'extreme' intersects with the line\n\t\t# segment from 'polygon[i]' to 'polygon[next]'\n\t\tif (doIntersect(points[i],\n\t\t\t\t\t\tpoints[next],\n\t\t\t\t\t\tp, extreme)):\n\t\t\t\t\t\t\t\n\t\t\t# If the point 'p' is collinear with line\n\t\t\t# segment 'i-next', then check if it lies\n\t\t\t# on segment. If it lies, return true, otherwise false\n\t\t\tif orientation(points[i], p,\n\t\t\t\t\t\tpoints[next]) == 0:\n\t\t\t\treturn onSegment(points[i], p,\n\t\t\t\t\t\t\t\tpoints[next])\n\t\t\t\t\t\t\t\t\n\t\t\tcount += 1\n\t\t\t\n\t\ti = next\n\t\t\n\t\tif (i == 0):\n\t\t\tbreak\n\t\t\n\t# Return true if count is odd, false otherwise\n\treturn (count % 2 == 1)\n\n# Driver code\nif __name__ == '__main__':\n\t\n\tpolygon1 = [ (0, 0), (10, 0), (10, 10), (0, 10) ]\n\t\n\tp = (20, 20)\n\tif (is_inside_polygon(points = polygon1, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tp = (5, 5)\n\tif (is_inside_polygon(points = polygon1, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\n\tpolygon2 = [ (0, 0), (5, 0), (5, 5), (3, 3) ]\n\t\n\tp = (3, 3)\n\tif (is_inside_polygon(points = polygon2, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tp = (5, 1)\n\tif (is_inside_polygon(points = polygon2, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tp = (8, 1)\n\tif (is_inside_polygon(points = polygon2, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tpolygon3 = [ (0, 0), (10, 0), (10, 10), (0, 10) ]\n\t\n\tp = (-1, 10)\n\tif (is_inside_polygon(points = polygon3, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n# This code is contributed by Vikas Chitturi"}
{"nl": "Write a DECIMATOR function which takes a string and decimates it (i.e. it removes the last 1/10 of the characters).\nAlways round up: if the string has 21 characters, 1/10 of the characters would be 2.1 characters, hence the DECIMATOR removes 3 characters. The DECIMATOR shows no mercy!\nExamples\nDECIMATOR(\"1234567890\") \u279e \"123456789\"\n# 10 characters, removed 1.\n\nDECIMATOR(\"1234567890AB\") \u279e \"1234567890\"\n# 12 characters, removed 2.\n\nDECIMATOR(\"123\") \u279e \"12\"\n# 3 characters, removed 1.\n\nDECIMATOR(\"123456789012345678901\") \u279e \"123456789012345678\"\n# 21 characters, removed 3.\nNotes\nMake sure to remove characters from the end of the string.", "code": "def DECIMATOR(txt):\n  return txt[:-((len(txt)+9)//10)]"}
{"nl": "Files and File Handling in Python:\n\nA file is a piece of information or data that is saved in computer storage devices. One of the most crucial aspects of any language is file handling. The Python programming language allows two types of files. The first is a text file, which stores data in the form of text that humans and computers can read. The second type is a binary file, which stores binary data and is only readable by a computer. I\n\nFile handling is the process of managing files on a file system. Each operating system has its own method of storing files.\n\n\n\nPython file handling comes in useful when working with files in our projects. We don\u2019t need to be concerned about the underlying operating system or its file system rules and operations.", "code": "# Take a variable say wordCount that stores the calculate the\n# count of given word in a given file and initialize it to 0.\nwordCount = 0\n# Scan the given word by user input using the int(input()) function and store it in a variable.\ngivenword = input('Enter the given word = ')\n# Enter the file's name into the input() function and save it to a variable.\nfilename = input(\"Enter the file name = \")\n# Open the file with the entered file name in read mode.\nwith open(filename, 'r') as givenfile:\n  # Traverse the lines in the file using a For loop.\n  for fileline in givenfile:\n  # Using the split() method, split the line into words.\n  wordslist = fileline.split()\n  # To traverse the words in the list, use a For loop.\n  for words in wordslist:\n  # If the iterator value is equal to the given word then increase the wordCount by 1.\n  if(words == givenword):\n  wordCount = wordCount+1\n# Print the wordCount.\nprint('The total count of the given word {',\n  givenword, '} in the given file = ', wordCount)"}
{"nl": "Files in Python:\n\nPython, like many other programming languages, offers file handling and allows users to read and write files, as well as perform a variety of other file-related tasks. The concept of file handling has been extended to a variety of other languages, but the implementation is either complicated or lengthy. However, like most Python principles, this concept is simple and straightforward. Python processes file differently depending on whether they are text or binary, which is crucial. Each line of code consists of a series of characters that together constitute a text file. A specific character called the EOL or End of Line character, such as the comma, or a newline character is used to end each line in a file.\n\nGiven two files, the task is to copy the contents of one file to the other file.", "code": "# In read mode, open the first file say  samplefile1.txt.\nwith open(\"samplefile1.txt\") as file1:\n  # In write mode, open the second file say  samplefile2.txt.\n    with open(\"samplefile2.txt\", \"w\") as file2:\n      # Using for loop, go over the lines in the first file.\n        for iline in file1:\n          # Copy the ith line of the first file to the second file using the write function.\n            file2.write(iline)"}
{"nl": "Files in Python:\n\nFiles are identified locations on the disc where associated data is stored. They\u2019re used to keep data in non-volatile memory for a long time (e.g. hard disk).\n\nWe use files for future usage of the data by permanently saving it because Random Access Memory (RAM) is volatile (it loses its contents when the machine is turned off).\n\n\n\nWe must first open a file before we can read from or write to it. When we\u2019re finished, it needs to be closed so that the file\u2019s resources may be released.\n\nAs a result, a file operation in Python is performed in the following order:\n\nCreate a new file\nYou can either read or write (perform the operations)\nClose the file.\n\nGiven a file, the task is to copy odd lines from a given file into another file in Python.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nreading_file = open(givenFilename, \"r\") \n# Make another variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"oddlinesfile.txt\"\n# Open another file in write mode. In this case, we're writing the contents into the file.\nwriting_file = open(givenFilename, \"w\") \n# Get the lines of the reading file using the readlines() function and store it in a variable\nfilelines = reading_file.readlines() \n# Iterate in the length of the file lines using the for loop\nfor line_indx in range(0, len(filelines)): \n  # Check if the index of the file lines is odd using the if conditional statement\n  if(line_indx % 2 != 0): \n  # If it is true, then write the file line using the write() function into the \n  # writing file\n  writing_file.write(filelines[line_indx]) \n# Close the writing file using the close() function\nwriting_file.close()\n# Close the reading file using the close() function\nreading_file.close()"}
{"nl": "Given the values of equations of two lines, and the task is to check if the given two lines are parallel or not.", "code": "#Create a function checkParallel() which accepts the 6 parameters\n#(First and second line x,y,z coordinates)\n#We can Check if the slopes of the given two lines are equal by formula (a1/b1 == a2/b2).\ndef checkParallel(a1,b1,c1,a2,b2,c2):\n    #Inside the checkParallel() function.\n    #Check if both lines y coordinates are not equal to 0 \n    #using the If conditional Statement.\n    if(b1!=0 and b2!=0):\n        #If it is true then check a1/b1 is equal to a2/b2 \n        #using another Nested If conditional Statement.\n        if(a1/b1==a2/b2):\n            #If it is true then return True\n            return True\n        else:\n            #Else return False.\n            return False\n    #If parent If conditional statement is false then inside the else statement \n    \n    else:\n      #check if first line and second line x and y coordinates are equal\n      #or not using the nested If conditional statement.\n      if(a1==a2 and b1==b2):\n          #If it is true then return True else return False.\n          return True\n      else:\n          return False\n#Give the values of a1,b1,c1 as user input using map(),int(),split() functions \n#and store it in three separate variables.\na1,b1,c1=map(int,input('Enter some random x y z coordinates separated by spaces = ').split())                    \n#Give the values of a2,b2,c2 as user input using map(),int(),split() functions \n#and store it in three separate variables.\na2,b2,c2=map(int,input('Enter some random x y z coordinates separated by spaces = ').split())\n#Pass the a1,b1,c1,a2,b2,c2 as the arguments to checkParallel() function\n#inside the if Conditional statement.\nif(checkParallel(a1,b1,c1,a2,b2,c2)):\n  #If it is true then print those lines are parallel.\n  print('The given lines are parallel to each other')\nelse:\n  #Else they are not parallel.\n  print('The given lines are not parallel to each other')"}
{"nl": "Given a 2D Matrix of order n X m, print K\u2019th element in the spiral form of the matrix.\u00a0\n\n\n\u00a0", "code": "R = 3\nC = 6\n\u00a0\ndef spiralPrint(m, n, a, c):\n\u00a0\u00a0\u00a0\u00a0k = 0\n\u00a0\u00a0\u00a0\u00a0l = 0\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0\"\"\" k - starting row index\n\u00a0\u00a0\u00a0\u00a0m - ending row index\n\u00a0\u00a0\u00a0\u00a0l - starting column index\n\u00a0\u00a0\u00a0\u00a0n - ending column index\n\u00a0\u00a0\u00a0\u00a0i - iterator\n\u00a0\u00a0\u00a0\u00a0\"\"\"\n\u00a0\u00a0\u00a0\u00a0while (k < m and l < n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(l,n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[k][i] , end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\"\" check the last column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0from the remaining columns \"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(k,m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[i][n - 1],end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n-=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\"\" check the last row from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the remaining rows \"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k < m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(n - 1,l-1,-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[m - 1][i],end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m-=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\"\" check the first column from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the remaining columns \"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (l < n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(m - 1,k-1,-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[i][l],end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0l+=1\n\u00a0\n\"\"\" Driver program to test above functions \"\"\"\n\u00a0\na = [[1, 2, 3, 4, 5, 6 ],[ 7, 8, 9, 10, 11, 12 ],[ 13, 14, 15, 16, 17, 18]]\nk = 17\nspiralPrint(R, C, a, k)\n\u00a0\n# This code is contributed by shivanisingh\n"}
{"nl": "You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.\n\nAs the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times:\n\nRemove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time.\nRemove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time.\nRemove a train car from anywhere in the sequence which takes 2 units of time.\nReturn the minimum time to remove all the cars containing illegal goods.\n\nNote that an empty sequence of cars is considered to have no cars containing illegal goods.", "code": "class Solution:\n    def minimumTime(self, s: str) -> int:\n        s = [int(c) for c in s]\n        for i in range(1, len(s)):\n            s[i] += s[i-1]\n        s = [2*x - i - 1 for i, x in enumerate(s)]\n        \n        curMax = ret = 0\n        for i, x in enumerate(s):\n            ret = min(ret, x - curMax)\n            curMax = max(x, curMax)\n        \n        return ret + len(s)\n"}
{"nl": "In the rod-cutting problem, we are given a rod of length n inches and a table of prices p[i] for i = 1, 2, \u2026, n. Here p[i] is the price of a rod of length i inches. We have to find the optimal way of cutting the rod so that maximum revenue can be generated by selling the pieces.", "code": "def cut_rod(p, n):\n    \"\"\"Take a list p of prices and the rod length n and return lists r and s.\n    r[i] is the maximum revenue that you can get and s[i] is the length of the\n    first piece to cut from a rod of length i.\"\"\"\n    # r[i] is the maximum revenue for rod length i\n    # r[i] = -1 means that r[i] has not been calculated yet\n    r = [-1]*(n + 1)\n    r[0] = 0\n\u00a0\n    # s[i] is the length of the initial cut needed for rod length i\n    # s[0] is not needed\n    s = [-1]*(n + 1)\n\u00a0\n    for i in range(1, n + 1):\n        q = -1\n        for j in range(1, i + 1):\n            temp = p[j] + r[i - j]\n            if q < temp:\n                q = temp\n                s[i] = j\n        r[i] = q\n\u00a0\n    return r, s\n\u00a0\n\u00a0\nn = int(input('Enter the length of the rod in inches: '))\n\u00a0\n# p[i] is the price of a rod of length i\n# p[0] is not needed, so it is set to None\np = [None]\nfor i in range(1, n + 1):\n    price = input('Enter the price of a rod of length {} in: '.format(i))\n    p.append(int(price))\n\u00a0\nr, s = cut_rod(p, n)\nprint('The maximum revenue that can be obtained:', r[n])\nprint('The rod needs to be cut into length(s) of ', end='')\nwhile n > 0:\n    print(s[n], end=' ')\n    n -= s[n]"}
{"nl": "Given a root of a tree, and an integer k. Print all the nodes which are at k distance from root. \nFor example, in the below tree, 4, 5 & 8 are at distance 2 from root. \n \n\n            1\n          /   \\\n        2      3\n      /  \\    /\n    4     5  8 ", "code": "# Python program to find the nodes at k distance from root\n\n# A Binary tree node\nclass Node:\n\t\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\ndef printKDistant(root, k):\n\t\n\tif root is None:\n\t\treturn\n\tif k == 0:\n\t\tprint (root.data,end=' ')\n\telse:\n\t\tprintKDistant(root.left, k-1)\n\t\tprintKDistant(root.right, k-1)\n\n# Driver program to test above function\n\"\"\"\nConstructed binary tree is\n\t\t\t1\n\t\t/ \\\n\t\t2\t 3\n\t/ \\ /\n\t4\t 5 8\n\"\"\"\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(8)\n\nprintKDistant(root, 2)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Parallel Lines :\n\nIf two lines remain the same distance apart along their entire length, they are said to be parallel. They will not meet no matter how far you stretch them. These lines are denoted by the equations ax+by=c.\n\n\n\nThe line equation is ax+by=c, where an is the x coefficient and b is the y coefficient. If the slopes of two lines are equal, we say they are parallel. As a result, we must determine the slope, which is \u201crise over run.\u201d\n\nThe straight-line equation is y=mx+c, where m is the slope. Take a1,b1,c1 and a2,b2,c2 from the user and see if they are parallel.\n\nGiven the values of equations of two lines, and the task is to check if the given two lines are parallel or not.\n\nExamples:\n\nExample 1:\n\nInput:\n\na1=4, b1=8, c1=13\na2=2, b2=4, c2=7\nOutput:\n\nThe given lines are parallel to each other\nExample 2:\n\nInput:\n\na1=8, b1=0, c1=9\na2=8, b2=0, c2=11\nOutput:\n\nThe given lines are parallel to each other", "code": "#Create a function checkParallel() which accepts the 6 parameters\n #(First and second line x,y,z coordinates)\n #We can Check if the slopes of the given two lines are equal by formula (a1/b1 == a2/b2).\n def checkParallel(a1,b1,c1,a2,b2,c2):\n  #Inside the checkParallel() function.\n  #Check if both lines y coordinates are not equal to 0 \n  #using the If conditional Statement.\n  if(b1!=0 and b2!=0):\n  #If it is true then check a1/b1 is equal to a2/b2 \n  #using another Nested If conditional Statement.\n  if(a1/b1==a2/b2):\n  #If it is true then return True\n  return True\n  else:\n  #Else return False.\n  return False\n  #If parent If conditional statement is false then inside the else statement \n  else:\n  #check if first line and second line x and y coordinates are equal\n  #or not using the nested If conditional statement.\n  if(a1==a2 and b1==b2):\n  #If it is true then return True else return False.\n  return True\n  else:\n  return False\n #Give the values of a1,b1,c1 as static input \n #and store it in three separate variables.\n a1,b1,c1=4,8,13\n #Give the values of a2,b2,c2 as static input \n #and store it in three separate variables.\n a2,b2,c2=2,4,7\n #Pass the a1,b1,c1,a2,b2,c2 as the arguments to checkParallel() function\n #inside the if Conditional statement.\n if(checkParallel(a1,b1,c1,a2,b2,c2)):\n  #If it is true then print those lines are parallel.\n  print('The given lines are parallel to each other')\n else:\n  #Else they are not parallel.\n  print('The given lines are not parallel to each other')"}
{"nl": "Given a matrix and the task is to find the sum of an upper triangular matrix of the given matrix in Python.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[6, 2, 1], [1, 5, 0], [2, 8, 3]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\nprint(\"The sum of Upper Triangular matrix of the given matrix is :\")\r\n# Take a variable say uppr_sum and initialize its value to 0.\r\nuppr_sum = 0\r\n# To print all the elements of the given matrix.\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n is greater than m using the if conditional statement where n\r\n      # is the iterator value of the parent For loop and m is the iterator value of the\r\n      # inner For loop.\r\n        if n > m:\r\n          # If the statement is true, add the gvnmatrix[n][m] to the above-initialized\r\n          # uppr_sum and store it in the same variable uppr_sum.\r\n            uppr_sum += mtrx[n][m]\r\n# Print the variable uppr_sum to get the sum of an upper triangular matrix of the\r\n# given matrix.\r\nprint(uppr_sum)"}
{"nl": "Instructions\r\nWe are going to do the Transform step of an Extract-Transform-Load.\r\n\r\nETL\r\nExtract-Transform-Load (ETL) is a fancy way of saying, \"We have some crufty, legacy data over in this system, and now we need it in this shiny new system over here, so we're going to migrate this.\"\r\n\r\n(Typically, this is followed by, \"We're only going to need to run this once.\" That's then typically followed by much forehead slapping and moaning about how stupid we could possibly be.)\r\n\r\nThe goal\r\nWe're going to extract some Scrabble scores from a legacy system.\r\n\r\nThe old system stored a list of letters per score:\r\n\r\n1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\r\n2 points: \"D\", \"G\",\r\n3 points: \"B\", \"C\", \"M\", \"P\",\r\n4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\r\n5 points: \"K\",\r\n8 points: \"J\", \"X\",\r\n10 points: \"Q\", \"Z\",\r\nThe shiny new Scrabble system instead stores the score per letter, which makes it much faster and easier to calculate the score for a word. It also stores the letters in lower-case regardless of the case of the input letters:\r\n\r\n\"a\" is worth 1 point.\r\n\"b\" is worth 3 points.\r\n\"c\" is worth 3 points.\r\n\"d\" is worth 2 points.\r\nEtc.\r\nYour mission, should you choose to accept it, is to transform the legacy data format to the shiny new format.\r\n\r\nNotes\r\nA final note about scoring, Scrabble is played around the world in a variety of languages, each with its own unique scoring table. For example, an \"E\" is scored at 2 in the M\u0101ori-language version of the game while being scored at 4 in the Hawaiian-language version.\r\n\r", "code": "def transform(in_dict: {}) -> {}:\r\n    return {m.lower(): n for n in in_dict for m in in_dict[n]}"}
{"nl": "Sort a List of String Tuples in Increasing Order by the Last Element in Each Tuple Using sorted function", "code": "def lastEle(ele):\r\n  # returning the last element\r\n    return ele[-1]\r\n\r\n\r\ndef sortlastElementTuple(listTuple):\r\n  # using sorted function with first parameter as given list of tuples and\r\n  # key as last element\r\n  # To get last element we create a function which returns the last element\r\n  # returning the sorted list of tuples\r\n    return sorted(listTuple, key=lastEle)\r\n\r\n\r\nlistofTuples = [('hello', 'this'), ('BTechGeeks', 'online',\r\n                                    'platform'), ('for', 'students')]\r\n# printing the sorted list of tuples by last element\r\nprint(\"Printing the sorted list of tuples : \")\r\n# Passing the given list of tuples to sortlastElementTuple function\r\nprint(sortlastElementTuple(listofTuples))"}
{"nl": "Here is a trainwreck of a photo:\nThe challenge is to fix all of the bugs in this incredibly messy code, which the code in the image might've actually looked like (probably not)! The code given will output the same middle two lines as in the image shown above.\nFirst parameter is the user's score.\nSecond parameter is the required score.\nExamples\ngrade_percentage(\"85%\", \"85%\") \u279e \"You PASSED the Exam\"\n\ngrade_percentage(\"99%\", \"85%\") \u279e \"You PASSED the Exam\"\n\ngrade_percentage(\"65%\", \"90%\") \u279e \"You FAILED the Exam\"\nNotes\nNote that inputs will be given as a string percentage number.\nMaintain all capitalization.\nFeel free to declutter and refactor code if it helps!", "code": "def grade_percentage(user_score, pass_score):\n  return 'You {} the Exam'.format('PASSED' if user_score >= pass_score else 'FAILED')"}
{"nl": "Instructions\r\nImplement a binary search algorithm.\r\n\r\nSearching a sorted collection is a common task. A dictionary is a sorted list of word definitions. Given a word, one can find its definition. A telephone book is a sorted list of people's names, addresses, and telephone numbers. Knowing someone's name allows one to quickly find their telephone number and address.\r\n\r\nIf the list to be searched contains more than a few items (a dozen, say) a binary search will require far fewer comparisons than a linear search, but it imposes the requirement that the list be sorted.\r\n\r\nIn computer science, a binary search or half-interval search algorithm finds the position of a specified input value (the search \"key\") within an array sorted by key value.\r\n\r\nIn each step, the algorithm compares the search key value with the key value of the middle element of the array.\r\n\r\nIf the keys match, then a matching element has been found and its index, or position, is returned.\r\n\r\nOtherwise, if the search key is less than the middle element's key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the search key is greater, on the sub-array to the right.\r\n\r\nIf the remaining array to be searched is empty, then the key cannot be found in the array and a special \"not found\" indication is returned.\r\n\r\nA binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm.\r\n\r\nException messages\r\nSometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.\r\n\r\nThis particular exercise requires that you use the raise statement to \"throw\" a ValueError when the given value is not found within the array. The tests will only pass if you both raise the exception and include a message with it.\r\n\r\nTo raise a ValueError with a message, write the message as an argument to the exception type:\r\n\r\n# example when value is not found in the array.\r\nraise ValueError(\"value not in array\")\r", "code": "def find(search_list, value):\r\n    if value in search_list:\r\n        return search_list.index(value)\r\n    else:\r\n        raise ValueError(\"value not in array\")"}
{"nl": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n \n\nExample 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10\n \n\nConstraints:\n\n1 <= triangle.length <= 200\ntriangle[0].length == 1\ntriangle[i].length == triangle[i - 1].length + 1\n-104 <= triangle[i][j] <= 104\n ", "code": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        for row in range(1, len(triangle)):\n            for col in range(row + 1):\n                smallest_above = math.inf\n                if col > 0:\n                    smallest_above = triangle[row - 1][col - 1]\n                if col < row:\n                    smallest_above = min(smallest_above, triangle[row - 1][col])\n                triangle[row][col] += smallest_above\n        return min(triangle[-1])"}
{"nl": "In this challenge, you have to establish if an integer num is Alternating. To be Alternating, num must be positive and every digit in its sequence must have a different parity than its next and its previous digit.\nGiven an integer num, implement a function that returns True is num is an Alternating number, or False if it's not.\nExamples\nis_alternating(123) \u279e True\n# 1 is odd, 2 is even, 3 is odd\n\nis_alternating(67) \u279e True\n# 6 is even, 7 is odd\n\nis_alternating(2380) \u279e False\n# 2 is even, 3 is odd, 8 is even, 0 is even\n\nis_alternating(75) \u279e False\n# 7 is odd, 5 is odd\nNotes\nA single-digit number is trivially considered Alternating, given the absence of neighboring digits.\nThe first digit has to be compared only to its next neighbor, and the last digit has to be compared only to its previous neighbor.\nEvery non-positive integer must be treated as False.", "code": "def is_alternating(num):\n  s = str(num)\n  return num>0 and all((int(a)+int(b))%2 for a,b in zip(s,s[1:]))"}
{"nl": "Check if Array can be Sorted with One Swap (User Input)", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n#Store it in a variable.\r\ngven_lst = list(map(int, input(\r\n   'Enter some random List Elements separated by spaces = ').split()))\r\n# Copy the given list in a variable say \"new_lst\" using the copy() function.\r\nnew_lst = gven_lst.copy()\r\n# Take a variable say 'c' and initialize its value with 0.\r\nc = 0\r\n# Sort the above obtained \"new_lst\".\r\nnew_lst.sort()\r\n# Loop until the length of the \"new_lst\" using the for loop.\r\nfor i in range(len(new_lst)):\r\n # Check if the given list element is not equal to the new_lst element using the\r\n    # if conditional statement.\r\n    if(gven_lst[i] != new_lst[i]):\r\n     # If the statement is true then increment the count value of 'c' by 1 and\r\n        # store it in the same variable 'c'.\r\n        c += 1\r\n# Check if the value of 'c' is equal to 0 or true using the if conditional statement\r\n# and 'or ' keyword.\r\nif(c == 0 or c == 2):\r\n  # If the statement is true, print \"The given list can be sorted with a single swap\".\r\n    print(\"The given list\", gven_lst, \"can be sorted with a single swap\")\r\n # If it is false, then print \"The given list cannot be sorted with a single swap\".\r\nelse:\r\n    print(\"The given list\", gven_lst, \"cannot be sorted with a single swap\")"}
{"nl": "OOP Exercise 3:Create a Bus object that will inherit all of the variables and methods of the parent Vehicle class and display it.", "code": "class Vehicle:\r\n\r\n    def __init__(self, name, max_speed, mileage):\r\n        self.name = name\r\n        self.max_speed = max_speed\r\n        self.mileage = mileage\r\n\r\nclass Bus(Vehicle):\r\n    pass\r\n\r\nSchool_bus = Bus(\"School Volvo\", 180, 12)\r\nprint(\"Vehicle Name:\", School_bus.name, \"Speed:\", School_bus.max_speed, \"Mileage:\", School_bus.mileage)"}
{"nl": "You are given a list representing the number of 0s, 1s, 2s, ..., 9s you have. The function will look like:\ncan_build([#0s, #1s, #2s, ..., #9s], [num1, num2, ...])\nWrite a function that returns True if you can build the following numbers using only the digits you have.\nExamples\ncan_build([0, 1, 2, 2, 3, 0, 0, 0, 1, 1], [123, 444, 92]) \u279e True\n\n# You have: one 1, two 2s, two 3s, three 4s, one 8 and one 9\n# Using only these digits, you can build 123, 444, and 92\n\ncan_build([10, 2, 3, 8, 5, 8, 5, 5, 3, 1], [11, 2, 22, 49, 444, 998, 87, 44]) \u279e False\n\ncan_build([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], []) \u279e True\n\ncan_build([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3]) \u279e False\nNotes\nN/A", "code": "def can_build(digits, lst):\n  nums = ''.join(str(i) for i in lst)\n  return all(nums.count(j)<= digits[int(j)] for j in set(nums))"}
{"nl": "There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\nIn each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\nThe game ends when there is only one stone remaining. Alice's is initially zero.\nReturn the maximum score that Alice can obtain.\n \nExample 1:\n\nInput: stoneValue = [6,2,3,4,5,5]\nOutput: 18\nExplanation: In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\nExample 2:\n\nInput: stoneValue = [7,7,7,7,7,7,7]\nOutput: 28\n\nExample 3:\n\nInput: stoneValue = [4]\nOutput: 0\n\n \nConstraints:\n\n1 <= stoneValue.length <= 500\n1 <= stoneValue[i] <= 106", "code": "def stoneGameV(self, A):\n  n = len(A)\n  prefix = [0] * (n + 1)\n  for i, a in enumerate(A):\n  prefix[i + 1] = prefix[i] + A[i]\n\n  @functools.lru_cache(None)\n  def dp(i, j):\n  if i == j: return 0\n  res = 0\n  for m in range(i, j):\n  left = prefix[m + 1] - prefix[i]\n  right = prefix[j + 1] - prefix[m + 1]\n  if left <= right:\n  res = max(res, dp(i, m) + left)\n  if left >= right:\n  res = max(res, dp(m + 1, j) + right)\n  return res\n  return dp(0, n - 1)"}
{"nl": "Given an array of n-positive elements. The sub-array sum is defined as the sum of all elements of a particular sub-array, the task is to find the sum of all unique sub-array sum. ", "code": "\r\n# Python3 for finding sum of all\r\n# unique subarray sum\r\n \r\n# function for finding grandSum\r\ndef findSubarraySum(arr, n):\r\n \r\n    res = 0\r\n \r\n    # Go through all subarrays, compute sums\r\n    # and count occurrences of sums.\r\n    m = dict()\r\n    for i in range(n):\r\n        Sum = 0\r\n        for j in range(i, n):\r\n            Sum += arr[j]\r\n            m[Sum] = m.get(Sum, 0) + 1\r\n         \r\n    # Print all those Sums that appear\r\n    # once.\r\n    for x in m:\r\n        if m[x] == 1:\r\n            res += x\r\n \r\n    return res\r\n \r\n# Driver code\r\narr = [3, 2, 3, 1, 4]\r\nn = len(arr)\r\nprint(findSubarraySum(arr, n))\r\n \r\n# This code is contributed by mohit kumar"}
{"nl": "The math.log10() method returns the base-10 logarithm of a number.\r\n\r\n", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the base-10 logarithm of different numbers\r\nprint(math.log10(2.7183))\r\nprint(math.log10(2))\r\nprint(math.log10(1))"}
{"nl": "Given the root of a binary search tree and K as input, find Kth smallest element in BST. \nFor example, in the following BST, if k = 3, then the output should be 10, and if k = 5, then the output should be 14.\n\nMethod 2: Augmented Tree Data Structure (O(h) Time Complexity and O(h) auxiliary space)\r\nThe idea is to maintain the rank of each node. We can keep track of elements in the left subtree of every node while building the tree. Since we need the K-th smallest element, we can maintain the number of elements of the left subtree in every node.\r\nAssume that the root is having \u2018lCount\u2019 nodes in its left subtree. If K = lCount + 1, root is K-th node. If K < lCount + 1, we will continue our search (recursion) for the Kth smallest element in the left subtree of root. If K > lCount + 1, we continue our search in the right subtree for the (K \u2013 lCount \u2013 1)-th smallest element. Note that we need the count of elements in the left subtree only.", "code": "# A simple inorder traversal based Python3\r\n# program to find k-th smallest element in a BST.\r\n \r\n# A BST node\r\nclass newNode:\r\n     \r\n    def __init__(self, x):\r\n         \r\n        self.data = x\r\n        self.left = None\r\n        self.right = None\r\n        self.lCount = 0\r\n \r\n# Recursive function to insert\r\n# an key into BST\r\ndef insert(root, x):\r\n     \r\n    if (root == None):\r\n        return newNode(x)\r\n \r\n    # If a node is inserted in left subtree,\r\n    # then lCount of this node is increased.\r\n    # For simplicity, we are assuming that\r\n    # all keys (tried to be inserted) are\r\n    # distinct.\r\n    if (x < root.data):\r\n        root.left = insert(root.left, x)\r\n        root.lCount += 1\r\n \r\n    elif (x > root.data):\r\n        root.right = insert(root.right, x);\r\n         \r\n    return root\r\n \r\n# Function to find k'th largest element\r\n# in BST. Here count denotes the number\r\n# of nodes processed so far\r\ndef kthSmallest(root, k):\r\n     \r\n    # Base case\r\n    if (root == None):\r\n        return None\r\n         \r\n    count = root.lCount + 1\r\n     \r\n    if (count == k):\r\n        return root\r\n \r\n    if (count > k):\r\n        return kthSmallest(root.left, k)\r\n \r\n    # Else search in right subtree\r\n    return kthSmallest(root.right, k - count)\r\n \r\n# Driver code\r\nif __name__ == '__main__':\r\n     \r\n    root = None\r\n    keys = [ 20, 8, 22, 4, 12, 10, 14 ]\r\n \r\n    for x in keys:\r\n        root = insert(root, x)\r\n \r\n    k = 4\r\n    res = kthSmallest(root, k)\r\n     \r\n    if (res == None):\r\n        print(\"There are less than k nodes in the BST\")\r\n    else:\r\n        print(\"K-th Smallest Element is\", res.data)\r\n         \r\n# This code is contributed by bgangwar59"}
{"nl": "Given Preorder traversal of a BST, check if each non-leaf node has only one child. Assume that the BST contains unique entries.", "code": "# Check if each internal\n# node of BST has only one child\n\u00a0\ndef hasOnlyOneChild (pre, size):\n\u00a0\u00a0\u00a0\u00a0nextDiff=0; lastDiff=0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(size-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nextDiff = pre[i] - pre[i+1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastDiff = pre[i] - pre[size-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if nextDiff*lastDiff < 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\n# driver program to\n# test above function\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0pre = [8, 3, 5, 7, 6]\n\u00a0\u00a0\u00a0\u00a0size= len(pre)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (hasOnlyOneChild(pre,size) == True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\n# This code is contributed by\n# Harshit Saini\n"}
{"nl": "Write a program that unsets the rightmost set bit of an integer. ", "code": "# unsets the rightmost set bit\n# of n and returns the result\ndef fun(n):\n\n\treturn n & (n-1)\n\n# Driver code\n\nn = 7\nprint(\"The number after unsetting the rightmost set bit\", fun(n))\n\n# This code is contributed\n# by Anant Agarwal.\n"}
{"nl": "Create a function that takes a string (will be a person's first and last name) and returns a string with the first and last name swapped.\nExamples\nname_shuffle(\"Donald Trump\") \u279e \"Trump Donald\"\n\nname_shuffle(\"Rosie O'Donnell\") \u279e \"O'Donnell Rosie\"\n\nname_shuffle(\"Seymour Butts\") \u279e \"Butts Seymour\"\nNotes\nThere will be exactly one space between the first and last name.\nIf you get stuck on a challenge, find help in the Resources tab.\nIf you're really stuck, unlock solutions in the Solutions tab.", "code": "def nameShuffle(str):\n  return ' '.join(reversed(str.split(' ')))"}
{"nl": "Implement a Queue Data Structure in Python.The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.\n\nOperations on Queue:\u00a0\nEnqueue:\u00a0Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.\u00a0\nDequeue:\u00a0Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition.\u00a0\nFront:\u00a0Get the front item from queue.\u00a0\nRear: Get the last item from queue.\u00a0\n\n\n\u00a0", "code": "# Python3 program for array implementation of queue\n\u00a0\n# Class Queue to represent a queue\nclass Queue:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# __init__ function\n\u00a0\u00a0\u00a0\u00a0def __init__(self, capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = self.size = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = capacity -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.Q = [None]*capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.capacity = capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Queue is full when size becomes\n\u00a0\u00a0\u00a0\u00a0# equal to the capacity\n\u00a0\u00a0\u00a0\u00a0def isFull(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.size == self.capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Queue is empty when size is 0\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.size == 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to add an item to the queue.\n\u00a0\u00a0\u00a0\u00a0# It changes rear and size\n\u00a0\u00a0\u00a0\u00a0def EnQueue(self, item):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isFull():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Full\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = (self.rear + 1) % (self.capacity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.Q[self.rear] = item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size = self.size + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"% s enqueued to queue\"\u00a0 % str(item))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to remove an item from queue.\n\u00a0\u00a0\u00a0\u00a0# It changes front and size\n\u00a0\u00a0\u00a0\u00a0def DeQueue(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Empty\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"% s dequeued from queue\" % str(self.Q[self.front]))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = (self.front + 1) % (self.capacity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size = self.size -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to get front of queue\n\u00a0\u00a0\u00a0\u00a0def que_front(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue is empty\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Front item is\", self.Q[self.front])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to get rear of queue\n\u00a0\u00a0\u00a0\u00a0def que_rear(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue is empty\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Rear item is\",\u00a0 self.Q[self.rear])\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0queue = Queue(30)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(10)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(20)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(30)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(40)\n\u00a0\u00a0\u00a0\u00a0queue.DeQueue()\n\u00a0\u00a0\u00a0\u00a0queue.que_front()\n\u00a0\u00a0\u00a0\u00a0queue.que_rear()\n"}
{"nl": "Find Super Factorial of a Number (User input)", "code": "# Import math module using the import keyword.\r\nimport math\r\n# Give the number as User input and store it in a variable.\r\ngvn_numbr = int(input(\"Enter some Random Number =\"))\r\n# Take a variable and initialize it's value with '1'.\r\nsupr_factrl = 1\r\n# Loop from '1 ' to above given number using For loop.\r\nfor iteror in range(gvn_numbr+1):\r\n  # Calculate the factorial of the iterator value using built-in factorial method\r\n  # and multiply it with above initialized superfactorial value.\r\n # Store it in another variable.\r\n    supr_factrl = supr_factrl * math.factorial(iteror)\r\n# Print the superfactorial value of the above given number.\r\nprint(\"The super Factorial value of above given number = \", supr_factrl)"}
{"nl": "OOP Exercise 2: Create a Vehicle class without any variables and methods", "code": "class Vehicle:\r\n    pass"}
{"nl": "Method #1: Using For Loop (Static Input)\r\nApproach:\r\n\r\nGive the number of rows as static input and store it in a variable.\r\nLoop from 1 to the number of rows using For loop.\r\nLoop from the parent loop iterator value to 0 in decreasing order using another For loop(Nested For Loop).\r\nPrint the iterator value of the inner for loop.\r\nPrint the Newline character after the end of the inner loop.\r\nThe Exit of the Program.", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumbrrows = 10\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numbrrows):\r\n    # Loop from the parent loop iterator value to 0 in decreasing order\r\n    # using another For loop(Nested For Loop).\r\n    for n in range(m, 0, -1):\r\n        # Print the iterator value of the inner for loop.\r\n        print(n, end=' ')\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "In the previous article, we have discussed Python Program to Split the Array/List and add the First Part to the End\n Given a list that contains the negative and positive elements the task is to move all the negative elements to the end of the list.\n Examples:\n Example1:\n Input:\n Given List =[1, 9, -3, 6, 8, 11, 35, -5, -7, 10, -1, -2, -3]\n Output:\n The given list after moving negative elements to the end is [1, 9, 6, 8, 11, 35, 10, -3, -5, -7, -1, -2, -3]\n Example2:\n Input:\n Given List = [-7 11 56 -3 -8 12 17 -25 -8 -11 -6 9 10]\n Output:\n The given list after moving negative elements to the end is [11, 56, 12, 17, 9, 10, -7, -3, -8, -25, -8, -11, -6]", "code": "# Give the list as static input and store it in a variable.\n gvnlst = [1, 9, -3, 6, 8, 11, 35, -5, -7, 10, -1, -2, -3]\n # Using list comprehension and if conditional statements\n # separate the positive numbers from the list\n # and store it in a variable to say the positive list.\n pstivelist = [elemn for elemn in gvnlst if elemn &gt;= 0]\n # Using list comprehension and if conditional statements\n # separate the negative numbers from the list and store it\n # in a variable to say the negative list.\n ngtivelist = [elemn for elemn in gvnlst if elemn &lt; 0]\n # Add the positive list and negative list using the + operator\n # and store it in another variable to say result list\n # (This operation moves all the negative list).\n resltlist = pstivelist+ngtivelist\n # Print the result list.\n print('The given list after moving negative elements to the end is', resltlist)"}
{"nl": "Given two numbers a, b and the task is to find all x such that given a % x = b\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven a value = 21\nGiven b value = 5\nOutput:\n\nThe value of x such that given a%x==b {a,b = 21 5 } =  2\nExplanation:\n\nHere the values of x which satisfy a%x=b are 8,16 because 21%8=5 ,21%16=5.\nso total number of possible x are 8,16 i.e 2 values\nExample2:\n\nInput:\n\nGiven a value = 35\nGiven b value = 8\nOutput:\n\nThe value of x such that given a%x==b {a,b = 35 8 } =  2", "code": "# Import the math module using the import keyword.\n import math\n # Create a function to say a_mod_xisb which takes the given two numbers as the arguments\n # and returns all the values of x such that given a % x = b.\n def a_mod_xisb(gvn_a_val, gvn_b_val):\n  # Check if the given number a is less than the given b value using the if conditional\n  # statement.\n  if (gvn_a_val < gvn_b_val):\n  # If it is true then print \"There are no solutions possible\".\n  print(\"There are no solutions possible\")\n  # Return.\n  return\n  # Check if the given a value is equal to the given b value using the if conditional\n  # statement.\n  if (gvn_a_val == gvn_b_val):\n  # If it is true then print \"Infinite Solutions are possible for the equation\".\n  # Return.\n  print(\"Infinite Solutions are possible for the equation\")\n  return\n  # Take a variable say cnt and initialize its value to 0.\n  cnt = 0\n  # Subtract the given b value from the given a value and store it in another variable\n  # say rslt.\n  rslt = gvn_a_val - gvn_b_val\n  # Calculate the value of square root of (gvn_a_val - gvn_b_val) using the math.sqrt()\n  # function and convert result to an integer using the int() function.\n  # Store it in another variable say k.\n  k = (int)(math.sqrt(gvn_a_val - gvn_b_val))\n  # Loop from 1 to the above result k using the for loop.\n  for itr in range(1, k+1):\n  # Inside the loop, check if the above value of rslt modulus iterator value is equal\n  # to 0 using the if conditional statement.\n  if (rslt % itr == 0):\n  # Again check if the rslt divided by the iterator value greater than the given b value\n  # using the if conditional statement.\n  if (rslt / itr > gvn_b_val):\n  # If it is true, increment the count value by 1 and store it in the same variable.\n  cnt = cnt + 1\n  # Check if the iterator value is greater than the given b value using the if\n  # conditional statement.\n  if (itr > gvn_b_val):\n  # If it is true, increment the count value by 1 and store it in the same variable.\n  cnt = cnt + 1\n  # Check if the k multiplied with itself is equal to the rslt and k greater than the\n  # given b value using the if conditional statement.\n  if (k * k == rslt and k > gvn_b_val):\n  # If it is true, decrement the count value by 1 and store it in the same variable.\n  cnt = cnt - 1\n  # Print the value of x such that given a%x==b.\n  print(\n  \"The value of x such that given a%x==b {a,b =\", gvn_a_val, gvn_b_val, \"} = \", cnt)\n # Give the number as static input and store it in a variable.\n gvn_a_val = 15\n # Give the other number as static input and store it in another variable.\n gvn_b_val = 2\n # Pass the given number two numbers as the arguments to the a_mod_xisb function.\n a_mod_xisb(gvn_a_val, gvn_b_val)"}
{"nl": "Given a name, return the letter with the highest index in alphabetical order, with its corresponding index, in the form of a string. You are prohibited to use max() nor is reassigning a value to the alphabet list allowed.\nExamples\nalphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n\n\nalphabet_index(alphabet, \"Flavio\") \u279e \"22v\"\n\nalphabet_index(alphabet, \"Andrey\") \u279e \"25y\"\n\nalphabet_index(alphabet, \"Oscar\") \u279e \"19s\"\nNotes\nIf you're stuck, check the Resources tab.\nsorted() is not best practice.", "code": "alphabet='abcdefghijklmnopqrstuvwxyz'\nalphabet_index=lambda a,s:'%s%s'%next((a.find(x)+1,x)for x in a[::-1]if x in s.lower())"}
{"nl": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n \n\nExample 1:\n\nInput\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True\n \n\nConstraints:\n\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.", "code": "class TrieNode:\n# Initialize your data structure here.\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n\nclass Trie:\n\ndef __init__(self):\n    self.root = TrieNode()\n\ndef insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True\n\ndef search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word\n\ndef startsWith(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True"}
{"nl": "Write a function that returns True if all the strings in a list can be formed by using only the characters from the longest string.\nExamples\ncan_form([\"mast\", \"manifest\", \"met\", \"fan\"]) \u279e True\n\ncan_form([\"may\", \"master\", \"same\", \"reams\"]) \u279e False\n\ncan_form([\"may\", \"same\", \"reams\", \"mastery\"]) \u279e True\nNotes\nThere will only be one unique longest string.", "code": "def can_form(lst):\n  longest = max(lst, key=len)\n  return all(longest.count(i) >= word.count(i) for word in lst for i in set(word))"}
{"nl": "You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\nReturn the minimum number of operations needed to make s alternating.\n \nExample 1:\n\nInput: s = \"0100\"\nOutput: 1\nExplanation: If you change the last character to '1', s will be \"0101\", which is alternating.\n\nExample 2:\n\nInput: s = \"10\"\nOutput: 0\nExplanation: s is already alternating.\n\nExample 3:\n\nInput: s = \"1111\"\nOutput: 2\nExplanation: You need two operations to reach \"0101\" or \"1010\".\n\n \nConstraints:\n\n1 <= s.length <= 104\ns[i] is either '0' or '1'.", "code": "def minOperations(self, s):\n  res = sum(i % 2 == int(c) for i, c in enumerate(s))\n  return min(res, len(s) - res)"}
{"nl": "Given an array and a number k where k is smaller than the size of the array, we need to find the k\u2019th smallest element in the given array. It is given that all array elements are distinct.\n\nExamples:  \n\nInput: arr[] = {7, 10, 4, 3, 20, 15} \nk = 3 \nOutput: 7\n\nInput: arr[] = {7, 10, 4, 3, 20, 15} \nk = 4 \nOutput: 10 ", "code": "# Python3 program to find k'th smallest\n# element\n\n# Function to return k'th smallest\n# element in a given array\ndef kthSmallest(arr, n, k):\n\n        # Sort the given array\n        arr.sort()\n\n        # Return k'th element in the\n        # sorted array\n        return arr[k-1]\n\n# Driver code\nif __name__=='__main__':\n        arr = [12, 3, 5, 7, 19]\n        n = len(arr)\n        k = 2\n        print(\"K'th smallest element is\",\n                kthSmallest(arr, n, k))\n\n# This code is contributed by\n# Shrikant13"}
{"nl": "Create a function that returns the product of all odd integers in a list.\nExamples\nodd_product([3, 4, 1, 1, 5]) \u279e 15\n\nodd_product([5, 5, 8, 2, 4, 32]) \u279e 25\n\nodd_product([1, 2, 1, 2, 1, 2, 1, 2]) \u279e 1\nNotes\nN/A", "code": "import numpy\ndef odd_product(lst):\n    return numpy.prod([i for i in lst if i % 2 != 0])"}
{"nl": "A word is on the loose and now has tried to hide amongst a crowd of tall letters! Help write a function to detect what the word is, knowing the following rules:\nThe wanted word is in lowercase.\nThe crowd of letters is all in uppercase.\nNote that the word will be spread out amongst the random letters, but their letters remain in the same order.\nExamples\ndetect_word(\"UcUNFYGaFYFYGtNUH\") \u279e \"cat\"\n\ndetect_word(\"bEEFGBuFBRrHgUHlNFYaYr\") \u279e \"burglar\"\n\ndetect_word(\"YFemHUFBbezFBYzFBYLleGBYEFGBMENTment\") \u279e \"embezzlement\"\nNotes\nN/A", "code": "def detect_word(txt):\n  return \"\".join(c for c in txt if c.islower())"}
{"nl": "The article describes an approach to solving the problem of finding the LCA of two nodes in a tree by reducing it to a RMQ problem.", "code": "# Python3 program to find LCA of u and v by\n# reducing the problem to RMQ\nfrom math import log2, floor\nfrom typing import List\n\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, val: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.val, self.left, self.right = val, None, None\n\u00a0\nclass BinaryTree:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, root: Node):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.root = root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.val_max = self._get_max_val()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler = [0] * (2 * self.val_max - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level = [0] * (2 * self.val_max - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.f_occur = [-1] * (self.val_max + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def _get_max_val(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack = [self.root]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_val = -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x = stack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if x.val > max_val:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_val = x.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if x.left:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(x.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if x.right:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(x.right)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return max_val\n\u00a0\u00a0\u00a0\u00a0''' A recursive function to get the minimum value in a given range\n\u00a0\u00a0\u00a0\u00a0\u00a0of array indexes. The following are parameters for this function.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0st\u00a0\u00a0\u00a0 --> Pointer to segment tree\n\u00a0\u00a0\u00a0\u00a0index --> Index of current node in the segment tree. Initially\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 is passed as root is always at index 0\n\u00a0\u00a0\u00a0\u00a0ss & se\u00a0 --> Starting and ending indexes of the segment represented\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0by current node, i.e., st[index]\n\u00a0\u00a0\u00a0\u00a0qs & qe\u00a0 --> Starting and ending indexes of query range '''\n\u00a0\u00a0\u00a0\u00a0def rmq_util(self, index, ss, se, qs, qe) -> int:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If segment of this node is part of given range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then return the min of the segment\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if qs <= ss and qe >= se:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.segment_tree[index]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If segment of this node is outside\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the given range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif se < qs or ss > qe:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If part of this segment overlaps with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# given range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mid = (ss + se) // 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1 = self.rmq_util(2 * index + 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ss, mid, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q2 = self.rmq_util(2 * index + 2, mid + 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0se, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if q1 == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return q2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if q2 == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return q1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (q1 if self.level[q1] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[q2] else q2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return minimum of elements in range from\n\u00a0\u00a0\u00a0\u00a0# index qs (query start) to\u00a0 qe (query end).\u00a0\n\u00a0\u00a0\u00a0\u00a0# It mainly uses rmq_util()\n\u00a0\u00a0\u00a0\u00a0def rmq(self, n: int, qs: int, qe: int) -> int:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if qs < 0 or qe > n - 1 or qs > qe:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print('invalid input')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.rmq_util(0, 0, n - 1, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# A recursive function that constructs Segment\n\u00a0\u00a0\u00a0\u00a0# Tree for array[ss..se]. si is index of\n\u00a0\u00a0\u00a0\u00a0# current node in segment tree st\n\u00a0\u00a0\u00a0\u00a0def construct_segment_tree_util(self, si, ss,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0se, arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If\u00a0 there is one element in array,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# store it in current node of segment tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ss == se:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree[si] = ss\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If there are more than one elements,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then recur for left and right subtrees and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# store the min of two values in this node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mid = (ss + se) // 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index_left, index_right = si * 2 + 1, si * 2 + 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree_util(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index_left, ss, mid, arr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree_util(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index_right, mid+1, se, arr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[self.segment_tree[index_left]] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[self.segment_tree[index_right]]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree[si] = self.segment_tree[index_left]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree[si] = self.segment_tree[index_right]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to construct segment tree from given\n\u00a0\u00a0\u00a0\u00a0# array. This function allocates memory for segment\n\u00a0\u00a0\u00a0\u00a0# tree and calls construct_segment_tree_util()\n\u00a0\u00a0\u00a0\u00a0# to fill the allocated memory\n\u00a0\u00a0\u00a0\u00a0def construct_segment_tree(self, arr: List, n: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Height of segment tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x = floor(log2(n) + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Maximum size of segment tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_size = 2 * (1 << x) - 1\u00a0\u00a0\u00a0\u00a0\u00a0 # 2*pow(2,x) -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree = [0] * max_size\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Fill the allocated memory st\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree_util(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00, 0, n - 1, arr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recursive version of the Euler tour of T\n\u00a0\u00a0\u00a0\u00a0def euler_tour(self, node: Node, lev: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the passed node exists\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if node is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler[self.fill] = node.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[self.fill] = lev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If unvisited, mark first occurence\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.f_occur[node.val] == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.f_occur[node.val] = self.fill - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Tour left subtree if exists and remark\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# euler and level arrays for parent on\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if node.left is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler_tour(node.left, lev + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler[self.fill] = node.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[self.fill] = lev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Tour right subtree if exists and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# remark euler and level arrays for\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# parent on return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if node.right is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler_tour(node.right, lev + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler[self.fill] = node.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[self.fill] = lev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns LCA of nodes n1, n2 (assuming they are\n\u00a0\u00a0\u00a0\u00a0# present in the tree)\n\u00a0\u00a0\u00a0\u00a0def find_lca(self, u: int, v: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Start euler tour with root node on level 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler_tour(self.root, 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Construct segment tree on level array\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree(self.level,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 * self.val_max - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# For rmq to work, u must be smaller than v\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.f_occur[u] > self.f_occur[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u, v = v, u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Start and end of query range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qs = self.f_occur[u]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qe = self.f_occur[v]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Query for index of lca in tour\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index = self.rmq(2 * self.val_max - 1, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Return lca node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.euler[index]\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = Node(1)\n\u00a0\u00a0\u00a0\u00a0root.left = Node(2)\n\u00a0\u00a0\u00a0\u00a0root.right = Node(3)\n\u00a0\u00a0\u00a0\u00a0root.left.left = Node(4)\n\u00a0\u00a0\u00a0\u00a0root.left.right = Node(5)\n\u00a0\u00a0\u00a0\u00a0root.right.left = Node(6)\n\u00a0\u00a0\u00a0\u00a0root.right.right = Node(7)\n\u00a0\u00a0\u00a0\u00a0root.left.right.left = Node(8)\n\u00a0\u00a0\u00a0\u00a0root.left.right.right = Node(9)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0tree = BinaryTree(root)\n\u00a0\u00a0\u00a0\u00a0u, v = 4, 9\n\u00a0\u00a0\u00a0\u00a0print('The lca of node {} and {} is node {}'.format(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u, v, tree.find_lca(u, v)))\n\u00a0\n# This code is contributed by Rajat Srivastava\n"}
{"nl": "Given the radius and height of a cone, the task is to find the surface area, volume, and lateral surface for a given cone.", "code": "# Import math module using the import keyword.\nimport math\n# Give the radius of a cone user input using the float(input()) function and store it in a variable.\ngvn_rad = float(input(\"Enter some random number = \"))\n# Give the height of a cone user input using the float(input()) function and store it in another variable.\ngvn_heigt = float(input(\"Enter some random number = \"))\n# Calculate the Slant height of a given cone using the above given mathematical formula\n# and math.sqrt() function and store it in another variable.\nslant_l = math.sqrt(gvn_rad * gvn_rad + gvn_heigt * gvn_heigt)\n# Calculate the surface area of a given cone using the above given mathematical formula and math.pi function\n# Store it in another variable.\nsurf_area = math.pi * gvn_rad * (gvn_rad + slant_l)\n# Calculate the volume of a given cone using the above given mathematical formula and\n# math.pi function\n# Store it in another variable.\nVol = (1.0/3) * math.pi * gvn_rad * gvn_rad * gvn_heigt\n# Calculate the lateral surface area of a given cone using the above given mathematical\n# formula and math.pi function.\n# Store it in another variable.\nLaterl_surfcarea = math.pi * gvn_rad * slant_l\n# Print the slant height of a given cone.\nprint(\"The given cone's slant height = %.3f\" % slant_l)\n# Print the surface area of a given cone.\nprint(\n    \"The given surface Area of a cone with given radius,height[\", gvn_rad, gvn_heigt, \"]= %.3f\" % surf_area)\n# Print the volume of a given cone.\nprint(\n    \"The given volume of a cone with given radius,height[\", gvn_rad, gvn_heigt, \"]= %.3f\" % Vol)\n# Print the lateral surface area of a given cone.\nprint(\n    \"The given lateral surface Area of a cone with given radius,height[\", gvn_rad, gvn_heigt, \"]= %.3f \" % Laterl_surfcarea)"}
{"nl": "Given an array of integers arr and an integer k.\nA value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.\nIf |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].\nReturn a list of the strongest k values in the array. return the answer in any arbitrary order.\nMedian is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).\n\nFor arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6.\nFor arr = [-7, 22, 17, 3], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3.\n\n \nExample 1:\n\nInput: arr = [1,2,3,4,5], k = 2\nOutput: [5,1]\nExplanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.\nPlease note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.\n\nExample 2:\n\nInput: arr = [1,1,3,5,5], k = 2\nOutput: [5,5]\nExplanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].\n\nExample 3:\n\nInput: arr = [6,7,11,7,6,8], k = 5\nOutput: [11,8,6,6,7]\nExplanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].\nAny permutation of [11,8,6,6,7] is accepted.\n\n \nConstraints:\n\n1 <= arr.length <= 105\n-105 <= arr[i] <= 105\n1 <= k <= arr.length", "code": "class Solution:\n  def getStrongest(self, arr: List[int], k: int) -> List[int]:\n  arr.sort()\n  i, j = 0, len(arr) - 1\n  median = arr[(len(arr) - 1) // 2]\n  while len(arr) + i - j <= k:\n  if median - arr[i] > arr[j] - median:\n  i = i + 1\n  else:\n  j = j - 1\n  return arr[:i] + arr[j + 1:]"}
{"nl": "Create a function that takes a string and checks if every single character is preceded and followed by a character adjacent to it in the english alphabet.\nExample: \"b\" should be preceded and followed by ether \"a\" or \"c\" (abc || cba || aba || cbc == True but abf || zbc == False).\nExamples\nneighboring(\"aba\") \u279e True\n\nneighboring(\"abcdedcba\") \u279e True\n\nneighboring(\"efghihfe\") \u279e False\n\nneighboring(\"abc\") \u279e True\n\nneighboring(\"qrstuv\") \u279e True\n\nneighboring(\"mnopqrstsrqponm\") \u279e True\nNotes\nAll test cases will consist of lower case letters only.", "code": "def neighboring(txt):\n  return all(abs(ord(a)-ord(b)) == 1 for a, b in zip(txt, txt[1:]))"}
{"nl": "Given a directed graph, a source vertex \u2018s\u2019 and a destination vertex \u2018d\u2019, print all paths from given \u2018s\u2019 to \u2018d\u2019.\u00a0", "code": "# Python program to print all paths from a source to destination.\n\u00a0\u00a0\nfrom collections import defaultdict\n\u00a0\u00a0\n# This class represents a directed graph\n# using adjacency list representation\nclass Graph:\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, vertices):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# No. of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# default dictionary to store graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# function to add an edge to graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self, u, v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[u].append(v)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0'''A recursive function to print all paths from 'u' to 'd'.\n\u00a0\u00a0\u00a0\u00a0visited[] keeps track of vertices in current path.\n\u00a0\u00a0\u00a0\u00a0path[] stores actual vertices and path_index is current\n\u00a0\u00a0\u00a0\u00a0index in path[]'''\n\u00a0\u00a0\u00a0\u00a0def printAllPathsUtil(self, u, d, visited, path):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark the current node as visited and store in path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[u]= True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append(u)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current vertex is same as destination, then print\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current path[]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if u == d:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current vertex is not destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Recur for all the vertices adjacent to this vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in self.graph[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[i]== False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.printAllPathsUtil(i, d, visited, path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove current vertex from path[] and mark it as unvisited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[u]= False\n\u00a0\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Prints all paths from 's' to 'd'\n\u00a0\u00a0\u00a0\u00a0def printAllPaths(self, s, d):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark all the vertices as not visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited =[False]*(self.V)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create an array to store paths\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Call the recursive helper function to print all paths\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.printAllPathsUtil(s, d, visited, path)\n\u00a0\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\n# Create a graph given in the above diagram\ng = Graph(4)\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(0, 3)\ng.addEdge(2, 0)\ng.addEdge(2, 1)\ng.addEdge(1, 3)\n\u00a0\u00a0\ns = 2 ; d = 3\nprint (\"Following are all different paths from % d to % d :\" %(s, d))\ng.printAllPaths(s, d)\n# This code is contributed by Neelam Yadav\n"}
{"nl": "In the previous article, we have discussed Python Program to Remove Characters that Appear More than k Times\n Given a string, K value and the task is to remove all the characters from the given string that appears strictly less than k times.\n Examples:\n Example1:\n Input:\n Given String = \"hellobtechgeekssss \"\n \n Given k value = 2\n Output:\n The given string { hellobtechgeekssss } after removal of all characters that appears more than k{ 2 } times : helleheessss\n Example2:\n Input:\n Given String = \"gooodmorningallll \"\n \n Given k value= 3\n Output:\n The given string { gooodmorningallll } after removal of all characters that appears more than k{ 3 } times : oooollll", "code": "# Take a dictionary and initialize it to empty\n \n # using the {} or dict() say freqncyDictionary.\n \n freqncyDictionary = {}\n \n # Give the string as static input and store it in a variable\n \n gvnstrng = \"hellobtechgeekssss\"\n \n # Loop in the given string using the For loop.\n \n for i in gvnstrng:\n \n  # Inside the For loop,\n \n  # Check if the string character is present in the dictionary\n \n  # or not using the if conditional statement and 'in' keyword.\n \n  if i in freqncyDictionary.keys():\n \n  # If it is true then increment the count of the string character\n \n  # in the dictionary by 1.\n \n  freqncyDictionary[i] = freqncyDictionary[i]+1\n \n  # Else initialize the dictionary with the string character as key and value as 1.\n \n  else:\n \n  freqncyDictionary[i] = 1\n \n # Give the k value as static input and store it in a variable.\n \n k = 2\n \n # Take a string which stores all the characters which are not occuring even number\n \n # of times and initialize it to null string using \"\" or str()\n \n modifd_string = \"\"\n \n # loop in the given string using the for loop\n \n for charac in gvnstrng:\n \n \n \n  # check if the character has frequency greater than or equal to k by checking value of that character in frequency dictionary\n \n  # we check using the if conditional statement\n \n  if(freqncyDictionary[charac] >= k):\n \n  # if it is true then concatenate this character to modifd_string using string concatenation\n \n  modifd_string = modifd_string+charac\n \n \n \n # print the modifd_string string\n \n print('The given string {', gvnstrng,\n \n  '} after removal of all characters that appears more than k{', k, '} times :', modifd_string)"}
{"nl": "Given a pattern containing only I\u2019s and D\u2019s. I for increasing and D for decreasing. Device an algorithm to print the minimum number following that pattern. Digits from 1-9 and digits can\u2019t repeat.", "code": "# Python3 program to print minimum number that\n# can be formed from a given sequence of Is and Ds\n\u00a0\n# Prints the minimum number that can be formed from\n# input sequence of I's and D's\ndef PrintMinNumberForPattern(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize current_max (to make sure that\n\u00a0\u00a0\u00a0\u00a0# we don't use repeated character\n\u00a0\u00a0\u00a0\u00a0curr_max = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize last_entry (Keeps track for\n\u00a0\u00a0\u00a0\u00a0# last printed digit)\n\u00a0\u00a0\u00a0\u00a0last_entry = 0\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Iterate over input array\n\u00a0\u00a0\u00a0\u00a0while i < len(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Initialize 'noOfNextD' to get count of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next D's available\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0noOfNextD = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr[i] == \"I\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If letter is 'I'\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate number of next consecutive D's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# available\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while j < len(arr) and arr[j] == \"D\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0noOfNextD += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr_max = noOfNextD + 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If 'I' is first letter, print incremented\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sequence from 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry, end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", curr_max, end = \"\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Set max digit reached\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry = curr_max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If not first letter\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get next digit to print\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr_max += noOfNextD + 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print digit for I\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry = curr_max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry, end = \"\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# For all next consecutive 'D' print\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# decremented sequence\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(noOfNextD):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry, end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If letter is 'D'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif arr[i] == \"D\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If 'D' is first letter in sequence\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Find number of Next D's available\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while j < len(arr) and arr[j] == \"D\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0noOfNextD += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate first digit to print based on\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# number of consecutive D's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr_max = noOfNextD + 2\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print twice for the first time\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", curr_max, curr_max - 1, end = \"\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Store last entry\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry = curr_max - 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current 'D' is not first letter\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Decrement last_entry\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry - 1, end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"IDID\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"I\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"DD\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"II\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"DIDI\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"IIDDD\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"DDIDDIID\")\n\u00a0\n# This code is contributed by\n# sanjeev2552\n"}
{"nl": "Given masses of two objects and the radius , the task is to calculate the Gravitational Force acting between the given two particles in Python.", "code": "# scanning  first mass as float\nmass1 = float(input(\"Enter the first mass of the object =\"))\n# given second mass as float\nmass2 = float(input(\"Enter the second mass of the object =\"))\n# enter the radius as float\nradius = float(input(\"Enter the distance/radius between the objects =\"))\n# Given value of Gravitational Constant Gval\nGval = 6.673*(10**(-11))\n# Calculating the value of the gravitational force Gforce\nGforce = (Gval*mass1*mass2)/(radius**2)\n# printing the value of gravitational force\nprint(\"The gravitational force of objects with masses\", str(mass1) +\n      \" kg \"+str(mass2)+\" kg \", \"of radius=\", radius, \"=\", Gforce)"}
{"nl": "Deque or Double Ended Queue is a generalized version of Queue data structure that allows insert and delete at both ends.In previous post we had discussed introduction of deque. Now in this post we see how we implement deque Using circular array. \nOperations on Deque: \nMainly the following four basic operations are performed on queue: \ninsertFront(): Adds an item at the front of Deque. \ninsertRear(): Adds an item at the rear of Deque. \ndeleteFront(): Deletes an item from front of Deque. \ndeleteRear(): Deletes an item from rear of Deque.\nIn addition to above operations, following operations are also supported \ngetFront(): Gets the front item from queue. \ngetRear(): Gets the last item from queue. \nisEmpty(): Checks whether Deque is empty or not. \nisFull(): Checks whether Deque is full or not. ", "code": "# Python implementation of De-queue using circular\n# array\n\n# A structure to represent a Deque\nMAX = 100;\n\nclass Deque:\n\tdef __init__(self, size):\n\t\tself.arr = [0] * MAX\n\t\tself.front = -1;\n\t\tself.rear = 0;\n\t\tself.size = size;\n\t\n\t\n\t''' Operations on Deque:\n\tvoid insertfront(int key);\n\tvoid insertrear(int key);\n\tvoid deletefront();\n\tvoid deleterear();\n\tbool isFull();\n\tbool isEmpty();\n\tint getFront();\n\tint getRear(); '''\n\n\t# Checks whether Deque is full or not.\n\tdef isFull(self):\n\t\treturn ((self.front == 0 and self.rear == self.size-1) or self.front == self.rear + 1)\n\t\n\t\n\t# Checks whether Deque is empty or not.\n\tdef isEmpty (self):\n\t\treturn (self.front == -1);\n\t\n\t# Inserts an element at front\n\tdef insertfront(self, key):\n\n\t\t# check whether Deque if full or not\n\t\tif (self.isFull()):\n\t\t\tprint(\"Overflow\");\n\t\t\treturn;\n\t\t\n\n\t\t# If queue is initially empty\n\t\tif (self.front == -1):\n\t\t\tself.front = 0;\n\t\t\tself.rear = 0;\n\t\t\n\t\t\n\t\t# front is at first position of queue\n\t\telif (self.front == 0):\n\t\t\tself.front = self.size - 1 ;\n\n\t\telse: # decrement front end by '1'\n\t\t\tself.front = self.front-1;\n\n\t\t# insert current element into Deque\n\t\tself.arr[self.front] = key ;\n\t\n\t\n\t# function to inset element at rear end\n\t# of Deque.\n\tdef insertrear(self, key):\n\t\tif (self.isFull()):\n\t\t\tprint(\" Overflow\");\n\t\t\treturn;\n\t\t\n\n\t\t# If queue is initially empty\n\t\tif (self.front == -1):\n\t\t\tself.front = 0;\n\t\t\tself.rear = 0;\n\t\t\n\n\t\t# rear is at last position of queue\n\t\telif (self.rear == self.size-1):\n\t\t\tself.rear = 0;\n\n\t\t# increment rear end by '1'\n\t\telse:\n\t\t\tself.rear = self.rear+1;\n\t\t\n\t\t# insert current element into Deque\n\t\tself.arr[self.rear] = key ;\n\t\n\t\n\t# Deletes element at front end of Deque\n\tdef deletefront(self):\n\t\t# check whether Deque is empty or not\n\t\tif (self.isEmpty()):\n\t\t\tprint(\"Queue Underflow\");\n\t\t\treturn ;\n\t\t\n\n\t\t# Deque has only one element\n\t\tif (self.front == self.rear):\n\t\t\tself.front = -1;\n\t\t\tself.rear = -1;\n\t\t\n\t\telse:\n\t\t\t# back to initial position\n\t\t\tif (self.front == self.size -1):\n\t\t\t\tself.front = 0;\n\n\t\t\telse: # increment front by '1' to remove current\n\t\t\t\t# front value from Deque\n\t\t\t\tself.front = self.front+1;\n\t\n\t\n\t# Delete element at rear end of Deque\n\tdef deleterear(self):\n\t\tif (self.isEmpty()):\n\t\t\tprint(\" Underflow\");\n\t\t\treturn ;\n\t\t\n\n\t\t# Deque has only one element\n\t\tif (self.front == self.rear):\n\t\t\tself.front = -1;\n\t\t\tself.rear = -1;\n\t\t\n\t\telif (self.rear == 0):\n\t\t\tself.rear = self.size-1;\n\t\telse:\n\t\t\tself.rear = self.rear-1;\n\t\n\t\n\t# Returns front element of Deque\n\tdef getFront(self):\n\t\t# check whether Deque is empty or not\n\t\tif (self.isEmpty()):\n\t\t\tprint(\" Underflow\");\n\t\t\treturn -1 ;\n\t\t\n\t\treturn self.arr[self.front];\n\t\n\t\n\t# function return rear element of Deque\n\tdef getRear(self):\n\t\t# check whether Deque is empty or not\n\t\tif(self.isEmpty() or self.rear < 0):\n\t\t\tprint(\" Underflow\");\n\t\t\treturn -1 ;\n\t\t\n\t\treturn self.arr[self.rear];\n\t\n\t\n\n\n# Driver program to test above function\ndq = Deque(5);\n\t\t\nprint(\"Insert element at rear end : 5 \");\ndq.insertrear(5);\n\nprint(\"insert element at rear end : 10 \");\ndq.insertrear(10);\n\nprint(f\"get rear element : {dq.getRear()}\");\n\ndq.deleterear();\nprint(f\"After delete rear element new rear become : {dq.getRear()}\");\n\nprint(\"inserting element at front end\");\ndq.insertfront(15);\n\nprint(f\"get front element: {dq.getFront()}\");\n\ndq.deletefront();\n\nprint(f\"After delete front element new front become : {dq.getFront()}\");\n\n# This code is contributed by _saurabh_jaiswal\n"}
{"nl": "Count Numbers that don\u2019t Contain 3 (User Input)", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\nlstnmbs = list(map(int, input(\r\n    'Enter some random List Elements separated by spaces = ').split()))\r\n# Take a variable that stores the count of numbers\r\n# that doesn't contain digit 3 in them(say cunt)\r\ncunt = 0\r\n# Traverse the given list using For loop.\r\nfor numbr in lstnmbs:\r\n    # Convert the list element to a string and store it in a variable.\r\n    strnumbr = str(numbr)\r\n    # Check if this string contains digit 3 in it using not in operator and If statement.\r\n    if '3' not in strnumbr:\r\n        # If it is true then increment the cunt by 1.\r\n        cunt = cunt+1\r\n# Print the cunt value.\r\nprint('The Count of numbers that doesnt contain three in the given list',\r\n      lstnmbs, 'is [', cunt, ']')"}
{"nl": "Recursion:\n\nRecursion is a functional technique to problem-solving that involves breaking an issue down into a series of small subproblems with an identical pattern and solving them sequentially by calling one subproblem within another. Recursion is carried out by defining a function capable of solving one subproblem at a time. It calls itself but solves another subproblem somewhere inside that method. As a result, the call to itself continues until some limiting requirements are met.\n\nThe main program\u2019s first call to a recursive function will be returned only after all sub calls have completed. As a result, Python keeps the results of all subproblems in temporary memory, does some arithmetic operations (if necessary), and releases the memory at the end of the recursion.\n\nThe smallest positive number that is divisible by both a and b is the least or lowest common multiple (LCM) of two numbers a and b. In this article, we\u2019ll look at how to use recursion to find the LCM of two numbers.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven first number = 10\ngiven second number = 16\nOutput:\n\nThe value of lcm of the given two numbers 10 16  =  80", "code": "# function which accepts the given two numbers as arguments\n# and return the lcm of the given two numbers.\n\n\ndef lcmRecursion(numb1, numb2):\n    # Set the multiple variable to the highest value between the given two numbers.\n    lcmRecursion.multiple = lcmRecursion.multiple+numb2\n    # Check to see if the multiple variable  divides both given numbers perfectly.\n    if((lcmRecursion.multiple % numb1 == 0) and (lcmRecursion.multiple % numb2 == 0)):\n      # If it does, the process is terminated and the multiple variable is returned as the LCM.\n        return lcmRecursion.multiple\n    else:\n      # If the multiple does not divide both given numbers perfectly, then it is increased by the maximum value\n      # among both given numbers using the max() function.\n        lcmRecursion(numb1, numb2)\n    # The recursive function returns the multiple variable\n    # which is the result(lcm of the given two numbers)\n    return lcmRecursion.multiple\n\n\n# set multiplee variable value to 0\nlcmRecursion.multiple = 0\n# Give two numbers as static input and store them in two variables.\nnumbe1 = 10\nnumbe2 = 16\n# if the first number is greater than second number then swap the arguments\nif(numbe1 > numbe2):\n    LcmVal = lcmRecursion(numbe2, numbe1)\n# else pass the original numbers as arguments\nelse:\n    LcmVal = lcmRecursion(numbe1, numbe2)\nprint('The value of lcm of the given two numbers', numbe1, numbe2, ' = ', LcmVal)"}
{"nl": "Given a binary tree containing n nodes. The problem is to replace each node in the binary tree with the sum of its inorder predecessor and inorder successor.\n\nExamples: \n\nInput :          1\n               /   \\\n              2     3\n            /  \\  /  \\\n           4   5  6   7\n\nOutput :        11\n              /    \\\n             9      13\n            / \\    /  \\\n           2   3   4   3\n                  \nFor 1:\nInorder predecessor = 5\nInorder successor  = 6\nSum = 11\n\nFor 4:\nInorder predecessor = 0\n(as inorder predecessor is not present)\nInorder successor  = 2\nSum = 2\n\nFor 7:\nInorder predecessor = 3\nInorder successor  = 0\n(as inorder successor is not present)\nSum = 3", "code": "# Python3 implementation to replace each\n# node in binary tree with the sum of its\n# inorder predecessor and successor\n\n# class to get a new node of a\n# binary tree\nclass getNode:\n\tdef __init__(self, data):\n\t\t\n\t\t# put in the data\n\t\tself.data = data\n\t\tself.left = self.right = None\n\t\n# function to store the inorder traversal\n# of the binary tree in 'arr'\ndef storeInorderTraversal(root, arr):\n\t\n\t# if root is None\n\tif (not root):\n\t\treturn\n\n\t# first recur on left child\n\tstoreInorderTraversal(root.left, arr)\n\n\t# then store the root's data in 'arr'\n\tarr.append(root.data)\n\n\t# now recur on right child\n\tstoreInorderTraversal(root.right, arr)\n\n# function to replace each node with the\n# sum of its inorder predecessor and successor\ndef replaceNodeWithSum(root, arr, i):\n\t\n\t# if root is None\n\tif (not root):\n\t\treturn\n\n\t# first recur on left child\n\treplaceNodeWithSum(root.left, arr, i)\n\n\t# replace node's data with the sum of its\n\t# inorder predecessor and successor\n\troot.data = arr[i[0] - 1] + arr[i[0] + 1]\n\n\t# move 'i' to point to the next 'arr' element\n\ti[0] += 1\n\n\t# now recur on right child\n\treplaceNodeWithSum(root.right, arr, i)\n\n# Utility function to replace each node in\n# binary tree with the sum of its inorder\n# predecessor and successor\ndef replaceNodeWithSumUtil(root):\n\t\n\t# if tree is empty\n\tif (not root):\n\t\treturn\n\n\tarr = []\n\n\t# store the value of inorder predecessor\n\t# for the leftmost leaf\n\tarr.append(0)\n\n\t# store the inorder traversal of the\n\t# tree in 'arr'\n\tstoreInorderTraversal(root, arr)\n\n\t# store the value of inorder successor\n\t# for the rightmost leaf\n\tarr.append(0)\n\n\t# replace each node with the required sum\n\ti = [1]\n\treplaceNodeWithSum(root, arr, i)\n\n# function to print the preorder traversal\n# of a binary tree\ndef preorderTraversal(root):\n\t\n\t# if root is None\n\tif (not root):\n\t\treturn\n\n\t# first print the data of node\n\tprint(root.data, end = \" \")\n\n\t# then recur on left subtree\n\tpreorderTraversal(root.left)\n\n\t# now recur on right subtree\n\tpreorderTraversal(root.right)\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# binary tree formation\n\troot = getNode(1) #\t\t 1\t\n\troot.left = getNode(2)\t #\t / \\\t\n\troot.right = getNode(3)\t #\t 2\t 3\t\n\troot.left.left = getNode(4) # / \\ / \\\n\troot.left.right = getNode(5) # 4 5 6 7\n\troot.right.left = getNode(6)\n\troot.right.right = getNode(7)\n\n\tprint(\"Preorder Traversal before\",\n\t\t\t\t\"tree modification:\")\n\tpreorderTraversal(root)\n\n\treplaceNodeWithSumUtil(root)\n\tprint()\n\tprint(\"Preorder Traversal after\",\n\t\t\t\t\"tree modification:\")\n\tpreorderTraversal(root)\n\n# This code is contributed by PranchalK\n"}
{"nl": "This problem is a continuation of Uno Part 1 (although you don't need to complete that problem to complete this one).\nIt's your turn to play again. Create a function that takes as its arguments (1) your hand (a list of cards), and (2) the face-up card. In Uno, you are able to play a card from your hand if either:\nOne of the card colors in your hand matches the face-up card's color.\nOne of the card numbers in your hand matches the face-up card's number.\nWrite a function that will return:\n\"Uno!\" if after playing your card, you are left with a single card.\n\"You won!\" if after playing your card, you are left with zero cards (an empty list).\n\"Keep going...\" otherwise.\nExamples\ndecision([\"yellow 3\", \"red 3\"], \"red 10\") \u279e \"Uno!\"\n\ndecision([\"blue 1\"], \"blue 5\") \u279e \"You won!\"\n\ndecision([\"blue 1\", \"green 2\", \"yellow 4\", \"red 2\"], \"blue 5\") \u279e \"Keep going...\"\nNotes\nN/A", "code": "def decision(hand, face):\n  match = any(i in ''.join(hand) for i in face.split())\n  outcomes = {(1, True): 'You won!', (2, True): 'Uno!', (1, False): 'Uno!'}\n  return outcomes.get((len(hand), match), 'Keep going...')"}
{"nl": "You are given a stream of points on the X-Y plane. Design an algorithm that:\n\nAdds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.\nGiven a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.\nAn axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\n\nImplement the DetectSquares class:\n\nDetectSquares() Initializes the object with an empty data structure.\nvoid add(int[] point) Adds a new point point = [x, y] to the data structure.\nint count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.\n ", "code": "class DetectSquares:\n\ndef __init__(self):\n    self.dic={}\n\ndef add(self, point: List[int]) -> None:\n    key=(point[0],point[1])\n    self.dic[key]=self.dic.get(key,0)+1\n\ndef count(self, point: List[int]) -> int:\n    res=0\n    x1,y1=point\n    \n    for x2,y2 in self.dic:\n        if(x1!=x2 and y1!=y2 and abs(x1-x2)==abs(y1-y2) and (x1,y2) in self.dic and (x2,y1) in self.dic):\n            res+=self.dic[(x2,y2)]*self.dic[(x1,y2)]*self.dic[(x2,y1)]\n    return res"}
{"nl": "Here, we will discuss how to get the first digit of a number in python. If the number was \u201c12345\u201d then print the first digit \u201c1\u201d. We will develop a Python program to get the first digit of the given number using native methods, built-in function, [ ] operator, and slice operator.", "code": "# Python Program to get the first digit of number # take input num = int(input('Enter any Number: ')) # get the first digit while (num >= 10): num = num // 10 # printing first digit of number print('The first digit of number:', num)"}
{"nl": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\n\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\n\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.", "code": "class Solution:\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\n        arr_price, arr_beauty, res, max_ = [], [], [], -inf\n        items.sort()\n        \n        for i in range(len(items)):\n            if i == len(items) - 1 or items[i][0] != items[i + 1][0]:\n                arr_price.append(items[i][0])\n                max_ = max(max_, items[i][1])\n                arr_beauty.append(max_)\n\n        for q in queries:\n            ind = bisect.bisect(arr_price, q)\n            if ind == 0: res.append(0)\n            else: res.append(arr_beauty[ind - 1])\n            \n        return res"}
{"nl": "Given four sorted arrays each of size n of distinct elements. Given a value x. The problem is to count all quadruples(group of four numbers) from all the four arrays whose sum is equal to x.\nNote: The quadruple has an element from each of the four arrays.\n\nExamples: \n\nInput : arr1 = {1, 4, 5, 6},\n        arr2 = {2, 3, 7, 8},\n        arr3 = {1, 4, 6, 10},\n        arr4 = {2, 4, 7, 8} \n        n = 4, x = 30\nOutput : 4\nThe quadruples are:\n(4, 8, 10, 8), (5, 7, 10, 8),\n(5, 8, 10, 7), (6, 7, 10, 7)\n\nInput : For the same above given fours arrays\n        x = 25\nOutput : 14", "code": "# A Python3 implementation to count\n# quadruples from four sorted arrays\n# whose sum is equal to a given value x\n\n# function to count all quadruples\n# from four sorted arrays whose sum\n# is equal to a given value x\ndef countQuuadruples(arr1, arr2,\n\t\t\t\t\tarr3, arr4, n, x):\n\tcount = 0\n\n\t# generate all possible\n\t# quadruples from the four\n\t# sorted arrays\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tfor k in range(n):\n\t\t\t\tfor l in range(n):\n\n\t\t\t\t\t# check whether elements of\n\t\t\t\t\t# quadruple sum up to x or not\n\t\t\t\t\tif (arr1[i] + arr2[j] +\n\t\t\t\t\t\tarr3[k] + arr4[l] == x):\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\t\n\t# required count of quadruples\n\treturn count\n\n# Driver Code\narr1 = [1, 4, 5, 6]\narr2 = [2, 3, 7, 8]\narr3 = [1, 4, 6, 10]\narr4 = [2, 4, 7, 8 ]\nn = len(arr1)\nx = 30\nprint(\"Count = \", countQuuadruples(arr1, arr2,\n\t\t\t\t\t\t\t\tarr3, arr4, n, x))\n\n# This code is contributed\n# by Shrikant13"}
{"nl": "Given an ancestor matrix mat[n][n] where Ancestor matrix is defined as below. \n\nmat[i][j] = 1 if i is ancestor of j\r\nmat[i][j] = 0, otherwise\n\nConstruct a Binary Tree from a given ancestor matrix where all its values of nodes are from 0 to n-1.\r\n\r\n1. It may be assumed that the input provided the program is valid and tree can be constructed out of it. \r\n2. Many Binary trees can be constructed from one input. The program will construct any one of them.", "code": "# key structure to store a binary tree node\r\nclass Node:\r\n\tdef __init__(self, key, left = None, right = None):\r\n\t\tself.key = key\r\n\t\tself.left = left\r\n\t\tself.right = right\r\n\r\n# Utility function to print binary tree nodes in-order fashion\r\ndef inorder(node):\r\n\tif node:\r\n\t\tinorder(node.left)\r\n\t\tprint(node.key, end = ' ')\r\n\t\tinorder(node.right)\r\n\r\n# Function to construct a binary tree\r\n# from specified ancestor matrix\r\ndef constructBT(mat):\r\n\r\n\t# get number of rows in the matrix\r\n\tN = len(mat)\r\n\r\n\t# create an empty multi-dict\r\n\tdict = {}\r\n\r\n\t# Use sum as key and row numbers as values in the multi-dict\r\n\tfor i in range(N):\r\n\r\n\t\t# find the sum of the current row\r\n\t\ttotal = sum(mat[i])\r\n\r\n\t\t# insert the sum and row number into the dict\r\n\t\tdict.setdefault(total, []).append(i)\r\n\r\n\t# node[i] will store node for i in constructed tree\r\n\tnode = [Node(-1)] * N\r\n\tlast = 0\r\n\r\n\t# the value of parent[i] is true if parent is set for i'th node\r\n\tparent = [False] * N\r\n\r\n\t# Traverse the dictionary in sorted order (default behavior)\r\n\tfor key in dict.keys():\r\n\t\tfor row in dict.get(key):\r\n\t\t\tlast = row\r\n\t\t\t\r\n\t\t\t# create a new node\r\n\t\t\tnode[row] = Node(row)\r\n\r\n\t\t\t# if leaf node, do nothing\r\n\t\t\tif key == 0:\r\n\t\t\t\tcontinue\r\n\r\n\t\t\t# traverse row\r\n\t\t\tfor i in range(N):\r\n\t\t\t\r\n\t\t\t\t# do if parent is not set and ancestor exits\r\n\t\t\t\tif not parent[i] and mat[row][i] == 1:\r\n\t\t\t\t\r\n\t\t\t\t\t# check for the unoccupied node\r\n\t\t\t\t\tif node[row].left is None:\r\n\t\t\t\t\t\tnode[row].left = node[i]\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tnode[row].right = node[i]\r\n\r\n\t\t\t\t\t# set parent for i'th node\r\n\t\t\t\t\tparent[i] = True\r\n\r\n\t# last processed node is the root\r\n\treturn node[last]\r\n\r\n# Construct a Binary Tree from Ancestor Matrix\r\nif __name__ == '__main__':\r\n\r\n\tmat = [[0, 0, 0, 0, 0, 0],\r\n\t\t[1, 0, 0, 0, 1, 0],\r\n\t\t[0, 0, 0, 1, 0, 0],\r\n\t\t[0, 0, 0, 0, 0, 0],\r\n\t\t[0, 0, 0, 0, 0, 0],\r\n\t\t[1, 1, 1, 1, 0, 0]]\r\n\r\n\troot = constructBT(mat)\r\n\tinorder(root)\r\n\r\n# This code is contributed by Priyadarshini Kumari\r"}
{"nl": "Multiplication Table in Python | In this post, We will discuss how to print multiplication tables in python. In mathematics, a multiplication table is a mathematical table used to define a multiplication operation for an algebraic system. We will also develop a Python program to print multiplication tables from 1 to 10.", "code": "# Python program to print multiplication table # take inputs num = int(input('Display multiplication table of: ')) # print multiplication table for i in range(1, 11): print (\"%d * %d = %d\" % (num, i, num * i))"}
{"nl": "Find a Mother Vertex in a Graph\r\n", "code": "\r\n# program to find a mother vertex in O(V+E) time\r\nfrom collections import defaultdict\r\n \r\n# This class represents a directed graph using adjacency list\r\n# representation\r\nclass Graph:\r\n \r\n    def __init__(self,vertices):\r\n        self.V = vertices #No. of vertices\r\n        self.graph = defaultdict(list) # default dictionary\r\n \r\n    # A recursive function to print DFS starting from v\r\n    def DFSUtil(self, v, visited):\r\n \r\n        # Mark the current node as visited and print it\r\n        visited[v] = True\r\n \r\n        # Recur for all the vertices adjacent to this vertex\r\n        for i in self.graph[v]:\r\n            if visited[i] == False:\r\n                self.DFSUtil(i, visited)\r\n \r\n    # Add w to the list of v\r\n    def addEdge(self, v, w):\r\n        self.graph[v].append(w)\r\n \r\n    # Returns a mother vertex if exists. Otherwise returns -1\r\n    def findMother(self):\r\n \r\n        # visited[] is used for DFS. Initially all are\r\n        # initialized as not visited\r\n        visited =[False]*(self.V)\r\n \r\n        # To store last finished vertex (or mother vertex)\r\n        v=0\r\n \r\n        # Do a DFS traversal and find the last finished\r\n        # vertex\r\n        for i in range(self.V):\r\n            if visited[i]==False:\r\n                self.DFSUtil(i,visited)\r\n                v = i\r\n \r\n        # If there exist mother vertex (or vertices) in given\r\n        # graph, then v must be one (or one of them)\r\n \r\n        # Now check if v is actually a mother vertex (or graph\r\n        # has a mother vertex). We basically check if every vertex\r\n        # is reachable from v or not.\r\n \r\n        # Reset all values in visited[] as false and do\r\n        # DFS beginning from v to check if all vertices are\r\n        # reachable from it or not.\r\n        visited = [False]*(self.V)\r\n        self.DFSUtil(v, visited)\r\n        if any(i == False for i in visited):\r\n            return -1\r\n        else:\r\n            return v\r\n \r\n# Create a graph given in the above diagram\r\ng = Graph(7)\r\ng.addEdge(0, 1)\r\ng.addEdge(0, 2)\r\ng.addEdge(1, 3)\r\ng.addEdge(4, 1)\r\ng.addEdge(6, 4)\r\ng.addEdge(5, 6)\r\ng.addEdge(5, 2)\r\ng.addEdge(6, 0)\r\nprint (\"A mother vertex is \" + str(g.findMother()))\r\n \r\n# This code is contributed by Neelam Yadav"}
{"nl": "Create a function that returns the right diagonal of a matrix if the sum of the right diagonal is greater than or equal to the sum of the left diagonal, else returns the left diagonal.\nExamples\ncompare_diagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \u279e [3, 5, 7]\nNotes\nThe matrix will be a square matrix of any order.", "code": "def compare_diagonal(m):\n  return max([[l[len(m)-1-i] for i,l in enumerate(m)],[l[i] for i,l in enumerate()]] ,key = sum)"}
{"nl": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n\nRead in and ignore any leading whitespace.\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\nConvert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\nIf the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\nReturn the integer as the final result.\nNote:\n\nOnly the space character ' ' is considered a whitespace character.\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n \n\nExample 1:\n\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.\nExample 2:\n\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.\nExample 3:\n\nInput: s = \"4193 with words\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.\n \n\nConstraints:\n\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.", "code": "class StateMachine:\n    def __init__(self):\n        self.State = { \"q0\": 1, \"q1\": 2, \"q2\": 3, \"qd\": 4 }\n        self.INT_MAX, self.INT_MIN = pow(2, 31) - 1, -pow(2, 31)\n        \n        # Store current state value.\n        self.__current_state = self.State[\"q0\"]\n        # Store result formed and its sign.\n        self.__result = 0\n        self.__sign = 1\n\n    def to_state_q1(self, ch: chr) -> None:\n        \"\"\"Transition to state q1.\"\"\"\n        self.__sign = -1 if (ch == '-') else 1\n        self.__current_state = self.State[\"q1\"]\n    \n    def to_state_q2(self, digit: int) -> None:\n        \"\"\"Transition to state q2.\"\"\"\n        self.__current_state = self.State[\"q2\"]\n        self.append_digit(digit)\n    \n    def to_state_qd(self) -> None:\n        \"\"\"Transition to dead state qd.\"\"\"\n        self.__current_state = self.State[\"qd\"]\n    \n    def append_digit(self, digit: int) -> None:\n        \"\"\"Append digit to result, if out of range return clamped value.\"\"\"\n        if ((self.__result > self.INT_MAX // 10) or \n            (self.__result == self.INT_MAX // 10 and digit > self.INT_MAX % 10)):\n            if self.__sign == 1:\n                # If sign is 1, clamp result to INT_MAX.\n                self.__result = self.INT_MAX\n            else:\n                # If sign is -1, clamp result to INT_MIN.\n                self.__result = self.INT_MIN\n                self.__sign = 1\n            \n            # When the 32-bit int range is exceeded, a dead state is reached.\n            self.to_state_qd()\n        else:\n            # Append current digit to the result. \n            self.__result = (self.__result * 10) + digit\n\n    def transition(self, ch: chr) -> None:\n        \"\"\"Change state based on current input character.\"\"\"\n        if self.__current_state == self.State[\"q0\"]:\n            # Beginning state of the string (or some whitespaces are skipped).\n            if ch == ' ':\n                # Current character is a whitespaces.\n                # We stay in same state. \n                return\n            elif ch == '-' or ch == '+':\n                # Current character is a sign.\n                self.to_state_q1(ch)\n            elif ch.isdigit():\n                # Current character is a digit.\n                self.to_state_q2(int(ch))\n            else:\n                # Current character is not a space/sign/digit.\n                # Reached a dead state.\n                self.to_state_qd()\n        \n        elif self.__current_state == self.State[\"q1\"] or self.__current_state == self.State[\"q2\"]:\n            # Previous character was a sign or digit.\n            if ch.isdigit():\n                # Current character is a digit.\n                self.to_state_q2(int(ch))\n            else:\n                # Current character is not a digit.\n                # Reached a dead state.\n                self.to_state_qd()\n    \n    def get_integer(self) -> None:\n        \"\"\"Return the final result formed with it's sign.\"\"\"\n        return self.__sign * self.__result\n    \n    def get_state(self) -> None:\n        \"\"\"Get current state.\"\"\"\n        return self.__current_state\n\nclass Solution:\n    def myAtoi(self, input: str) -> int:\n        q = StateMachine()\n        \n        for ch in input:\n            q.transition(ch)\n            if q.get_state() == q.State[\"qd\"]:\n                break\n\n        return q.get_integer()"}
{"nl": "Given a list and the task is to find the sum of even numbers using recursion in a given list in python.\n\nRecursion:\n\nRecursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven List = [1, 6, 3, 7, 8, 4]\nOutput:\n\nThe Sum of Even Elements in a given list [1, 6, 3, 7, 8, 4] = 18", "code": "# Create a recursive function to say evenelemt_sum which takes the given list and length\n# of the given list as the arguments and returns the sum of even numbers in a given list\n# using recursion.\n\n\ndef evenelemt_sum(gven_lst, len_lst):\n    # Make the rslt_sum a global declaration.\n    global rslt_sum\n    # Check if the length of the given list is greater than 0 using the if conditional\n    # statement.\n    if(len_lst > 0):\n        # If the statement is true, then subtract 1 from the length of the given list and\n        # store it in a variable k.\n        k = len_lst-1\n   # Check if the element present at the index k of the given list is even using modulus\n   # operator and if conditional statement.\n        if(gven_lst[k] % 2 == 0):\n            # If the statement is true, add the element present at the index k of the\n            # given list to the above-initialized rslt_sum.\n            # Store it in the same variable.\n            rslt_sum = rslt_sum+gven_lst[k]\n           # Pass the given list and k value as the arguments to the evenelemt_sum function\n           # {Recursive Logic}.\n        evenelemt_sum(gven_lst, k)\n       # Return rslt_sum.\n    return rslt_sum\n\n\n# Give the list as static input and store it in a variable.\ngven_lst = [1, 6, 3, 7, 8, 4]\n# Calculate the length of the given list and store it in another variable.\nlen_lst = len(gven_lst)\n# Take a variable say rslt_sum and initialize its value to 0.\nrslt_sum = 0\n# Pass the given list and length of the given list as the arguments to the evenelemt_sum\n# function.\n# Print the sum of even numbers in the above-given list.\nprint(\"The Sum of Even Elements in a given list\",\n      gven_lst, \"=\", evenelemt_sum(gven_lst, len_lst))"}
{"nl": "Create a function that takes a string txt and expands it as per the following rules:\nThe numeric values represent the occurrence of each letter preceding that numeric value.\nstring_expansion(\"3M2u5b2a1s1h2i1r\") \u279e \"MMMuubbbbbaashiir\"\nThe first occurrence of a numeric value should be the number of times each character behind it is repeated, until the next numeric value appears.\nstring_expansion(\"3Mat\")\u279e \"MMMaaattt\"      # correct\n\nstring_expansion(\"3Mat\") \u279e \"MMMat\"          # wrong\nstring_expansion(\"3Mat\") \u279e \"MatMatMat\"      # wrong\nIf there are consecutive numeric characters, ignore them all except last one.\nstring_expansion(\"3M123u42b12a\") \u279e \"MMMuuubbaa\"\nIf there are two consecutive alphabetic characters then the string will remain unchanged.\nstring_expansion(\"airforce\") \u279e \"airforce\"\nEmpty strings should return an empty string.\nstring_expansion(\"\") \u279e \"\"\nNotes\nN/A", "code": "def string_expansion(txt):\n    m,n = '',1\n    for j in txt:\n        if j.isdigit():\n            n = int(j)\n        else:\n            m += j*n\n    return m"}
{"nl": "Given a list of integers, find the pair of adjacent elements that have the largest product and return that product.\nExamples\nadjacent_product([3, 6, -2, -5, 7, 3] ) \u279e 21\n\nadjacent_product([5, 6, -4, 2, 3, 2, -23]) \u279e 30\n\nadjacent_product([0, -1, 1, 24, 1, -4, 8, 10]) \u279e 80\nNotes\nEach list has at least two elements.", "code": "def adjacent_product(lst):\n  return max(a*b for a, b in zip(lst, lst[1:]))"}
{"nl": "Write three functions:\nboolean_and\nboolean_or\nboolean_xor\nThese functions should evaluate a list of True and False values, starting from the leftmost element and evaluating pairwise.\nExamples\nboolean_and([True, True, False, True]) \u279e False\n# [True, True, False, True] => [True, False, True] => [False, True] => False\n\nboolean_or([True, True, False, False]) \u279e True\n# [True, True, False, True] => [True, False, False] => [True, False] => True\n\nboolean_xor([True, True, False, False]) \u279e False\n# [True, True, False, False] => [False, False, False] => [False, False] => False\nNotes\nXOR is the same as OR, except that it excludes [True, True].\nEach time you evaluate an element at 0 and at 1, you collapse it into the single result.", "code": "boolean_and=all\nboolean_or=any  \nboolean_xor=lambda l:sum(l)%2"}
{"nl": "Create a function that, when given a list of individual finite-state automaton instructions, generates an FSA in the form described in this challenge. Each instruction will be a list of three elements: The first element will be the current state, the second element will be the input to which the instruction pertains, and the third element will be the new state.\nFor example, the instruction [\"S0\", 1, \"S1\"] indicates that, if the current state is \"S0\", upon receiving a 1 as input, the new state will be \"S1\". A deconstruction of the FSA from this challenge can be seen below:\nExamples\ndivisible = [\n  [\"S0\", 0, \"S0\"], [\"S0\", 1, \"S1\"],\n  [\"S1\", 0, \"S2\"], [\"S1\", 1, \"S0\"],\n  [\"S2\", 0, \"S1\"], [\"S2\", 1, \"S2\"]\n]\n\ncombine(divisible) \u279e {\n  \"S0\": [\"S0\", \"S1\"],\n  \"S1\": [\"S2\", \"S0\"],\n  \"S2\": [\"S1\", \"S2\"]\n}\nNotes\nEvery FSA will use a binary alphabet.\nAll states will be of the form Sn, where n is an integer, e.g. S2.", "code": "def combine(lst):\n  return {a[0]: [a[2], b[2]] for a, b in zip(lst[::2], lst[1::2])}"}
{"nl": "There are n people and 40 types of hats labeled from 1 to 40.\nGiven a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person.\nReturn the number of ways that the n people wear different hats to each other.\nSince the answer may be too large, return it modulo 109 + 7.\n \nExample 1:\n\nInput: hats = [[3,4],[4,5],[5]]\nOutput: 1\nExplanation: There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n\nExample 2:\n\nInput: hats = [[3,5,1],[3,5]]\nOutput: 4\nExplanation: There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n\nExample 3:\n\nInput: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\nOutput: 24\nExplanation: Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n\n \nConstraints:\n\nn == hats.length\n1 <= n <= 10\n1 <= hats[i].length <= 40\n1 <= hats[i][j] <= 40\nhats[i] contains a list of unique integers.", "code": "class Solution:\n  def numberWays(self, hats: List[List[int]]) -> int:\n  htop = [[] for i in range(41)] # htop: hat to people list\n  for p, prefer_hats in enumerate(hats):\n  for h in prefer_hats:\n  htop[h].append(p)\n  htop = list(filter(lambda h: h, htop)) # filter out hats no one wants\n  \n  num_hats, num_people = len(htop), len(hats)\n  if num_hats < num_people:\n  return 0\n  \n  MOD = 10**9+7\n  @functools.lru_cache(None)\n  def dp(i, mask):\n  if bin(mask).count('1') == num_people:\n  return 1\n  if i == num_hats:\n  return 0\n  res = dp(i+1, mask) # not using the current hat\n  for p in htop[i]:\n  if mask & (1<<p) == 0:\n  mask |= 1<<p\n  res += dp(i+1, mask)\n  mask ^= 1<<p\n  return res%MOD\n  return dp(0, 0)"}
{"nl": "Definition and Usage\r\nThe seekable() method returns True if the file is seekable, False if not.\r\n\r\nA file is seekable if it allows access to the file stream, like the seek() method.", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.seekable())"}
{"nl": "Given a binary tree, where every node value is a Digit from 1-9 .Find the sum of all the numbers which are formed from root to leaf paths.\nFor example consider the following Binary Tree. \n \n\n           6\n       /      \\\n     3          5\n   /   \\          \\\n  2     5          4  \n      /   \\\n     7     4\n  There are 4 leaves, hence 4 root to leaf paths:\n   Path                    Number\n  6->3->2                   632\n  6->3->5->7               6357\n  6->3->5->4               6354\n  6->5>4                    654   \nAnswer = 632 + 6357 + 6354 + 654 = 13997 ", "code": "# Python program to find sum of all paths from root to leaves\n\n# A Binary tree node\nclass Node:\n\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Returns sums of all root to leaf paths. The first parameter is root\n# of current subtree, the second paramete\"r is value of the number\n# formed by nodes from root to this node\ndef treePathsSumUtil(root, val):\n\n\t# Base Case\n\tif root is None:\n\t\treturn 0\n\n\t# Update val\n\tval = (val*10 + root.data)\n\n\t# If current node is leaf, return the current value of val\n\tif root.left is None and root.right is None:\n\t\treturn val\n\n\t# Recur sum of values for left and right subtree\n\treturn (treePathsSumUtil(root.left, val) +\n\t\t\ttreePathsSumUtil(root.right, val))\n\n# A wrapper function over treePathSumUtil()\ndef treePathsSum(root):\n\t\n\t# Pass the initial value as 0 as ther is nothing above root\n\treturn treePathsSumUtil(root, 0)\n\n# Driver function to test above function\nroot = Node(6)\nroot.left = Node(3)\nroot.right = Node(5)\nroot.left.left = Node(2)\nroot.left.right = Node(5)\nroot.right.right = Node(4)\nroot.left.right.left = Node(7)\nroot.left.right.right = Node(4)\nprint (\"Sum of all paths is\", treePathsSum(root))\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "In the rod-cutting problem, we are given a rod of length n inches and a table of prices p[i] for i = 1, 2, \u2026, n. Here p[i] is the price of a rod of length i inches. We have to find the optimal way of cutting the rod so that maximum revenue can be generated by selling the pieces.", "code": "def cut_rod(p, n):\n    \"\"\"Take a list p of prices and the rod length n and return lists r and s.\n    r[i] is the maximum revenue that you can get and s[i] is the length of the\n    first piece to cut from a rod of length i.\"\"\"\n    # r[i] is the maximum revenue for rod length i\n    # r[i] = -1 means that r[i] has not been calculated yet\n    r = [-1]*(n + 1)\n\u00a0\n    # s[i] is the length of the initial cut needed for rod length i\n    # s[0] is not needed\n    s = [-1]*(n + 1)\n\u00a0\n    cut_rod_helper(p, n, r, s)\n\u00a0\n    return r, s\n\u00a0\n\u00a0\ndef cut_rod_helper(p, n, r, s):\n    \"\"\"Take a list p of prices, the rod length n, a list r of maximum revenues\n    and a list s of initial cuts and return the maximum revenue that you can get\n    from a rod of length n.\n\u00a0\n    Also, populate r and s based on which subproblems need to be solved.\n    \"\"\"\n    if r[n] >= 0:\n        return r[n]\n\u00a0\n    if n == 0:\n        q = 0\n    else:\n        q = -1\n        for i in range(1, n + 1):\n            temp = p[i] + cut_rod_helper(p, n - i, r, s)\n            if q < temp:\n                q = temp\n                s[n] = i\n    r[n] = q\n\u00a0\n    return q\n\u00a0\n\u00a0\nn = int(input('Enter the length of the rod in inches: '))\n\u00a0\n# p[i] is the price of a rod of length i\n# p[0] is not needed, so it is set to None\np = [None]\nfor i in range(1, n + 1):\n    price = input('Enter the price of a rod of length {} in: '.format(i))\n    p.append(int(price))\n\u00a0\nr, s = cut_rod(p, n)\nprint('The maximum revenue that can be obtained:', r[n])\nprint('The rod needs to be cut into length(s) of ', end='')\nwhile n > 0:\n    print(s[n], end=' ')\n    n -= s[n]"}
{"nl": null, "code": null}
{"nl": "Create a function which returns how many Friday 13ths there are in a given year.\nExamples\nhow_unlucky(2020) \u279e 2\n\nhow_unlucky(2026) \u279e 3\n\nhow_unlucky(2016) \u279e 1\nNotes\nCheck Resources for some helpful tutorials on the Python datetime module.", "code": "from datetime import date\ndef how_unlucky(y):\n  return sum(date(y, m, 13).strftime('%A') == 'Friday' for m in range(1, 13))"}
{"nl": "Rearrange the Letters of Multiple strings separated by spaces in Alphabetical Order Using sorted() and join() functions (User Input)", "code": "# Give the string as user input using the input() function and store it in a variable.\r\ngvnstrng = input('Enter some random string = ')\r\n# Reorder the letters of a string alphabetically using\r\n# the sorted function(This method returns a list of letters in alphabetical order).\r\nsortdstrng = sorted(gvnstrng)\r\n# Join this using the join() function.\r\n# Use the strip() function to remove spaces between the strings.\r\nfinalstrng = ''.join(sortdstrng).strip()\r\n# Print the modified string after reordering the letters of a string alphabetically.\r\nprint('The original string is [', gvnstrng, ']')\r\nprint(\r\n    'The modified string after reordering the letters of a string alphabetically is [', finalstrng, ']')"}
{"nl": "Definition and Usage\r\nThe insert() method inserts the specified value at the specified position.", "code": "fruits = ['apple', 'banana', 'cherry']\r\n\r\nfruits.insert(1, \"orange\")"}
{"nl": "In this article, we will see how to implement graph in python using dictionary data structure in python. \nThe keys of the dictionary used are the nodes of our graph and the corresponding values are lists with each nodes, which are connecting by an edge. \nThis simple graph has six nodes (a-f) and five arcs: \n \n\na -> c\nb -> c\nb -> e\nc -> a\nc -> b\nc -> d\nc -> e\nd -> c\ne -> c\ne -> b\nIt can be represented by the following Python data structure. This is a dictionary whose keys are the nodes of the graph. For each key, the corresponding value is a list containing the nodes that are connected by a direct arc from this node. \n \n\ngraph = { \"a\" : [\"c\"],\n          \"b\" : [\"c\", \"e\"],\n          \"c\" : [\"a\", \"b\", \"d\", \"e\"],\n          \"d\" : [\"c\"],\n          \"e\" : [\"c\", \"b\"],\n          \"f\" : []\n        } ", "code": "# Python program for\n# validation of a graph\n\u00a0\n# import dictionary for graph\nfrom collections import defaultdict\n\u00a0\n# function for adding edge to graph\ngraph = defaultdict(list)\ndef addEdge(graph,u,v):\n\u00a0\u00a0\u00a0\u00a0graph[u].append(v)\n\u00a0\n# definition of function\ndef generate_edges(graph):\n\u00a0\u00a0\u00a0\u00a0edges = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# for each node in graph\n\u00a0\u00a0\u00a0\u00a0for node in graph:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for each neighbour node of a single node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for neighbour in graph[node]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if edge exists then append\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges.append((node, neighbour))\n\u00a0\u00a0\u00a0\u00a0return edges\n\u00a0\n# declaration of graph as dictionary\naddEdge(graph,'a','c')\naddEdge(graph,'b','c')\naddEdge(graph,'b','e')\naddEdge(graph,'c','d')\naddEdge(graph,'c','e')\naddEdge(graph,'c','a')\naddEdge(graph,'c','b')\naddEdge(graph,'e','b')\naddEdge(graph,'d','c')\naddEdge(graph,'e','c')\n\u00a0\n# Driver Function call\n# to print generated graph\nprint(generate_edges(graph))\n"}
{"nl": "Score a bowling game.\n\nBowling is a game where players roll a heavy ball to knock down pins arranged in a triangle. Write code to keep track of the score of a game of bowling.\n\nScoring Bowling\nThe game consists of 10 frames. A frame is composed of one or two ball throws with 10 pins standing at frame initialization. There are three cases for the tabulation of a frame.\n\nAn open frame is where a score of less than 10 is recorded for the frame. In this case the score for the frame is the number of pins knocked down.\n\nA spare is where all ten pins are knocked down by the second throw. The total value of a spare is 10 plus the number of pins knocked down in their next throw.\n\nA strike is where all ten pins are knocked down by the first throw. The total value of a strike is 10 plus the number of pins knocked down in the next two throws. If a strike is immediately followed by a second strike, then the value of the first strike cannot be determined until the ball is thrown one more time.\n\nHere is a three frame example:\n\nFrame 1\tFrame 2\tFrame 3\nX (strike)\t5/ (spare)\t9 0 (open frame)\nFrame 1 is (10 + 5 + 5) = 20\n\nFrame 2 is (5 + 5 + 9) = 19\n\nFrame 3 is (9 + 0) = 9\n\nThis means the current running total is 48.\n\nThe tenth frame in the game is a special case. If someone throws a strike or a spare then they get a fill ball. Fill balls exist to calculate the total of the 10th frame. Scoring a strike or spare on the fill ball does not give the player more fill balls. The total value of the 10th frame is the total number of pins knocked down.\n\nFor a tenth frame of X1/ (strike and a spare), the total value is 20.\n\nFor a tenth frame of XXX (three strikes), the total value is 30.", "code": "class Frame(object):\n    \"\"\"Frame\"\"\"\n    def __init__(self, ID):\n        self.id = ID\n        self.throws = []\n    @property\n    def is_done(self):\n        return sum(self.throws) == 10 or len(self.throws) == 2\n    @property\n    def is_strike(self):\n        return sum(self.throws) == 10 and len(self.throws) == 1\n    @property\n    def is_spare(self):\n        return sum(self.throws) == 10 and len(self.throws) == 2\n    def score(self, next_throws):\n        res = sum(self.throws)\n        if self.is_strike:\n            res += sum(next_throws[:2])\n        elif self.is_spare:\n            res += sum(next_throws[:1])\n        return res\n    def roll(self, pins):\n        if pins < 0:\n            raise ValueError(f'pins cannot be negative but received \"{pins}\".')\n        if pins > 10:\n            raise ValueError(f'pins cannot be greater than 10 but received \"{pins}\".')  # noqa\n        if sum(self.throws) + pins > 10:\n            raise ValueError(f'A frame\\'s rolls cannot exceed 10 pins.')\n        self.throws.append(pins)\nclass BowlingGame(object):\n    \"\"\"BowlingGame\"\"\"\n    def __init__(self):\n        self.bonus_throws = []\n        self.frames = [Frame(i) for i in range(10)]\n        self.frame_num = 0\n    @property\n    def crnt_frame(self):\n        return self.get_frame(self.frame_num)\n    def get_frame(self, frame_num):\n        return self.frames[frame_num]\n    def next_throws(self, frameID):\n        next_throws = []\n        next_frameID = frameID + 1\n        while next_frameID < 10:\n            next_throws += self.get_frame(next_frameID).throws\n            next_frameID += 1\n        next_throws += self.bonus_throws\n        return next_throws\n    def handle_bonus_throw(self, pins):\n        if self.get_frame(9).is_spare:\n            if len(self.bonus_throws) == 1:\n                raise IndexError(f'Game over. Please insert quarter.')\n            self.bonus_throws += [pins]  # TODO guard against bad input\n        elif self.get_frame(9).is_strike:\n            if len(self.bonus_throws) == 2:\n                raise IndexError(f'Game over. Please insert quarter.')\n            if sum(self.bonus_throws + [pins]) > 10:\n                if len(self.bonus_throws) == 1 and self.bonus_throws[0] == 10:\n                    pass\n                else:\n                    raise ValueError(f'You lie!')\n            self.bonus_throws += [pins]\n        else:\n            raise IndexError(f'Game over. Please insert quarter.')\n    def roll(self, pins):\n        if pins > 10:\n            raise ValueError(f'You lie!')\n        if self.frame_num == 10:\n            self.handle_bonus_throw(pins)\n        else:\n            self.crnt_frame.roll(pins)\n            if self.crnt_frame.is_done:\n                self.frame_num += 1\n    def score(self):\n        if self.frame_num < 10:\n            raise IndexError(f'All frames must be complete before scoring.')\n        if self.get_frame(9).is_spare:\n            if len(self.bonus_throws) != 1:\n                raise IndexError(f'If the final frame is a spare, then one bonus roll must be taken.')  # noqa\n        if self.get_frame(9).is_strike:\n            if len(self.bonus_throws) != 2:\n                raise IndexError(f'If the final frame is a strike, then two bonus rolls must be taken.')  # noqa\n        return sum(frame.score(self.next_throws(frame.id))\n                   for frame in self.frames)"}
{"nl": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn true if you can reach the last index, or false otherwise.\n\n \n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n \n\nConstraints:\n\n1 <= nums.length <= 104\n0 <= nums[i] <= 105", "code": "def canJump(self, nums):\n    m = 0\n    for i, n in enumerate(nums):\n        if i > m:\n            return False\n        m = max(m, i+n)\n    return True"}
{"nl": "Given an array of integers and a number k, write a function that returns true if the given array can be divided into pairs such that the sum of every pair is divisible by k.\n\nExamples: \n\nInput: arr[] = {9, 7, 5, 3}, \nk = 6 \nOutput: True \nWe can divide the array into (9, 3) and \n(7, 5). Sum of both of these pairs \nis a multiple of 6.\n\nInput: arr[] = {92, 75, 65, 48, 45, 35}, \nk = 10 \nOutput: True ", "code": "# Python3 program to check if\n# arr[0..n-1] can be divided\n# in pairs such that every\n# pair is divisible by k.\nfrom collections import defaultdict\n\n# Returns true if arr[0..n-1] can be\n# divided into pairs with sum\n# divisible by k.\n\n\ndef canPairs(arr, n, k):\n\n        # An odd length array cannot\n        # be divided into pairs\n        if (n & 1):\n                return 0\n\n        # Create a frequency array to\n        # count occurrences of all\n        # remainders when divided by k.\n        freq = defaultdict(lambda: 0)\n\n        # Count occurrences of all remainders\n        for i in range(0, n):\n                freq[((arr[i] % k) + k) % k] += 1\n\n        # Traverse input array and use\n        # freq[] to decide if given array\n        # can be divided in pairs\n        for i in range(0, n):\n\n                # Remainder of current element\n                rem = ((arr[i] % k) + k) % k\n\n                # If remainder with current element\n                # divides k into two halves.\n                if (2 * rem == k):\n\n                        # Then there must be even occurrences\n                        # of such remainder\n                        if (freq[rem] % 2 != 0):\n                                return 0\n\n                # If remainder is 0, then there\n                # must be two elements with 0 remainder\n                else if (rem == 0):\n                        if (freq[rem] & 1):\n                                return 0\n\n                        # Else number of occurrences of\n                        # remainder must be equal to\n                        # number of occurrences of\n                        # k - remainder\n                else if (freq[rem] != freq[k - rem]):\n                        return 0\n\n        return 1\n\n\n# Driver code\narr = [92, 75, 65, 48, 45, 35]\nk = 10\nn = len(arr)\n\n# Function call\nif (canPairs(arr, n, k)):\n        print(\"True\")\nelse:\n        print(\"False\")\n\n# This code is contributed by Stream_Cipher\n"}
{"nl": "Recursion in Python:\n\nPython also supports function recursion, which means that a specified function can call itself.\n\nRecursion is a mathematical and programming concept that is widely used. It signifies that a function calls itself. This has the advantage of allowing you to loop through data to obtain a result.\n\nThe developer must exercise extreme caution when using recursion since it is quite easy to write a function that never terminates or consumes excessive amounts of memory or computing power. However, when performed correctly, recursion may be a tremendously efficient and mathematically elegant way to programming.\n\nNested List:\n\nA list can include any form of the object, including another list (sublist), which can contain sublists, and so on. This is referred to as a nested list.\n\nGiven a nested list, the task is to write a python program that converts the given list to flatted list.\n\nExamples:\n\nI)Integer Nested List\n\nExample1:\n\nInput:\n\ngiven Nested List = [ [7, 8, 2], [11, 19, 29, 63, 91], [12, 52, 98], [11, 19, 18], \n                                 [11, 28, 34, 39, 35, 56, 87, 46, 1, 2], [5], [9, 23],[3, 23, 124] ]\nOutput:\n\nPrinting the given nested list : \n [[7, 8, 2], [11, 19, 29, 63, 91], [12, 52, 98], [11, 19, 18], [11, 28, 34, 39, 35, 56, 87, 46, 1, 2], [5], [9, 23], [3, 23, 124]]\nPrinting the flattened list : \n [7, 8, 2, 11, 19, 29, 63, 91, 12, 52, 98, 11, 19, 18, 11, 28, 34, 39, 35, 56, 87, 46, 1, 2, 5, 9, 23, 3, 23, 124]", "code": "# function which takes the nested list as argument and\n# returns the flattened list using recursion\n\n\ndef flattenListRecursion(given_NestedList):\n    # If the list is empty, the function returns the list.\n    if given_NestedList == []:\n        return given_NestedList\n     # Otherwise, use the function with the sublists as parameters\n     # recursively until the entire list is flattened.\n    if isinstance(given_NestedList[0], list):\n        return flattenListRecursion(given_NestedList[0]) + flattenListRecursion(given_NestedList[1:])\n    return given_NestedList[:1] + flattenListRecursion(given_NestedList[1:])\n\n\n# Give the nested list as static input and store it in a variable.\ngivenNestedList = [[7, 8, 2], [11, 19, 29, 63, 91], [12, 52, 98], [11, 19, 18],\n                   [11, 28, 34, 39, 35, 56, 87, 46, 1, 2], [5], [9, 23], [3, 23, 124]]\n# printing the given nested list\nprint('Printing the given nested list : \\n', givenNestedList)\n# passing the given nested list as an argument to the recursive function flattenListRecursion\n# which returns the flattened lsit\nprint(\"Printing the flattened list : \\n\",\n      flattenListRecursion(givenNestedList))"}
{"nl": "How to implement a stack which will support following operations in O(1) time complexity?\u00a0\n\n1) push() which adds an element to the top of stack.\u00a0\n2) pop() which removes an element from top of stack.\u00a0\n3) findMiddle() which will return middle element of the stack.\u00a0\n4) deleteMiddle() which will delete the middle element.\u00a0\nPush and pop are standard stack operations.\u00a0", "code": "''' Python3 Program to implement a stack\nthat supports findMiddle()\nand deleteMiddle in O(1) time '''\n\u00a0\n''' A Doubly Linked List Node '''\n\u00a0\n\u00a0\nclass DLLNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, d):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.prev = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = d\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next = None\n\u00a0\n\u00a0\n''' Representation of the stack\ndata structure that supports\nfindMiddle() in O(1) time. The\nStack is implemented using\nDoubly Linked List. It maintains\npointer to head node, pointer\nto middle node and count of\nnodes '''\n\u00a0\n\u00a0\nclass myStack:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.head = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.mid = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.count = 0\n\u00a0\n\u00a0\n''' Function to create the stack data structure '''\n\u00a0\n\u00a0\ndef createMyStack():\n\u00a0\u00a0\u00a0\u00a0ms = myStack()\n\u00a0\u00a0\u00a0\u00a0ms.count = 0\n\u00a0\u00a0\u00a0\u00a0return ms\n\u00a0\n\u00a0\n''' Function to push an element to the stack '''\n\u00a0\n\u00a0\ndef push(ms, new_data):\n\u00a0\u00a0\u00a0\u00a0''' allocate DLLNode and put in data '''\n\u00a0\u00a0\u00a0\u00a0new_DLLNode = DLLNode(new_data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' Since we are adding at the beginning,\n\u00a0\u00a0\u00a0\u00a0prev is always NULL '''\n\u00a0\u00a0\u00a0\u00a0new_DLLNode.prev = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' link the old list off the new DLLNode '''\n\u00a0\u00a0\u00a0\u00a0new_DLLNode.next = ms.head\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' Increment count of items in stack '''\n\u00a0\u00a0\u00a0\u00a0ms.count += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' Change mid pointer in two cases\n\u00a0\u00a0\u00a0\u00a01) Linked List is empty\n\u00a0\u00a0\u00a0\u00a02) Number of nodes in linked list is odd '''\n\u00a0\u00a0\u00a0\u00a0if(ms.count == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.mid = new_DLLNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.head.prev = new_DLLNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update mid if ms->count is odd\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if((ms.count % 2) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.mid = ms.mid.prev\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' move head to point to the new DLLNode '''\n\u00a0\u00a0\u00a0\u00a0ms.head = new_DLLNode\n\u00a0\n\u00a0\n''' Function to pop an element from stack '''\n\u00a0\n\u00a0\ndef pop(ms):\n\u00a0\u00a0\u00a0\u00a0''' Stack underflow '''\n\u00a0\u00a0\u00a0\u00a0if(ms.count == 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack is empty\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0head = ms.head\n\u00a0\u00a0\u00a0\u00a0item = head.data\n\u00a0\u00a0\u00a0\u00a0ms.head = head.next\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If linked list doesn't become empty,\n\u00a0\u00a0\u00a0\u00a0# update prev of new head as NULL\n\u00a0\u00a0\u00a0\u00a0if(ms.head != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.head.prev = None\n\u00a0\u00a0\u00a0\u00a0ms.count -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# update the mid pointer when\n\u00a0\u00a0\u00a0\u00a0# we have even number of elements\n\u00a0\u00a0\u00a0\u00a0# in the stack, i,e move down\n\u00a0\u00a0\u00a0\u00a0# the mid pointer.\n\u00a0\u00a0\u00a0\u00a0if(ms.count % 2 == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.mid = ms.mid.next\n\u00a0\u00a0\u00a0\u00a0return item\n\u00a0\n# Function for finding middle of the stack\n\u00a0\n\u00a0\ndef findMiddle(ms):\n\u00a0\u00a0\u00a0\u00a0if(ms.count == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack is empty now\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\u00a0\u00a0return ms.mid.data\n\u00a0\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ms = createMyStack()\n\u00a0\u00a0\u00a0\u00a0push(ms, 11)\n\u00a0\u00a0\u00a0\u00a0push(ms, 22)\n\u00a0\u00a0\u00a0\u00a0push(ms, 33)\n\u00a0\u00a0\u00a0\u00a0push(ms, 44)\n\u00a0\u00a0\u00a0\u00a0push(ms, 55)\n\u00a0\u00a0\u00a0\u00a0push(ms, 66)\n\u00a0\u00a0\u00a0\u00a0push(ms, 77)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Item popped is \" +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str(pop(ms)))\n\u00a0\u00a0\u00a0\u00a0print(\"Item popped is \" +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str(pop(ms)))\n\u00a0\u00a0\u00a0\u00a0print(\"Middle Element is \" +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str(findMiddle(ms)))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by rutvik_56.\n"}
{"nl": "Mubashir has a cat and a dog. He purchased both of them at the same time human_years ago.\nCreate a function which takes an argument of human_years and returns [human_years, cat_years, dog_years] list.\nHuman Years\nHuman Years >= 1\nHuman Years are whole numbers only.\nCat Years\n15 cat years for first year.\n+9 cat years for second year.\n+4 cat years for each year after that.\nDog Years\n15 dog years for first year\n+9 dog years for second year\n+5 dog years for each year after that\nExamples\ncalculate_years(1) \u279e [1, 15, 15]\n\ncalculate_years(2) \u279e [2, 24, 24]\n\ncalculate_years(10) \u279e [10, 56, 64]\nNotes\nN/A", "code": "def calculate_years(years):\n  return [\n    years,\n    15 + 9 * (years > 1) + 4 * (years > 2) * (years - 2),\n    15 + 9 * (years > 1) + 5 * (years > 2) * (years - 2),\n  ]"}
{"nl": "Threaded Binary Search Tree | Deletion", "code": "# Here 'par' is pointer to parent Node and 'ptr' is\n# pointer to current Node.\ndef caseB(root, par, ptr):\n\tchild = None;\n\n\t# Initialize child Node to be deleted has\n\t# left child.\n\tif (ptr.lthread == False):\n\t\tchild = ptr.left;\n\n\t# Node to be deleted has right child.\n\telse:\n\t\tchild = ptr.right;\n\n\t# Node to be deleted is root Node.\n\tif (par == None):\n\t\troot = child;\n\n\t# Node is left child of its parent.\n\telif(ptr == par.left):\n\t\tpar.left = child;\n\telse:\n\t\tpar.right = child;\n\n\t# Find successor and predecessor\n\ts = inSucc(ptr);\n\tp = inPred(ptr);\n\n\t# If ptr has left subtree.\n\tif (ptr.lthread == False):\n\t\tp.right = s;\n\n\t# If ptr has right subtree.\n\telse:\n\t\tif (ptr.rthread == False):\n\t\t\ts.left = p;\n\t\n\treturn root;\n\n# This code is contributed by umadevi9616"}
{"nl": "Create a function that takes an expression exp and an upper limit i as arguments and returns the sum of that expression up to the i'th term (recall sigma from math class).\nExamples\nsummation(\"n\", 10) \u279e 55\n\nsummation(\"1/n\", 50) \u279e 4.5\n\nsummation(\"n**n\", 6) \u279e 50069\nNotes\nAssume the lower limit is i = 1.\nRound your answer to the nearest tenth.", "code": "def summation(exp, i):\n  return round(sum(eval(exp) for n in range(1,i+1)),1)"}
{"nl": "Given an array of n positive integers. We are required to write a program to print the minimum product of k integers of the given array.\nExamples: \n \n\nInput : 198 76 544 123 154 675\n         k = 2\nOutput : 9348\nWe get minimum product after multiplying\n76 and 123.\n\nInput : 11 8 5 7 5 100\n        k = 4\nOutput : 1400", "code": "# Python3 program to find minimum\n# product of k elements in an array\nimport math\nimport heapq\n\ndef minProduct(arr, n, k):\n\n\theapq.heapify(arr)\n\tcount = 0\n\tans = 1\n\n\t# One by one extract\n\t# items from min heap\n\twhile ( arr ) and count < k:\n\t\tx = heapq.heappop(arr)\n\t\tans = ans * x\n\t\tcount = count + 1\n\t\n\treturn ans;\n\n# Driver method\narr = [198, 76, 544, 123, 154, 675]\nk = 2\nn = len(arr)\nprint (\"Minimum product is\",\n\tminProduct(arr, n, k))"}
{"nl": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\n\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\n\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\n\nYou must decrease the overall operation steps as much as possible.\n\n \n\nExample 1:\n\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\n\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n \n\nConstraints:\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums is guaranteed to be rotated at some pivot.\n-104 <= target <= 104\n \n\nFollow up: This problem is similar to Search in Rotated Sorted Array, but nums may contain duplicates. Would this affect the runtime complexity? How and why?", "code": "def search(self, nums, target):\n    l, r = 0, len(nums)-1\n    while l <= r:\n        mid = l + (r-l)//2\n        if nums[mid] == target:\n            return True\n        while l < mid and nums[l] == nums[mid]: # tricky part\n            l += 1\n        # the first half is ordered\n        if nums[l] <= nums[mid]:\n            # target is in the first half\n            if nums[l] <= target < nums[mid]:\n                r = mid - 1\n            else:\n                l = mid + 1\n        # the second half is ordered\n        else:\n            # target is in the second half\n            if nums[mid] < target <= nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n    return False"}
{"nl": "Instructions\nA Pythagorean triplet is a set of three natural numbers, {a, b, c}, for which,\n\na\u00b2 + b\u00b2 = c\u00b2\nand such that,\n\na < b < c\nFor example,\n\n3\u00b2 + 4\u00b2 = 9 + 16 = 25 = 5\u00b2.\nGiven an input integer N, find all Pythagorean triplets for which a + b + c = N.\n\nFor example, with N = 1000, there is exactly one Pythagorean triplet for which a + b + c = 1000: {200, 375, 425}.\n\nNOTE: The description above mentions mathematical sets, but also that a Pythagorean Triplet {a, b, c} must be ordered such that a < b < c (ascending order). This makes Python's set type unsuited to this exercise, since it is an inherently unordered container. Therefore please return a list of lists instead (i.e. [[a, b, c]]). You can generate the triplets themselves in whatever order you would like, as the enclosing list's order will be ignored in the tests.", "code": "def triplets_with_sum(number):\r\n    output_list = []\r\n    for a in range(1, 2 * number // 7 + 1):\r\n        denominator = 2 * (number - a)\r\n        numerator = 2 * a**2 - 2 * number * a + number**2\r\n        if denominator > 0 and numerator % denominator == 0:\r\n          c = numerator // denominator\r\n          output_list.append([a, number - a - c, c])\r\n    return output_list"}
{"nl": "Mubashir has written a mysterious function that takes two numbers a and b and returns multiplication?. Solve the riddle of what Mubashir's function is by having a look at some of the examples below.\n\nExamples\nmubashir_function(0, 1) \u279e 0\n\nmubashir_function(1, 2) \u279e 2\n\nmubashir_function(10, 10) \u279e 1", "code": "def mubashir_function(a, b):\n\treturn sum(map(int, str(a))) * sum(map(int, str(b)))"}
{"nl": "In the previous article, we have discussed Python Program to Print Series 0 2 6 12 20 30 42\u2026N\n Given a number N and the task is to find the sum of series (5^2+10^2+15^2+\u2026..N^2) till the given number N in Python.\n Examples:\n Example1:\n Input:\n Given Number (Limit) = 25\n Output:\n The above given series sum = 1375\n Example2:\n Input:\n Given Number (Limit) = 14\n Output:\n The above given series sum = 125", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the number N(limit) as static input and store it in a variable.\n \n gvn_numb = 25\n \n # Take a variable to say itr and initialize its value to 5.\n \n itr = 5\n \n # Take a variable to say rsltseries_summ and initialize its value to 0.\n \n rsltseries_summ = 0\n \n # Loop until the above-declared variable itr value is less than or equal to the\n \n # given number using the while loop.\n \n while(itr &lt;= gvn_numb):\n \n  # Calculate the value of itr raised to the power 2 (square) using the pow() function\n \n  # and store it in another variable.\n \n  k = pow(itr, 2)\n \n  # Add the above result to the rsltseries_summ and store it in the\n \n  # same variable.\n \n  rsltseries_summ += k\n \n  # Increment the above itr value by 5.\n \n  itr += 5\n \n print(\"The above given series sum = \", rsltseries_summ)\n \n </pre>"}
{"nl": "Given an array of 0s and 1s in random order. Segregate 0s on left side and 1s on right side of the array. Traverse array only once.", "code": "# Python3 program to sort an array with\r\n# two types of values in one traversal.\r\n\r\n# Method for segregation 0 and\r\n# 1 given input array\r\ndef segregate0and1(arr, n):\r\n\r\n\ttype0 = 0; type1 = n - 1\r\n\r\n\twhile (type0 < type1):\r\n\t\tif (arr[type0] == 1):\r\n\t\t\tarr[type0], arr[type1] = arr[type1], arr[type0]\r\n\t\t\ttype1 -= 1\r\n\t\t\r\n\t\telse:\r\n\t\t\ttype0 += 1\r\n\t\t\r\n# Driver Code\r\narr = [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1]\r\nn = len(arr)\r\nsegregate0and1(arr, n)\r\nfor i in range(0, n):\r\n\tprint(arr[i], end = \" \")\r\n\r\n# This code is contributed by Smitha Dinesh Semwal\r"}
{"nl": "Given a number, and the task is to check if the sum of even digits of a number is divisible by 4 and the sum of odd digits of a given number is divisible by 3.", "code": "# Give the number as static input and store it in a variable.\nnumb = 123452\n# Convert the given number to string using the str() function.\nstringnum = str(numb)\n# Create a list of digits say \"digtslst\" using map(),list(),int functions.\ndigtslst = list(map(int, stringnum))\n# Take a variable say \"evn_sum\" and initialize it with 0.\nevn_sum = 0\n# Take another variable say \"od_sum\" and initialize it with 0.\nod_sum = 0\n# Loop in the above list of digits until the length of the \"digtslst\" using the for loop.\nfor itr in range(len(digtslst)):\n    # Check if the element of the \"digtslst\" is even or not using the if conditional statement.\n    if(digtslst[itr] % 2 == 0):\n     # If the statement is true, then add the element of the \"digtslst\" to the \"evn_sum\"\n        # and store it in the same variable evn_sum.\n        evn_sum += digtslst[itr]\n    else:\n        # If the statement is false, then add the element of the \"digtslst\" to the \"od_sum\"\n        # and store it in the same variable od_sum.\n        od_sum += digtslst[itr]\n# Check if the evn_sum modulus 4 is equal to 0 and od_sum modulus 3 is equal to 0\n# using the if conditional statement.\nif(evn_sum % 4 == 0 and od_sum % 3 == 0):\n  # If the statement is true, print \"yes, the even digits sum and odd digits sum of a\n    # given number are divisible by 4 and 3 respectively.\n    print(\n        \"yes, the even digits sum and odd digits sum of a given number{\", numb, \"} is divisible by 4 and 3 respectively.\")\nelse:\n # If the statement is false, print \"No, the even digits sum and odd digits sum\n    # of a given number are not divisible by 4 and 3 respectively.\n    print(\n        \"No, the even digits sum and odd digits sum of a given number{\", numb, \"} is not divisible by 4 and 3 respectively.\")"}
{"nl": "Files In Python:\n\nA file is a piece of data or information stored on a computer\u2019s hard drive. You\u2019re already familiar with a variety of file kinds, including music, video, and text files. Manipulation of these files is trivial with Python. Text files and binary files are the two types of files that are commonly used. Binary files contain binary data that can only be read by a computer, whereas text files include plain text.\n\nFor programmers and automation testers, Python file handling (also known as File I/O) is a crucial topic. Working with files is required in order to write to or read data from them.\n\n\n\nIn addition, if you didn\u2019t know, I/O activities are the most expensive techniques via which software might fail. As a result, when implementing file processing for reporting or any other reason, you should proceed with caution. The construction of a high-performance application or a robust solution for automated software testing can benefit from optimizing a single file activity.\n\nGiven a file, the task is to print all words in the given file using python.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  print('The words in the given file : ')\n  for gvnfileline in givenfilecontent:\n  # Split the words of the line using the split() function and store them in a variable(it is of type list).\n  gvnfilewords = gvnfileline.split()\n  # Loop in the above list using another Nested For loop\n  # and print all the contents of the list using the print() function.\n  for words in gvnfilewords:\n  print(words)"}
{"nl": "List\r\nA list is a collection which is ordered and changeable.\r\n\r\nIn Python lists are written with square brackets.", "code": "thislist = [\"apple\", \"banana\", \"cherry\"]\r\nprint(thislist)"}
{"nl": "Python has three main types of data structures formed by smaller objects:\nLists, written with [] square brackets, such as [1, 2, 4, 8].\nTuples, written with () parentheses, such as (7, 8, 9).\nSets, written with{} curly brackets, such as {2, 3, 5, 7, 11, 13}.\nEach of these types has its own special properties and peculiarities that are worth knowing, but this challenge is only about transforming these data types into each other.\nThis can be done as in the following:\ntuple([1,2,4,8]) returns (1,2,4,8)\nlist({2,3,5,7,11}) returns [2, 3, 5, 7, 11, 13]\nset((1,2,4)) returns {1,2,4}\nGiven two data structures, data1 and data2, return data2 converted to the type of data1.\nExamples\nconvert([1, 2, 4, 8], (7, 8, 9)) \u279e [7, 8, 9]\n\nconvert((7, 8, 9), [1, 2, 4, 8]) \u279e (1, 2, 4, 8)\n\nconvert([1, 2, 4, 8], {2, 3, 5, 7, 11, 13}) \u279e [2, 3, 5, 7, 11, 13]\n\nconvert({2, 3, 5, 7, 11, 13}, [1, 2, 4, 8]) \u279e {8, 1, 2, 4}\nNotes\nYou might have noticed that the last example gives {8, 1, 2, 4} rather than{1, 2, 4, 8}. This has to do with the fact that in sets order doesn't matter, so that Python considers {8, 1, 2, 4} and {1, 2, 4, 8} to be the same set.\nIn the test cases you won't have to worry about orders: the answers will always have the order given by applying the list(), tuple(), set() functions.", "code": "def convert(data1, data2):\n  return type(data1)(data2)"}
{"nl": "Create a function that determines whether a string is a valid hex code.\nA hex code must begin with a pound key # and is exactly 6 characters in length. Each character must be a digit from 0-9 or an alphabetic character from A-F. All alphabetic characters may be uppercase or lowercase.\nExamples\nis_valid_hex_code(\"#CD5C5C\") \u279e True\n\nis_valid_hex_code(\"#EAECEE\") \u279e True\n\nis_valid_hex_code(\"#eaecee\") \u279e True\n\nis_valid_hex_code(\"#CD5C58C\") \u279e False\n# Length exceeds 6\n\nis_valid_hex_code(\"#CD5C5Z\") \u279e False\n# Not all alphabetic characters in A-F\n\nis_valid_hex_code(\"#CD5C&C\") \u279e False\n# Contains unacceptable character\n\nis_valid_hex_code(\"CD5C5C\") \u279e False\n# Missing #\nNotes\nN/A", "code": "import re\ndef is_valid_hex_code(txt):\n  return bool(re.match(r'#[A-Fa-f0-9]{6}$', txt))"}
{"nl": "Files in Python:\n\nPython, like many other programming languages, offers file handling and allows users to read and write files, as well as perform a variety of other file-related tasks. The concept of file handling has been extended to a variety of other languages, but the implementation is either complicated or lengthy. However, like most Python principles, this concept is simple and straightforward. Python processes file differently depending on whether they are text or binary, which is crucial. Each line of code consists of a series of characters that together constitute a text file. A specific character called the EOL or End of Line character, such as the comma, or a newline character is used to end each line in a file.\n\nGiven a file, the task is to read the given text file and print all the numbers present in the given text file.", "code": "filename = input('Enter the name of the given file : ')\n# In read mode, open the given file with the name 'filename'\nwith open(filename, 'r') as file:\n  # Using for loop, go over the lines in the sample file.\n  for line in file:\n  # Split the line into words using the split() function.\n  words = line.split()\n  # Traverse through the words using for loop.\n  for i in words:\n  # Traverse through all the characters of the word using another for loop.\n  for letter in i:\n  # Check to see if the letter is a digit, and if so, print it.\n  if(letter.isdigit()):\n  print(letter)"}
{"nl": "Write a function that reverses all the words in a sentence that start with a particular letter.\nExamples\nspecial_reverse(\"word searches are super fun\", \"s\")\n\u279e \"word sehcraes are repus fun\"\n\nspecial_reverse(\"first man to walk on the moon\", \"m\")\n\u279e \"first nam to walk on the noom\"\n\nspecial_reverse(\"peter piper picked pickled peppers\", \"p\")\n\u279e \"retep repip dekcip delkcip sreppep\"\nNotes\nReverse the words themselves, not the entire sentence.\nAll characters in the sentence will be in lower case.", "code": "def special_reverse(s, c):\n  return ' '.join(i[::-1] if i[0]==c else i for i in s.split())"}
{"nl": "Given the number of rows of the triangle, the task is to print Floyd\u2019s triangle in C, C++, and Python.", "code": "# Give the number of rows of the triangle as static input and store it in a variable.\ntriRows = 10\n# Take a variable and initialize it with 1 say sampNum.\nsampNum = 1\n# Loop from 1 to the number of rows of the triangle using For loop.\nfor m in range(1, triRows+1):\n  # Using another For loop, loop from 1 to the parent loop iterator value (Nested For loop).\n    for n in range(1, m+1):\n        # Inside the inner for loop print the sampNum with a space character.\n        print(sampNum, end=' ')\n        # Increase the value of sampNum by 1.\n        sampNum = sampNum+1\n    # Print the Newline Character after the end of the inner for loop.\n    print()"}
{"nl": "Given a string , the task is to reverse the given string in Python.", "code": "# given string\ngiven_string = \"vikram\"\n# calculating the length of string\nlength = len(given_string)\n# Reversing the string using slicing\nreverse_string = given_string[len(given_string)::-1]\n# print the reversed string\nprint(\"The reversed string of\", given_string, \"=\", reverse_string)"}
{"nl": "Given a binary tree, task is to find subtree with maximum sum in tree.\nExamples: \n \n\nInput :       1\n            /   \\\n           2      3\n          / \\    / \\\n         4   5  6   7\nOutput : 28\nAs all the tree elements are positive,\nthe largest subtree sum is equal to\nsum of all tree elements.\n\nInput :       1\n            /    \\\n          -2      3\n          / \\    /  \\\n         4   5  -6   2\nOutput : 7\nSubtree with largest sum is :  -2\n                             /  \\ \n                            4    5\nAlso, entire tree sum is also 7.", "code": "# Python3 program to find largest subtree\n# sum in a given binary tree.\n\n# Function to create new tree node.\nclass newNode:\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = self.right = None\n\n# Helper function to find largest\n# subtree sum recursively.\ndef findLargestSubtreeSumUtil(root, ans):\n\t\n\t# If current node is None then\n\t# return 0 to parent node.\n\tif (root == None):\n\t\treturn 0\n\t\n\t# Subtree sum rooted at current node.\n\tcurrSum = (root.key +\n\t\t\tfindLargestSubtreeSumUtil(root.left, ans) +\n\t\t\tfindLargestSubtreeSumUtil(root.right, ans))\n\n\t# Update answer if current subtree\n\t# sum is greater than answer so far.\n\tans[0] = max(ans[0], currSum)\n\n\t# Return current subtree sum to\n\t# its parent node.\n\treturn currSum\n\n# Function to find largest subtree sum.\ndef findLargestSubtreeSum(root):\n\t\n\t# If tree does not exist,\n\t# then answer is 0.\n\tif (root == None):\t\n\t\treturn 0\n\t\n\t# Variable to store maximum subtree sum.\n\tans = [-999999999999]\n\n\t# Call to recursive function to\n\t# find maximum subtree sum.\n\tfindLargestSubtreeSumUtil(root, ans)\n\n\treturn ans[0]\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t#\n\t#\t\t 1\n\t#\t\t / \\\n\t#\t /\t \\\n\t#\t -2\t 3\n\t#\t / \\\t / \\\n\t#\t / \\ / \\\n\t# 4\t 5 -6\t 2\n\troot = newNode(1)\n\troot.left = newNode(-2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(-6)\n\troot.right.right = newNode(2)\n\n\tprint(findLargestSubtreeSum(root))\n\n# This code is contributed by PranchalK"}
{"nl": "A regression problem is when the output variable is a real or continuous value, such as \u201csalary\u201d or \u201cweight\u201d. Many different models can be used, the simplest is linear regression. It tries to fit data with the best hyperplane which goes through the points.\n\nTypes of Regression:  \n\nLinear regression is used for predictive analysis. Linear regression is a linear approach for modelling the relationship between the criterion or the scalar response and the multiple predictors or explanatory variables. Linear regression focuses on the conditional probability distribution of the response given the values of the predictors. For linear regression, there is a danger of overfitting. The formula for linear regression is: Y\u2019 = bX + A.\n\nPolynomial regression is used for curvilinear data. Polynomial regression is fit with the method of least squares. The goal of regression analysis is to model the expected value of a dependent variable y in regards to the independent variable x. The equation for polynomial regression is: l = \\beta_{0}+\\beta_{0}x_{1}+\\epsilon  . \n\nStepwise regression is used for fitting regression models with predictive models. It is carried out automatically. With each step, the variable is added or subtracted from the set of explanatory variables. The approaches for stepwise regression are forward selection, backward elimination, and bidirectional elimination. The formula for stepwise regression is b_{j.std} = b_{j}(s_{x} * s_{y}^{-1})  . \n\nRidge regression is a technique for analyzing multiple regression data. When multicollinearity occurs, least squares estimates are unbiased. A degree of bias is added to the regression estimates, and as a result, ridge regression reduces the standard errors. The formula for ridge regression is \\beta = (X^{T}X + \\lambda * I)^{-1}X^{T}y  . \n\nLasso regression is a regression analysis method that performs both variable selection and regularization. Lasso regression uses soft thresholding. Lasso regression selects only a subset of the provided covariates for use in the final model. Lasso regression is N^{-1}\\sum^{N}_{i=1}f(x_{i}, y_{I}, \\alpha, \\beta)  .\n\nElasticNet regression is a regularized regression method that linearly combines the penalties of the lasso and ridge methods. ElasticNet regression is used for support vector machines, metric learning, and portfolio optimization.The penalty function is given by:||\\beta||_{1} = \\sum^{p}_{j=1}|\\beta_{j}|  .", "code": "\r\n# importing libraries\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom sklearn.linear_model import LinearRegression\r\n \r\nx = 11 * np.random.random((10, 1))\r\n \r\n# y = a * x + b\r\ny = 1.0 * x + 3.0\r\n \r\n# create a linear regression model\r\nmodel = LinearRegression()\r\nmodel.fit(x, y)\r\n \r\n# predict y from the data where the x is predicted from the x\r\nx_pred = np.linspace(0, 11, 100)\r\ny_pred = model.predict(x_pred[:, np.newaxis])\r\n \r\n# plot the results\r\nplt.figure(figsize =(3, 5))\r\nax = plt.axes()\r\nax.scatter(x, y)\r\n \r\nax.plot(x_pred, y_pred)\r\nax.set_xlabel('predictors')\r\nax.set_ylabel('criterion')\r\nax.axis('tight')\r\n \r\nplt.show()"}
{"nl": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\n\nFor example, the following two linked lists begin to intersect at node c1:\n\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\nNote that the linked lists must retain their original structure after the function returns.\n\nCustom Judge:\n\nThe inputs to the judge are given as follows (your program is not given these inputs):\n\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.", "code": "class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pA = headA\n        pB = headB\n\n        while pA != pB:\n            pA = headB if pA is None else pA.next\n            pB = headA if pB is None else pB.next\n\n        return pA\n        # Note: In the case lists do not intersect, the pointers for A and B\n        # will still line up in the 2nd iteration, just that here won't be\n        # a common node down the list and both will reach their respective ends\n        # at the same time. So pA will be NULL in that case."}
{"nl": "A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.\nGiven a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.\n \nExample 1:\n\nInput: n = \"32\"\nOutput: 3\nExplanation: 10 + 11 + 11 = 32\n\nExample 2:\n\nInput: n = \"82734\"\nOutput: 8\n\nExample 3:\n\nInput: n = \"27346209830709182346\"\nOutput: 9\n\n \nConstraints:\n\n1 <= n.length <= 105\nn consists of only digits.\nn does not contain any leading zeros and represents a positive integer.", "code": "def minPartitions(self, x):\n  return int(max(x))"}
{"nl": "Write a function that returns True if all integers in a list are factors of a number, and False otherwise.\nExamples\ncheck_factors([2, 3, 4], 12) \u279e True\n# Since 2, 3, and 4 are all factors of 12.\n\ncheck_factors([1, 2, 3, 8], 12) \u279e False\n# 8 is not a factor of 12.\n\ncheck_factors([1, 2, 50], 100) \u279e True\n\ncheck_factors([3, 6], 9) \u279e False\nNotes\nN/A", "code": "def check_factors(factors, num):\n  return all([num%i == 0 for i in factors])"}
{"nl": "You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\nReturn true if it is possible to form the array arr from pieces. Otherwise, return false.\n \nExample 1:\n\nInput: arr = [15,88], pieces = [[88],[15]]\nOutput: true\nExplanation: Concatenate [15] then [88]\n\nExample 2:\n\nInput: arr = [49,18,16], pieces = [[16,18,49]]\nOutput: false\nExplanation: Even though the numbers match, we cannot reorder pieces[0].\n\nExample 3:\n\nInput: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\nOutput: true\nExplanation: Concatenate [91] then [4,64] then [78]\n\n \nConstraints:\n\n1 <= pieces.length <= arr.length <= 100\nsum(pieces[i].length) == arr.length\n1 <= pieces[i].length <= arr.length\n1 <= arr[i], pieces[i][j] <= 100\nThe integers in arr are distinct.\nThe integers in pieces are distinct (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).", "code": "class Solution:\n  def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n  mp = {x[0]: x for x in pieces}\n  res = []\n  \n  for num in arr:\n  res += mp.get(num, [])\n  \n  return res == arr"}
{"nl": "We will be given a decimal number and the python program to convert the given decimal number into an equivalent binary number.", "code": "# Python program to convert decimal to binary # take input num = int(input('Enter any decimal number: ')) # display result print('Binary value:', bin(num))"}
{"nl": "Given the root of a binary search tree and K as input, find Kth smallest element in BST.\u00a0\n\n\nFor example, in the following BST, if k = 3, then the output should be 10, and if k = 5, then the output should be 14.", "code": "# A simple inorder traversal based Python3\n# program to find k-th smallest element\n# in a BST.\n\u00a0\n# A BST node\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Recursive function to insert an key into BST\ndef insert(root, x):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(x)\n\u00a0\u00a0\u00a0\u00a0if (x < root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, x)\n\u00a0\u00a0\u00a0\u00a0elif (x > root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, x)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# Function to find k'th largest element\n# in BST. Here count denotes the number\n# of nodes processed so far\ndef kthSmallest(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0global k\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Search in left subtree\n\u00a0\u00a0\u00a0\u00a0left = kthSmallest(root.left)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If k'th smallest is found in\n\u00a0\u00a0\u00a0\u00a0# left subtree, return it\n\u00a0\u00a0\u00a0\u00a0if (left != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If current element is k'th\n\u00a0\u00a0\u00a0\u00a0# smallest, return it\n\u00a0\u00a0\u00a0\u00a0k -= 1\n\u00a0\u00a0\u00a0\u00a0if (k == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Else search in right subtree\n\u00a0\u00a0\u00a0\u00a0return kthSmallest(root.right)\n\u00a0\n# Function to find k'th largest element in BST\ndef printKthSmallest(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Maintain index to count number\n\u00a0\u00a0\u00a0\u00a0# of nodes processed so far\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0res = kthSmallest(root)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (res == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"There are less than k nodes in the BST\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"K-th Smallest Element is \", res.data)\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0keys = [ 20, 8, 22, 4, 12, 10, 14 ]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for x in keys:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = insert(root, x)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0k = 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0printKthSmallest(root)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Solve the zebra puzzle.\n\nThere are five houses.\nThe Englishman lives in the red house.\nThe Spaniard owns the dog.\nCoffee is drunk in the green house.\nThe Ukrainian drinks tea.\nThe green house is immediately to the right of the ivory house.\nThe Old Gold smoker owns snails.\nKools are smoked in the yellow house.\nMilk is drunk in the middle house.\nThe Norwegian lives in the first house.\nThe man who smokes Chesterfields lives in the house next to the man with the fox.\nKools are smoked in the house next to the house where the horse is kept.\nThe Lucky Strike smoker drinks orange juice.\nThe Japanese smokes Parliaments.\nThe Norwegian lives next to the blue house.\nEach of the five houses is painted a different color, and their inhabitants are of different national extractions, own different pets, drink different beverages and smoke different brands of cigarettes.\n\nWhich of the residents drinks water? Who owns the zebra?", "code": "import itertools\nppl = 'Norwegian Englishman Ukrainian Spaniard Japanese'.split()\ndef drinks_water():\n    x,_ = solve()\n    return ppl[x]\ndef owns_zebra():\n    _,x = solve()\n    return ppl[x]\ndef solve():\n    g = ((water, zebra)\n        for (red, green, ivory, yellow, blue) in itertools.permutations(range(5))\n        if green - ivory == 1\n        for (norway, english, ukraine, spain, japan) in itertools.permutations(range(5))\n        if norway == 0\n        if english == red\n        for (dog, fox, snails, horse, zebra) in itertools.permutations(range(5))\n        if spain == dog\n        for (coffee, tea, milk, orange, water) in itertools.permutations(range(5))\n        if coffee == green\n        if ukraine == tea\n        if milk == 2\n        for (oldgold, kools, chesterfields, luckystrike, parliaments) in itertools.permutations(range(5))\n        if oldgold == snails\n        if kools == yellow\n        if abs(chesterfields - fox) == 1\n        if abs(kools - horse) == 1\n        if luckystrike == orange\n        if parliaments == japan\n        if abs(norway - blue) == 1\n        )\n    return next(g)"}
{"nl": "A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and the top-right cell at (width - 1, height - 1). The grid is aligned with the four cardinal directions (\"North\", \"East\", \"South\", and \"West\"). A robot is initially at cell (0, 0) facing direction \"East\".\n\nThe robot can be instructed to move for a specific number of steps. For each step, it does the following.\n\nAttempts to move forward one cell in the direction it is facing.\nIf the cell the robot is moving to is out of bounds, the robot instead turns 90 degrees counterclockwise and retries the step.\nAfter the robot finishes moving the number of steps required, it stops and awaits the next instruction.\n\nImplement the Robot class:\n\nRobot(int width, int height) Initializes the width x height grid with the robot at (0, 0) facing \"East\".\nvoid step(int num) Instructs the robot to move forward num steps.\nint[] getPos() Returns the current cell the robot is at, as an array of length 2, [x, y].\nString getDir() Returns the current direction of the robot, \"North\", \"East\", \"South\", or \"West\".", "code": "class Robot:\n\n    def __init__(self, width: int, height: int):\n        self.direction = \"East\"  # Faces East at the start\n        self.position = [0, 0]  # Is at position (0,0) on the board at the start\n        self.moved = False # Had to add this so if we're at 0,0 and we moved, we're facing south and not East\n        \n    def step(self, num: int) -> None:\n\n        dictio = {\n            \"South\": (-1, 0),\n            \"East\": (0, 1),\n            \"North\": (1, 0),\n            \"West\": (0, -1)\n        }\n\n        horizontal = len(self.board[0]) # Width of the board\n        vertical = len(self.board) # Height of the board\n\n        steps = num % (horizontal * 2 + vertical * 2 - 4) # 1 complete lap is 2 times the width + 2 times the height - 4 (-4 because we don't wanna count every corners twice for one lap)\n        self.moved = True\n        while steps > 0: # We'll now do the steps that will actually move the robot from its position\n            if 0 <= self.position[0] + dictio.get(self.direction)[0] < vertical and 0 <= self.position[1] + dictio.get(self.direction)[1] < horizontal:\n                self.position[0] += dictio.get(self.direction)[0]\n                self.position[1] += dictio.get(self.direction)[1]\n                steps -= 1\n\n                if steps == 0:\n                    break\n            else:\n                # Change direction of the robot since we can't move anymore in that direction (out of bounds)\n                if self.direction != \"West\": # If it's not west, we just wanna get the next one\n                    new_direction = list(dictio.keys())[list(dictio.keys()).index(self.direction) + 1]  # Get the following direction from the dict\n                else: # If it's West, just change our direction to South\n                    new_direction = \"South\"\n                self.direction = new_direction\n\n\n\n\n    def getPos(self):\n        return self.position[::-1]\n\n    def getDir(self):\n        if self.moved and self.position[0] == 0 and self.position[1] == 0:\n            self.direction = \"South\"\n            return self.direction\n        else:\n            return self.direction"}
{"nl": "Create a function that converts Celsius to Fahrenheit and vice versa.\nExamples\nconvert(\"35*C\") \u279e \"95*F\"\n\nconvert(\"19*F\") \u279e \"-7*C\"\n\nconvert(\"33\") \u279e \"Error\"\nNotes\nRound to the nearest integer.\nIf the input is incorrect, return \"Error\".\nFor the formulae to convert back and forth, check the Resources tab.", "code": "def convert(deg):\n    try:\n      temp, unit = deg.split('*')\n    except:\n      return 'Error'\n        if unit == 'F':\n      return str(round((int(temp) - 32) / 1.8)) + '*' + 'C'\n          if unit == 'C':\n      return str(round((int(temp) * 1.8) + 32)) + '*' + 'F'"}
{"nl": "There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.\n\nIn one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.\n\nGiven a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.\n\n ", "code": "class Solution:\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\n        \n        @functools.lru_cache(None)\n        def dp(i, k):\n            if k == 0 or i == 0:\n                return 0\n            \n            max_value, curr_pile, curr_sum = dp(i - 1, k), piles[i - 1], 0\n            for j in range(min(len(curr_pile), k)):\n                curr_sum += curr_pile[j]\n                max_value = max(max_value, curr_sum + dp(i - 1, k - j - 1))\n            return max_value\n\n        # dp(i, k) means max value for first i piles with k coins\n        return dp(len(piles), k)"}
{"nl": "Check if a Binary Tree (not BST) has duplicate values\nExamples: \n \n\nInput : Root of below tree\n         1\n       /   \\\n      2     3\n             \\\n              2\nOutput : Yes\nExplanation : The duplicate value is 2.\n\nInput : Root of below tree\n         1\n       /   \\\n     20     3\n             \\\n              4\nOutput : No\nExplanation : There are no duplicates.", "code": "\"\"\" Program to check duplicates\n# in Binary Tree \"\"\"\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pointers.\t\t\t\t\t\t\t\t\nclass newNode:\n\n\t# Construct to create a new node\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\ndef checkDupUtil( root, s) :\n\n\t# If tree is empty, there are no\n\t# duplicates.\n\tif (root == None) :\n\t\treturn False\n\n\t# If current node's data is already present.\n\tif root.data in s:\n\t\treturn True\n\n\t# Insert current node\n\ts.add(root.data)\n\t\n\t# Recursively check in left and right\n\t# subtrees.\n\treturn checkDupUtil(root.left, s) or checkDupUtil(root.right, s)\n\n\n# To check if tree has duplicates\ndef checkDup( root) :\n\n\ts=set()\n\treturn checkDupUtil(root, s)\n\n\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(2)\n\troot.left.left = newNode(3)\n\tif (checkDup(root)):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Instructions\r\nDetermine if a word or phrase is an isogram.\r\n\r\nAn isogram (also known as a \"non-pattern word\") is a word or phrase without a repeating letter, however spaces and hyphens are allowed to appear multiple times.\r\n\r\nExamples of isograms:\r\n\r\nlumberjacks\r\nbackground\r\ndownstream\r\nsix-year-old\r\nThe word isograms, however, is not an isogram, because the s repeats.\r\n\r", "code": "def is_isogram(string: str) -> bool:\r\n    letters = set()\r\n    for c in (c.lower() for c in string if c.isalpha()):\r\n        if c in letters:\r\n            return False\r\n        letters.add(c)\r\n    return True"}
{"nl": "Given the lower limit range and upper limit range, the task is to print all Co-binary Palindromic Numbers in the given range in Python.\n Co-binary Palindromic Numbers:\n A co-binary palindrome is a number that is a palindrome both as a decimal number and after being binary transformed.\n Examples:\n Example1:\n Input:\n Given upper limit range =11\n \n Given lower limit range =2426\n Output:\n The Co-binary palindrome numbers in the given range 11 and 2426 are:\n \n 33 99 313 585 717\n Example2:\n Input:\n Given upper limit range =5\n \n Given lower limit range =12564\n Output:\n The Co-binary palindrome numbers in the given range 5 and 12564 are:\n \n 5 7 9 33 99 313 585 717 7447 9009", "code": "# Create a function checkpalindromicNumb() which accepts the string as an argument and\n \n # returns true if the string is palindrome else it returns False.\n \n def checkpalindromicNumb(val):\n \n  return val == val[::-1]\n \n # Create a function convertBinar() which converts the given number to binary and returns it.\n \n def convertBinar(orinumb):\n \n  return bin(orinumb)[2:]\n \n # Give the lower limit range as static input and store it in a variable.\n \n lowlimrange = 11\n \n # Give the upper limit range as static input and store it in another variable.\n \n upplimrange = 2426\n \n print('The Co-binary palindrome numbers in the given range',\n \n  lowlimrange, 'and', upplimrange, 'are:')\n \n # Loop from lower limit range to upper limit range using For loop.\n \n for itervalu in range(lowlimrange, upplimrange+1):\n \n  # Convert this iterator value to binary by passing it as an argument\n \n  # to convertBinar() function and store it in a variable say binarystrng.\n \n  binarystrng = convertBinar(itervalu)\n \n  # Convert this iterator value to a string\n \n  # using the str() function say strngnumb.\n \n  strngnumb = str(itervalu)\n \n  # Check if the strngnumb is palindrome or not by giving the given strngnumb\n \n  # as an argument to checkpalindromicNumb().\n \n  # Check if the binarystrng is palindrome or not by giving the given binarystrng\n \n  # as an argument to checkpalindromicNumb().\n \n  # Check if both statements are true using the and operator and If conditional Statement.\n \n  if(checkpalindromicNumb(binarystrng) and checkpalindromicNumb(strngnumb)):\n \n  # If it is true then print it.\n \n  print(strngnumb, end=' ')\n \n </pre>"}
{"nl": "Write a function which takes a list of numbers and returns a list of tuples that is a subset of product of the list with itself and first member of each tuple is less than or equall to the second one.\nIn mathematical terms:\nA x A = {(x,y)| x\u2208A and y\u2208A}\n\n{(x,y)| x>=y, (x,y) \u2208 A x A }\nExamples\nrelation_list([0, 1, 2, 3]) \u279e [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3)]\n\nrelation_lst([858, 544, 164]) \u279e [(164, 164), (164, 544), (164, 858), (544, 544), (544, 858), (858, 858)]\n\nrelation_lst([-1]) \u279e [(-1, -1)]\n\nrelation_lst([0]) \u279e [(0, 0)]\n\nrelation_lst([]), []\nNotes\nThe result should be in ascending order.", "code": "def relation_lst(lst):\n    return sorted([(x,y) for x in lst for y in lst if x <= y])"}
{"nl": "Create a function that takes a list with temperature type, temperature, and a second temperature type. The temperature types can be Celsius, Fahrenheit, or Kelvin. Return the temperature type (in the list) converted into the second temperature type.\nExamples\nconverter([\"fahrenheit\", 3] , \"kelvin\") \u279e 257.0\n\nconverter([\"celsius\", 10] , \"fahrenheit\") \u279e 50.0\n\nconverter([\"celsius\", 20] , \"kelvin\") \u279e 293.1\nNotes\nRound to one decimal place.", "code": "def converter(a, b):\n    a, t = a\n    d = {('celsius', 'kelvin'): t + 273.15, \n         ('celsius', 'fahrenheit'): t * 9/5 + 32, \n         ('fahrenheit', 'celsius'): (t - 32) * 5/9, \n         ('fahrenheit', 'kelvin'): (t + 459.67) * 5/9, \n         ('kelvin', 'celsius'): t - 273.15, \n         ('kelvin', 'fahrenheit'): t * 9/5 - 459.67}\n    return round(d[(a, b)], 1)"}
{"nl": "Goods and Services Tax (GST):\n\nGST is an abbreviation for Goods and Services Tax. It is a value-added tax levied on goods and services sold for domestic use or consumption. Customers pay GST to the government when they buy goods and services.\n\n\n\nTo calculate the GST percentage, first, compute the net GST amount by subtracting the original price from the net price that includes the GST. We will use the GST percent formula after calculating the net GST amount.\n\nFormula:\n\nGST% formula = ((GST Amount * 100)/Original price)\n\nNet price  = Original price + GST amount\n\nGST amount  = Net price \u2013 Original price\n\nGST%  = ((GST amount * 100)/Original price)\n\nround() function: round function rounds off to the nearest integer value.\n\n\n\nGiven the Net price, the original price, and the task is to calculate the GST percentage.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven original price = 520\nGiven Net price  = 650\nOutput:\n\nThe GST percent for the above given input net and original prices =  25.0%\nExample 2:\n\nInput:\n\nGiven original price = 354.80\nGiven Net price  = 582.5\nOutput:\n\nThe GST percent for the above given input net and original prices =  64.17700112739571%", "code": "# Give the original price as static input and store it in a variable.\n gvn_Orignl_amt = 520\n # Give the net price as static input and store it in another variable.\n gvn_Net_amt = 650\n # Calculate the GST amount by using the above given formula and store it in\n # another variable.\n GST_amnt = gvn_Net_amt - gvn_Orignl_amt\n # Calculate the given GST percentage by using the above given formula and\n # store it in another variable.\n gvn_GST_percnt = ((GST_amnt * 100) / gvn_Orignl_amt)\n # Print the given GST value for the above given original and net prices.\n print(\"The GST percent for the above given input net and original prices = \",\n  gvn_GST_percnt, end='')\n print(\"%\")"}
{"nl": "Definition and Usage\r\nThe isatty() method returns True if the file stream is interactive, example: connected to a terminal device.\r\n\r\n", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.isatty())"}
{"nl": "You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].\n\nThe array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.\n\nFor example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:\nIf question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.\nIf instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.\nReturn the maximum points you can earn for the exam.", "code": "class Solution:\n    def mostPoints(self, questions: List[List[int]]) -> int:\n        dp = {}\n        \n        def helper(i):\n            if i >= len(questions):\n                return 0\n            \n            if i in dp:\n                return dp[i]\n            \n            points, power = questions[i]\n            dp[i] = max(helper(i + 1), helper(i + 1 + power) + points)\n            return dp[i]\n        \n        return helper(0)"}
{"nl": "Write a program to find the smallest of three integers, without using any of the comparison operators. \nLet 3 input numbers be x, y and z.", "code": "# Python3 program to find Smallest\n# of three integers without\n# comparison operators\n\ndef smallest(x, y, z):\n\tc = 0\n\t\n\twhile ( x and y and z ):\n\t\tx = x-1\n\t\ty = y-1\n\t\tz = z-1\n\t\tc = c + 1\n\n\treturn c\n\n# Driver Code\nx = 12\ny = 15\nz = 5\nprint(\"Minimum of 3 numbers is\",\n\tsmallest(x, y, z))\n\n# This code is contributed by Anshika Goyal\n"}
{"nl": "Mubashir is getting old but he wants to celebrate his 20th or 21st birthday only. It is possible with some basic maths skills. He just needs to select the correct number base with your help!\nFor example, if his current age is 22, that's exactly 20 - in base 11. Similarly, 65 is exactly 21 - in base 32 and so on.\nCreate a function that takes his current age and returns the given age 20 (or 21) years, with number base in the format specified in the below examples.\nExamples\nhappy_birthday(22) \u279e \"Mubashir is just 20, in base 11!\"\n\nhappy_birthday(65) \u279e \"Mubashir is just 21, in base 32!\"\n\nhappy_birthday(83) \u279e \"Mubashir is just 21, in base 41!\"\nNotes\nGiven age will always be greater than 21.", "code": "def happy_birthday(age):\n  return \"Mubashir is just {}, in base {}!\".format(20 + age%2, age//2)"}
{"nl": "Write a Python program to print downward triangle mirrored alphabets pattern using for loop.\n\n", "code": "rows = int(input(\"Enter Downward Triangle Mirrored Alphabets Rows = \"))\n\nprint(\"====Downward Triangle of Mirrored Alphabets Pattern====\")\nalphabet = 65\n\nfor i in range(rows):\n    for j in range(i, rows):\n        print('%c' %(alphabet + j), end = ' ')\n    for k in range(rows - 2, i - 1, -1):\n        print('%c' %(alphabet + k), end = ' ')       \n    print()"}
{"nl": "Mubashir needs your help in a simple task.\nGiven a list of integers lst and an integer k, find the lowest positive integer x so that exactly k elements of the given list are less than or equal to x. Return None if the condition does not match.\nSee below examples for a better understanding:\nExamples\nless_or_equal([3, 7, 6, 1, 10, 3, 20], 4) \u279e 6\n# 1, 3, 3, 6 = 4 elements\n# All elements are less than or equal to 6\n\nless_or_equal([3, 7, 6, 1, 10, 3, 20], 2) \u279e None\n# 1, 3 = 2 elements\n# Not possible to return 3 because we have another 3 in the list\n\nless_or_equal([3, 7, 5, 1, 10, 3, 20], 4) \u279e 5\n# 1, 3, 3, 5 = 4 elements\n# All elements are less than or equal to 5\n\nless_or_equal([10, 15, 20, 25], 0) \u279e 1\n# k = 0\nNotes\nAll numbers of the given list and k will be \u2265 0.\nUnderstanding the description of this challenge is the hardest part.", "code": "def less_or_equal(lst, k):\n    r = [1] + sorted(lst)    \n    return r[k] if len(lst) == k or r[k] != r[k + 1] else None"}
{"nl": "Given an n x n square matrix, find sum of all sub-squares of size k x k", "code": "# A simple Python 3 program to find sum\n# of all subsquares of size k x k\n \n# Size of given matrix\nn = 5\n \n# A simple function to find sum of all\n# sub-squares of size k x k in a given\n# square matrix of size n x n\ndef printSumSimple(mat, k):\n \n    # k must be smaller than or equal to n\n    if (k > n):\n        return\n \n    # row number of first cell in current\n    # sub-square of size k x k\n    for i in range(n - k + 1):\n     \n        # column of first cell in current\n        # sub-square of size k x k\n        for j in range(n - k + 1):\n             \n            # Calculate and print sum of\n            # current sub-square\n            sum = 0\n            for p in range(i, k + i):\n                for q in range(j, k + j):\n                    sum += mat[p][q]\n            print(sum, end = \" \")\n     \n        # Line separator for sub-squares\n        # starting with next row\n        print()\n \n# Driver Code\nif __name__ == \"__main__\":\n \n    mat = [[1, 1, 1, 1, 1],\n           [2, 2, 2, 2, 2],\n           [3, 3, 3, 3, 3],\n           [4, 4, 4, 4, 4],\n           [5, 5, 5, 5, 5]]\n    k = 3\n    printSumSimple(mat, k)\n \n# This code is contributed by ita_c"}
{"nl": "Most beginners in Machine Learning start with learning Supervised Learning techniques such as classification and regression. However, one of the most important paradigms in Machine Learning is Reinforcement Learning (RL) which is able to tackle many challenging tasks. It is an aspect of Machine learning where an agent learns to behave in an environment, by performing certain actions and observing the rewards(results) which it gets from those actions.\r\n\r\nIn Reinforcement Learning, we give the machines a few inputs and actions, and then, reward them based on the output. Reward maximization is the end goal. It is just like a little baby who knows nothing at first is left alone in an environment and then after a little understanding tends to know things around itself.", "code": "\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n  \r\n# specifying the size for each and \r\n# every matplotlib plot globally\r\nplt.rcParams['figure.figsize'] = [8, 6] \r\n  \r\n# defining list objects with range of the graph\r\nx1_range = [-100, 100]\r\nx2_range = [-100, 100]\r\n  \r\n# empty list object to store the population\r\npopulation = []\r\n  \r\n# this function is used to generate the population\r\n# and appending it to the population list defined above\r\n# it takes the attributes as no. of features in a \r\n# population and size that we have in it\r\ndef populate(features, size = 1000):\r\n      \r\n    # here we are defining the coordinate \r\n    # for each entity in a population\r\n    initial = [] \r\n      \r\n    for _ in range(size):\r\n        entity = []\r\n        for feature in features:\r\n              \r\n            # this * feature variable unpacks a list \r\n            # or tuple into position arguments.\r\n            val = np.random.randint(*feature)\r\n            entity.append(val)\r\n        initial.append(entity)\r\n      \r\n    return np.array(initial)\r\n  \r\n# defining the virus in the form of numpy array\r\nvirus = np.array([5, 5])\r\n  \r\n# only the 100 fit ones will survive in this one\r\ndef fitness(population, virus, size = 100):\r\n      \r\n    scores = []\r\n      \r\n    # enumerate also provides the index as for the iterator\r\n    for index, entity in enumerate(population): \r\n        score = np.sum((entity-virus)**2)\r\n        scores.append((score, index))\r\n      \r\n    scores = sorted(scores)[:size]\r\n      \r\n    return np.array(scores)[:, 1]\r\n  \r\n# this function is used to plot the graph\r\ndef draw(population, virus):\r\n    plt.xlim((-100, 100))\r\n    plt.ylim((-100, 100))\r\n    plt.scatter(population[:, 0], population[:, 1], c ='green', s = 12)\r\n    plt.scatter(virus[0], virus[1], c ='red', s = 60) \r\n      \r\n      \r\ndef reduction(population, virus, size = 100):\r\n      \r\n    # only the index of the fittest ones\r\n    # is returned in sorted format\r\n    fittest = fitness(population, virus, size) \r\n  \r\n    new_pop = []\r\n      \r\n    for item in fittest:\r\n        new_pop.append(population[item])\r\n          \r\n    return np.array(new_pop)\r\n  \r\n# cross mutation in order to generate the next generation\r\n# of the population which will be more immune to virus than previous\r\ndef cross(population, size = 1000):\r\n      \r\n    new_pop = []\r\n      \r\n    for _ in range(size):\r\n        p = population[np.random.randint(0, len(population))]\r\n        m = population[np.random.randint(0, len(population))]\r\n      \r\n        # we are only considering half of each \r\n        # without considering random selection\r\n        entity = []\r\n        entity.append(*p[:len(p)//2])\r\n        entity.append(*m[len(m)//2:])\r\n          \r\n        new_pop.append(entity)\r\n      \r\n    return np.array(new_pop)\r\n  \r\n# generating and adding the random features to\r\n# the entity so that it looks more distributed\r\ndef mutate(population):\r\n      \r\n    return population + np.random.randint(-10, 10, 2000).reshape(1000, 2)\r\n  \r\n  \r\n# the complete cycle of the above steps\r\npopulation = populate([x1_range, x2_range], 1000)\r\n  \r\n# gens is the number of generation\r\ndef cycle(population, virus, gens = 1): \r\n      \r\n    # if we change the value of gens, we'll get \r\n    # next and genetically more powerful generation\r\n    # of the population\r\n    for _ in range(gens):\r\n        population = reduction(population, virus, 100)\r\n        population = cross(population, 1000)\r\n        population = mutate(population)\r\n          \r\n    return population\r\n  \r\npopulation = cycle(population, virus)\r\n  \r\ndraw(population, virus)"}
{"nl": "A graph is a data structure that consists of the following two components: \r\n1. A finite set of vertices also called as nodes. \r\n2. A finite set of ordered pair of the form (u, v) called as edge. The pair is ordered because (u, v) is not the same as (v, u) in case of a directed graph(di-graph). The pair of the form (u, v) indicates that there is an edge from vertex u to vertex v. The edges may contain weight/value/cost.", "code": "\"\"\"\r\nA Python program to demonstrate the adjacency\r\nlist representation of the graph\r\n\"\"\"\r\n \r\n# A class to represent the adjacency list of the node\r\n \r\n \r\nclass AdjNode:\r\n    def __init__(self, data):\r\n        self.vertex = data\r\n        self.next = None\r\n \r\n \r\n# A class to represent a graph. A graph\r\n# is the list of the adjacency lists.\r\n# Size of the array will be the no. of the\r\n# vertices \"V\"\r\nclass Graph:\r\n    def __init__(self, vertices):\r\n        self.V = vertices\r\n        self.graph = [None] * self.V\r\n \r\n    # Function to add an edge in an undirected graph\r\n    def add_edge(self, src, dest):\r\n        # Adding the node to the source node\r\n        node = AdjNode(dest)\r\n        node.next = self.graph[src]\r\n        self.graph[src] = node\r\n \r\n        # Adding the source node to the destination as\r\n        # it is the undirected graph\r\n        node = AdjNode(src)\r\n        node.next = self.graph[dest]\r\n        self.graph[dest] = node\r\n \r\n    # Function to print the graph\r\n    def print_graph(self):\r\n        for i in range(self.V):\r\n            print(\"Adjacency list of vertex {}\\n head\".format(i), end=\"\")\r\n            temp = self.graph[i]\r\n            while temp:\r\n                print(\" -> {}\".format(temp.vertex), end=\"\")\r\n                temp = temp.next\r\n            print(\" \\n\")\r\n \r\n \r\n# Driver program to the above graph class\r\nif __name__ == \"__main__\":\r\n    V = 5\r\n    graph = Graph(V)\r\n    graph.add_edge(0, 1)\r\n    graph.add_edge(0, 4)\r\n    graph.add_edge(1, 2)\r\n    graph.add_edge(1, 3)\r\n    graph.add_edge(1, 4)\r\n    graph.add_edge(2, 3)\r\n    graph.add_edge(3, 4)\r\n \r\n    graph.print_graph()\r\n \r\n# This code is contributed by Kanav Malhotra\r"}
{"nl": "You are given two 0-indexed integer arrays servers and tasks of lengths n\u200b\u200b\u200b\u200b\u200b\u200b and m\u200b\u200b\u200b\u200b\u200b\u200b respectively. servers[i] is the weight of the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b server, and tasks[j] is the time needed to process the j\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b task in seconds.\n\nTasks are assigned to the servers using a task queue. Initially, all servers are free, and the queue is empty.\n\nAt second j, the jth task is inserted into the queue (starting with the 0th task being inserted at second 0). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the smallest weight, and in case of a tie, it is assigned to a free server with the smallest index.\n\nIf there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\n\nA server that is assigned task j at second t will be free again at second t + tasks[j].\n\nBuild an array ans\u200b\u200b\u200b\u200b of length m, where ans[j] is the index of the server the j\u200b\u200b\u200b\u200b\u200b\u200bth task will be assigned to.\n\nReturn the array ans\u200b\u200b\u200b\u200b.", "code": "class Solution:\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\n        time=0\n        heap=[(weight,index) for index,weight in enumerate(servers)]\n        heapq.heapify(heap)\n        task_pointer=0\n        processing=[]\n        assingment=[-1 for task in tasks]\n        last_task=len(tasks)-1\n        \n        while task_pointer<=last_task:\n            while processing and processing[0][0]<=time:\n                time_freed,weight,server_index=heapq.heappop(processing)\n                heapq.heappush(heap,(weight,server_index))\n            while heap and task_pointer<=min(time,last_task):\n                weight,server_index=heapq.heappop(heap)\n                assingment[task_pointer]=server_index\n                heapq.heappush(processing,(time+tasks[task_pointer],weight,server_index))\n                task_pointer+=1\n            if heap:\n                time+=1\n            else:\n                time=processing[0][0]\n        \n        return assingment"}
{"nl": "Program for Set clear() Method in Python. The set clear function allows you to clear or remove all of the items in a given set.", "code": "# Give the set as static input and initialize it with some random values.\n# Store it in a variable.\ngven_set = {'hello', 'this', 'is', 'btechgeeks'}\n# Print the above-given set.\nprint(\"The given set is :\")\nprint(gven_set)\n# Clear the values of the given set by applying clear() function to the given set.\ngven_set.clear()\n# Print the above-given set after clearing all the values.\nprint(\"The given set after clearing all the values :\")\nprint(gven_set)"}
{"nl": "Write a function that returns the extended form of the prime factorization of a number. Return in the format [a, b, c, d, ...], where each element of the list is an integer.\nExamples\nprime_factorization(216) \u279e [2, 2, 2, 3, 3, 3]\n\nprime_factorization(64) \u279e [2, 2, 2, 2, 2, 2]\n\nprime_factorization(23) \u279e [23]\nNotes\nN/A", "code": "def prime_factorization(n):\n  i, fact = 2, []\n  while n>1:\n    while n%i==0:\n      fact+= [i]\n      n//= i\n    i+= 1\n  return fact"}
{"nl": "You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.\nYou would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:\n\n2 digits: A single block of length 2.\n3 digits: A single block of length 3.\n4 digits: Two blocks of length 2 each.\n\nThe blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.\nReturn the phone number after formatting.\n \nExample 1:\n\nInput: number = \"1-23-45 6\"\nOutput: \"123-456\"\nExplanation: The digits are \"123456\".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\nStep 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456\".\nJoining the blocks gives \"123-456\".\n\nExample 2:\n\nInput: number = \"123 4-567\"\nOutput: \"123-45-67\"\nExplanation: The digits are \"1234567\".\nStep 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\".\nStep 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45\" and \"67\".\nJoining the blocks gives \"123-45-67\".\n\nExample 3:\n\nInput: number = \"123 4-5678\"\nOutput: \"123-456-78\"\nExplanation: The digits are \"12345678\".\nStep 1: The 1st block is \"123\".\nStep 2: The 2nd block is \"456\".\nStep 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78\".\nJoining the blocks gives \"123-456-78\".\n\n \nConstraints:\n\n2 <= number.length <= 100\nnumber consists of digits and the characters '-' and ' '.\nThere are at least two digits in number.", "code": "def reformatNumber(self, number: str) -> str:\n  return re.sub('(...?(?=..))', r'\\1-', re.sub('\\D', '', number))"}
{"nl": "Create a function that takes two inputs: indexes (a list of integers) and string (a string). The function should return another string with the letters of string at each index in indexes in order.\nExamples\nindex_filter([2, 3, 8, 11], \"Autumn in New York\") \u279e \"tune\"\n\nindex_filter([0, 1, 5, 7, 4, 2], \"Cry me a river\") \u279e \"creamy\"\n\nindex_filter([9, -9, 2, 27, 36, 6, 5, 13, -1, 2, 0, 30, 2], \n  \"That's life, I've got you under my skin\") \u279e \"frank sinatra\"\nNotes\nIndexes may not be in order / may be negative (see example #2 and #3).\nThe output string must always be lowercase, but the input string may not be (see examples).\nBonus points for submitting a lambda function.", "code": "index_filter=lambda i,s:''.join(s[x].lower()for x in i)"}
{"nl": "Suppose there is a circle. There are n petrol pumps on that circle. You are given two sets of data.\n\nThe amount of petrol that every petrol pump has.\nDistance from that petrol pump to the next petrol pump.\nCalculate the first point from where a truck will be able to complete the circle (The truck will stop at each petrol pump and it has infinite capacity). Expected time complexity is O(n). Assume for 1-litre petrol, the truck can go 1 unit of distance.\nFor example, let there be 4 petrol pumps with amount of petrol and distance to next petrol pump value pairs as {4, 6}, {6, 5}, {7, 3} and {4, 5}. The first point from where the truck can make a circular tour is 2nd petrol pump. Output should be \u201cstart = 1\u201d (index of 2nd petrol pump).", "code": "# Python program to find circular tour for a truck\n# In this approach we will start the tour from the first petrol pump\n# then while moving to the next pumps in the loop we will store the cumulative\n# information that whether we have a deficit of petrol at the current pump or not\n# If there is a deficit then we will add it to the deficit value calculated\n# till the previous petrol pump and then update the starting point to the next pump\n# and reset the petrol available in the truck as 0\n\n# This function return starting point if there is a possible\n# solution otherwise returns -1\ndef printTour(arr,n):\n\t\n\t# Consider first petrol pump as starting point\n\tstart = 0\n\t# These two variable will keep tracking if there is\n\t# surplus(s) or deficit(d) of petrol in the truck\n\ts = 0\t\t # petrol available the truck till now\n\td = 0\t # deficit of petrol till visiting this petrol pump\n\t\n\t# Start from the first petrol pump and complete one loop\n\t# of visiting all the petrol pumps and keep updating s and d at each pump\n\tfor i in range(n):\n\ts += arr[i][0] - arr[i][1]\n\tif s < 0:\t\t # the truck has a deficit of petrol\n\t\tstart = i+1\t # change the starting point\n\t\td += s\t\t # storing the deficit of petrol till current petrol pump\n\t\ts = 0\t\t # starting again from new station\n\t\n\t# when we reach first petrol pump again and sum of the petrol available at the truck\n\t# and the petrol deficit till now is 0 or more petrol then return the starting point\n\t# else return -1\n\treturn start if (s+d)>=0 else -1\n\n\n# Driver program to test above function\narr = [[6,4], [3,6], [7,3]]\nstart = printTour(arr,3)\nif start == -1:\nprint(\"No Solution Possible !!!\")\nelse:\nprint(\"start = {}\".format(start))\n\n# This code is contributed by Antara Das(anny)"}
{"nl": "In this tutorial, we will write a Python program to get the transpose of matrix and print the result in output.\n\nBefore writing the Python program, let's first look at the overview of the transpose of a matrix.\n\nTranspose of a matrix\nIf you change the rows of a matrix with the column of the same matrix, it is known as the transpose of a matrix. It is denoted as X'. For example: The element at ith row and jth column in X will be placed at jth row and ith column in X'.\n\nExample: Suppose we have given following matrix A:\n\nA = [[5, 4, 3]  \n         [2, 4, 6]  \n         [4, 7, 9]  \n         [8, 1, 3]]  \nAt would be the transpose of above given matrix i.e., A[i][j] = At[j][i] and therefore At should be:\n\nAt = [5, 2, 4, 8]\n        [4, 4, 7, 1]\n        [3, 6, 9, 3]\n", "code": "# Define a matrix A  \nA = [[5, 4, 3],  \n         [2, 4, 6],  \n         [4, 7, 9],  \n         [8, 1, 3]]  \n# Define an empty matrix of reverse order  \ntransResult = [[0, 0, 0, 0],    \n                             [0, 0, 0, 0],  \n                             [0, 0, 0, 0]]  \n# Use nested for loop on matrix A  \nfor a in range(len(A)):    \n   for b in range(len(A[0])):    \n          transResult[b][a] = A[a][b] # store transpose result on empty matrix          \n# Printing result in the output  \nprint(\"The transpose of matrix A is: \")  \nfor res in transResult:    \n   print(res)  "}
{"nl": "Create a function that takes a string of words and return a string sorted alphabetically by the last character of each word.\nExamples\nsort_by_last(\"herb camera dynamic\") \u279e \"camera herb dynamic\"\n\nsort_by_last(\"stab traction artist approach\") \u279e \"stab approach traction artist\"\n\nsort_by_last(\"sample partner autonomy swallow trend\") \u279e \"trend sample partner swallow autonomy\"\nNotes\nTests consist of lowercase alphabetic characters (a-z) and spaces.\nIf two words have the same last character, sort by the order they originally appeared.", "code": "def sort_by_last(txt):\n  return ' '.join(sorted(txt.split(), key=lambda x: x[-1]))"}
{"nl": "Create a function that takes two strings and returns True if the first string ends with the second string; otherwise return False.\nExamples\ncheck_ending(\"abc\", \"bc\") \u279e True\n\ncheck_ending(\"abc\", \"d\") \u279e False\n\ncheck_ending(\"samurai\", \"zi\") \u279e False\n\ncheck_ending(\"feminine\", \"nine\") \u279e True\n\ncheck_ending(\"convention\", \"tio\") \u279e False\nNotes\nAll test cases are valid one word strings.", "code": "def check_ending(str1, str2):\n  return str1.endswith(str2)"}
{"nl": "The math.erf() method returns the error function of a number.\r\n\r\nThis method accepts a value between - inf and + inf, and returns a value between - 1 to + 1.", "code": "# Import math Library\r\nimport math\r\n\r\n# Print error function for different numbers\r\nprint (math.erf(0.67))\r\nprint (math.erf(1.34))\r\nprint (math.erf(-6))"}
{"nl": "Here, we will discuss how to multiply two matrices in Python. Matrix multiplication is a binary operation that multiplies two matrices, as in addition and subtraction both the matrices should be of the same size, but here in multiplication matrices need not be of the same size.", "code": "# Python program to multiply two matrices using numpy # import NumPy library import numpy # take inputs m1 = [[1, 7], [4, 5]] m2 = [[5, 3], [4, 2]] res = [[0, 0], [0, 0]] # multiply matrix print(\"Matrix Multiplication: \") result = numpy.dot(m1, m2) for row in result: print(row)"}
{"nl": "Reverse DNS look up is using an internet IP address to find a domain name.\nOne solution is to use Hashing. \r\nIn this post, a Trie based solution is discussed. One advantage of Trie based solutions is, the worst case upper bound is O(1) for Trie, for hashing, the best possible average case time complexity is O(1). Also, with Trie we can implement prefix search (finding all urls for a common prefix of IP addresses). \r\nThe general disadvantage of Trie is large amount of memory requirement, this is not a major problem here as the alphabet size is only 11 here. Ten characters are needed for digits from \u20180\u2019 to \u20189\u2019 and one for dot (\u2018.\u2019). \r\nThe idea is to store IP addresses in Trie nodes and in the last node we store the corresponding domain name. ", "code": "# Trie Node\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.child = [None] * 11\r\n        self.url = None\r\n        self.is_end = False\r\n \r\nclass Trie:\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n     \r\n    def getIndex(self, c):\r\n        # For the . (dot) in IP address, we'll use the 10th index in child list\r\n        return 10 if c == '.' else int(c)\r\n     \r\n    def insert(self, ip, domain):\r\n        cur = self.root\r\n        n = len(ip)\r\n         \r\n        for level in range(n):\r\n            # We'll use the digits of IP address to form the trie structure\r\n            idx = self.getIndex(ip[level])\r\n             \r\n            if cur.child[idx] is None:\r\n                # Create a new trie node if not available for a particular digit\r\n                # and assign to the respective index\r\n                cur.child[idx] = TrieNode()\r\n                 \r\n            cur = cur.child[idx]\r\n         \r\n        # At the end, we'll map the domain name and mark the end node\r\n        cur.url = domain\r\n        cur.is_end = True\r\n     \r\n    def search_domain(self, ip):\r\n        cur = self.root\r\n        n = len(ip)\r\n         \r\n        # Traverse through the trie structure with all digits in ip address\r\n        for level in range(n):\r\n            idx = self.getIndex(ip[level])\r\n            if cur.child[idx] is None:\r\n                return \"Domain name not found\"\r\n             \r\n            cur = cur.child[idx]\r\n         \r\n        # Returns the url when all the digits in ip found\r\n        if cur and cur.url:\r\n            return cur.url\r\n         \r\n        return \"Domain name not found\"\r\n \r\n# Driver Code\r\nip = [\"107.108.11.123\", \"107.109.123.255\", \"74.125.200.106\"]\r\ndomain = [\"www.samsung.com\", \"www.samsung.net\", \"www.google.co.in\"]\r\n \r\ntrie = Trie()\r\nfor idx in range(len(ip)):\r\n    trie.insert(ip[idx], domain[idx])\r\n \r\nprint(trie.search_domain(\"107.109.123.255\"))\r\nprint(trie.search_domain(\"107.109.123.245\"))\r\n \r\n# This code is contributed by Abhilash Pujari"}
{"nl": "Exercise 8: Update set1 by adding items from set2, except common items", "code": "set1 = {10, 20, 30, 40, 50}\r\nset2 = {30, 40, 50, 60, 70}\r\n\r\nset1.symmetric_difference_update(set2)\r\nprint(set1)"}
{"nl": "Write a function that pairs the first number in an array with the last, the second number with the second to last, etc.\nExamples\npairs([1, 2, 3, 4, 5, 6, 7]) \u279e [[1, 7], [2, 6], [3, 5], [4, 4]]\n\npairs([1, 2, 3, 4, 5, 6]) \u279e [[1, 6], [2, 5], [3, 4]]\n\npairs([5, 9, 8, 1, 2]) \u279e [[5, 2], [9, 1], [8, 8]]\n\npairs([]) \u279e []\nNotes\nIf the list has an odd length, repeat the middle element twice for the last pair.\nReturn an empty list if the input is an empty list.", "code": "def pairs(lst):\n  return [[lst[i], lst[-(i+1)]] for i in range((len(lst)+1) //  2)]"}
{"nl": "Given a list, the task is to generate random numbers except for a particular number in a list in Python.", "code": "# Import the random module using the import statement.\r\nimport random\r\n# Give the list as static input and store it in a variable.\r\ngvnlst = [12, 42, 48, 19, 24, 29, 23, 11, 19, 5, 7, 31, 39, 45, 47, 49]\r\n# Give the number as static input and store it in a variable.\r\nnumbr = 24\r\n# Using List Comprehension create a new list that does not contain the given number.\r\nnwlist = [elmnt for elmnt in gvnlst if elmnt != numbr]\r\n# Using the random. choice() function generates some random element in the given list.\r\nrndm_numbrr = random.choice(nwlist)\r\n# Print the random element in the given list.\r\nprint('The Random Element in the given list', gvnlst, 'is [', rndm_numbrr, ']'"}
{"nl": "Given a number n, write a function that returns PI to n decimal places.\nExamples\nmy_pi(5) \u279e 3.14159\n\nmy_pi(4) \u279e 3.1416\n\nmy_pi(15) \u279e 3.141592653589793\nNotes\nn will not be above 15, to keep this challenge simple.\nRound up the last digit if the next digit in PI is greater or equal to 5 (see second example above).\nThe return value must be a number, not a string.", "code": "from math import pi\ndef my_pi(n):\n  return round(pi, n)"}
{"nl": "Why Circular? In a singly linked list, for accessing any node of the linked list, we start traversing from the first node. If we are at any node in the middle of the list, then it is not possible to access nodes that precede the given node. This problem can be solved by slightly altering the structure of a singly linked list. In a singly linked list, the next part (pointer to next node) is NULL. If we utilize this link to point to the first node, then we can reach the preceding nodes. Refer to this for more advantages of circular linked lists.\r\nThe structure thus formed is a circular singly linked list and looks like this: \r\n\r\n\r\n\r\n\r\n\r\nIn this post, the implementation and insertion of a node in a Circular Linked List using a singly linked list are explained.\r\n\r\nImplementation \r\nTo implement a circular singly linked list, we take an external pointer that points to the last node of the list. If we have a pointer last pointing to the last node, then last -> next will point to the first node. \r\n\r\n\r\n\r\nThe pointer last points to node Z and last -> next points to node P.\r\n\r\nWhy have we taken a pointer that points to the last node instead of the first node? \r\nFor the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of start pointer, we take a pointer to the last node, then in both cases there won\u2019t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.", "code": "prev = current"}
{"nl": "Given is a dict with the Morse alphabet, added a code for space between words. Write a function, which takes a string, either out of letters or out of Morse code from the dictionary. The function outputs an encrypted letter string of a decrypted Mmorse code.\r\n\r\nExamples\r\nmorse(\"F Mueller\") \u279e \"..-. ..... -- ..- . .-.. .-.. . .-.\"\r\n\r\nmorse(\".--- --- .... -. ..... ..-. ..... -.- . -. -. . -.. -.--\") \u279e \"JOHN F KENNEDY\"\r\n\r\nmorse(\"Barack Obama\") \u279e \"-... .- .-. .- -.-. -.- ..... --- -... .- -- .-\"\r\nNotes\r\nYou can use capital or small letters, however Morse always returns capitals.\r\nUse only letters and Morse codes from the dictionary.", "code": "def morse(txt):\r\n    encrypt = {'A':'.-', 'B':'-...', 'C':'-.-.', 'D':'-..', 'E':'.', 'F':'..-.', \r\n                'G':'--.', 'H':'....', 'I':'..', 'J':'.---', 'K':'-.-', 'L':'.-..', \r\n                'M':'--', 'N':'-.', 'O':'---', 'P':'.--.', 'Q':'--.-', 'R':'.-.', \r\n                'S':'...', 'T':'-', 'U':'..-', 'V':'...-', 'W':'.--', 'X':'-..-', \r\n                'Y':'-.--', 'Z':'--..', ' ':'.....'}\r\n    decrypt = {v: k for k, v in encrypt.items()}\r\n    \r\n    if '-' in txt:\r\n        return ''.join(decrypt[i] for i in txt.split())\r\n    return ' '.join(encrypt[i] for i in txt.upper())"}
{"nl": "Given an array A of n elements. We need to change the array into a permutation of numbers from 1 to n using minimum replacements in the array. \nExamples: \n \n\nInput : A[] = {2, 2, 3, 3} \nOutput : 2 1 3 4\nExplanation:\nTo make it a permutation of 1 to 4, 1 and 4 are\nmissing from the array. So replace 2, 3 with \n1 and 4.\n\nInput :  A[] = {1, 3, 2}\nOutput : 1 3 2\n\nInput : A[] = {10, 1, 2}\nOutput : 3 1 2", "code": "# Python3 code to make a permutation\n# of numbers from 1 to n using\n# minimum changes.\n\ndef makePermutation (a, n):\n\n\t# Store counts of all elements.\n\tcount = dict()\n\tfor i in range(n):\n\t\tif count.get(a[i]):\n\t\t\tcount[a[i]] += 1\n\t\telse:\n\t\t\tcount[a[i]] = 1;\n\t\t\n\tnext_missing = 1\n\tfor i in range(n):\n\t\tif count[a[i]] != 1 or a[i] > n or a[i] < 1:\n\t\t\tcount[a[i]] -= 1\n\t\t\t\n\t\t\t# Find next missing element to put\n\t\t\t# in place of current element.\n\t\t\twhile count.get(next_missing):\n\t\t\t\tnext_missing+=1\n\t\t\t\n\t\t\t# Replace with next missing and\n\t\t\t# insert the missing element in hash.\n\t\t\ta[i] = next_missing\n\t\t\tcount[next_missing] = 1\n\n# Driver Code\nA = [ 2, 2, 3, 3 ]\nn = len(A)\nmakePermutation(A, n)\n\nfor i in range(n):\n\tprint(A[i], end = \" \")\n\t\n# This code is contributed by \"Sharad_Bhardwaj\"."}
{"nl": "The statistics.harmonic_mean() method calculates the harmonic mean (central location) of the given data set.\r\n\r\nHarmonic mean = The reciprocal of the arithmetic mean() of the reciprocals of the data.\r\n\r\nThe harmonic mean is calculated as follows:\r\n\r\nIf you have four values (a, b, c and d) - it will be equivalent to 4 / (1/a + 1/b + 1/c + 1/d).\r\n\r", "code": "# Import statistics Library\r\nimport statistics\r\n\r\n# Calculate harmonic mean\r\nprint(statistics.harmonic_mean([40, 60, 80]))\r\nprint(statistics.harmonic_mean([10, 30, 50, 70, 90]))"}
{"nl": "Fibonacci numbers are created in the following way:\r\n\r\nF(0) = 0\r\nF(1) = 1\r\n...\r\nF(n) = F(n-2) + F(n-1)\r\nWrite a function that calculates the nth Fibonacci number.\r\n\r\nExamples\r\nfib(0) \u279e 0\r\n\r\nfib(1) \u279e 1\r\n\r\nfib(2) \u279e 1\r\n\r\nfib(8) \u279e 21", "code": "def fib(n):\r\n    return fib(n - 1) + fib(n - 2) if n > 1 else n"}
{"nl": "Write a function to connect all the adjacent nodes at the same level in a binary tree. Structure of the given Binary Tree node is like following. \n\nInitially, all the nextRight pointers point to garbage values. Your function should set these pointers to point next right for each node.\nExample: \n \n\nInput Tree\n       A\n      / \\\n     B   C\n    / \\   \\\n   D   E   F\n\n\nOutput Tree\n       A--->NULL\n      / \\\n     B-->C-->NULL\n    / \\   \\\n   D-->E-->F-->NULL\n \nMethod 2 (Extend Pre Order Traversal) \nThis approach works only for Complete Binary Trees. In this method we set nextRight in Pre Order fashion to make sure that the nextRight of parent is set before its children. When we are at node p, we set the nextRight of its left and right children. Since the tree is complete tree, nextRight of p\u2019s left child (p->left->nextRight) will always be p\u2019s right child, and nextRight of p\u2019s right child (p->right->nextRight) will always be left child of p\u2019s nextRight (if p is not the rightmost node at its level). If p is the rightmost node, then nextRight of p\u2019s right child will be NULL. \nTime Complexity: O(n)\nWhy doesn\u2019t method 2 work for trees which are not Complete Binary Trees? \nLet us consider following tree as an example. In Method 2, we set the nextRight pointer in pre order fashion. When we are at node 4, we set the nextRight of its children which are 8 and 9 (the nextRight of 4 is already set as node 5). nextRight of 8 will simply be set as 9, but nextRight of 9 will be set as NULL which is incorrect. We can\u2019t set the correct nextRight, because when we set nextRight of 9, we only have nextRight of node 4 and ancestors of node 4, we don\u2019t have nextRight of nodes in right subtree of root. \n \n\n            1\n          /    \\\n        2        3\n       / \\      /  \\\n      4   5    6    7\n     / \\           / \\  \n    8   9        10   11", "code": "# Python3 program to connect nodes at same\n# level using extended pre-order traversal\n\nclass newnode:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = self.nextRight = None\n\t\t\n# Sets the nextRight of root and calls\n# connectRecur() for other nodes\ndef connect (p):\n\t\n\t# Set the nextRight for root\n\tp.nextRight = None\n\n\t# Set the next right for rest of\n\t# the nodes (other than root)\n\tconnectRecur(p)\n\n# Set next right of all descendants of p.\n# Assumption: p is a complete binary tree\ndef connectRecur(p):\n\t\n\t# Base case\n\tif (not p):\n\t\treturn\n\t\n\t# Set the nextRight pointer for p's\n\t# left child\n\tif (p.left):\n\t\tp.left.nextRight = p.right\n\t\n\t# Set the nextRight pointer for p's right\n\t# child p.nextRight will be None if p is\n\t# the right most child at its level\n\tif (p.right):\n\t\tif p.nextRight:\n\t\t\tp.right.nextRight = p.nextRight.left\n\t\telse:\n\t\t\tp.right.nextRight = None\n\t\n\t# Set nextRight for other nodes in\n\t# pre order fashion\n\tconnectRecur(p.left)\n\tconnectRecur(p.right)\n\n# Driver Code\nif __name__ == '__main__':\n\n\t# Constructed binary tree is\n\t# 10\n\t#\t / \\\n\t# 8\t 2\n\t# /\n\t# 3\n\troot = newnode(10)\n\troot.left = newnode(8)\n\troot.right = newnode(2)\n\troot.left.left = newnode(3)\n\n\t# Populates nextRight pointer in all nodes\n\tconnect(root)\n\n\t# Let us check the values of nextRight pointers\n\tprint(\"Following are populated nextRight\",\n\t\t\"pointers in the tree (-1 is printed\",\n\t\t\t\t\t\"if there is no nextRight)\")\n\tprint(\"nextRight of\", root.data, \"is \", end = \"\")\n\tif root.nextRight:\n\t\tprint(root.nextRight.data)\n\telse:\n\t\tprint(-1)\n\tprint(\"nextRight of\", root.left.data, \"is \", end = \"\")\n\tif root.left.nextRight:\n\t\tprint(root.left.nextRight.data)\n\telse:\n\t\tprint(-1)\n\tprint(\"nextRight of\", root.right.data, \"is \", end = \"\")\n\tif root.right.nextRight:\n\t\tprint(root.right.nextRight.data)\n\telse:\n\t\tprint(-1)\n\tprint(\"nextRight of\", root.left.left.data, \"is \", end = \"\")\n\tif root.left.left.nextRight:\n\t\tprint(root.left.left.nextRight.data)\n\telse:\n\t\tprint(-1)\n\n# This code is contributed by PranchalK\n"}
{"nl": "Given a number of friends who have to give or take some amount of money from one another. Design an algorithm by which the total cash flow among all the friends is minimized.\u00a0", "code": "# Python3 program to find maximum\n# cash flow among a set of persons\n\u00a0\n# Number of persons(or vertices in graph)\nN = 3\n\u00a0\n# A utility function that returns\n# index of minimum value in arr[]\ndef getMin(arr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0minInd = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i] < arr[minInd]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minInd = i\n\u00a0\u00a0\u00a0\u00a0return minInd\n\u00a0\n# A utility function that returns\n# index of maximum value in arr[]\ndef getMax(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0maxInd = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i] > arr[maxInd]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxInd = i\n\u00a0\u00a0\u00a0\u00a0return maxInd\n\u00a0\n# A utility function to\n# return minimum of 2 values\ndef minOf2(x, y):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return x if x < y else y\n\u00a0\n# amount[p] indicates the net amount to\n# be credited/debited to/from person 'p'\n# If amount[p] is positive, then i'th\n# person will amount[i]\n# If amount[p] is negative, then i'th\n# person will give -amount[i]\ndef minCashFlowRec(amount):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find the indexes of minimum\n\u00a0\u00a0\u00a0\u00a0# and maximum values in amount[]\n\u00a0\u00a0\u00a0\u00a0# amount[mxCredit] indicates the maximum\n\u00a0\u00a0\u00a0\u00a0# amount to be given(or credited) to any person.\n\u00a0\u00a0\u00a0\u00a0# And amount[mxDebit] indicates the maximum amount\n\u00a0\u00a0\u00a0\u00a0# to be taken (or debited) from any person.\n\u00a0\u00a0\u00a0\u00a0# So if there is a positive value in amount[],\n\u00a0\u00a0\u00a0\u00a0# then there must be a negative value\n\u00a0\u00a0\u00a0\u00a0mxCredit = getMax(amount)\n\u00a0\u00a0\u00a0\u00a0mxDebit = getMin(amount)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If both amounts are 0,\n\u00a0\u00a0\u00a0\u00a0# then all amounts are settled\n\u00a0\u00a0\u00a0\u00a0if (amount[mxCredit] == 0 and amount[mxDebit] == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find the minimum of two amounts\n\u00a0\u00a0\u00a0\u00a0min = minOf2(-amount[mxDebit], amount[mxCredit])\n\u00a0\u00a0\u00a0\u00a0amount[mxCredit] -=min\n\u00a0\u00a0\u00a0\u00a0amount[mxDebit] += min\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If minimum is the maximum amount to be\n\u00a0\u00a0\u00a0\u00a0print(\"Person \" , mxDebit , \" pays \" , min\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0, \" to \" , \"Person \" , mxCredit)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for the amount array. Note that\n\u00a0\u00a0\u00a0\u00a0# it is guaranteed that the recursion\n\u00a0\u00a0\u00a0\u00a0# would terminate as either amount[mxCredit]\n\u00a0\u00a0\u00a0\u00a0# or amount[mxDebit] becomes 0\n\u00a0\u00a0\u00a0\u00a0minCashFlowRec(amount)\n\u00a0\n# Given a set of persons as graph[] where\n# graph[i][j] indicates the amount that\n# person i needs to pay person j, this\n# function finds and prints the minimum\n# cash flow to settle all debts.\ndef minCashFlow(graph):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an array amount[],\n\u00a0\u00a0\u00a0\u00a0# initialize all value in it as 0.\n\u00a0\u00a0\u00a0\u00a0amount = [0 for i in range(N)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Calculate the net amount to be paid\n\u00a0\u00a0\u00a0\u00a0# to person 'p', and stores it in amount[p].\n\u00a0\u00a0\u00a0\u00a0# The value of amount[p] can be calculated by\n\u00a0\u00a0\u00a0\u00a0# subtracting debts of 'p' from credits of 'p'\n\u00a0\u00a0\u00a0\u00a0for p in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0amount[p] += (graph[i][p] - graph[p][i])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0minCashFlowRec(amount)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver code\n\u00a0\n# graph[i][j] indicates the amount\n# that person i needs to pay person j\ngraph = [ [0, 1000, 2000],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 0, 5000],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 0, 0] ]\n\u00a0\nminCashFlow(graph)\n\u00a0\n# This code is contributed by Anant Agarwal.\n"}
{"nl": "Given two numbers base value and the exponential value, the task is to find the power of base and exponent modular 10^9+7", "code": "# Take a variable to say numb and initialize its value with 1000000007(10^9+7).\nnumb = 1000000007\n\n# Create a function to say exponentl_squaring() which takes the given two base and\n# exponential values as the arguments and returns the value of the power of base and\n# exponent modular 10^9+7.\n\n\ndef exponentl_squaring(gvn_baseval, gvn_exponentlval):\n  # Inside the function, take a variable say p, and initialize its value to 1.\n    p = 1\n    # Loop until the given exponential value is greater than 0 using the while loop.\n    while(gvn_exponentlval > 0):\n           # Check if the given exponential value is odd using the if conditional statement.\n        if (gvn_exponentlval % 2 != 0):\n            # If it is true, multiply p with the given base value and store it in another\n            # variable.\n            k = p * gvn_baseval\n            # Calculate the value of the above result modulus numb(10^9+7) and store it in the\n            # same variable p.\n            p = k % numb\n      # Multiply the given base value with itself and apply the modulus operator with\n      # 10^9+7(numb).\n      # Store it in the same variable given base value.\n        gvn_baseval = (gvn_baseval * gvn_baseval) % numb\n        # Divide the given exponential value by 2 and convert it to an integer using the\n        # int() function.\n        # Store it in the same variable given exponential value.\n        gvn_exponentlval = int(gvn_exponentlval / 2)\n   # Return the value of p modulus 10^9+7.\n    return p % numb\n\n# Give the base value as user input using the int(input()) function and store it in a variable.\ngvn_baseval = int(input(\"Enter some random number = \"))\n# Give the exponential value as user input using the int(input()) function and \n# store it in another variable.\ngvn_exponentlval = int(input(\"Enter some random number = \"))\n# Pass the given base and exponential values as the arguments to the exponentl_squaring()\n# function and store it in a variable.\nrslt = exponentl_squaring(gvn_baseval, gvn_exponentlval)\n# Print the value of the power of base and exponent modular 10^9+7.\nprint(\"The value of the power of base and exponent modular 10^9+7 = \", rslt)"}
{"nl": "In the delete operation, the element to be deleted is searched using the linear search, and then delete operation is performed followed by shifting the elements. ", "code": "# Python program to delete an element\r\n# from an unsorted array\r\n\r\n# Declaring array and key to delete\r\narr = [10, 50, 30, 40, 20]\r\nkey = 30\r\n\r\nprint(\"Array before deletion:\")\r\nprint (arr)\r\n\r\n# deletes key if found in the array\r\n# otherwise shows error not in list\r\narr.remove(key)\r\nprint(\"Array after deletion\")\r\nprint(arr)\r\n\r\n# This code is contributed by Aditi Sharma.\r"}
{"nl": "The ledger exercise is a refactoring exercise. There is code that prints a nicely formatted ledger, given a locale (American or Dutch) and a currency (US dollar or euro). The code however is rather badly written, though (somewhat surprisingly) it consistently passes the test suite.\n\nRewrite this code. Remember that in refactoring the trick is to make small steps that keep the tests passing. That way you can always quickly go back to a working version. Version control tools like git can help here as well.\n\nPlease keep a log of what changes you've made and make a comment on the exercise containing that log, this will help reviewers.", "code": "import datetime\nclass LedgerEntry(object):\n    def __init__(self, date, description, change):\n        self.date = datetime.datetime.strptime(date, '%Y-%m-%d')\n        self.description = description\n        self.change = change\n    def __eq__(self, other):\n        return (self.date == other.date\n                or self.change == other.change\n                or self.description == other.description)\n    def __lt__(self, other):\n        return (self.date < other.date\n                or self.change < other.change\n                or self.description < other.description)\ncreate_entry = LedgerEntry\ndef format_entries(currency, locale, entries):\n    return \"\\n\".join(format_iter(currency, locale, entries))\ndef format_iter(currency, locale, entries):\n    header = {\n        \"en_US\": \"Date|Description|Change\",\n        \"nl_NL\": \"Datum|Omschrijving|Verandering\"\n    }[locale].split(\"|\")\n    yield TableFormat().header(*header)\n    for entry in sorted(entries):\n        date = DateFormatter().format(entry.date, locale)\n        change = CurrencyFormatter().format(entry.change / 100.0, currency, locale)\n        yield TableFormat().row(date, entry.description, change)\ndef wrap(field, width):\n    # NOTE: normally, I use `textwrap.wrap` but it is aware of word-breaking,\n    # but the tests aren't...\n    return f\"{field[:width-3]}...\" if len(field) > width else field\nclass TableFormat:\n    def header(self, date, desc, change):\n        return f\"{wrap(date, 10):<10} | {wrap(desc, 25):<25} | {wrap(change, 13):<13}\"\n    def row(self, date, desc, change):\n        return f\"{wrap(date, 10):<10} | {wrap(desc, 25):<25} | {wrap(change, 13):>13}\"\nclass CurrencyFormatter:\n    def format(self, value, currency, locale):\n        # NOTE: normally I should use `locale` module to do this, but the tests\n        # provided don't follow international currency representation rules...\n        symbol = {\"USD\": \"$\", \"EUR\": \"\u20ac\"}[currency]\n        return getattr(self, f\"_polish_{locale[:2]}\")(f\"{value:,.2f}\", symbol)\n    def _polish_en(self, text, symbol):\n        if text.startswith(\"-\"):\n            return f\"({symbol}{text[1:]})\"\n        return f\" {symbol}{text} \"\n    def _polish_nl(self, text, symbol):\n        swap_symbols = dict(zip(\",.\", \".,\"))\n        text = \"\".join(swap_symbols.get(s, s) for s in text)\n        return f\"{symbol} {text} \"\nclass DateFormatter:\n    def format(self, date, locale):\n        snowflake_formats = { \"en_US\": \"%m/%d/%Y\" }\n        sane_person_format = \"%d-%m-%Y\"\n        return date.strftime(snowflake_formats.get(locale, sane_person_format))"}
{"nl": "This program checks whether given three angles of a triangle forms a valid triangle or not.\r\nA triangle is valid if the sum of the three angles is equal to 180 degree and none of the angle is 0.\r\nIf a, b and c are three angles of triangle then following conditions must be satisfied for a valid triangle.\r\n\r\na + b + c = 180\u00b0\r\n\r\na \u2260 0\r\n\r\nb \u2260 0\r\n\r\nc \u2260 0", "code": "# Validity of Triangle given angles\r\n\r\n# Function definition to check validity\r\ndef is_valid_triangle(a,b,c):\r\n    if a+b+c==180 and a!=0 and b!=0 and c!=0:\r\n        return True\r\n    else:\r\n        return False\r\n\r\n# Reading Three Angles\r\nangle_a = float(input('Enter angle a: '))\r\nangle_b = float(input('Enter angle b: '))\r\nangle_c = float(input('Enter angle c: '))\r\n\r\n# Function call & making decision\r\nif is_valid_triangle(angle_a, angle_b, angle_c):\r\n    print('Triangle is Valid.')\r\nelse:\r\n    print('Triangle is Invalid.')"}
{"nl": "Find a common element in all rows of a given row-wise sorted matrix", "code": "\n# Python 3 program to find a common element\n# in all rows of a row wise sorted array\n \n# Specify number of rows\n# and columns\nM = 4\nN = 5\n \n# Returns common element in all rows\n# of mat[M][N]. If there is no common\n# element, then -1 is returned\ndef findCommon(mat):\n \n    # An array to store indexes of\n    # current last column\n    column = [N - 1] * M\n \n    min_row = 0 # Initialize min_row as first row\n \n    # Keep finding min_row in current last\n    # column, till either all elements of\n    # last column become same or we hit first column.\n    while (column[min_row] >= 0):\n     \n        # Find minimum in current last column\n        for i in range(M):\n            if (mat[i][column[i]] <\n                mat[min_row][column[min_row]]):\n                min_row = i\n     \n        # eq_count is count of elements equal\n        # to minimum in current last column.\n        eq_count = 0\n \n        # Traverse current last column elements\n        # again to update it\n        for i in range(M):\n             \n            # Decrease last column index of a row\n            # whose value is more than minimum.\n            if (mat[i][column[i]] >\n                mat[min_row][column[min_row]]):\n                if (column[i] == 0):\n                    return -1\n \n                column[i] -= 1 # Reduce last column\n                               # index by 1\n         \n            else:\n                eq_count += 1\n \n        # If equal count becomes M, return the value\n        if (eq_count == M):\n            return mat[min_row][column[min_row]]\n    return -1\n \n# Driver Code\nif __name__ == \"__main__\":\n     \n    mat = [[1, 2, 3, 4, 5],\n           [2, 4, 5, 8, 10],\n           [3, 5, 7, 9, 11],\n           [1, 3, 5, 7, 9]]\n \n    result = findCommon(mat)\n    if (result == -1):\n        print(\"No common element\")\n    else:\n        print(\"Common element is\", result)\n \n# This code is contributed by ita_c"}
{"nl": "In daily share trading, a buyer buys shares in the morning and sells them on the same day. If the trader is allowed to make at most 2 transactions in a day, whereas the second transaction can only start after the first one is complete (Buy->sell->Buy->sell). Given stock prices throughout the day, find out the maximum profit that a share trader could have made.", "code": "import sys\r\n \r\ndef maxtwobuysell(arr, size):\r\n    first_buy = -sys.maxsize;\r\n    first_sell = 0;\r\n    second_buy = -sys.maxsize;\r\n    second_sell = 0;\r\n \r\n    for i in range(size):\r\n \r\n        first_buy = max(first_buy, -arr[i]);\r\n        first_sell = max(first_sell, first_buy + arr[i]);\r\n        second_buy = max(second_buy, first_sell - arr[i]);\r\n        second_sell = max(second_sell, second_buy + arr[i]);\r\n \r\n     \r\n    return second_sell;\r\n \r\nif __name__ == '__main__':\r\n    arr = [ 2, 30, 15, 10, 8, 25, 80 ];\r\n    size = len(arr);\r\n    print(maxtwobuysell(arr, size));\r\n \r\n# This code is contributed by gauravrajput1"}
{"nl": "This python program calculates area and volume of sphere whose radius is given by user.\r\nThis program uses following formula for area and volume of sphere:\r\n\r\nArea = 4\u03c0r2\r\n\r\nVolume =(4/3)\u03c0r3", "code": "# Finding area and volume of sphere\r\n\r\n# importing math module for PI\r\nimport math\r\n\r\n# Reading temperature in Celsius\r\nradius = float(input('Enter radius of circle: '))\r\n\r\n# Calculating area and volume\r\narea = 4 * math.pi * radius ** 2\r\nvolume = (4/3) * math.pi * radius**3\r\n\r\n# Displaying output\r\nprint('Area = %0.4f.' % (area))\r\nprint('Volume = %0.4f.' % (volume))"}
{"nl": "Write a function that returns the length of a string. Make your function recursive.\nExamples\nlength(\"apple\") \u279e 5\n\nlength(\"make\") \u279e 4\n\nlength(\"a\") \u279e 1\n\nlength(\"\") \u279e 0\nNotes\nCheck the Resources tab for info on recursion.", "code": "def length(s):\n  if s: return length(s[:-1]) + 1\n  return 0"}
{"nl": "The very first solution that comes to our mind is the one that we learned in school. If sum of digits in a number is multiple of 3 then number is multiple of 3 e.g., for 612 sum of digits is 9 so it\u2019s a multiple of 3. But this solution is not efficient. You have to get all decimal digits one by one, add them and then check if sum is multiple of 3.\n ", "code": "# Python program to check if n is a multiple of 3\n\n# Function to check if n is a multiple of 3\ndef isMultipleOf3(n):\n\n\todd_count = 0\n\teven_count = 0\n\n\t# Make no positive if + n is multiple of 3\n\t# then is -n. We are doing this to avoid\n\t# stack overflow in recursion\n\tif(n < 0):\n\t\tn = -n\n\tif(n == 0):\n\t\treturn 1\n\tif(n == 1):\n\t\treturn 0\n\n\twhile(n):\n\t\t\n\t\t# If odd bit is set then\n\t\t# increment odd counter\n\t\tif(n & 1):\n\t\t\todd_count += 1\n\n\t\t# If even bit is set then\n\t\t# increment even counter\n\t\tif(n & 2):\n\t\t\teven_count += 1\n\t\tn = n >> 2\n\n\treturn isMultipleOf3(abs(odd_count - even_count))\n\n# Program to test function isMultipleOf3\nnum = 24\nif (isMultipleOf3(num)):\n\tprint(num, 'is multiple of 3')\nelse:\n\tprint(num, 'is not a multiple of 3')\n\n# This code is contributed by Danish Raza"}
{"nl": "Given a list of strings and another string, the task is to remove the given string from the given list of strings.", "code": "# Give the list of strings as user input using list(), split(),\n# and input() functions and store it in a variable.\ngvnstrnlists = list(input('Enter some random list of strings = ').split())\n# Give the string as user input using input() and store it in another variable.\ngvnstrng = input('enter some random string which you want to remove = ')\nprint(\n    'The given list of strings before removing the string [', gvnstrng, '] is', gvnstrnlists)\n\n# Remove the given strings from the list of strings using List Comprehension.\nmodilststrngs = [elemen for elemen in gvnstrnlists if elemen != gvnstrng]\n# Print the modified list of strings.\nprint(\n    'The given list of strings after removing the string [', gvnstrng, '] is', modilststrngs)"}
{"nl": "You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.\nExamples : \n \n\nInput : arr[] = {1, 2, 3, 4}\nOutput :1\nExplanation : A single subset can contains all \nvalues and all values are distinct\n\nInput : arr[] = {1, 2, 3, 3}\nOutput : 2\nExplanation : We need to create two subsets\n{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such\nthat both subsets have distinct elements.", "code": "# A sorting based solution to find the\n# minimum number of subsets of a set\n# such that every subset contains distinct\n# elements.\n\n# function to count subsets such that all\n# subsets have distinct elements.\ndef subset(ar, n):\n\n\t# take input and initialize res = 0\n\tres = 0\n\n\t# sort the array\n\tar.sort()\n\n\t# traverse the input array and\n\t# find maximum frequency\n\tfor i in range(0, n) :\n\t\tcount = 1\n\n\t\t# for each number find its repetition / frequency\n\t\tfor i in range(n - 1):\n\t\t\tif ar[i] == ar[i + 1]:\n\t\t\t\tcount+=1\n\t\t\telse:\n\t\t\t\tbreak\n\t\t\t\n\t\t# update res\n\t\tres = max(res, count)\n\t\n\treturn res\n\n\n# Driver code\nar = [ 5, 6, 9, 3, 4, 3, 4 ]\nn = len(ar)\nprint(subset(ar, n))\n\n# This code is contributed by\n# Smitha Dinesh Semwal"}
{"nl": "The return keyword is to exit a function and return a value.\r\n\r", "code": "def myfunction():\r\n  return 3+3\r\n\r\nprint(myfunction())"}
{"nl": "Toggle Bits of a Number Except First and Last bits Using Right Shift (>>)Operator (User Input)", "code": "# Create a  function to say setallmidlebits which takes the given number as an\r\n# argument.\r\n\r\n\r\ndef setallmidlebits(gven_numb):\r\n    # Apply the or(|) operator to the given number and given_numb >> 1(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 1\r\n    # Apply the or(|) operator to the given number and given_numb >> 2(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 2\r\n    # Apply the or(|) operator to the given number and given_numb >> 4(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 4\r\n    # Apply the or(|) operator to the given number and given_numb >> 8(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 8\r\n    # Apply the or(|) operator to the given number and given_numb >> 16(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 16\r\n    # Right shift the given number by 1 and store it in another variable.\r\n    p = (gven_numb >> 1)\r\n    # Return the Xor value of the above result and 1.\r\n    return (p ^ 1)\r\n\r\n# Create a  function to say toglemidlebits which takes the given number as an\r\n# argument and returns the number after toggling all the bits of a given number except the\r\n# first and last bits.\r\n\r\n\r\ndef toglemidlebits(gven_numb):\r\n  # Check if the given number is equal to 1 using the if conditional statement.\r\n    if (gven_numb == 1):\r\n      # If the statement is true, then return 1.\r\n        return 1\r\n    # Return the Xor result of the given number and setallmidlebits(gven_numb).\r\n    return gven_numb ^ setallmidlebits(gven_numb)\r\n\r\n\r\n# Give the number as user input using the int(input()) function and store it in a variable.\r\ngven_numb = int(input(\"Enter some random number = \"))\r\n# Pass the given number as an argument to the setallmidlebits function.\r\n# Pass the given number as an argument to the toglemidlebits function.\r\n# Print the number after toggling all the bits of a given number except the\r\n# first and last bits.\r\nprint(\"The Number after toggling all the bits of a given number{\", gven_numb,\r\n      \"} except the first and last bits = \", toglemidlebits(gven_numb))"}
{"nl": "An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.\n\nGiven an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.\n\n ", "code": "class Solution:\n    def findOriginalArray(self, changed: List[int]) -> List[int]:\n        dct=collections.Counter(changed)\n        if dct[0]%2!=0: return []\n        res=[]\n        for el in sorted(dct):\n            while dct[el]>0 and dct[el*2]>0:\n                res.append(el)\n                dct[el]-=1\n                dct[el*2]-=1\n        return res if sum(dct.values())==0 else []"}
{"nl": "Instructions\r\nRefactor a Markdown parser.\r\n\r\nThe markdown exercise is a refactoring exercise. There is code that parses a given string with Markdown syntax and returns the associated HTML for that string. Even though this code is confusingly written and hard to follow, somehow it works and all the tests are passing! Your challenge is to re-write this code to make it easier to read and maintain while still making sure that all the tests keep passing.\r\n\r\nIt would be helpful if you made notes of what you did in your refactoring in comments so reviewers can see that, but it isn't strictly necessary. The most important thing is to make the code better!", "code": "import re\ndef parse(markdown):\n    s = markdown\n    s = re.sub(r'__([^\\n]+?)__', r'<strong>\\1</strong>', s)\n    s = re.sub(r'_([^\\n]+?)_', r'<em>\\1</em>', s)\n    s = re.sub(r'^\\* (.*?$)', r'<li>\\1</li>', s, flags=re.M)\n    s = re.sub(r'(<li>.*</li>)', r'<ul>\\1</ul>', s, flags=re.S)\n    for i in range(6, 0, -1):\n        s = re.sub(r'^{} (.*?$)'.format('#' * i), r'<h{0}>\\1</h{0}>'.format(i), s, flags=re.M)\n    s = re.sub(r'^(?!<[hlu])(.*?$)', r'<p>\\1</p>', s, flags=re.M)\n    s = re.sub(r'\\n', '', s)\n    return s\n"}
{"nl": "Given principle, Rate, Time, and the task are to calculate EMI for the given input values in Python.Estimated Monthly Installment (EMI):\nEMI is an abbreviation for Estimated Monthly Installment. It is a set amount of money paid by the customer or borrower to the bank or lender on a set date each month of the year. This amount is deducted from the customer\u2019s or borrower\u2019s account every month for a set number of years until the loan is fully paid off by the customer or borrower to the bank or lender.\n\nFormula :\nEMI = (P*R*(1+R)T)/((1+R)T-1), where P = Principle, T = Time, R = Rate of interest.", "code": "# Give the Principle as user input using float(input()) and store it in a variable.\ngvn_princpl = float(input(\"Enter some random number = \"))\n# Give the Rate as user input using float(input()) and store it in another variable.\ngvn_rate = float(input(\"Enter some random number = \"))\n# Give the Time as user input using float(input()) and store it in another variable.\ngvn_time = float(input(\"Enter some random number = \"))\n# Calculate the given rate using given rate formula( given rate/(12*100))and\n# store it in a same variable.\ngvn_rate = gvn_rate/(12*100)\n# Calculate the given time using given time formula (given time *12) and\n# store it in a same variable.\ngvn_time = gvn_time*12\n# Calculate the EMI Value using the above given mathematical formula and\n# store it in another variable.\nfnl_Emi = (gvn_princpl*gvn_rate*pow(1+gvn_rate, gvn_time)) / \\\n    (pow(1+gvn_rate, gvn_time)-1)\n# Print the given EMI value for the above given values of Principle,Rate,Time.\nprint(\"The EMI for the above given values of P,T,R = \", fnl_Emi)"}
{"nl": "Create a function that takes a dictionary of student names and returns a list of student names in alphabetical order.\nExamples\nget_student_names({\n  \"Student 1\" : \"Steve\",\n  \"Student 2\" : \"Becky\",\n  \"Student 3\" : \"John\"\n}) \u279e [\"Becky\", \"John\", \"Steve\"]\nNotes\nDon't forget to return your result.\nIf you get stuck on a challenge, find help in the Resources tab.\nIf you're really stuck, unlock solutions in the Solutions tab.", "code": "def get_student_names(students):\n  return sorted(students.values())"}
{"nl": "The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\n\nA chess knight can move as indicated in the chess diagram below:\n\n\nWe have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).\n\n\nGiven an integer n, return how many distinct phone numbers of length n we can dial.\n\nYou are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\n\nAs the answer may be very large, return the answer modulo 109 + 7.", "code": "def knightDialer(self, N):\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\n    neighbors = {\n        0:(4,6),\n        1:(6,8),\n        2:(7,9),\n        3:(4,8),\n        4:(0,3,9),\n        5:(),\n        6:(0,1,7),\n        7:(2,6),\n        8:(1,3),\n        9:(2,4)\n    }\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    for _ in range(N-1):\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        for src_key in range(10):\n            for dst_key in neighbors[src_key]:\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\n        current_counts = next_counts\n    return sum(current_counts) % (10**9 + 7)"}
{"nl": "Create a function that takes two integers and returns true if a digit repeats three times in a row at any place in num1 AND that same digit repeats two times in a row in num2.\nExamples\ntrouble(451999277, 41177722899) \u279e True\n\ntrouble(1222345, 12345) \u279e False\n\ntrouble(666789, 12345667) \u279e True\n\ntrouble(33789, 12345337) \u279e False\nNotes\nYou can expect every test case to contain exactly two integers.", "code": "def trouble(num1, num2):\n  for i in \"0123456789\":\n    if i*3 in str(num1) and i*2 in str(num2):\n      return True\n  return False"}
{"nl": "Create a function that will return an integer number corresponding to the amount of digits in the given integer num.\nExamples\nnum_of_digits(1000) \u279e 4\n\nnum_of_digits(12) \u279e 2\n\nnum_of_digits(1305981031) \u279e 10\n\nnum_of_digits(0) \u279e 1\nNotes\nTry to solve this challenge without using strings!", "code": "def num_of_digits(n):\n  return next(i for i in range(1, 100) if abs(n) < 10**i)"}
{"nl": "The values() method returns a view object. The view object contains the values of the dictionary, as a list.\r\n\r\nThe view object will reflect any changes done to the dictionary, see example below.", "code": "car = {\r\n  \"brand\": \"Ford\",\r\n  \"model\": \"Mustang\",\r\n  \"year\": 1964\r\n}\r\n\r\nx = car.values()\r\n\r\nprint(x)\r\n"}
{"nl": "Given a matrix and a scalar element k, our task is to find out the scalar product of that matrix.\u00a0\n\n\u00a0", "code": "# Python 3 program to find the scalar\n# product of a matrix\n\u00a0\n# Size of given matrix\nN = 3\n\u00a0\ndef scalarProductMat( mat, k):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# scalar element is multiplied\n\u00a0\u00a0\u00a0\u00a0# by the matrix\n\u00a0\u00a0\u00a0\u00a0for i in range( N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range( N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = mat[i][j] * k\u00a0\u00a0\u00a0\u00a0\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[ 1, 2, 3 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 4, 5, 6 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 7, 8, 9 ]]\n\u00a0\u00a0\u00a0\u00a0k = 4\n\u00a0\n\u00a0\u00a0\u00a0\u00a0scalarProductMat(mat, k)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# to display the resultant matrix\n\u00a0\u00a0\u00a0\u00a0print(\"Scalar Product Matrix is : \")\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": null, "code": null}
{"nl": "Solve Quadratic Equation using Python", "code": "# importing cmath\nimport cmath\n# given a,b,c values\na = 2\nb = -7\nc = 6\ndiscriminant = (b**2) - (4*a*c)\n# checking if the value of discriminant is greater than 0\nif(discriminant > 0):\n    # here exist the two distinct roots and we print them\n    # calculating the roots\n    root1 = (-b+discriminant) / (2 * a)\n    root2 = (-b-discriminant) / (2 * a)\n    # printing the roots\n\n    print(\"The two distinct roots are : \")\n    print(root1)\n    print(root2)\n# checking if the value of discriminant is equal to 0\nelif(discriminant == 0):\n    # here exist the two equal roots\n    # calculating single root here discriminant is 0 so we dont need to write full formulae\n    root = (-b)/(2*a)\n    # printing the root\n    print(\"The two equal roots are : \")\n    print(root, root)\n# else there exists complex roots\nelse:\n    # here exist the two complex roots\n    # calculating complex roots\n    realpart = -b/(2*a)\n    complexpart = discriminant/(2*a)*(-1)\n    # printing the roots\n    print(\"There exists two complex roots:\")\n    print(realpart, \"+\", complexpart, \"i\")\n    print(realpart, \"-\", complexpart, \"i\")"}
{"nl": "Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.\n\nA substring is a contiguous sequence of characters within a string.", "code": "class Solution:\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\n        count=0\n        for i in patterns:\n            if i in word:\n                count+=1\n        return count"}
{"nl": "The program sorts a list by merge sort.", "code": "def merge_sort(alist, start, end):\n    '''Sorts the list from indexes start to end - 1 inclusive.'''\n    if end - start > 1:\n        mid = (start + end)//2\n        merge_sort(alist, start, mid)\n        merge_sort(alist, mid, end)\n        merge_list(alist, start, mid, end)\n\u00a0\ndef merge_list(alist, start, mid, end):\n    left = alist[start:mid]\n    right = alist[mid:end]\n    k = start\n    i = 0\n    j = 0\n    while (start + i < mid and mid + j < end):\n        if (left[i] <= right[j]):\n            alist[k] = left[i]\n            i = i + 1\n        else:\n            alist[k] = right[j]\n            j = j + 1\n        k = k + 1\n    if start + i < mid:\n        while k < end:\n            alist[k] = left[i]\n            i = i + 1\n            k = k + 1\n    else:\n        while k < end:\n            alist[k] = right[j]\n            j = j + 1\n            k = k + 1\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\nmerge_sort(alist, 0, len(alist))\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "A spanning tree of a graph can be defined as a graph with minimal set of edges that connect all vertices. A minimum spanning tree of a graph is a spanning tree of the graph with least weight (where the weight is computed by adding the weights of all the edges in the spanning tree). In general, a graph can have multiple minimum spanning trees. The problem is to find a minimum spanning tree of a graph.", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def display(self):\n        print('Vertices: ', end='')\n        for v in self:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in self:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n\u00a0\n    def __len__(self):\n        return len(self.vertices)\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef mst_prim(g):\n    \"\"\"Return a minimum cost spanning tree of the connected graph g.\"\"\"\n    mst = Graph() # create new Graph object to hold the MST\n\u00a0\n    # if graph is empty\n    if not g:\n        return mst\n\u00a0\n    # nearest_neighbour[v] is the nearest neighbour of v that is in the MST\n    # (v is a vertex outside the MST and has at least one neighbour in the MST)\n    nearest_neighbour = {}\n    # smallest_distance[v] is the distance of v to its nearest neighbour in the MST\n    # (v is a vertex outside the MST and has at least one neighbour in the MST)\n    smallest_distance = {}\n    # v is in unvisited iff v has not been added to the MST\n    unvisited = set(g)\n\u00a0\n    u = next(iter(g)) # select any one vertex from g\n    mst.add_vertex(u.get_key()) # add a copy of it to the MST\n    unvisited.remove(u)\n\u00a0\n    # for each neighbour of vertex u\n    for n in u.get_neighbours():\n        if n is u:\n            # avoid self-loops\n            continue\n        # update dictionaries\n        nearest_neighbour[n] = mst.get_vertex(u.get_key())\n        smallest_distance[n] = u.get_weight(n)\n\u00a0\n    # loop until smallest_distance becomes empty\n    while (smallest_distance):\n        # get nearest vertex outside the MST\n        outside_mst = min(smallest_distance, key=smallest_distance.get)\n        # get the nearest neighbour inside the MST\n        inside_mst = nearest_neighbour[outside_mst]\n\u00a0\n        # add a copy of the outside vertex to the MST\n        mst.add_vertex(outside_mst.get_key())\n        # add the edge to the MST\n        mst.add_edge(outside_mst.get_key(), inside_mst.get_key(),\n                     smallest_distance[outside_mst])\n        mst.add_edge(inside_mst.get_key(), outside_mst.get_key(),\n                     smallest_distance[outside_mst])\n\u00a0\n        # now that outside_mst has been added to the MST, remove it from our\n        # dictionaries and the set unvisited\n        unvisited.remove(outside_mst)\n        del smallest_distance[outside_mst]\n        del nearest_neighbour[outside_mst]\n\u00a0\n        # update dictionaries\n        for n in outside_mst.get_neighbours():\n            if n in unvisited:\n                if n not in smallest_distance:\n                    smallest_distance[n] = outside_mst.get_weight(n)\n                    nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())\n                else:\n                    if smallest_distance[n] > outside_mst.get_weight(n):\n                        smallest_distance[n] = outside_mst.get_weight(n)\n                        nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())\n\u00a0\n    return mst\n\u00a0\n\u00a0\ng = Graph()\nprint('Undirected Graph')\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('mst')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                    g.add_edge(dest, src, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'mst':\n        mst = mst_prim(g)\n        print('Minimum Spanning Tree:')\n        mst.display()\n        print()\n\u00a0\n    elif operation == 'display':\n        g.display()\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Create a function that takes a number n (integer greater than zero) as an argument, and returns 2 if n is odd and 8 if n is even.\nYou can only use the following arithmetic operators: addition of numbers +, subtraction of numbers -, multiplication of number *, division of number /, and exponentiation **.\nYou are not allowed to use any other methods in this challenge (i.e. no if statements, comparison operators, etc).\nExamples\nf(1) \u279e 2\n\nf(2) \u279e 8\n\nf(3) \u279e 2\nNotes\nN/A", "code": "def f(n):\n    return 3*(-1)**n + 5"}
{"nl": "Create a function that takes a number as its parameter and returns another function. The returned function must take a list of numbers as its parameter, and return a list of the numbers divided by the number that was passed into the first function.\nExamples\nfirst = factory(15)\n# returns a function first.\n\nlst = [30, 45, 60]\n# 30 / 15 = 2, 45 / 15 = 3, 60 / 15 = 4\n\nfirst(lst) \u279e [2, 3, 4]\nsecond = factory(2)\n# returns a function second.\n\nlst = [2, 4, 6]\n# 2 / 2 = 1, 4 / 2 = 2, 6 / 2 = 3\n\nsecond(lst) \u279e [1, 2, 3]\nNotes\nRounding not required.", "code": "def factory(n):\n  return lambda lst: [i // n for i in lst]"}
{"nl": "Write a function that replaces all letters within a specified range with the hash symbol #.\nExamples\nreplace(\"abcdef\", \"c-e\") \u279e \"ab###f\"\n\nreplace(\"rattle\", \"r-z\") \u279e \"#a##le\"\n\nreplace(\"microscopic\", \"i-i\") \u279e \"m#croscop#c\"\n\nreplace(\"\", \"a-z\") \u279e \"\"\nNotes\nThe range will always be in order, a.k.a. for m-n, character m will always come before or equal n.\nStrings will be in lower case letters only.\nReturn an empty string if the input is an empty string.", "code": "def replace(txt, r):\n  return ''.join('#' if r[0] <= i <= r[2] else i for i in txt)"}
{"nl": "Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\n\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).", "code": "def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n    for i in range(1, len(matrix)):\n        for j in range(len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][max(0, j - 1):j + 2])\n    return min(matrix[-1])"}
{"nl": "Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.\nA subarray of an array is a consecutive sequence of zero or more values taken out of that array.\nReturn the maximum length of a subarray with positive product.\n \nExample 1:\n\nInput: nums = [1,-2,-3,4]\nOutput: 4\nExplanation: The array nums already has a positive product of 24.\n\nExample 2:\n\nInput: nums = [0,1,-2,-3,-4]\nOutput: 3\nExplanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.\nNotice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\nExample 3:\n\nInput: nums = [-1,-2,-3,0,1]\nOutput: 2\nExplanation: The longest subarray with positive product is [-1,-2] or [-2,-3].\n\n \nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109", "code": "def getMaxLen(self, nums: List[int]) -> int:\n  n = len(nums)\n  pos, neg = 0, 0\n  if nums[0] > 0: pos = 1\n  if nums[0] < 0: neg = 1\n  ans = pos\n  for i in range(1, n):\n  if nums[i] > 0:\n  pos = 1 + pos\n  neg = 1 + neg if neg > 0 else 0\n  elif nums[i] < 0:\n  pos, neg = 1 + neg if neg > 0 else 0, 1 + pos\n  else:\n  pos, neg = 0, 0\n  ans = max(ans, pos)\n  return ans"}
{"nl": "Bit masking is a technique used to \"hide\" certain parts of a number. It's great to use if you want to convey lots of information in a single integer. It takes a number n, converts it to its binary form, and then returns the digit at the index b of that binary number. Note that digit 0 is really the last digit since the least significant (smallest) digit is last. Your job is to create a function bit_mask that takes two arguments - the first being n and the second b - and returns the \"masked\" form of n.\nExamples\nbit_mask(37, 2) -> 1\n# Binary representation is this:\n# 0b100101\n#      ^\n# We return index 2 from the right, which is 1\n\nbit_mask(56, 1) -> 0\n# 0b111000\n#        ^\n\nbit_mask(327, 6) -> 1\n# 0b101000111\n#     ^\nNotes\nYou cannot use the bin function.\nFor an extra challenge, try only using bit operations!\nAll numbers 0 \u2264 n < 256 will be tested.\nThere are over 2,000 tests, and they all have to run within 12 seconds (set by Edabit, not me).\nIf n is too small to have a bth index, return 0.", "code": "def bit_mask(n, b):\n  return (n >> b) & 1"}
{"nl": "Given a directed graph, check whether the graph contains a cycle or not. Your function should return true if the given graph contains at least one cycle, else return false.\n\u00a0", "code": "# Python program to detect cycle\n# in a graph\n\u00a0\nfrom collections import defaultdict\n\u00a0\nclass Graph():\n\u00a0\u00a0\u00a0\u00a0def __init__(self,vertices):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = vertices\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u,v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[u].append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def isCyclicUtil(self, v, visited, recStack):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark current node as visited and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# adds to recursion stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[v] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recStack[v] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Recur for all neighbours\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if any neighbour is visited and in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recStack then graph is cyclic\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for neighbour in self.graph[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[neighbour] == False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isCyclicUtil(neighbour, visited, recStack) == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif recStack[neighbour] == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# The node needs to be poped from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursion stack before function ends\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recStack[v] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if graph is cyclic else false\n\u00a0\u00a0\u00a0\u00a0def isCyclic(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited = [False] * (self.V + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recStack = [False] * (self.V + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for node in range(self.V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[node] == False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isCyclicUtil(node,visited,recStack) == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\ng = Graph(4)\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\nif g.isCyclic() == 1:\n\u00a0\u00a0\u00a0\u00a0print \"Graph has a cycle\"\nelse:\n\u00a0\u00a0\u00a0\u00a0print \"Graph has no cycle\"\n\u00a0\n# Thanks to Divyanshu Mehta for contributing this code\n"}
{"nl": "You are given an m liter jug and a n liter jug. Both the jugs are initially empty. The jugs don\u2019t have markings to allow measuring smaller quantities. You have to use the jugs to measure d liters of water where d is less than n.\u00a0\n(X, Y) corresponds to a state where X refers to the amount of water in Jug1 and Y refers to the amount of water in Jug2 \nDetermine the path from the initial state (xi, yi) to the final state (xf, yf), where (xi, yi) is (0, 0) which indicates both Jugs are initially empty and (xf, yf) indicates a state which could be (0, d) or (d, 0).\n\nThe operations you can perform are: \n\nEmpty a Jug, (X, Y)->(0, Y) Empty Jug 1\nFill a Jug, (0, 0)->(X, 0) Fill Jug 1\nPour water from one jug to the other until one of the jugs is either empty or full, (X, Y) -> (X-d, Y+d)\nExamples: \n\nInput : 4 3 2\nOutput : {(0, 0), (0, 3), (3, 0), (3, 3), (4, 2), (0, 2)}\nRecommended: Please try your approach on {IDE} first, before moving on to the solution.\nWe have discussed the optimal solution in The Two Water Jug Puzzle. In this post, a BFS based solution is discussed.\n\nHere, we keep exploring all the different valid cases of the states of water in the jug simultaneously until and unless we reach the required target water.\n\nAs provided in the problem statement, at any given state we can do either of the following operations:\n\n1. Fill a jug\n\n2. Empty a jug\n\n3. Transfer water from one jug to another until either of them gets completely filled or empty.\n\n", "code": "from collections import deque\n\u00a0\ndef BFS(a, b, target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Map is used to store the states, every\n\u00a0\u00a0\u00a0\u00a0# state is hashed to binary value to\n\u00a0\u00a0\u00a0\u00a0# indicate either that state is visited\n\u00a0\u00a0\u00a0\u00a0# before or not\n\u00a0\u00a0\u00a0\u00a0m = {}\n\u00a0\u00a0\u00a0\u00a0isSolvable = False\n\u00a0\u00a0\u00a0\u00a0path = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Queue to maintain states\n\u00a0\u00a0\u00a0\u00a0q = deque()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialing with initial state\n\u00a0\u00a0\u00a0\u00a0q.append((0, 0))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while (len(q) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Current state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = q.popleft()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#q.pop() #pop off used state\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this state is already visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((u[0], u[1]) in m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Doesn't met jug constraints\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((u[0] > a or u[1] > b or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u[0] < 0 or u[1] < 0)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Filling the vector for constructing\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the solution path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append([u[0], u[1]])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Marking current state as visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[(u[0], u[1])] = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we reach solution state, put ans=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[0] == target or u[1] == target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSolvable = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[0] == target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[1] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Fill final state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append([u[0], 0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[0] != 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Fill final state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append([0, u[1]])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print the solution path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sz = len(path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(sz):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"(\", path[i][0], \",\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[i][1], \")\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we have not reached final state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then, start developing intermediate\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# states to reach solution state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([u[0], b]) # Fill Jug2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([a, u[1]]) # Fill Jug1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for ap in range(max(a, b) + 1):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pour amount ap from Jug2 to Jug1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c = u[0] + ap\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d = u[1] - ap\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if this state is possible or not\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (c == a or (d == 0 and d >= 0)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([c, d])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pour amount ap from Jug 1 to Jug2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c = u[0] - ap\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d = u[1] + ap\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if this state is possible or not\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((c == 0 and c >= 0) or d == b):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([c, d])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Empty Jug2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([a, 0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Empty Jug1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([0, b])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# No, solution exists if ans=0\n\u00a0\u00a0\u00a0\u00a0if (not isSolvable):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"No solution\")\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Jug1, Jug2, target = 4, 3, 2\n\u00a0\u00a0\u00a0\u00a0print(\"Path from initial state \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"to solution state ::\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0BFS(Jug1, Jug2, target)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "This challenge has five miniature exercises to help practice proficiency in string slicing. Check the examples below for a visual indicator of how to slice the strings. Good luck!\nExamples\ntxt = \"abcdefghijklmnopqrstuvwxyz\"\nchallenge1(txt) \u279e \"abcde\"\n# First 5 characters of the string.\n\nchallenge2(txt) \u279e \"vwxyz\"\n# Last 5 characters of the string.\n\nchallenge3(txt) \u279e \"zyxwvutsrqponmlkjihgfedcba\"\n# All characters in the string from back.\n\nchallenge4(txt) \u279e \"fedcba\"\n# First 6 characters in the string (start with 6th character and go backwards).\n\nchallenge5(txt) \u279e \"tvxz\"\n# Take last 7 characters and only return odd positioned ones.\nNotes\nCheck the Tests tab for more examples.\nSee the Resources tab for further information on learning string slicing.\nYou are not allowed to concatenate strings together! Results must be achieved purely through string slicing!", "code": "def challenge1(s):\n  return s[:5]\n  def challenge2(s):\n  return s[-5:]\n  def challenge3(s):\n  return s[::-1]\n  def challenge4(s):\n  return s[5::-1]\n  def challenge5(s):\n  return s[-7::2]"}
{"nl": "The program creates a tree and presents a menu to the user to perform various operations including printing its BFS traversal.", "code": "class Tree:\n    def __init__(self, data=None):\n        self.key = data\n        self.children = []\n\u00a0\n    def set_root(self, data):\n        self.key = data\n\u00a0\n    def add(self, node):\n        self.children.append(node)\n\u00a0\n    def search(self, key):\n        if self.key == key:\n            return self\n        for child in self.children:\n            temp = child.search(key)\n            if temp is not None:\n                return temp\n        return None\n\u00a0\n    def bfs(self):\n        queue = [self]\n        while queue != []:\n            popped = queue.pop(0)\n            for child in popped.children:\n                queue.append(child)\n            print(popped.key, end=' ')\n\u00a0\n\u00a0\ntree = None\n\u00a0\nprint('Menu (this assumes no duplicate keys)')\nprint('add <data> at root')\nprint('add <data> below <data>')\nprint('bfs')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'add':\n        data = int(do[1])\n        new_node = Tree(data)\n        suboperation = do[2].strip().lower() \n        if suboperation == 'at':\n            tree = new_node\n        elif suboperation == 'below':\n            position = do[3].strip().lower()\n            key = int(position)\n            ref_node = None\n            if tree is not None:\n                ref_node = tree.search(key)\n            if ref_node is None:\n                print('No such key.')\n                continue\n            ref_node.add(new_node)\n\u00a0\n    elif operation == 'bfs':\n        if tree is None:\n            print('Tree is empty.')\n        else:\n            print('BFS traversal: ', end='')\n            tree.bfs()\n            print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Accessing Dictionary Items\r\nYou can access the items of a dictionary by referring to its key name, inside square brackets:", "code": "x = thisdict[\"model\"]"}
{"nl": "Given a number N and the task is to find the sum of the given series (3+7+13+21\u2026..+N) for the given number in Python.", "code": "# Give the number N as static input and store it in a variable.\r\ngvn_numb = 9\r\n# Take a variable say resltsum which gives the sum of the given series till N and\r\n# initialize its value to 0.\r\nresltsum = 0\r\n# Loop from 2 to the given number+1 using the for loop.\r\nfor itr in range(2, gvn_numb+2):\r\n  # Inside the loop, subtract 1 from the iterator value and multiply it with the\r\n  # iterator and add 1 to this result.\r\n  # Store it in another variable say p.\r\n    p = 1+(itr*(itr-1))\r\n  # Add the value of above p to the above-initialized resltsum and store it in the same\r\n  # variable resltsum.\r\n    resltsum += p\r\n# Print the resltsum value which is the result of the series till the given Number N.\r\nprint(\r\n    \"The total sum of the series till the given number {\", gvn_numb, \"} = \", resltsum)"}
{"nl": "Given an array representing preorder traversal of BST, print its postorder traversal. ", "code": "\"\"\"Python3 program for finding postorder\r\ntraversal of BST from preorder traversal\"\"\"\r\n\r\nINT_MIN = -2**31\r\nINT_MAX = 2**31\r\n\r\n# Function to find postorder traversal\r\n# from preorder traversal.\r\n\r\n\r\ndef findPostOrderUtil(pre, n, minval,\r\n\t\t\t\t\tmaxval, preIndex):\r\n\r\n\t# If entire preorder array is traversed\r\n\t# then return as no more element is left\r\n\t# to be added to post order array.\r\n\tif (preIndex[0] == n):\r\n\t\treturn\r\n\r\n\t# If array element does not lie in\r\n\t# range specified, then it is not\r\n\t# part of current subtree.\r\n\tif (pre[preIndex[0]] < minval or\r\n\t\t\tpre[preIndex[0]] > maxval):\r\n\t\treturn\r\n\r\n\t# Store current value, to be printed later,\r\n\t# after printing left and right subtrees.\r\n\t# Increment preIndex to find left and right\r\n\t# subtrees, and pass this updated value to\r\n\t# recursive calls.\r\n\tval = pre[preIndex[0]]\r\n\tpreIndex[0] += 1\r\n\r\n\t# All elements with value between minval\r\n\t# and val lie in left subtree.\r\n\tfindPostOrderUtil(pre, n, minval,\r\n\t\t\t\t\tval, preIndex)\r\n\r\n\t# All elements with value between val\r\n\t# and maxval lie in right subtree.\r\n\tfindPostOrderUtil(pre, n, val,\r\n\t\t\t\t\tmaxval, preIndex)\r\n\r\n\tprint(val, end=\" \")\r\n\r\n# Function to find postorder traversal.\r\n\r\n\r\ndef findPostOrder(pre, n):\r\n\r\n\t# To store index of element to be\r\n\t# traversed next in preorder array.\r\n\t# This is passed by reference to\r\n\t# utility function.\r\n\tpreIndex = [0]\r\n\r\n\tfindPostOrderUtil(pre, n, INT_MIN,\r\n\t\t\t\t\tINT_MAX, preIndex)\r\n\r\n\r\n# Driver Code\r\nif __name__ == '__main__':\r\n\tpre = [40, 30, 35, 80, 100]\r\n\r\n\tn = len(pre)\r\n\r\n\t# Calling function\r\n\tfindPostOrder(pre, n)\r\n\r\n# This code is contributed by\r\n# SHUBHAMSINGH10\r"}
{"nl": "Create a function that takes a list and finds the integer which appears an odd number of times.\nExamples\nfind_odd([1, 1, 2, -2, 5, 2, 4, 4, -1, -2, 5]) \u279e -1\n\nfind_odd([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]) \u279e 5\n\nfind_odd([10]) \u279e 10\nNotes\nThere will always only be one integer that appears an odd number of times.", "code": "def find_odd(lst):\n  for num in lst:\n    if lst.count(num) % 2:\n      return num"}
{"nl": "The general form of the equation of a circle is x\u00b2+y\u00b2+ax+by+c=0 where a, b, and c are constants.\r\n\r\nCreate a function that takes numbers a, b and c as arguments, and returns a list [(x_c, y_c), r] where (x_c, y_c) is the center and r is the radius.\r\n\r\nExamples\r\ncircle(-4, -6, -12) \u279e [(2, 3), 5]\r\n\r\ncircle(8, -2, -32) \u279e [(-4, 1), 7]\r\n\r\ncircle(16, 4, 67) \u279e [(-8, -2), 1]", "code": "def circle(a, b, c):\r\n\treturn [(-a/2, -b/2), (-c + (a/2)**2 + (b/2)**2)**0.5]"}
{"nl": "Given a string with brackets. If the start index of the open bracket is given, find the index of the closing bracket.", "code": "# Python program to find index of closing\n# bracket for a given opening bracket.\nfrom collections import deque\n\u00a0\u00a0\ndef getIndex(s, i):\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If input is invalid.\n\u00a0\u00a0\u00a0\u00a0if s[i] != '[':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a deque to use it as a stack.\n\u00a0\u00a0\u00a0\u00a0d = deque()\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse through all elements\n\u00a0\u00a0\u00a0\u00a0# starting from i.\n\u00a0\u00a0\u00a0\u00a0for k in range(i, len(s)):\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pop a starting bracket\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for every closing bracket\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if s[k] == ']':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d.popleft()\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push all starting brackets\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif s[k] == '[':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d.append(s[i])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If deque becomes empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not d:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return k\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\n# Driver code to test above method.\ndef test(s, i):\n\u00a0\u00a0\u00a0\u00a0matching_index = getIndex(s, i)\n\u00a0\u00a0\u00a0\u00a0print(s + \", \" + str(i) + \": \" + str(matching_index))\n\u00a0\u00a0\ndef main():\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 0) # should be 8\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 4) # should be 7\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 9) # should be 12\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 1) # No matching bracket\n\u00a0\u00a0\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0main()\n"}
{"nl": "Create a function that subtracts one positive integer from another, without using any arithmetic operators such as -, %, /, +, etc.\nExamples\nmy_sub(5, 9) \u279e 4\n\nmy_sub(10, 30) \u279e 20\n\nmy_sub(0, 0) \u279e 0\nNotes\nDo not multiply by -1.\nUse bitwise operations only: <<, |, ~, &, etc.", "code": "def my_sub(a, b):\n    return len(range(a,b))"}
{"nl": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n\nReturn the quotient after dividing dividend by divisor.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n\n \n\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n \n\nConstraints:\n\n-231 <= dividend, divisor <= 231 - 1\ndivisor != 0", "code": "def divide(self, dividend: int, divisor: int) -> int:\n\n    # Constants.\n    MAX_INT = 2147483647        # 2**31 - 1\n    MIN_INT = -2147483648       # -2**31\n    HALF_MIN_INT = -1073741824  # MIN_INT // 2\n\n    # Special case: overflow.\n    if dividend == MIN_INT and divisor == -1:\n        return MAX_INT\n\n    # We need to convert both numbers to negatives.\n    # Also, we count the number of negatives signs.\n    negatives = 2\n    if dividend > 0:\n        negatives -= 1\n        dividend = -dividend\n    if divisor > 0:\n        negatives -= 1\n        divisor = -divisor\n\n    quotient = 0\n    # Once the divisor is bigger than the current dividend,\n    # we can't fit any more copies of the divisor into it anymore */\n    while divisor >= dividend:\n        # We know it'll fit at least once as divivend >= divisor.\n        # Note: We use a negative powerOfTwo as it's possible we might have\n        # the case divide(INT_MIN, -1). */\n        powerOfTwo = -1\n        value = divisor\n        # Check if double the current value is too big. If not, continue doubling.\n        # If it is too big, stop doubling and continue with the next step */\n        while value >= HALF_MIN_INT and value + value >= dividend:\n            value += value;\n            powerOfTwo += powerOfTwo\n        # We have been able to subtract divisor another powerOfTwo times.\n        quotient += powerOfTwo\n        # Remove value so far so that we can continue the process with remainder.\n        dividend -= value\n\n    # If there was originally one negative sign, then\n    # the quotient remains negative. Otherwise, switch\n    # it to positive.\n    return -quotient if negatives != 1 else quotient"}
{"nl": "You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\n\nplantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.\ngrowTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.\nFrom the beginning of day 0, you can plant the seeds in any order.\n\nReturn the earliest possible day where all seeds are blooming.", "code": "class Solution:\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\n        time_line = sorted(range(len(plantTime)), key=growTime.__getitem__, reverse=True)\n        line = 0\n        for x in time_line:\n            line = max(line - plantTime[x], growTime[x])\n        return sum(plantTime) + line"}
{"nl": "We will develop a program to reverse each word in a string python. In this article, we are using the split() function, list comprehension, and join() function to reverse each word of a string in Python. The split() method splits the string from the specified separator and returns a list object with string elements. The join() method takes all items in an iterable and joins them into one string. A string must be specified as the separator. List comprehensions provide a concise way to create lists.", "code": "# Python program to reverse each word in a string # take inputs string = 'Know Program' # splitting the string into list of words words = string.split(' ') # reversing each word and creating a new list of words reverseWords = [word[::-1] for word in words] # joining the new list of words to for a new string reverseString = \" \".join(reverseWords) # print reverse of each word in a string print('The reverse is', reverseString)"}
{"nl": null, "code": null}
{"nl": "Given two lists of the same length, the task is to perform the Xor Operation on both the list elements which are having the same index in Python.\n Examples:\n Example1:\n Input:\n Given list 1= [4, 19, 11, 5, 3, 9, 7]\n \n Given list 2= [10, 3, 7, 2, 9, 8, 6, 5]\n Output:\n The given First list elements are = [4, 19, 11, 5, 3, 9, 7]\n \n The given Second list elements are = [10, 3, 7, 2, 9, 8, 6, 5]\n \n The result after applying xor operation on both lists is [14, 16, 12, 7, 10, 1, 1]\n Example2:\n Input:\n Given list 1 = [5, 7, 9, 6]\n \n Given list 2 = [3, 8, 9, 4]\n Output:\n The given First list elements are = [5, 7, 9, 6]\n \n The given Second list elements are = [3, 8, 9, 4]\n \n The result after applying xor operation on both list is [6, 15, 0, 2]", "code": "# Give the first list as static input and store it in a variable.\n \n lstt1 = [4, 19, 11, 5, 3, 9, 7]\n \n # Give the second list as static input and store it in another variable.\n \n lstt2 = [10, 3, 7, 2, 9, 8, 6, 5]\n \n print('The given First list elements are =', lstt1)\n \n print('The given Second list elements are =', lstt2)\n \n # Calculate the length of the first list using the len()\n \n # function(as both lists have same length) and store it in a variable.\n \n lenlst = len(lstt1)\n \n # Loop till the above length using the For loop.\n \n for p in range(lenlst):\n \n  # Inside the for loop initialize the list 1 element as xor operation\n \n  # between list1 and list2 using xor operator i.e lst1[p]=lst1[p]^lst2[p]\n \n  # where p is the iterator value of the For loop.\n \n  lstt1[p] = lstt1[p] ^ lstt2[p]\n \n # Print the list1 which is the result.\n \n print('The result after applying xor operation on both lists is', lstt1)\n \n </pre>"}
{"nl": "Write a function that sorts a given list in an aletrnative fashion. The result should be a list sorted in ascending order (number then letter). Lists will contain equal amounts of integer numbers and single characters.\nExamples\nalternate_sort([\"a\", \"b\", \"c\", 1, 2, 3]) \u279e [1, \"a\", 2, \"b\", 3, \"c\"]\n\nalternate_sort([-2, \"f\", \"A\", 0, 100, \"z\"]) \u279e [-2, \"A\", 0, \"f\", 100, \"z\"]\n\nalternate_sort([\"X\", 15, 12, 18, \"Y\", \"Z\"]) \u279e [12, \"X\", 15, \"Y\", 18, \"Z\"]\nNotes\nN/A", "code": "def alternate_sort(lst):\n    nums, chars, res = [], [], []\n    for i in lst:\n        nums.append(i) if type(i) == int else chars.append(i) \n    for i in zip(sorted(nums), sorted(chars)):\n        res += i\n    return res"}
{"nl": "Practice Java programming from home without using any fancy software just by tapping on this Simple Java Programs for Beginners tutorial.\n Given a very large number N, the task is to find the Digital Root of large Integers using Recursion in Python.\n Examples:\n Example1:\n Input:\n Given Large Number =64829048194591378492648546725\n Output:\n The Digital root of the given number 64829048194591378492648546725 is [ 6 ]\n Example2:\n Input:\n Given Large Number =587199248368256143942\n Output:\n The Digital root of the given number 587199248368256143942 is [ 7 ]", "code": "# Create a function digitalRootRecursion which accepts the given number as an argument\n \n # and returns the digital root of the given number.\n \n \n \n \n \n def digitalRootRecursion(largenumbr):\n \n  # Then determine whether the integer is greater than or less than 10.\n \n  # If the integer is less than 10, return the number immediately\n \n  # and terminate the function\n \n  if(largenumbr < 10):\n \n  return largenumbr\n \n  # If the number is higher than 10, use the above function to recursively\n \n  # compute the sum of the digits of the given integer.\n \n  largenumbr = largenumbr % 10+digitalRootRecursion(largenumbr//10)\n \n  return digitalRootRecursion(largenumbr)\n \n \n \n \n \n # Give the number(Very Large) as static input and store it in a variable.\n \n lrgenumbr = 64829048194591378492648546725\n \n # Pass the given number as an argument to digitalRootRecursion() function.\n \n rsdigitalroot = digitalRootRecursion(lrgenumbr)\n \n # print the result digital root\n \n print('The Digital root of the given number',\n \n  lrgenumbr, 'is [', rsdigitalroot, ']')"}
{"nl": "Write a method that accepts two integer parameters rows and cols. The output is a 2d array of numbers displayed in column-major order, meaning the numbers shown increase sequentially down each column and wrap to the top of the next column to the right once the bottom of the current column is reached.\nExamples\nprintGrid(3, 6) \u279e [\n  [1, 4, 7, 10, 13, 16],\n  [2, 5, 8, 11, 14, 17],\n  [3, 6, 9, 12, 15, 18]\n]\n\nprintGrid(5, 3) \u279e [\n  [1, 6, 11],\n  [2, 7, 12],\n  [3, 8, 13],\n  [4, 9, 14],\n  [5, 10, 15]\n]\n\nprintGrid(4, 1) \u279e [\n  [1],\n  [2],\n  [3],\n  [4]\n]\nNotes\nN/A", "code": "def printgrid(rows, cols):\n  return [[c*rows+r for c in range(cols)] for r in range(1, rows+1)]"}
{"nl": "Create a function that takes a number as an argument and returns a list of numbers counting down from this number to zero.\nExamples\ncountdown(5) \u279e [5, 4, 3, 2, 1, 0]\n\ncountdown(1) \u279e [1, 0]\n\ncountdown(0) \u279e [0]\nNotes\nThe argument will always be greater than or equal to zero.", "code": "def countdown(start):\n  return [i for i in range(start,-1,-1)]"}
{"nl": "Write a function that finds the sum of the first n natural numbers. Make your function recursive.\nExamples\nsum_numbers(5) \u279e 15\n# 1 + 2 + 3 + 4 + 5 = 15\n\nsum_numbers(1) \u279e 1\n\nsum_numbers(12) \u279e 78\nNotes\nAssume the input number is always positive.\nCheck the Resources tab for info on recursion.", "code": "def sum_numbers(n):\n  return n + sum_numbers(n-1) if n else 0"}
{"nl": "Given a matrix where every cell represents points. How to collect maximum points using two traversals under following conditions?\n\nLet the dimensions of given grid be R x C.\n1) The first traversal starts from top left corner, i.e., (0, 0) and should reach left bottom corner, i.e., (R-1, 0). The second traversal starts from top right corner, i.e., (0, C-1) and should reach bottom right corner, i.e., (R-1, C-1)/\n2) From a point (i, j), we can move to (i+1, j+1) or (i+1, j-1) or (i+1, j)\n3) A traversal gets all points of a particular cell through which it passes. If one traversal has already collected points of a cell, then the other traversal gets no points if goes through that cell again.\n \n\nInput :\n    int arr[R][C] = {{3, 6, 8, 2},\n                     {5, 2, 4, 3},\n                     {1, 1, 20, 10},\n                     {1, 1, 20, 10},\n                     {1, 1, 20, 10},\n                    };\n\n     Output: 73\n\nExplanation :\n\nFirst traversal collects total points of value 3 + 2 + 20 + 1 + 1 = 27\n\nSecond traversal collects total points of value 2 + 4 + 10 + 20 + 10 = 46.\nTotal Points collected = 27 + 46 = 73.", "code": "# A Memoization based program to find maximum collection\n# using two traversals of a grid\n\u00a0\nR=5\nC=4\nintmin=-10000000\nintmax=10000000\n\u00a0\n# checks whether a given input is valid or not\ndef isValid(x,y1,y2):\n\u00a0\u00a0\u00a0\u00a0return ((x >= 0 and x < R and y1 >=0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0and y1 < C and y2 >=0 and y2 < C))\n\u00a0\n# Driver function to collect max value\ndef getMaxUtil(arr,mem,x,y1,y2):\n\u00a0\u00a0\u00a0\u00a0# ---------- BASE CASES -----------\n\u00a0\u00a0\u00a0\u00a0if isValid(x, y1, y2)==False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return intmin\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if both traversals reach their destinations\n\u00a0\u00a0\u00a0\u00a0if x == R-1 and y1 == 0 and y2 == C-1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if y1==y2:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return arr[x][y1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return arr[x][y1]+arr[x][y2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If both traversals are at last row\n\u00a0\u00a0\u00a0\u00a0# but not at their destination\n\u00a0\u00a0\u00a0\u00a0if x==R-1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return intmin\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If subproblem is already solved\n\u00a0\u00a0\u00a0\u00a0if mem[x][y1][y2] != -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return mem[x][y1][y2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize answer for this subproblem\n\u00a0\u00a0\u00a0\u00a0ans=intmin\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# this variable is used to store gain of current cell(s)\n\u00a0\u00a0\u00a0\u00a0temp=0\n\u00a0\u00a0\u00a0\u00a0if y1==y2:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp=arr[x][y1]\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp=arr[x][y1]+arr[x][y2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for all possible cases, then store and return the\n\u00a0\u00a0\u00a0\u00a0# one with max value\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1, y2-1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1, y2+1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1, y2))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1-1, y2))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1-1, y2-1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1-1, y2+1))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1+1, y2))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1+1, y2-1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1+1, y2+1))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mem[x][y1][y2] = ans\n\u00a0\u00a0\u00a0\u00a0return ans\n\u00a0\n# This is mainly a wrapper over recursive\n# function getMaxUtil().\n# This function creates a table for memoization and calls\n# getMaxUtil()\n\u00a0\ndef geMaxCollection(arr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a memoization table and\n\u00a0\u00a0\u00a0\u00a0# initialize all entries as -1\n\u00a0\u00a0\u00a0\u00a0mem=[[[-1 for i in range(C)] for i in range(C)] for i in range(R)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Calculation maximum value using\n\u00a0\u00a0\u00a0\u00a0# memoization based function\n\u00a0\u00a0\u00a0\u00a0# getMaxUtil()\n\u00a0\u00a0\u00a0\u00a0return getMaxUtil(arr, mem, 0, 0, C-1)\n\u00a0\n# Driver program to test above functions\nif __name__=='__main__':\n\u00a0\u00a0\u00a0\u00a0arr=[[3, 6, 8, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[5, 2, 4, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 20, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 20, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 20, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\n\u00a0\u00a0\u00a0\u00a0print('Maximum collection is ', geMaxCollection(arr))\n\u00a0\u00a0\u00a0\u00a0\u00a0\n#this code is contributed by sahilshelangia\n"}
{"nl": "List A is contained inside list B if each element in A also exists in B.\nThe number of times a number is present doesn't matter. In other words, if we transformed both lists into sets, A would be a subset of B.\nA = [3, 3, 9, 9, 9, 5]\nB = [1, 3, 9, 5, 8, 44, 44]\n\nA_Set = [3, 9, 5]\nB_Set = [1, 3, 9, 5, 8, 44]\n\n# A_Set is a subset of B_Set\nCreate a function that determines if the first list is a subset of the second.\nExamples\nsubset([1, 3], [1, 3, 3, 5]) \u279e True\n\nsubset([4, 8, 7], [7, 4, 4, 4, 9, 8]) \u279e True\n\nsubset([1, 3], [1, 33]) \u279e False\n\nsubset([1, 3, 10], [10, 8, 8, 8]) \u279e False\nNotes\nEach input list will have at least one element.\nCheck the resources tab for a hint.", "code": "def subset(lst1, lst2):\n    return set(lst1).issubset(set(lst2))"}
{"nl": "Given a dictionary, a method to do lookup in dictionary and a M x N board where every cell has one character. Find all possible words that can be formed by a sequence of adjacent characters. Note that we can move to any of 8 adjacent characters, but a word should not have multiple instances of same cell.", "code": "# Python3 program for Boggle game\r\n# Let the given dictionary be following\r\n \r\ndictionary = [\"GEEKS\", \"FOR\", \"QUIZ\", \"GO\"]\r\nn = len(dictionary)\r\nM = 3\r\nN = 3\r\n \r\n# A given function to check if a given string\r\n# is present in dictionary. The implementation is\r\n# naive for simplicity. As per the question\r\n# dictionary is given to us.\r\ndef isWord(Str):\r\n   \r\n    # Linearly search all words\r\n    for i in range(n):\r\n        if (Str == dictionary[i]):\r\n            return True\r\n    return False\r\n \r\n# A recursive function to print all words present on boggle\r\ndef findWordsUtil(boggle, visited, i, j, Str):\r\n    # Mark current cell as visited and\r\n    # append current character to str\r\n    visited[i][j] = True\r\n    Str = Str + boggle[i][j]\r\n     \r\n    # If str is present in dictionary,\r\n    # then print it\r\n    if (isWord(Str)):\r\n        print(Str)\r\n     \r\n    # Traverse 8 adjacent cells of boggle[i,j]\r\n    row = i - 1\r\n    while row <= i + 1 and row < M:\r\n        col = j - 1\r\n        while col <= j + 1 and col < N:\r\n            if (row >= 0 and col >= 0 and not visited[row][col]):\r\n                findWordsUtil(boggle, visited, row, col, Str)\r\n            col+=1\r\n        row+=1\r\n     \r\n    # Erase current character from string and\r\n    # mark visited of current cell as false\r\n    Str = \"\" + Str[-1]\r\n    visited[i][j] = False\r\n \r\n# Prints all words present in dictionary.\r\ndef findWords(boggle):\r\n   \r\n    # Mark all characters as not visited\r\n    visited = [[False for i in range(N)] for j in range(M)]\r\n     \r\n    # Initialize current string\r\n    Str = \"\"\r\n     \r\n    # Consider every character and look for all words\r\n    # starting with this character\r\n    for i in range(M):\r\n      for j in range(N):\r\n        findWordsUtil(boggle, visited, i, j, Str)\r\n \r\n# Driver Code\r\nboggle = [[\"G\", \"I\", \"Z\"], [\"U\", \"E\", \"K\"], [\"Q\", \"S\", \"E\"]]\r\n \r\nprint(\"Following words of\", \"dictionary are present\")\r\nfindWords(boggle)\r\n \r\n#  This code is contributed by divyesh072019."}
{"nl": "List Length\r\nTo determine how many items a list has, use the len() function:", "code": "thislist = [\"apple\", \"banana\", \"cherry\"]\r\nprint(len(thislist))"}
{"nl": "The maximum sub-array sum situation needs you to identify a continuous sub-array that has the highest sum.", "code": "def findKadane(givnList, listleng):\n    # Set both of the variablesto the value at the first index, i.e., givnList[0].\n    cur_maxi = givnList[0]\n    maxi_so_far = givnList[0]\n\n    for i in range(1, listleng):\n      # Store the maximum of givnList[i] and cur_maxi + givnList[i]\n      # in the cur_maxi for the following index i.\n        cur_maxi = max(givnList[i], cur_maxi + givnList[i])\n        # maxi_so_far stores the maximum of maxi_so_far and cur_maxi.\n        maxi_so_far = max(maxi_so_far, cur_maxi)\n    # return the maxi_so_far\n    return maxi_so_far\n\n\n# Give the array/list as user input using list(),map(),split() and input() functions.\n# Here the given numbers will get divided by space using the split() function.\n# The string numbers get converted to integer using map and int functions.\ngivnList = list(\n    map(int, input('Enter some random list numbers separated by spaces = ').split()))\n# Calculate the length of the given list\n# using the len() function and store it in a variable.\nlistleng = len(givnList)\n# Pass the given list and length of the given\n# list as an arguments to the findKadane function which implements the kadane's algorithm.\nresltsum = findKadane(givnList, listleng)\n# Print the maximum sum.\nprint('The maximum subarray sum of the given list', givnList, ':')\nprint(resltsum)"}
{"nl": "Given an octal number and the task is to get the respective decimal number using the while loop in Python.", "code": "# Give the octal number as user input using the int(input()) function and\n# store it in a variable.\ngvn_octl_numb = int(input(\"Enter some Random Number = \"))\n# Take a variable say 'a 'and initialize its value with 0.\na = 0\n# Take another variable say deciml_numb and initialize its value with 0.\ndeciml_numb = 0\n# Loop till the given octal number is not equal to zero using the while loop.\nprint(\"The Decimal value of the given Octal number {\", gvn_octl_numb, \"} is: \")\nwhile(gvn_octl_numb != 0):\n  # Inside the loop, calculate the value of the given octal number modulus 10\n  # (to get the last digit) and store it in a variable say 'b'.\n    b = (gvn_octl_numb % 10)\n# Calculate the value of 8 raised to the power 'a' using the pow() function and multiply\n# it with the above-obtained 'b'.\n# Store it in another variable 'c'.\n    c = b*pow(8, a)\n  # Add the above variable 'c' with the deciml_numb and store it in the same variable\n  # deciml_numb.\n    deciml_numb = deciml_numb+c\n  # Increment the value a by 1 and store it in the same variable 'a'.\n    a += 1\n# Divide the given octal number by 10 (to remove the last digit) and store it in the\n# same variable gvn_octl_numb.\n    gvn_octl_numb = gvn_octl_numb // 10\n# Print the deciml_num to get the decimal value of the given Octal number.\nprint(deciml_numb)"}
{"nl": "Python has a built-in function, calendar to work with date related tasks. You will learn to display the calendar of a given date in this example.  ", "code": "# Program to display calendar of the given month and year\n\n# importing calendar module\nimport calendar\n\nyy = 2014  # year\nmm = 11    # month\n\n# To take month and year input from the user\n# yy = int(input(\"Enter year: \"))\n# mm = int(input(\"Enter month: \"))\n\n# display the calendar\nprint(calendar.month(yy, mm))"}
{"nl": "Gravitational Force:\n\nThe gravitational force is a force that attracts any two mass-bearing objects. The gravitational force is called attractive because it always strives to pull masses together rather than pushing them apart. In reality, every thing in the cosmos, including you, is tugging on every other item! Newton\u2019s Universal Law of Gravitation is the name for this. You don\u2019t have a significant mass, thus you\u2019re not dragging on those other objects very much. Objects that are extremely far apart do not noticeably pull on each other either. However, the force exists and can be calculated.\n\nGravitational Force Formula :\n\nGravitational Force = ( G *  m1 * m2 ) / ( r ** 2 )\n\nGiven masses of two objects and the radius , the task is to calculate the Gravitational Force acting between the given two particles in Python.\n\nExamples:\n\nExample1:\n\nInput:\n\nmass1 = 1300012.67\nmass2 = 303213455.953\nradius = 45.4\nOutput:\n\nThe gravitational force of objects with masses 1300012.67 kg 303213455.953 kg  of radius= 45.4 = 12.761610184592419\nExample2:\n\nInput:\n\nEnter the first mass of the object =2491855.892 \nEnter the second mass of the object =9000872 \nEnter the distance/radius between the objects =50\nOutput:\n\nThe gravitational force of objects with masses 24918552.892 kg 23145689000872.0 kg of radius= 50.0 = 15394799.86164859", "code": "# given first mass\n mass1 = 1300012.67\n # given second mass\n mass2 = 303213455.953\n # enter the radius\n radius = 45.4\n # Given value of Gravitational Constant Gval\n Gval = 6.673*(10**(-11))\n # Calculating the value of the gravitational force Gforce\n Gforce = (Gval*mass1*mass2)/(radius**2)\n # printing the value of gravitational force\n print(\"The gravitational force of objects with masses\", str(mass1) +\n  \" kg \"+str(mass2)+\" kg \", \"of radius=\", radius, \"=\", Gforce)"}
{"nl": "Exercise 6: Return a set of elements present in Set A or B, but not both", "code": "set1 = {10, 20, 30, 40, 50}\r\nset2 = {30, 40, 50, 60, 70}\r\n\r\nprint(set1.symmetric_difference(set2))"}
{"nl": "Given two given arrays of equal length, the task is to find if given arrays are equal or not. Two arrays are said to be equal if both of them contain the same set of elements, arrangements (or permutation) of elements may be different though.\n\nNote: If there are repetitions, then counts of repeated elements must also be the same for two arrays to be equal. \n\nExamples : \n\nInput  : arr1[] = {1, 2, 5, 4, 0};\n         arr2[] = {2, 4, 5, 0, 1}; \nOutput : Yes\n\nInput  : arr1[] = {1, 2, 5, 4, 0, 2, 1};\n         arr2[] = {2, 4, 5, 0, 1, 1, 2}; \nOutput : Yes\n \nInput : arr1[] = {1, 7, 1};\n        arr2[] = {7, 7, 1};\nOutput : No", "code": "# Python3 program to find given\n# two array are equal or not\n\n# Returns true if arr1[0..n-1] and\n# arr2[0..m-1] contain same elements.\n\n\ndef areEqual(arr1, arr2, n, m):\n\n\t# If lengths of array are not\n\t# equal means array are not equal\n\tif (n != m):\n\t\treturn False\n\n\t# Sort both arrays\n\tarr1.sort()\n\tarr2.sort()\n\n\t# Linearly compare elements\n\tfor i in range(0, n):\n\t\tif (arr1[i] != arr2[i]):\n\t\t\treturn False\n\n\t# If all elements were same.\n\treturn True\n\n\n# Driver Code\narr1 = [3, 5, 2, 5, 2]\narr2 = [2, 3, 5, 5, 2]\nn = len(arr1)\nm = len(arr2)\n\nif (areEqual(arr1, arr2, n, m)):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n\n# This code is contributed\n# by Shivi_Aggarwal."}
{"nl": "You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.\n\nReturn true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.\n\nAn integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.\n\n ", "code": "class Solution:\n\ndef isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:\n    # loop throught the range from left and right, inclusively\n    for i in range(left, right + 1):\n        # check if the number is between any interval\n        # put this variable to see if the number is found in any range\n        in_range = False\n        for interval in ranges:\n            # if the number is found, we set the boolean true\n            if i >= interval[0] and i <= interval[1]:\n                in_range = True\n                break\n        if not in_range:\n            return False\n    \n    return True"}
{"nl": "Given a string that contains only the following => \u2018{\u2018, \u2018}\u2019, \u2018(\u2018, \u2018)\u2019, \u2018[\u2019, \u2018]\u2019. At some places there is \u2018X\u2019 in place of any bracket. Determine whether by replacing all \u2018X\u2019s with appropriate bracket, is it possible to make a valid bracket sequence.", "code": "# Python3 program to determine whether\n# given expression is balanced/ parenthesis\n# expression or not.\n\u00a0\n# Function to check if two brackets are\n# matching or not.\ndef isMatching(a, b):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if ((a == '{' and b == '}') or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a == '[' and b == ']') or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a == '(' and b == ')') or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a == 'X'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n# Recursive function to check if given\n# expression is balanced or not.\ndef isBalanced(s, ele, ind):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case.\n\u00a0\u00a0\u00a0\u00a0# If the string is balanced then all the\n\u00a0\u00a0\u00a0\u00a0# opening brackets had been popped and\n\u00a0\u00a0\u00a0\u00a0# stack should be empty after string is\n\u00a0\u00a0\u00a0\u00a0# traversed completely.\n\u00a0\u00a0\u00a0\u00a0if (ind == len(s)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if len(ele) == 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Variable to store element at the top\n\u00a0\u00a0\u00a0\u00a0# of the stack.\n\u00a0\u00a0\u00a0\u00a0# char topEle;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Variable to store result of\n\u00a0\u00a0\u00a0\u00a0# recursive call.\n\u00a0\u00a0\u00a0\u00a0# int res;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Case 1: When current element is an\n\u00a0\u00a0\u00a0\u00a0# opening bracket then push that\n\u00a0\u00a0\u00a0\u00a0# element in the stack.\n\u00a0\u00a0\u00a0\u00a0if (s[ind] == '{' or s[ind] == '(' or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s[ind] == '['):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ele.append(s[ind])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return isBalanced(s, ele, ind + 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Case 2: When current element is a closing\n\u00a0\u00a0\u00a0\u00a0# bracket then check for matching bracket\n\u00a0\u00a0\u00a0\u00a0# at the top of the stack.\n\u00a0\u00a0\u00a0\u00a0elif (s[ind] == '}' or s[ind] == ')' or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s[ind] == ']'):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If stack is empty then there is no matching\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# opening bracket for current closing bracket\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and the expression is not balanced.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(ele) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0topEle = ele[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ele.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check bracket is matching or not.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (isMatching(topEle, s[ind]) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return isBalanced(s, ele, ind + 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Case 3: If current element is 'X' then check\n\u00a0\u00a0\u00a0\u00a0# for both the cases when 'X' could be opening\n\u00a0\u00a0\u00a0\u00a0# or closing bracket.\n\u00a0\u00a0\u00a0\u00a0elif (s[ind] == 'X'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmp = ele\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmp.append(s[ind])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = isBalanced(s, tmp, ind + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (res):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(ele) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ele.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return isBalanced(s, ele, ind + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\ns = \"{(X}[]\"\nele = []\n\u00a0\nif (isBalanced(s, ele, 0)):\n\u00a0\u00a0\u00a0\u00a0print(\"Balanced\")\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"Not Balanced\")\n\u00a0\n# This code is contributed by divyeshrabadiya07\n"}
{"nl": "Write a function that receives two portions of a path and joins them. The portions will be joined with the \"/\" separator. There could be only one separator and if it is not present it should be added.\nExamples\njoin_path(\"portion1\", \"portion2\") \u279e \"portion1/portion2\"\n\njoin_path(\"portion1/\", \"portion2\") \u279e \"portion1/portion2\"\n\njoin_path(\"portion1\", \"/portion2\") \u279e \"portion1/portion2\"\n\njoin_path(\"portion1/\", \"/portion2\") \u279e \"portion1/portion2\"\nNotes\nTry not to solve this challenge using only if-else conditions.", "code": "def join_path(portion1, portion2):\n  return '/'.join((portion1.rstrip('/'), portion2.lstrip('/')))"}
{"nl": "Fibonacci sequence:\n\nA Fibonacci sequence is a sequence of integers which first two terms are 0 and 1 and all other terms of the sequence are obtained by adding their preceding two numbers.\n\nFor example: 0, 1, 1, 2, 3, 5, 8, 13 and so on...", "code": "def recur_fibo(n):  \n   if n <= 1:  \n       return n  \n   else:  \n       return(recur_fibo(n-1) + recur_fibo(n-2))  \n# take input from the user  \nnterms = int(input(\"How many terms? \"))  \n# check if the number of terms is valid  \nif nterms <= 0:  \n   print(\"Plese enter a positive integer\")  \nelse:  \n   print(\"Fibonacci sequence:\")  \n   for i in range(nterms):  \n       print(recur_fibo(i))  "}
{"nl": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        profit = 0\n        for i in range(1, len(prices)):\n            profit += max(prices[i]-prices[i-1], 0)\n        return profit"}
{"nl": "Given the length, breadth of the rectangle the task is to print the rectangle star pattern in C, C++, and Python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven length of rectangle =8\ngiven breadth of rectangle =29\nOutput:\n\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n* * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nExample2:\n\nInput:\n\ngiven length of rectangle =19\ngiven breadth of rectangle =5\nOutput:\n\n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * *", "code": "# Give the length and breadth as static input and store them in two variables.\nlengthnum = 8\nbreadthnum = 11\n# Loop till the length of the rectangle using For loop.\nfor m in range(lengthnum):\n  # Loop till the breadth of the rectangle using another nested For loop.\n  for n in range(breadthnum):\n  # Print the * character inside the nested For loop.\n  print('* ', end=' ')\n  print()"}
{"nl": "Instructions\nCompute the prime factors of a given natural number.\n\nA prime number is only evenly divisible by itself and 1.\n\nNote that 1 is not a prime number.\n\nExample\nWhat are the prime factors of 60?\n\nOur first divisor is 2. 2 goes into 60, leaving 30.\n2 goes into 30, leaving 15.\n2 doesn't go cleanly into 15. So let's move on to our next divisor, 3.\n3 goes cleanly into 15, leaving 5.\n3 does not go cleanly into 5. The next possible factor is 4.\n4 does not go cleanly into 5. The next possible factor is 5.\n5 does go cleanly into 5.\nWe're left only with 1, so now, we're done.\nOur successful divisors in that computation represent the list of prime factors of 60: 2, 2, 3, and 5.\n\nYou can check this yourself:\n\n2 * 2 * 3 * 5\n= 4 * 15\n= 60\nSuccess!\n", "code": "def factors(value):\r\n    prime = []\r\n    factor = 2\r\n    while value > 1:\r\n        if value % factor == 0:\r\n            prime.append(factor)\r\n            value /= factor\r\n        else:\r\n            factor += 1\r\n    return prime"}
{"nl": "Indira first year computer science student is taking an intro to RegEx class. Her professor gives her the assignment to write a function that checks whether an input date as a string is in the format yyyy/mm/dd. She has written a regular expression but the regular expression does not seem to be correct. Help her fix the error.\nExamples\nassignment(\"12/1/1\") \u279e False\n\nassignment(\"1234/12/01\") \u279e True\n\nassignment(\"2012/1/1\") \u279e False\n\nassignment(\"2012/01/07\") \u279e True\nNotes\nThe pattern may not be the only part of the code that needs fixing.\nCheck the Resources tab for help.", "code": "import re\ndef assignment(date):\n    return bool(re.match('^\\d{4}/\\d{2}/\\d{2}$', date))"}
{"nl": "Definition and Usage\r\nThe copy() method returns a copy of the specified list.\r\n\r\n", "code": "fruits = ['apple', 'banana', 'cherry', 'orange']\r\n\r\nx = fruits.copy()"}
{"nl": "A tree consisting of n nodes is given, we need to print its DFS.\n\n\n\u00a0", "code": "# Python3 code to perform DFS of given tree :\n\u00a0\n# DFS on tree\ndef dfs(List, node, arrival):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Printing traversed node\n\u00a0\u00a0\u00a0\u00a0print(node)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing adjacent edges\n\u00a0\u00a0\u00a0\u00a0for i in range(len(List[node])):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Not traversing the parent node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (List[node][i] != arrival):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dfs(List, List[node][i], node)\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Number of nodes\n\u00a0\u00a0\u00a0\u00a0nodes = 5\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Adjacency List\n\u00a0\u00a0\u00a0\u00a0List = [[] for i in range(10000)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Designing the tree\n\u00a0\u00a0\u00a0\u00a0List[1].append(2)\n\u00a0\u00a0\u00a0\u00a0List[2].append(1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0List[1].append(3)\n\u00a0\u00a0\u00a0\u00a0List[3].append(1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0List[2].append(4)\n\u00a0\u00a0\u00a0\u00a0List[4].append(2)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0List[3].append(5)\n\u00a0\u00a0\u00a0\u00a0List[5].append(3)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call\n\u00a0\u00a0\u00a0\u00a0dfs(List, 1, 0)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Suppose we have a given number, \"K\", and we have to check whether the given number is an Armstrong number or not. In this tutorial, we will learn how to identify the given number is an Armstrong number or not using Python.\n\nDefinition:\nA positive number of \"p\" number of digits is called an Armstrong number of order n (order is the number of digits) if:\n\nabcde? = pow(a, p) + pow(b, p) + pow(c, p) + pow(d, p) + pow(e, p) + ?  ", "code": "def power_1(A, B):  \n        \n    if B == 0:  \n        return 1  \n    if B % 2 == 0:  \n        return power_1(A, B // 2) * power(A, B // 2)  \n            \n    return A * power(A, B // 2) * power(A, B // 2)  \n    \n# Function for calculating \"order of the number\"  \ndef order_1(A):  \n    \n    # Variable for storing the number  \n    N = 0  \n    while (A != 0):  \n        N = N + 1  \n        A = A // 10  \n            \n    return N  \n    \n# Function for checking if the given number is Armstrong number or not  \ndef is_Armstrong(A):  \n        \n    N = order_1(A)  \n    temp_1 = A  \n    sum_1 = 0  \n        \n    while (temp_1 != 0):  \n        R_1 = temp_1 % 10  \n        sum_1 = sum_1 + power_1(R_1, N)  \n        temp_1 = temp_1 // 10  \n    \n    # If the above condition is satisfied, it will return the result  \n    return (sum_1 == A)  \n    \n# Driver code  \nA = int(input(\"Please enter the number to be checked: \"))  \nprint(is_Armstrong(A))  \n"}
{"nl": "Given a linked list, write a function to reverse every k nodes (where k is an input to the function). \n\n", "code": "\n# Python program to reverse a\n# linked list in group of given size\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    def reverse(self, head, k):\n       \n        if head == None:\n          return None\n        current = head\n        next = None\n        prev = None\n        count = 0\n \n        # Reverse first k nodes of the linked list\n        while(current is not None and count < k):\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n            count += 1\n \n        # next is now a pointer to (k+1)th node\n        # recursively call for the list starting\n        # from current. And make rest of the list as\n        # next of first node\n        if next is not None:\n            head.next = self.reverse(next, k)\n \n        # prev is new head of the input list\n        return prev\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the linked LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data,end=' ')\n            temp = temp.next\n "}
{"nl": "Given a string with repeated characters, the task is to rearrange characters in a string so that no two adjacent characters are same.\nNote : It may be assumed that the string has only lowercase English alphabets.\nExamples: \n \n\nInput: aaabc \nOutput: abaca \n\nInput: aaabb\nOutput: ababa \n\nInput: aa \nOutput: Not Possible\n\nInput: aaaabc \nOutput: Not Possible", "code": "# Python program for rearranging characters in a string such\n# that no two adjacent are same\n\n# Function to find the char with maximum frequency in the given\n# string\ndef getMaxCountChar(count):\nmaxCount = 0\nfor i in range(26):\n\tif count[i] > maxCount:\n\t\tmaxCount = count[i]\n\t\tmaxChar = chr(i + ord('a'))\n\nreturn maxCount, maxChar\n\n# Main function for rearranging the characters\ndef rearrangeString(S):\nn = len(S)\n\n# if length of string is None return False\nif not n:\n\treturn False\n\t\n# create a hashmap for the alphabets\ncount = [0] * 26\nfor char in S:\n\tcount[ord(char) - ord('a')] += 1\n\n\nmaxCount, maxChar = getMaxCountChar(count)\n\n# if the char with maximum frequency is more than the half of the\n# total length of the string than return False\nif maxCount > (n + 1) // 2:\n\treturn False\n\n# create a list for storing the result\nres = [None] * n\n\nind = 0\n\n# place all occurrences of the char with maximum frequency in\n# even positions\nwhile maxCount:\n\tres[ind] = maxChar\n\tind += 2\n\tmaxCount -= 1\n\t\n# replace the count of the char with maximum frequency to zero\n# as all the maxChar are already placed in the result\ncount[ord(maxChar) - ord('a')] = 0\n\n# place all other char in the result starting from remaining even\n# positions and then place in the odd positions\nfor i in range(26):\n\twhile count[i] > 0:\n\t\tif ind >= n:\n\t\t\tind = 1\n\t\tres[ind] = chr(i + ord('a') )\n\t\tind += 2\n\t\tcount[i] -= 1\n\n\n# convert the result list to string and return\nreturn ''.join(res)\n\n# Driver Code\nstr = 'bbbaa'\nres = rearrangeString(str)\nif res:\nprint(res)\nelse:\nprint('Not valid string')\n\n# This code is contributed by Manish Thapa"}
{"nl": "Hermione has come up with a precise formula for determining whether or not a phrase was ssspoken by a parssseltongue (a reference from the Harry Potter universe; the language of ssserpents and those who can converse with them).\nEach word in a sssentence must contain either:\nTwo or more consecutive instances of the letter \"s\" (i.e. must be together ss..), or...\nZero instances of the letter \"s\" by itself.\nExamples\nis_parsel_tongue(\"Sshe ssselects to eat that apple. \") \u279e True\n\nis_parsel_tongue(\"She ssselects to eat that apple. \") \u279e False\n# \"She\" only contains one \"s\".\n\nis_parsel_tongue(\"Beatrice samples lemonade\") \u279e False\n# While \"samples\" has 2 instances of \"s\", they are not together.\n\nis_parsel_tongue(\"You ssseldom sssspeak sso boldly, ssso messmerizingly.\") \u279e True\nNotes\nN/A", "code": "def is_parsel_tongue(sentence):\n  return all('ss' in word or 's' not in word for word in sentence.lower().split())"}
{"nl": "Machine learning is a process that is widely used for prediction. N number of algorithms are available in various libraries which can be used for prediction. In this article, we are going to build a prediction model on historic data using different machine learning algorithms and classifiers, plot the results and calculate the accuracy of the model on the testing data. \r\nBuilding/Training a model using various algorithms on a large dataset is one part of the data. But using these model within different application is second part of deploying machine learning in the real world.\r\nTo put it to use in order to predict the new data, we have to deploy it over the internet so that the outside world can use it. In this article, we will talk about how we have trained a machine learning model, created a web application on it using Flask.\r\nWe have to install many required libraries which will be used in this model. Use pip command to install all the libraries. ", "code": "# importing the dataset\r\nimport pandas\r\nimport numpy\r\nfrom sklearn import preprocessing\r\n \r\ndf = pandas.read_csv('adult.csv')   \r\ndf.head()\r\ndf = df.drop(['fnlwgt', 'educational-num'], axis = 1)\r\n \r\ncol_names = df.columns\r\n \r\nfor c in col_names:\r\n    df = df.replace(\"?\", numpy.NaN)\r\ndf = df.apply(lambda x:x.fillna(x.value_counts().index[0]))\r\ndf.replace(['Divorced', 'Married-AF-spouse',\r\n              'Married-civ-spouse', 'Married-spouse-absent',\r\n              'Never-married', 'Separated', 'Widowed'],\r\n             ['divorced', 'married', 'married', 'married',\r\n              'not married', 'not married', 'not married'], inplace = True)\r\n \r\ncategory_col =['workclass', 'race', 'education', 'marital-status', 'occupation',\r\n               'relationship', 'gender', 'native-country', 'income']\r\nlabelEncoder = preprocessing.LabelEncoder()\r\n \r\nmapping_dict ={}\r\nfor col in category_col:\r\n    df[col] = labelEncoder.fit_transform(df[col])\r\n \r\n    le_name_mapping = dict(zip(labelEncoder.classes_,\r\n                        labelEncoder.transform(labelEncoder.classes_)))\r\n \r\n    mapping_dict[col]= le_name_mapping\r\nprint(mapping_dict)\r\nfrom sklearn.model_selection import train_test_split\r\nfrom sklearn.tree import DecisionTreeClassifier\r\nfrom sklearn.metrics import accuracy_score\r\n \r\nX = df.values[:, 0:12]\r\nY = df.values[:, 12]\r\nX_train, X_test, y_train, y_test = train_test_split(\r\n           X, Y, test_size = 0.3, random_state = 100)\r\n \r\ndt_clf_gini = DecisionTreeClassifier(criterion = \"gini\",\r\n                                     random_state = 100,\r\n                                     max_depth = 5,\r\n                                     min_samples_leaf = 5)\r\n \r\ndt_clf_gini.fit(X_train, y_train)\r\ny_pred_gini = dt_clf_gini.predict(X_test)\r\n \r\nprint (\"Decision Tree using Gini Index\\nAccuracy is \",\r\n             accuracy_score(y_test, y_pred_gini)*100 )\r\n# prediction function\r\ndef ValuePredictor(to_predict_list):\r\n    to_predict = np.array(to_predict_list).reshape(1, 12)\r\n    loaded_model = pickle.load(open(\"model.pkl\", \"rb\"))\r\n    result = loaded_model.predict(to_predict)\r\n    return result[0]\r\n \r\n@app.route('/result', methods = ['POST'])\r\ndef result():\r\n    if request.method == 'POST':\r\n        to_predict_list = request.form.to_dict()\r\n        to_predict_list = list(to_predict_list.values())\r\n        to_predict_list = list(map(int, to_predict_list))\r\n        result = ValuePredictor(to_predict_list)       \r\n        if int(result)== 1:\r\n            prediction ='Income more than 50K'\r\n        else:\r\n            prediction ='Income less that 50K'           \r\n        return render_template(\"result.html\", prediction = prediction)"}
{"nl": "Scientists have discovered that in four decades, the world will EXPLODE! It will also take three decades to make a spaceship to travel to a new planet that can hold the entire world population.\nYou must calculate the number of people there will be in three decades from now.\nThe variable P is the world population now.\nAssume that every month, someone gives birth to more people nP.\nReturn the number of people there will be when the spaceship is complete.\nExamples\nfuture_people(256, 2) \u279e 976\n\nfuture_people(3248, 6) \u279e 5408\n\nfuture_people(5240, 3) \u279e 6320\nNotes\nHumanity's fate lies in your calculation.", "code": "def future_people(P, nP):\n  return P+360*nP"}
{"nl": "This Python program checks whether a given number by user is even or odd using Conditional Operator.", "code": "# Check Even or Odd Using Conditional Operator\r\n\r\nnumber = int(input(\"Enter number: \"))\r\n\r\nprint(\"ODD\") if number%2 else print(\"EVEN\")"}
{"nl": "Given a set of n nuts of different sizes and n bolts of different sizes. There is a one-one mapping between nuts and bolts. Match nuts and bolts efficiently. \r\nConstraint: Comparison of a nut to another nut or a bolt to another bolt is not allowed. It means nut can only be compared with bolt and bolt can only be compared with nut to see which one is bigger/smaller.\r\nAnother way of asking this problem is, given a box with locks and keys where one lock can be opened by one key in the box. We need to match the pair.", "code": "# Python program to solve nut and bolt\r\n# problem using Quick Sort.\r\nfrom typing import List\r\n \r\n# Method to print the array\r\ndef printArray(arr: List[str]) -> None:\r\n    for i in range(6):\r\n        print(\" {}\".format(arr[i]), end=\" \")\r\n    print()\r\n \r\n# Similar to standard partition method.\r\n# Here we pass the pivot element too\r\n# instead of choosing it inside the method.\r\ndef partition(arr: List[str], low: int, high: int, pivot: str) -> int:\r\n    i = low\r\n    j = low\r\n    while j < high:\r\n        if (arr[j] < pivot):\r\n            arr[i], arr[j] = arr[j], arr[i]\r\n            i += 1\r\n        elif (arr[j] == pivot):\r\n            arr[j], arr[high] = arr[high], arr[j]\r\n            j -= 1\r\n        j += 1\r\n    arr[i], arr[high] = arr[high], arr[i]\r\n \r\n    # Return the partition index of\r\n    # an array based on the pivot\r\n    # element of other array.\r\n    return i\r\n \r\n# Function which works just like quick sort\r\ndef matchPairs(nuts: List[str], bolts: List[str], low: int, high: int) -> None:\r\n    if (low < high):\r\n \r\n        # Choose last character of bolts\r\n        # array for nuts partition.\r\n        pivot = partition(nuts, low, high, bolts[high])\r\n \r\n        # Now using the partition of nuts\r\n        # choose that for bolts partition.\r\n        partition(bolts, low, high, nuts[pivot])\r\n \r\n        # Recur for [low...pivot-1] &\r\n        # [pivot+1...high] for nuts and\r\n        # bolts array.\r\n        matchPairs(nuts, bolts, low, pivot - 1)\r\n        matchPairs(nuts, bolts, pivot + 1, high)\r\n \r\n# Driver code\r\nif __name__ == \"__main__\":\r\n \r\n    # Nuts and bolts are represented\r\n    # as array of characters\r\n    nuts = ['@', '#', '$', '%', '^', '&']\r\n    bolts = ['$', '%', '&', '^', '@', '#']\r\n \r\n    # Method based on quick sort which\r\n    # matches nuts and bolts\r\n    matchPairs(nuts, bolts, 0, 5)\r\n    print(\"Matched nuts and bolts are : \")\r\n    printArray(nuts)\r\n    printArray(bolts)\r\n \r\n# This code is contributed by sanjeev2552"}
{"nl": "Given an undirected and connected graph and a number n, count total number of cycles of length n in the graph. A cycle of length n simply means that the cycle contains n vertices and n edges. And we have to count all such cycles that exist.\u00a0\n\n\u00a0", "code": "# Python Program to count\n# cycles of length n\n# in a given graph.\n\u00a0\u00a0\n# Number of vertices\nV = 5\n\u00a0\ndef DFS(graph, marked, n, vert, start, count):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# mark the vertex vert as visited\n\u00a0\u00a0\u00a0\u00a0marked[vert] = True\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if the path of length (n-1) is found\n\u00a0\u00a0\u00a0\u00a0if n == 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark vert as un-visited to make\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# it usable again.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0marked[vert] = False\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if vertex vert can end with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# vertex start\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if graph[vert][start] == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = count + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# For searching every possible path of\n\u00a0\u00a0\u00a0\u00a0# length (n-1)\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if marked[i] == False and graph[vert][i] == 1:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# DFS for searching path by decreasing\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# length by 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = DFS(graph, marked, n-1, i, start, count)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# marking vert as unvisited to make it\n\u00a0\u00a0\u00a0\u00a0# usable again.\n\u00a0\u00a0\u00a0\u00a0marked[vert] = False\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\n# Counts cycles of length\n# N in an undirected\n# and connected graph.\ndef countCycles( graph, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# all vertex are marked un-visited initially.\n\u00a0\u00a0\u00a0\u00a0marked = [False] * V\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Searching for cycle by using v-n+1 vertices\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(V-(n-1)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = DFS(graph, marked, n-1, i, i, count)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# ith vertex is marked as visited and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# will not be visited again.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0marked[i] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return int(count/2)\n\u00a0\u00a0\n# main :\ngraph = [[0, 1, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1 ,0 ,1 ,0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 1, 0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 0, 1, 0]]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nn = 4\nprint(\"Total cycles of length \",n,\" are \",countCycles(graph, n))\n\u00a0\n# this code is contributed by Shivani Ghughtyal\n"}
{"nl": "Create a function that takes a number a and finds the missing exponent x so that a when raised to the power of x is equal to b.\nExamples\nsolve_for_exp(4, 1024) \u279e 5\n\nsolve_for_exp(2, 1024) \u279e 10\n\nsolve_for_exp(9, 3486784401) \u279e 10\nNotes\na is raised to the power of what in order to equal b?", "code": "from math import log\ndef solve_for_exp(a, b):\n  return round(log(b,a))"}
{"nl": "Given the number N, the task is to print the first n numbers of the pell series in Python.\n Pell Series:\n The Pell Series is a series in which the next number equals the sum of twice the previous number and the number preceding the previous number.\n It begins with 1 and 2.\n Pell Numbers: 1,2,5,12,29,70,169,\u2026\n Consider the following number sequence and try to match it to the definition of the Pell Series:\n 1 + 2 x 2 = 5\n 2 + 5* 2 = 12\n 5 + 12 x 2 = 29\n 12 + 29*2 = 70\n 29 + 70*2 = 169\n and so on\u2026\n Now that you have a clear idea of what the Pell Series are, let\u2019s move on to how we shall write the Python code to generate the same.\n Examples:\n Example1:\n Given number = 12\n Input:\n The first 12 numbers of the pell series are :\n \n 1 2 5 12 29 70 169 408 985 2378 5741 13860\n Output:\n Example2:\n Input:\n Given number = 21\n Output:\n The first 21 numbers of the pell series are :\n \n 1 2 5 12 29 70 169 408 985 2378 5741 13860 33461 80782 195025 470832 1136689 2744210 6625109\n \n  15994428 38613965", "code": "# Give the number N as static input and store it in a variable.\n \n numb = 21\n \n # Take a variable temp1 and initialize it to 1.\n \n temp1 = 1\n \n # Take another variable temp2 and initialize it to 2.\n \n temp2 = 2\n \n # Take the third variable temp3 and initialize it to 0.\n \n temp3 = 0\n \n # Now, print the first two numbers in the series,\n \n # and we'll print the other generated numbers in the order they were generated.\n \n print('The first', numb, 'numbers of the pell series are :')\n \n print(temp1, temp2, end=' ')\n \n # Loop till number -2 using For loop.\n \n for i in range(numb-2):\n \n  # Add the value of temp1 and twice the temp2 value\n \n  # and initialize the temp3 with this value.\n \n  temp3 = temp1+2*temp2\n \n  # Swap the previous number for the previous number's predecessor (temp1 =temp2).\n \n  temp1 = temp2\n \n  # Swap the generated and previously generated numbers (temp2 = temp3)\n \n  temp2 = temp3\n \n  # Print the value of temp3.\n \n  print(temp3, end=' ')\n \n </pre>"}
{"nl": "The math.cos() method returns the cosine of a number.\r\n\r\n", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the cosine of different numbers\r\nprint (math.cos(0.00))\r\nprint (math.cos(-1.23))\r\nprint (math.cos(10))\r\nprint (math.cos(3.14159265359))"}
{"nl": "The nonlocal keyword is used to work with variables inside nested functions, where the variable should not belong to the inner function.\r\n\r\nUse the keyword nonlocal to declare that the variable is not local.", "code": "def myfunc1():\r\n  x = \"John\"\r\n  def myfunc2():\r\n    nonlocal x\r\n    x = \"hello\"\r\n  myfunc2()\r\n  return x\r\n\r\nprint(myfunc1())"}
{"nl": "Definition and Usage\r\nThe difference_update() method removes the items that exist in both sets.\r\n\r\nThe difference_update() method is different from the difference() method, because the difference() method returns a new set, without the unwanted items, and the difference_update() method removes the unwanted items from the original set.\r\n\r\n", "code": "x = {\"apple\", \"banana\", \"cherry\"}\r\ny = {\"google\", \"microsoft\", \"apple\"}\r\n\r\nx.difference_update(y)\r\n\r\nprint(x)"}
{"nl": "This is a simple program to create an array and then to print it's all elements.\n\nNow, just know about arrays.\n\nArrays are the special variables that store multiple values under the same name in the contiguous memory allocation. Elements of the array can be accessed through their indexes.\n\nPython program to print the elements of an array\nHere, 1, 2, 3, 4 and 5 represent the elements of the array. These elements can be accessed through their corresponding indexes, 1.e., 0, 1, 2, 3 and 4.", "code": "#Initialize array     \narr = [1, 2, 3, 4, 5];     \n     \nprint(\"Elements of given array: \");    \n#Loop through the array by incrementing the value of i     \n    \nfor i in range(0, len(arr)):    \n    print(arr[i]),    "}
{"nl": "Find sum of Even Factors of a Number (Static Input)", "code": "# Give the number as static input and store it in a variable.\r\ngvn_numb = 24\r\n# Take an empty list and store it in another variable.\r\nall_factors = []\r\n# Loop from '1' to above given number range using For loop.\r\nfor itr in range(1, gvn_numb+1):\r\n    # Check whether the given number modulus iterator value is equal to '0' or not\r\n    # using if conditional statement.\r\n    if gvn_numb % itr == 0:\r\n# If the statement is True, Check if the iterator modulus 2 is equal to 0 using the\r\n# if conditional statement.\r\n        if itr % 2 == 0:\r\n            # If the statement is True ,append the iterator value to the above declared list .\r\n            all_factors.append(itr)\r\n      # Get the sum of all the even factors of above got list using built-in sum() function\r\n      # and store it in another variable.\r\nreslt = sum(all_factors)\r\n# Print the sum of all even factors of a given number.\r\nprint(\"The Sum of all even factors of {\", gvn_numb, \"}  = \", reslt)"}
{"nl": "In the previous post, we introduced Queue and discussed array implementation. In this post, linked list implementation is discussed. The following two main operations must be implemented efficiently.\nIn a Queue data structure, we maintain two pointers, front and rear. The front points the first item of queue and rear points to last item.\nenQueue() This operation adds a new node after rear and moves rear to the next node.\ndeQueue() This operation removes the front node and moves front to the next node.", "code": "# Python3 program to demonstrate linked list\n# based implementation of queue\n\n# A linked list (LL) node\n# to store a queue entry\nclass Node:\n\t\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\n# A class to represent a queue\n\n# The queue, front stores the front node\n# of LL and rear stores the last node of LL\nclass Queue:\n\t\n\tdef __init__(self):\n\t\tself.front = self.rear = None\n\n\tdef isEmpty(self):\n\t\treturn self.front == None\n\t\n\t# Method to add an item to the queue\n\tdef EnQueue(self, item):\n\t\ttemp = Node(item)\n\t\t\n\t\tif self.rear == None:\n\t\t\tself.front = self.rear = temp\n\t\t\treturn\n\t\tself.rear.next = temp\n\t\tself.rear = temp\n\n\t# Method to remove an item from queue\n\tdef DeQueue(self):\n\t\t\n\t\tif self.isEmpty():\n\t\t\treturn\n\t\ttemp = self.front\n\t\tself.front = temp.next\n\n\t\tif(self.front == None):\n\t\t\tself.rear = None\n\n# Driver Code\nif __name__== '__main__':\n\tq = Queue()\n\tq.EnQueue(10)\n\tq.EnQueue(20)\n\tq.DeQueue()\n\tq.DeQueue()\n\tq.EnQueue(30)\n\tq.EnQueue(40)\n\tq.EnQueue(50)\n\tq.DeQueue()\n\tprint(\"Queue Front \" + str(q.front.data))\n\tprint(\"Queue Rear \" + str(q.rear.data))\n\t"}
{"nl": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\nReturn nums after the rearrangement.", "code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        left = []\n        mid = []\n        right = []\n        for n in nums:\n            if n < pivot:\n                left.append(n)\n            elif n == pivot:\n                mid.append(n)\n            elif n > pivot:\n                right.append(n)\n        return left + mid + right"}
{"nl": "Given an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'.\n\nReturn the number of positive integers that can be generated that are less than or equal to a given integer n.\n\n \n\nExample 1:\n\nInput: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\nOutput: 20\nExplanation: \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\nExample 2:\n\nInput: digits = [\"1\",\"4\",\"9\"], n = 1000000000\nOutput: 29523\nExplanation: \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\nExample 3:\n\nInput: digits = [\"7\"], n = 8\nOutput: 1\n \n\nConstraints:\n\n1 <= digits.length <= 9\ndigits[i].length == 1\ndigits[i] is a digit from '1' to '9'.\nAll the values in digits are unique.\ndigits is sorted in non-decreasing order.\n1 <= n <= 109", "code": "class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        sn = str(n)\n        ln = len(sn)\n        res = 0\n        digits = tuple(digits)\n        for l in range(1,ln+1):\n            part = self.dfs(sn,l,digits)\n            res += part\n        return res\n    def dfs(self,sn,l,digits):\n        # return the number of numbers 1) whose length is l 2) constructed only using numbers from digits 3) smaller than sn \n        if l < len(sn):\n            return len(digits) ** l\n        elif l > len(sn):\n            return 0\n        else:\n            res = 0\n            for d in digits:\n                d = int(d)\n                if d == int(sn[0]):\n                    res += self.dfs(sn[1:],l-1,digits) if l-1 > 0 else 1\n                    break\n                elif d > int(sn[0]):\n                    res += 0\n                    break\n                else:  # d < int(sn[0])\n                    res += len(digits) ** (len(sn) - 1)\n            return res"}
{"nl": "Create a function that takes a dictionary representing student information and calculates the Grade Point Average using the formula explained below, and returns the following string:\nsol_format  = a\na = \"{student_name from dict} GPA for {student_semester from dict} is calculated_gpa\"\n\n# Formula Grade Point Average\n\n# Quality Points :  A -> 4  B -> 3  C -> 2  D -> 1  F -> 0\n# Example : grades  =[\"A\",\"A\"]  credit_hrs = [3,3]\n# gpa = totalpoints / totalcredithrs = (4 * 3 + 4 * 3) / (3 + 3) -> 4.00\n# Rounded to 2 Decimal Places\nExamples\ngpa_calculator({\"name\": \"Ansha Mandal\", \"courses\": [{\"name\": \"cal1\", \"credit_hours\": 5, \"grade\": \"A\"}, {\"name\": \"kin1\", \"credit_hours\": 3, \"grade\": \"A\"}], \"semester\": \"Spring 2018\"}) \u279e \"Ansha Mandal GPA for Spring 2018 is 4.00\"\nNotes\nGPA is rounded to two decimal places.", "code": "def gpa_calculator(student):\n    pts = {'A':4, 'B':3, 'C':2, 'D':1, 'F':0}\n    qp = []\n    hr = []\n    for c in student['courses']:\n        qp.append(pts[c['grade']])\n        hr.append(c['credit_hours'])\n    num = sum([qp[i]*hr[i] for i in range(len(qp))])\n    den = sum(hr)\n    av = \"% 4.2f\" % (num / den)\n    return student['name'] + ' GPA for ' + student['semester'] + ' is' + av"}
{"nl": "Given a binary tree, we need to check it has heap property or not, Binary tree need to fulfill the following two conditions for being a heap \u2013 \n\nIt should be a complete tree (i.e. all levels except last should be full).\nEvery node\u2019s value should be greater than or equal to its child node (considering max-heap).", "code": "# To check if a binary tree\n# is a MAX Heap or not\n\n\nclass GFG:\n\tdef __init__(self, value):\n\t\tself.key = value\n\t\tself.left = None\n\t\tself.right = None\n\n\tdef count_nodes(self, root):\n\t\tif root is None:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn (1 + self.count_nodes(root.left) +\n\t\t\t\t\tself.count_nodes(root.right))\n\n\tdef heap_property_util(self, root):\n\n\t\tif (root.left is None and\n\t\t\t\troot.right is None):\n\t\t\treturn True\n\n\t\tif root.right is None:\n\t\t\treturn root.key >= root.left.key\n\t\telse:\n\t\t\tif (root.key >= root.left.key and\n\t\t\t\t\troot.key >= root.right.key):\n\t\t\t\treturn (self.heap_property_util(root.left) and\n\t\t\t\t\t\tself.heap_property_util(root.right))\n\t\t\telse:\n\t\t\t\treturn False\n\n\tdef complete_tree_util(self, root,\n\t\t\t\t\t\tindex, node_count):\n\t\tif root is None:\n\t\t\treturn True\n\t\tif index >= node_count:\n\t\t\treturn False\n\t\treturn (self.complete_tree_util(root.left, 2 *\n\t\t\t\t\t\t\t\t\t\tindex + 1, node_count) and\n\t\t\t\tself.complete_tree_util(root.right, 2 *\n\t\t\t\t\t\t\t\t\t\tindex + 2, node_count))\n\n\tdef check_if_heap(self):\n\t\tnode_count = self.count_nodes(self)\n\t\tif (self.complete_tree_util(self, 0, node_count) and\n\t\t\t\tself.heap_property_util(self)):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\n\n# Driver Code\nroot = GFG(5)\nroot.left = GFG(2)\nroot.right = GFG(3)\nroot.left.left = GFG(1)\n\nif root.check_if_heap():\n\tprint(\"Given binary tree is a heap\")\nelse:\n\tprint(\"Given binary tree is not a Heap\")\n\n# This code has been\n# contributed by Yash Agrawal"}
{"nl": "Create a function that takes four lists as arguments and returns a count of the total number of identical lists.\nExamples\ncount_identical_lists([0, 0, 0], [0, 1, 2], [0, 0, 0], [2, 1, 0]) \u279e 2\n\ncount_identical_lists([0, 1, 0], [0, 1, 2], [0, 2, 0], [2, 1, 0]) \u279e 0\n\ncount_identical_lists([0, 1, 2], [0, 1, 2], [0, 1, 2], [2, 1, 0]) \u279e 3\nNotes\nDon't forget to return the result.\nIf you get stuck on a challenge, find help in the Resources tab.\nIf you're really stuck, unlock solutions in the Solutions tab.", "code": "def count_identical_lists(lst1, lst2, lst3, lst4):\n  thicboi = [lst1, lst2, lst3, lst4]\n  res =  max(thicboi.count(x) for x in thicboi)\n  return res if res > 1 else 0"}
{"nl": "Print all Happy Numbers within a given Range (User Input)", "code": "# Create a function digitSquareSum() that accepts the given number\r\n# as an argument and returns the sum of squares of digits.\r\n\r\n\r\ndef digitSquareSum(resltnumber):\r\n    # Inside the digitSquareSum() function.\r\n    # Convert the given argument to string using the str() function.\r\n    strnumbe = str(resltnumber)\r\n    # Convert the given argument into list of digits using list(),map(),int() functions.\r\n    # Store it in a variable.\r\n    numbrlistdigits = list(map(int, strnumbe))\r\n    # Take a variable sumsquaredigits and initialize its value to 0.\r\n    sumsquaredigits = 0\r\n    # Loop in this digits list using For loop.\r\n    for digitvalu in numbrlistdigits:\r\n        # Increment the value of sumsquaredigits by the square\r\n        # of the digit(iterator value).\r\n        sumsquaredigits = sumsquaredigits+(digitvalu**2)\r\n    # Return the sumsquaredigits value\r\n    return sumsquaredigits\r\n\r\n# Create a function checkhapppynumb() which accepts the number as an argument\r\n# and returns true if it is happy number else returns False.\r\n\r\n\r\ndef checkhapppynumb(numb):\r\n    # Take a variable rest and initialize its value to the given argument.\r\n    rest = numb\r\n    # Loop till the rest is not equal to 1 or 4 using while loop.\r\n    while(rest != 1 and rest != 4):\r\n        # Inside the loop pass the reslt value to digitSquareSum()\r\n        # and store it in the same variable reslt.\r\n        rest = digitSquareSum(rest)\r\n    # After the end of the while loop,\r\n    # Check whether rest value is 1 or not using the If statement.\r\n    if(rest == 1):\r\n        # If it is true then the given number is a happy number so return True\r\n        return True\r\n    else:\r\n        # Else it is not a happy number so return False.\r\n        return False\r\n\r\n\r\n# Give the lower limit range and upper limit range as\r\n# user input using map(),int(),split() functions.\r\n# Store them in two separate variables.\r\nlowlimrange, upplimrange = map(int, input(\r\n    'Enter lower limit range and upper limit range separate bt spaces = ').split())\r\nprint('The Harshad numbers in the given range',\r\n      lowlimrange, 'and', upplimrange, 'are:')\r\nprint('The happy numbers in the given range',\r\n      lowlimrange, 'and', upplimrange, 'are:')\r\n# Loop from lower limit range to upper limit range using For loop.\r\nfor l in range(lowlimrange, upplimrange+1):\r\n        # IInside the for loop pass the iterator value to checkhapppynumb() function.\r\n    if(checkhapppynumb(l)):\r\n        # If it returns true then print the iterator value.\r\n        print(l, end=' ')"}
{"nl": "In this post, we will discuss how to remove items or elements from the list using the pop() method. Python provides built-in function pop() that removes and returns the last value from the list or the given index value. This method takes a single argument (index). The argument passed to the method is optional. If not passed, the default index -1 is passed as an argument (index of the last element).", "code": "# Python program to remove element from list by index # take list my_list = ['C', 'Java', 'Python', 'HTML', 'Javascript'] # printing original list print('List:', my_list) # removed index 3 item from the list my_list.pop(3) # print list after item deletion print('New list:', my_list)"}
{"nl": "Create a function that accepts a string as an argument and returns the first non-repeated character.\nExamples\nfirst_non_repeated_character(\"g\") \u279e \"g\"\n\nfirst_non_repeated_character(\"it was then the frothy word met the round night\") \u279e \"a\"\n\nfirst_non_repeated_character(\"the quick brown fox jumps then quickly blows air\") \u279e \"f\"\n\nfirst_non_repeated_character(\"hheelloo\") \u279e False\n\nfirst_non_repeated_character(\"\") \u279e False\nNotes\nAn empty string should return False.\nIf every character repeats, return False.\nDon't worry about case sensitivity or non-alphanumeric characters.", "code": "def first_non_repeated_character(txt):\n  for c in txt:\n    if txt.count(c) == 1:\n      return c\n  return False"}
{"nl": "Given a Doubly Linked List, the task is to reverse the given Doubly Linked List.", "code": "# Program to reverse a doubly linked list\n\n# A node of the doubly linked list\n\n\nclass Node:\n\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\t\tself.prev = None\n\n\nclass DoublyLinkedList:\n\t# Constructor for empty Doubly Linked List\n\tdef __init__(self):\n\t\tself.head = None\n\n\t# Function reverse a Doubly Linked List\n\tdef reverse(self):\n\t\ttemp = None\n\t\tcurrent = self.head\n\n\t\t# Swap next and prev for all nodes of\n\t\t# doubly linked list\n\t\twhile current is not None:\n\t\t\ttemp = current.prev\n\t\t\tcurrent.prev = current.next\n\t\t\tcurrent.next = temp\n\t\t\tcurrent = current.prev\n\n\t\t# Before changing head, check for the cases like\n\t\t# empty list and list with only one node\n\t\tif temp is not None:\n\t\t\tself.head = temp.prev\n\n\t# Given a reference to the head of a list and an\n\t# integer,inserts a new node on the front of list\n\tdef push(self, new_data):\n\n\t\t# 1. Allocates node\n\t\t# 2. Put the data in it\n\t\tnew_node = Node(new_data)\n\n\t\t# 3. Make next of new node as head and\n\t\t# previous as None (already None)\n\t\tnew_node.next = self.head\n\n\t\t# 4. change prev of head node to new_node\n\t\tif self.head is not None:\n\t\t\tself.head.prev = new_node\n\n\t\t# 5. move the head to point to the new node\n\t\tself.head = new_node\n\n\tdef printList(self, node):\n\t\twhile(node is not None):\n\t\t\tprint(node.data,end=' ')\n\t\t\tnode = node.next\n\n\n# Driver code\ndll = DoublyLinkedList()\ndll.push(2)\ndll.push(4)\ndll.push(8)\ndll.push(10)\n\nprint (\"\\nOriginal Linked List\")\ndll.printList(dll.head)\n\n# Reverse doubly linked list\ndll.reverse()\n\nprint (\"\\nReversed Linked List\")\ndll.printList(dll.head)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Depth First Traversal (or Search) for a graph is similar to Depth First Traversal of a tree. The only catch here is, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a boolean visited array.\nApproach: \nDepth-first search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. So the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacent unmarked node and continue this loop until there is no unmarked adjacent node. Then backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.\n\nAlgorithm: \nCreate a recursive function that takes the index of the node and a visited array.\n\nMark the current node as visited and print the node.\nTraverse all the adjacent and unmarked nodes and call the recursive function with the index of the adjacent node.", "code": "# Python3 program to print DFS traversal\n# from a given given graph\nfrom collections import defaultdict\n\n# This class represents a directed graph using\n# adjacency list representation\n\n\nclass Graph:\n\n\t# Constructor\n\tdef __init__(self):\n\n\t\t# default dictionary to store graph\n\t\tself.graph = defaultdict(list)\n\n\t# function to add an edge to graph\n\tdef addEdge(self, u, v):\n\t\tself.graph[u].append(v)\n\n\t# A function used by DFS\n\tdef DFSUtil(self, v, visited):\n\n\t\t# Mark the current node as visited\n\t\t# and print it\n\t\tvisited.add(v)\n\t\tprint(v, end=' ')\n\n\t\t# Recur for all the vertices\n\t\t# adjacent to this vertex\n\t\tfor neighbour in self.graph[v]:\n\t\t\tif neighbour not in visited:\n\t\t\t\tself.DFSUtil(neighbour, visited)\n\n\t# The function to do DFS traversal. It uses\n\t# recursive DFSUtil()\n\tdef DFS(self, v):\n\n\t\t# Create a set to store visited vertices\n\t\tvisited = set()\n\n\t\t# Call the recursive helper function\n\t\t# to print DFS traversal\n\t\tself.DFSUtil(v, visited)\n\n# Driver code\n\n\n# Create a graph given\n# in the above diagram\ng = Graph()\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n\nprint(\"Following is DFS from (starting from vertex 2)\")\ng.DFS(2)\n\n# This code is contributed by Neelam Yadav"}
{"nl": "Given an infinite number line from -INFINITY to +INFINITY and we are on zero. We can move n steps either side at each n\u2019th time.\u00a0\nApproach 1 : Using Tree \n\n1st time; we can move only 1 step to both ways, means -1 1;\n\n2nd time we can move 2 steps  from -1 and 1;\n-1 :  -3 (-1-2)  1(-1+2)\n 1 :  -1 ( 1-2)  3(1+2)\n\n3rd time we can move 3 steps either way from -3, 1, -1, 3 \n-3:  -6(-3-3) 0(-3+3)\n1:   -2(1-3)   4(1+3)\n-1:  -4(-1-3)  2(-1+3)\n3:     0(0-3)   6(3+3) \n\nFind the minimum number of steps to reach a given number n.\nExamples: \n\nInput : n = 10\nOutput : 4\nWe can reach 10 in 4 steps,  1, 3, 6, 10 \n\n\nInput : n = 13\nOutput : 5\nWe can reach 10 in 4 steps,  -1, 2, 5, 9, 14\nRecommended: Please try your approach on {IDE} first, before moving on to the solution.\nThis problem can be modeled as tree. We put initial point 0 at root, 1 and -1 as children of root. Next level contains values at distance 2 and so on.  \n\n              0\n            /   \\\n         -1       1  \n        /  \\     /  \\\n       1   -3   -1   3\n     /  \\  / \\  / \\  / \\\nThe problem is now to find the closes node to root with value n. The idea is to do Level Order Traversal of tree to find the closest node. Note that using DFS for closest node is never a good idea (we may end up going down many unnecessary levels). ", "code": "from collections import deque\n\u00a0\n# Python program to find a number in minimum steps\nInF = 99999\n\u00a0\n# To represent data of a node in tree\nclass number:\n\u00a0\u00a0\u00a0\u00a0def __init__(self,n,l):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.no = n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level = l\n\u00a0\n# Prints level of node n\ndef findnthnumber(n):\n\u00a0\u00a0\u00a0\u00a0# Create a queue and insert root\n\u00a0\u00a0\u00a0\u00a0q = deque()\n\u00a0\u00a0\u00a0\u00a0r = number(0, 1)\n\u00a0\u00a0\u00a0\u00a0q.append(r)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Do level order traversal\n\u00a0\u00a0\u00a0\u00a0while (len(q) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove a node from queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = q.popleft()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# q.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# To avoid infinite loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.no >= InF or temp.no <= -InF):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if dequeued number is same as n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.no == n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Found number n at level\", temp.level - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Insert children of dequeued node to queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append(number(temp.no + temp.level, temp.level + 1))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append(number(temp.no - temp.level, temp.level + 1))\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0findnthnumber(13)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "In this program, you'll learn to find the factorial of a number using recursive function.", "code": "# Factorial of a number using recursion\n\ndef recur_factorial(n):\n   if n == 1:\n       return n\n   else:\n       return n*recur_factorial(n-1)\n\nnum = 7\n\n# check if the number is negative\nif num < 0:\n   print(\"Sorry, factorial does not exist for negative numbers\")\nelif num == 0:\n   print(\"The factorial of 0 is 1\")\nelse:\n   print(\"The factorial of\", num, \"is\", recur_factorial(num))"}
{"nl": "Given a Singly Linked List which has data members sorted in ascending order. Construct a Balanced Binary Search Tree which has same data members as the given Linked List.\u00a0\n\n\u00a0", "code": "# Python3 implementation of above approach\n\u00a0\n# Link list node\nclass LNode :\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next = None\n\u00a0\n# A Binary Tree node\nclass TNode :\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\nhead = None\n\u00a0\n# This function counts the number of\n# nodes in Linked List and then calls\n# sortedListToBSTRecur() to construct BST\ndef sortedListToBST():\n\u00a0\u00a0\u00a0\u00a0global head\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Count the number of nodes in Linked List\n\u00a0\u00a0\u00a0\u00a0n = countLNodes(head)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Construct BST\n\u00a0\u00a0\u00a0\u00a0return sortedListToBSTRecur(n)\n\u00a0\n# The main function that constructs\n# balanced BST and returns root of it.\n# head -. Pointer to pointer to\n# head node of linked list n -. No.\n# of nodes in Linked List\ndef sortedListToBSTRecur( n) :\n\u00a0\u00a0\u00a0\u00a0global head\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if (n <= 0) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recursively construct the left subtree\n\u00a0\u00a0\u00a0\u00a0left = sortedListToBSTRecur( int(n/2))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Allocate memory for root, and\n\u00a0\u00a0\u00a0\u00a0# link the above constructed left\n\u00a0\u00a0\u00a0\u00a0# subtree with root\n\u00a0\u00a0\u00a0\u00a0root = newNode((head).data)\n\u00a0\u00a0\u00a0\u00a0root.left = left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Change head pointer of Linked List\n\u00a0\u00a0\u00a0\u00a0# for parent recursive calls\n\u00a0\u00a0\u00a0\u00a0head = (head).next\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recursively construct the right\n\u00a0\u00a0\u00a0\u00a0# subtree and link it with root\n\u00a0\u00a0\u00a0\u00a0# The number of nodes in right subtree\n\u00a0\u00a0\u00a0\u00a0# is total nodes - nodes in\n\u00a0\u00a0\u00a0\u00a0# left subtree - 1 (for root) which is n-n/2-1\n\u00a0\u00a0\u00a0\u00a0root.right = sortedListToBSTRecur( n - int(n/2) - 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# UTILITY FUNCTIONS\n\u00a0\n# A utility function that returns\n# count of nodes in a given Linked List\ndef countLNodes(head) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0temp = head\n\u00a0\u00a0\u00a0\u00a0while(temp != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.next\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = count + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\n# Function to insert a node\n#at the beginning of the linked list\ndef push(head, new_data) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# allocate node\n\u00a0\u00a0\u00a0\u00a0new_node = LNode()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# put in the data\n\u00a0\u00a0\u00a0\u00a0new_node.data = new_data\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# link the old list off the new node\n\u00a0\u00a0\u00a0\u00a0new_node.next = (head)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# move the head to point to the new node\n\u00a0\u00a0\u00a0\u00a0(head) = new_node\n\u00a0\u00a0\u00a0\u00a0return head\n\u00a0\n\u00a0\n# Function to print nodes in a given linked list\ndef printList(node):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while(node != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print( node.data ,end= \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.next\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Helper function that allocates a new node with the\n# given data and None left and right pointers.\ndef newNode(data) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0node = TNode()\n\u00a0\u00a0\u00a0\u00a0node.data = data\n\u00a0\u00a0\u00a0\u00a0node.left = None\n\u00a0\u00a0\u00a0\u00a0node.right = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\n# A utility function to\n# print preorder traversal of BST\ndef preOrder( node) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (node == None) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0print(node.data, end = \" \" )\n\u00a0\u00a0\u00a0\u00a0preOrder(node.left)\n\u00a0\u00a0\u00a0\u00a0preOrder(node.right)\n\u00a0\n# Driver code\n\u00a0\n# Start with the empty list\nhead = None\n\u00a0\n# Let us create a sorted linked list to test the functions\n# Created linked list will be 1.2.3.4.5.6.7\nhead = push(head, 7)\nhead = push(head, 6)\nhead = push(head, 5)\nhead = push(head, 4)\nhead = push(head, 3)\nhead = push(head, 2)\nhead = push(head, 1)\n\u00a0\nprint(\"Given Linked List \" )\nprintList(head)\n\u00a0\n# Convert List to BST\nroot = sortedListToBST()\nprint(\"\\nPreOrder Traversal of constructed BST \")\npreOrder(root)\n\u00a0\n# This code is contributed by Arnab Kundu\n"}
{"nl": "This Python program finds ASCII value of a given character by user using built-in function ord().\r\n\r\nFunction ord() returns ASCII value corresponding to a one-character string.", "code": "# ASCII value of given character\r\n\r\ncharacter = input(\"Enter character: \")\r\n\r\nprint(\"ASCII value is: \", ord(character))"}
{"nl": "How to Print a Calendar in Python | Python provides a built-in function to print a calendar, also it allows to perform many operations based on the calendar, there are many ways to print the calendar. Let\u2019s see how to print a python calendar.", "code": "import calendar yy = 2022 mm = 10 print(calendar.month(yy, mm))"}
{"nl": "In the previous article, we have discussed Python Program to Count the Number of Odd and Even Digits\n The task is to sort the digits in ascending order given a number N. Print the new number after removing the leading zeroes.\n join() method in python:\n The join() method in Python can be used to convert a List to a String.\n Iterables such as Lists, Tuples, Strings, and others are accepted as parameters for the join() process.\n Examples:\n Example1:\n Input:\n Given Number = 4561230008\n Output:\n The sorted digits in ascending order of a given number 4561230008 after removal of leading zeros =\n \n 1234568\n Example2:\n Input:\n Given Number = 34879010\n Output:\n The sorted digits in ascending order of a given number 34879010 after removal of leading zeros =\n \n 134789", "code": "# Give the number as static input and store it in a variable.\n \n numb = 4561230008\n \n # Convert the given number into a string number using the str() function and\n \n # store it in another variable.\n \n strng_numbr = str(numb)\n \n # Sort the above-obtained string number using the sorted() function and store\n \n # it in another variable.\n \n sortdlst_num = sorted(strng_numbr)\n \n # Convert this sorted list of numbers into a string using the join function and\n \n # store it in another variable.\n \n sortd_str = ''.join(sortdlst_num)\n \n # Convert the above obtained sorted string to an integer using the int() function\n \n # (This removes the leading zeros) and store it in another variable.\n \n rslt = int(sortd_str)\n \n # Print the sorted digits in ascending order of a given number after removal of\n \n # leading zeros.\n \n print(\"The sorted digits in ascending order of a given number\",\n \n  numb, \"after removal of leading zeros =\")\n \n print(rslt)\n \n </pre>"}
{"nl": "Strings in Python:\n\nIn Python, a string may be a sequence of characters. It is an information type that has been derived. Strings are unchangeable. This means that when they have been defined, they can not be modified. Many Python functions change strings, like replace(), join(), and split(). They do not, however, alter the original string. They make a duplicate of a string, alter it, then return it to the caller.\n\nGiven a string, the task is to count the words and the total number of characters in the given string in Python.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven string ='Hello this is btechgeeks'\nOutput:\n\nTotal characters present in given string { Hello this is btechgeeks } = 24\nTotal words present in given string { Hello this is btechgeeks } = 4\nExample2:\n\nInput:\n\ngiven string ='hello this is btechgeeks online platform for coding students'\nOutput:\n\nTotal characters present in given string { hello this is btechgeeks online platform for coding students } = 61\nTotal words present in given string { hello this is btechgeeks online platform for coding students } = 9", "code": "# Give the string as static input and store it in a variable.\ngiven_string = 'Hello this is btechgeeks'\n# Take a variable to say stringchars that store the total characters in the given string.\n# Initialize the stringchars to 0.\nstringchars = 0\n# Take a variable to say stringwords that stores the total words in the given string.\n# Initialize the stringwords to 1.\nstringwords = 1\n# To traverse the characters in the string, use a For loop.\nfor charact in given_string:\n  # If a space character is encountered then increment the stringwords by 1.\n  if(charact == ' '):\n  stringwords = stringwords+1\n  # increment the stringchars variable each time by 1.\n  stringchars = stringchars+1\n# Print the total words and character present in the given string\nprint('Total characters present in given string {', given_string, '} =', stringchars)\nprint('Total words present in given string {', given_string, '} =', stringwords)"}
{"nl": "Here, we will develop Programs for How to check if a string contains special characters in Python. A special character is a character that is not an alphabetic or numeric character. Non-alphabetic or non-numeric character, such as @, #, $, %, &, * and +. We are going to write a program that checks whether a string contains any special character or not using various methods.", "code": "# Python program to check special character # import required package import re # take inputs string = input('Enter any string: ') # special characters special_char = re.compile('[@_!#$%^&*()<>?/\\|}{~:]') # check string contains special characters or not if(special_char.search(string) == None): print('String does not contain any special characters.') else: print('The string contains special characters.')"}
{"nl": "Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner:\n\nlower[i] = arr[i] - k, for every index i where 0 <= i < n\nhigher[i] = arr[i] + k, for every index i where 0 <= i < n\nUnfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array.\n\nGiven an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array.\n\nNote: The test cases are generated such that there exists at least one valid array arr.", "code": "class Solution:\n    def recoverArray(self, nums: List[int]) -> List[int]:\n        counter = Counter(nums)  # counter\n        nums = sorted(counter)   # sorted unique numbers\n\n        hm = nums[-1]            # the max number must be the max in the \"higher\" group\n        for num in nums[:-1]:    # test the corresponding number in the \"lower\" group. Not necessarily the min.\n            k, m = divmod(hm - num, 2)  # derived \"k\"\n            if m:                       # there is a remainder, so they are partners\n                continue\n            ans = []                    # to store the answer in case this will succeed\n            cnt = counter.copy()        # not sure if there is a better way than this\n            for n in nums:              # validation starts now.  start with the smallest value\n                c = cnt.pop(n)          # its number\n                if c == 0:              # this value must have been fully considered in the \"higher\" group\n                    continue\n                o = n + k                # derived origin\n                p = o + k                # derived partner\n                if cnt[p] >= c:          # \"p\" should have enough number. If it has more, the remaining join \"lower\".\n                    cnt[p] -= c          # reduce the count\n                    ans.extend([o] * c)  # add them into \"ans\"\n                else:                    # validation failed\n                    break\n            else:\n                return ans"}
{"nl": "Given a positive integer N, count all possible distinct binary strings of length N such that there are no consecutive 1\u2019s.", "code": "# Python program to count\n# all distinct binary strings\n# without two consecutive 1's\n \ndef countStrings(n):\n \n    a=[0 for i in range(n)]\n    b=[0 for i in range(n)]\n    a[0] = b[0] = 1\n    for i in range(1,n):\n        a[i] = a[i-1] + b[i-1]\n        b[i] = a[i-1]\n     \n    return a[n-1] + b[n-1]\n \n# Driver program to test\n# above functions\n \nprint(countStrings(3))\n \n# This code is contributed\n# by Anant Agarwal."}
{"nl": "Level order traversal of a tree is breadth first traversal for the tree. ", "code": "# Python program to print level\r\n# order traversal using Queue\r\n\r\n# A node structure\r\n\r\n\r\nclass Node:\r\n\t# A utility function to create a new node\r\n\tdef __init__(self, key):\r\n\t\tself.data = key\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# Iterative Method to print the\r\n# height of a binary tree\r\n\r\n\r\ndef printLevelOrder(root):\r\n\t# Base Case\r\n\tif root is None:\r\n\t\treturn\r\n\r\n\t# Create an empty queue\r\n\t# for level order traversal\r\n\tqueue = []\r\n\r\n\t# Enqueue Root and initialize height\r\n\tqueue.append(root)\r\n\r\n\twhile(len(queue) > 0):\r\n\r\n\t\t# Print front of queue and\r\n\t\t# remove it from queue\r\n\t\tprint(queue[0].data)\r\n\t\tnode = queue.pop(0)\r\n\r\n\t\t# Enqueue left child\r\n\t\tif node.left is not None:\r\n\t\t\tqueue.append(node.left)\r\n\r\n\t\t# Enqueue right child\r\n\t\tif node.right is not None:\r\n\t\t\tqueue.append(node.right)\r\n\r\n\r\n# Driver Program to test above function\r\nroot = Node(1)\r\nroot.left = Node(2)\r\nroot.right = Node(3)\r\nroot.left.left = Node(4)\r\nroot.left.right = Node(5)\r\n\r\nprint(\"Level Order Traversal of binary tree is -\")\r\nprintLevelOrder(root)\r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\r"}
{"nl": "The following is a simple recursive Binary Search function in C++ taken from here.", "code": "# A recursive binary search function. It returns location of x in\n# given array arr[l..r] is present, otherwise -1\ndef binarySearch(arr, l, r, x):\nif (r >= l):\n\t\tmid = l + (r - l)/2;\n\t\t\n# If the element is present at the middle itself\nif (arr[mid] == x):\n\t\treturn mid;\n\t\n# If element is smaller than mid, then it can only be present\n# in left subarray\n\tif (arr[mid] > x):\n\treturn binarySearch(arr, l, mid-1, x);\n\n\t# Else the element can only be present in right subarray\n\treturn binarySearch(arr, mid+1, r, x);\n\t\n# We reach here when element is not present in array\nreturn -1;\n\n# This code is contributed by umadevi9616"}
{"nl": "In the previous article, we have discussed Python Program to Print Palindrome Numbers in a Range\n Given a string/sentence and the task is to remove the last word from the given sentence.\n join() :\n The string method join() takes all of the items in an iterable and returns a string after joining them all together. Iterable types include list, tuple, string, dictionary, and set.\n pop() Function in Python:\n Python\u2019s list pop() function removes and returns the final value from a List or the supplied index value.\n Examples:\n Example1:\n Input:\n Given String = \"Hello this is btechgeeks\"\n Output:\n The given string{ Hello this is btechgeeks } after removal of last word = Hello this is\n Example2:\n Input:\n Given String = \"Good Morning btechgeeks Hello everyone\"\n Output:\n The given string{ Good Morning btechgeeks Hello everyone } after removal of last word = Good Morning btechgeeks Hello", "code": "# Give the string/sentence as static input and store it in a variable.\n \n gven_strng = 'Hello this is btechgeeks'\n \n # Convert the given string into a list of words using the list() and split() functions\n \n # and store it in another variable.\n \n str_lst = list(gven_strng.split())\n \n # Apply pop() function on the above list of words.\n \n str_lst.pop()\n \n # Convert the list of words into the string using the join() function and store it in\n \n # another variable.\n \n modified_str = ' '.join(str_lst)\n \n # Print the String after removal of the last word from the above-given string.\n \n print(\"The given string{\", gven_strng,\n \n  \"} after removal of last word = \", modified_str)\n \n </pre>"}
{"nl": "Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\nA subarray is a contiguous subsequence of the array.\n\n ", "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n\n        result = nums[0]\n\n        for i in range(len(nums)):\n            accu = 1\n            for j in range(i, len(nums)):\n                accu *= nums[j]\n                result = max(result, accu)\n\n        return result"}
{"nl": "Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\nA subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.\n \nExample 1:\n\nInput: nums = [10,2,-10,5,20], k = 2\nOutput: 37\nExplanation: The subsequence is [10, 2, 5, 20].\n\nExample 2:\n\nInput: nums = [-1,-2,-3], k = 1\nOutput: -1\nExplanation: The subsequence must be non-empty, so we choose the largest number.\n\nExample 3:\n\nInput: nums = [10,-2,-10,-5,20], k = 2\nOutput: 23\nExplanation: The subsequence is [10, -2, -5, 20].\n\n \nConstraints:\n\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104", "code": "def constrainedSubsetSum(self, A, k):\n  deque = collections.deque()\n  for i in xrange(len(A)):\n  A[i] += deque[0] if deque else 0\n  while len(deque) and A[i] > deque[-1]:\n  deque.pop()\n  if A[i] > 0:\n  deque.append(A[i])\n  if i >= k and deque and deque[0] == A[i - k]:\n  deque.popleft()\n  return max(A)"}
{"nl": "Clustering analysis or simply Clustering is basically an Unsupervised learning method that divides the data points into a number of specific batches or groups, such that the data points in the same groups have similar properties and data points in different groups have different properties in some sense. It comprises many different methods based on differential evolution. ", "code": "import matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom sklearn.cluster import DBSCAN\r\nfrom sklearn import metrics\r\nfrom sklearn.datasets.samples_generator import make_blobs\r\nfrom sklearn.preprocessing import StandardScaler\r\nfrom sklearn import datasets\r\n  \r\n# Load data in X\r\nX, y_true = make_blobs(n_samples=300, centers=4,\r\n                       cluster_std=0.50, random_state=0)\r\ndb = DBSCAN(eps=0.3, min_samples=10).fit(X)\r\ncore_samples_mask = np.zeros_like(db.labels_, dtype=bool)\r\ncore_samples_mask[db.core_sample_indices_] = True\r\nlabels = db.labels_\r\n  \r\n# Number of clusters in labels, ignoring noise if present.\r\nn_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\r\n  \r\nprint(labels)\r\n  \r\n# Plot result\r\n  \r\n# Black removed and is used for noise instead.\r\nunique_labels = set(labels)\r\ncolors = ['y', 'b', 'g', 'r']\r\nprint(colors)\r\nfor k, col in zip(unique_labels, colors):\r\n    if k == -1:\r\n        # Black used for noise.\r\n        col = 'k'\r\n  \r\n    class_member_mask = (labels == k)\r\n  \r\n    xy = X[class_member_mask & core_samples_mask]\r\n    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=col,\r\n             markeredgecolor='k',\r\n             markersize=6)\r\n  \r\n    xy = X[class_member_mask & ~core_samples_mask]\r\n    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=col,\r\n             markeredgecolor='k',\r\n             markersize=6)\r\n  \r\nplt.title('number of clusters: %d' % n_clusters_)\r\nplt.show()"}
{"nl": "Given an n x n matrix, where every row and column is sorted in non-decreasing order. Print all elements of matrix in sorted order.", "code": "# Python 3 program to Print all elements\n# in sorted order from row and column\n# wise sorted matrix\nimport sys\n\u00a0\nINF = sys.maxsize\nN = 4\n\u00a0\n# A utility function to youngify a Young\n# Tableau. This is different from standard\n# youngify. It assumes that the value at\n# mat[0][0] is infinite.\ndef youngify(mat, i, j):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find the values at down and\n\u00a0\u00a0\u00a0\u00a0# right sides of mat[i][j]\n\u00a0\u00a0\u00a0\u00a0downVal = mat[i + 1][j] if (i + 1 < N) else INF\n\u00a0\u00a0\u00a0\u00a0rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If mat[i][j] is the down right\n\u00a0\u00a0\u00a0\u00a0# corner element, return\n\u00a0\u00a0\u00a0\u00a0if (downVal == INF and rightVal == INF):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Move the smaller of two values\n\u00a0\u00a0\u00a0\u00a0# (downVal and rightVal) to mat[i][j]\n\u00a0\u00a0\u00a0\u00a0# and recur for smaller value\n\u00a0\u00a0\u00a0\u00a0if (downVal < rightVal):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = downVal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i + 1][j] = INF\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0youngify(mat, i + 1, j)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = rightVal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j + 1] = INF\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0youngify(mat, i, j + 1)\n\u00a0\n# A utility function to extract minimum\n# element from Young tableau\ndef extractMin(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ret = mat[0][0]\n\u00a0\u00a0\u00a0\u00a0mat[0][0] = INF\n\u00a0\u00a0\u00a0\u00a0youngify(mat, 0, 0)\n\u00a0\u00a0\u00a0\u00a0return ret\n\u00a0\n# This function uses extractMin() to\n# print elements in sorted order\ndef printSorted(mat):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Elements of matrix in sorted order n\")\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0while i < N * N:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(extractMin(mat), end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[10, 20, 30, 40],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[15, 25, 35, 45],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[27, 29, 37, 48],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[32, 33, 39, 50]]\n\u00a0\u00a0\u00a0\u00a0printSorted(mat)\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": "Given two binary trees, check if the first tree is subtree of the second one. A subtree of a tree T is a tree S consisting of a node in T and all of its descendants in T. The subtree corresponding to the root node is the entire tree; the subtree corresponding to any other node is called a proper subtree.\nFor example, in the following case, tree S is a subtree of tree T. \n \n\n        Tree 2\n          10  \n        /    \\ \n      4       6\n       \\\n        30\n\n        Tree 1\n              26\n            /   \\\n          10     3\n        /    \\     \\\n      4       6      3\n       \\\n        30", "code": "# Python program to check binary tree is a subtree of\n# another tree\n\n# A binary tree node\nclass Node:\n\n        # Constructor to create a new node\n        def __init__(self, data):\n                self.data = data\n                self.left = None\n                self.right = None\n\n# A utility function to check whether trees with roots\n# as root 1 and root2 are indetical or not\ndef areIdentical(root1, root2):\n        \n        # Base Case\n        if root1 is None and root2 is None:\n                return True\n        if root1 is None or root2 is None:\n                return False\n\n        # Check fi the data of both roots is same and data of\n        # left and right subtrees are also same\n        return (root1.data == root2.data and\n                        areIdentical(root1.left , root2.left)and\n                        areIdentical(root1.right, root2.right)\n                        )\n\n# This function returns True if S is a subtree of T,\n# otherwise False\ndef isSubtree(T, S):\n        \n        # Base Case\n        if S is None:\n                return True\n\n        if T is None:\n                return False\n\n        # Check the tree with root as current node\n        if (areIdentical(T, S)):\n                return True\n\n        # IF the tree with root as current node doesn't match\n        # then try left and right subtreee one by one\n        return isSubtree(T.left, S) or isSubtree(T.right, S)\n\n\n# Driver program to test above function\n\n\"\"\" TREE 1\n        Construct the following tree\n                        26\n                        / \\\n                10         3\n                / \\         \\\n        4         6         3\n        \\\n                30\n        \"\"\"\n\nT = Node(26)\nT.right = Node(3)\nT.right.right = Node(3)\nT.left = Node(10)\nT.left.left = Node(4)\nT.left.left.right = Node(30)\nT.left.right = Node(6)\n\n\"\"\" TREE 2\n        Construct the following tree\n                10\n                / \\\n        4         6\n        \\\n                30\n        \"\"\"\nS = Node(10)\nS.right = Node(6)\nS.left = Node(4)\nS.left.right = Node(30)\n\nif isSubtree(T, S):\n        print (\"Tree 2 is subtree of Tree 1\")\nelse :\n        print (\"Tree 2 is not a subtree of Tree 1\")\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Print the longest leaf to leaf path in a Binary tree", "code": "# Python3 program to print the longest\n# leaf to leaf path\n\n# Tree node structure used in the program\nclass Node:\n\t\n\tdef __init__(self, x):\n\t\t\n\t\tself.data = x\n\t\tself.left = None\n\t\tself.right = None\n\n# Function to find height of a tree\ndef height(root):\n\t\n\tglobal ans, k, lh, rh, f\n\t\n\tif (root == None):\n\t\treturn 0\n\n\tleft_height = height(root.left)\n\n\tright_height = height(root.right)\n\n\t# Update the answer, because diameter of a\n\t# tree is nothing but maximum value of\n\t# (left_height + right_height + 1) for each node\n\tif (ans < 1 + left_height + right_height):\n\t\tans = 1 + left_height + right_height\n\n\t\t# Save the root, this will help us finding the\n\t\t# left and the right part of the diameter\n\t\tk = root\n\n\t\t# Save the height of left & right\n\t\t# subtree as well.\n\t\tlh = left_height\n\t\trh = right_height\n\n\treturn 1 + max(left_height, right_height)\n\n# Prints the root to leaf path\ndef printArray(ints, lenn, f):\n\t\n\t# Print left part of the path\n\t# in reverse order\n\tif (f == 0):\n\t\tfor i in range(lenn - 1, -1, -1):\n\t\t\tprint(ints[i], end = \" \")\n\n\t# Print right part of the path\n\telif (f == 1):\n\t\tfor i in range(lenn):\n\t\t\tprint(ints[i], end = \" \")\n\n# This function finds out all the\n# root to leaf paths\ndef printPathsRecur(node, path, maxm, pathlen):\n\t\n\tglobal f\n\n\tif (node == None):\n\t\treturn\n\n\t# Append this node to the path array\n\tpath[pathlen] = node.data\n\tpathlen += 1\n\n\t# If it's a leaf, so print the\n\t# path that led to here\n\tif (node.left == None and node.right == None):\n\t\t\n\t\t# Print only one path which is equal to the\n\t\t# height of the tree.\n\t\t# print(pathlen,\"---\",maxm)\n\t\tif (pathlen == maxm and (f == 0 or f == 1)):\n\t\t\t\n\t\t\t# print(\"innn\")\n\t\t\tprintArray(path, pathlen,f)\n\t\t\tf = 2\n\n\telse:\n\t\t\n\t\t# Otherwise try both subtrees\n\t\tprintPathsRecur(node.left, path, maxm, pathlen)\n\t\tprintPathsRecur(node.right, path, maxm, pathlen)\n\n# Computes the diameter of a binary\n# tree with given root.\ndef diameter(root):\n\t\n\tglobal ans, lh, rh, f, k, pathLen\n\n\tif (root == None):\n\t\treturn\n\t\n\t# f is a flag whose value helps in printing\n\t# left & right part of the diameter only once\n\theight_of_tree = height(root)\n\tlPath = [0 for i in range(100)]\n\n\t# print(lh,\"--\",rh)\n\n\t# Print the left part of the diameter\n\tprintPathsRecur(k.left, lPath, lh, 0);\n\tprint(k.data, end = \" \")\n\trPath = [0 for i in range(100)]\n\tf = 1\n\n\t# Print the right part of the diameter\n\tprintPathsRecur(k.right, rPath, rh, 0)\n\t\n# Driver code\nif __name__ == '__main__':\n\t\n\tk, lh, rh, f, ans, pathLen = None, 0, 0, 0, 0 - 10 ** 19, 0\n\t\n\t# Enter the binary tree ...\n\t#\t\t 1\n\t#\t / \\\n\t#\t 2\t 3\n\t#\t / \\\n\t# 4\t 5\n\t#\t \\ / \\\n\t#\t 8 6 7\n\t#\t /\n\t# 9\n\troot = Node(1)\n\troot.left = Node(2)\n\troot.right = Node(3)\n\troot.left.left = Node(4)\n\troot.left.right = Node(5)\n\troot.left.right.left = Node(6)\n\troot.left.right.right = Node(7)\n\troot.left.left.right = Node(8)\n\troot.left.left.right.left = Node(9)\n\n\tdiameter(root)\n\t\n# This code is contributed by mohit kumar 29"}
{"nl": "aximum sum rectangle in a 2D matrix", "code": "# Python3 program to find maximum sum\n# subarray in a given 2D array\n \n# Implementation of Kadane's algorithm\n# for 1D array. The function returns the\n# maximum sum and stores starting and\n# ending indexes of the maximum sum subarray\n# at addresses pointed by start and finish\n# pointers respectively.\n \n \ndef kadane(arr, start, finish, n):\n \n    # initialize sum, maxSum and\n    Sum = 0\n    maxSum = -999999999999\n    i = None\n \n    # Just some initial value to check\n    # for all negative values case\n    finish[0] = -1\n \n    # local variable\n    local_start = 0\n \n    for i in range(n):\n        Sum += arr[i]\n        if Sum < 0:\n            Sum = 0\n            local_start = i + 1\n        elif Sum > maxSum:\n            maxSum = Sum\n            start[0] = local_start\n            finish[0] = i\n \n    # There is at-least one\n    # non-negative number\n    if finish[0] != -1:\n        return maxSum\n \n    # Special Case: When all numbers\n    # in arr[] are negative\n    maxSum = arr[0]\n    start[0] = finish[0] = 0\n \n    # Find the maximum element in array\n    for i in range(1, n):\n        if arr[i] > maxSum:\n            maxSum = arr[i]\n            start[0] = finish[0] = i\n    return maxSum\n \n# The main function that finds maximum\n# sum rectangle in M[][]\n \n \ndef findMaxSum(M):\n    global ROW, COL\n \n    # Variables to store the final output\n    maxSum, finalLeft = -999999999999, None\n    finalRight, finalTop, finalBottom = None, None, None\n    left, right, i = None, None, None\n \n    temp = [None] * ROW\n    Sum = 0\n    start = [0]\n    finish = [0]\n \n    # Set the left column\n    for left in range(COL):\n \n        # Initialize all elements of temp as 0\n        temp = [0] * ROW\n \n        # Set the right column for the left\n        # column set by outer loop\n        for right in range(left, COL):\n \n            # Calculate sum between current left\n            # and right for every row 'i'\n            for i in range(ROW):\n                temp[i] += M[i][right]\n \n            # Find the maximum sum subarray in\n            # temp[]. The kadane() function also\n            # sets values of start and finish.\n            # So 'sum' is sum of rectangle between\n            # (start, left) and (finish, right) which\n            # is the maximum sum with boundary columns\n            # strictly as left and right.\n            Sum = kadane(temp, start, finish, ROW)\n \n            # Compare sum with maximum sum so far.\n            # If sum is more, then update maxSum\n            # and other output values\n            if Sum > maxSum:\n                maxSum = Sum\n                finalLeft = left\n                finalRight = right\n                finalTop = start[0]\n                finalBottom = finish[0]\n \n    # Prfinal values\n    print(\"(Top, Left)\", \"(\", finalTop,\n          finalLeft, \")\")\n    print(\"(Bottom, Right)\", \"(\", finalBottom,\n          finalRight, \")\")\n    print(\"Max sum is:\", maxSum)\n \n \n# Driver Code\nROW = 4\nCOL = 5\nM = [[1, 2, -1, -4, -20],\n     [-8, -3, 4, 2, 1],\n     [3, 8, 10, 1, 3],\n     [-4, -1, 1, 7, -6]]\n \n# Function call\nfindMaxSum(M)\n \n# This code is contributed by PranchalK"}
{"nl": "The math.hypot() method returns the Euclidean norm. The Euclidian norm is the distance from the origin to the coordinates given.\r\n\r\nPrior Python 3.8, this method was used only to find the hypotenuse of a right-angled triangle: sqrt(x*x + y*y).\r\n\r\nFrom Python 3.8, this method is used to calculate the Euclidean norm as well. For n-dimensional cases, the coordinates passed are assumed to be like (x1, x2, x3, ..., xn). So Euclidean length from the origin is calculated by sqrt(x1*x1 + x2*x2 +x3*x3 .... xn*xn).", "code": "#Import math Library\r\nimport math\r\n\r\n#set perpendicular and base\r\nparendicular = 10\r\nbase = 5\r\n\r\n#print the hypotenuse of a right-angled triangle\r\nprint(math.hypot(parendicular, base))"}
{"nl": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.\n \nExample 1:\n\n\nInput: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:\n\n\nExample 2:\n\n\nInput: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:\n\n\nExample 3:\n\n\nInput: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.", "code": "class Solution:\n  def containsCycle(self, grid: List[List[str]]) -> bool:\n  def dfs(node, parent):\n  if node in visited: return True\n  visited.add(node)\n  nx,ny = node\n  childs = [(cx,cy) for cx,cy in [[nx+1,ny],[nx-1, ny],[nx,ny+1],[nx,ny-1]] \n  if 0 <= cx < m and 0 <= cy < n \n  and grid[cx][cy] == grid[nx][ny] and (cx,cy) != parent]\n  for x in childs:\n  if dfs(x, node): return True \n  return False  \n  \n  m, n = len(grid), len(grid[0])\n  visited = set()\n  for i in range(m):\n  for j in range(n):\n  if (i,j) in visited: continue \n  if dfs((i,j), None): return True\n  return False"}
{"nl": "Given an integer num, find the closest two integers in absolute difference whose product equals num + 1 or num + 2.\n\nReturn the two integers in any order.\n\n \n\nExample 1:\n\nInput: num = 8\nOutput: [3,3]\nExplanation: For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.\nExample 2:\n\nInput: num = 123\nOutput: [5,25]\nExample 3:\n\nInput: num = 999\nOutput: [40,25]\n \n\nConstraints:\n\n1 <= num <= 10^9", "code": "def closestDivisors(self, num: int) -> List[int]:\n  for i in reversed(range(1, int((num + 2) ** 0.5) + 1)):\n  if not (num + 1) % i:\n  return [i, (num + 1) // i]\n  if not (num + 2) % i:\n  return [i, (num + 2) // i]"}
{"nl": "Given an array of numbers, return true if given array can represent preorder traversal of a Binary Search Tree, else return false. Expected time complexity is O(n).", "code": "# Python program for an efficient solution to check if\n# a given array can represent Preorder traversal of\n# a Binary Search Tree\n\u00a0\nINT_MIN = -2**32\n\u00a0\ndef canRepresentBST(pre):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an empty stack\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize current root as minimum possible value\n\u00a0\u00a0\u00a0\u00a0root = INT_MIN\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse given array\n\u00a0\u00a0\u00a0\u00a0for value in pre:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#NOTE:value is equal to pre[i] according to the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#given algo\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we find a node who is on the right side\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and smaller than root, return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if value < root :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If value(pre[i]) is in right subtree of stack top,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Keep removing items smaller than value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and make the last removed items as new root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while(len(s) > 0 and s[-1] < value) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = s.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# At this point either stack is empty or value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is smaller than root, push value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(value)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n# Driver Program\npre1 = [40 , 30 , 35 , 80 , 100]\nprint (\"true\" if canRepresentBST(pre1) == True else \"false\")\npre2 = [40 , 30 , 35 , 20 ,\u00a0 80 , 100]\nprint (\"true\" if canRepresentBST(pre2) == True else \"false\")\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "In Python, the in operator determines if a given value is a constituent element of a sequence such as a string, array, list, or tuple, among other things.\r\n\r\nThe statement returns a Boolean result that evaluates to True or False when used in a condition. The statement returns True if the supplied value is found within the sequence. When it isn\u2019t found, though, we get a False.\r\n\r\n\r\n \r\nLet us use an example to gain a better grasp of how the in operator works.", "code": "# given list\r\ngiven_list = [\"hello\", \"this\", \"is\", \"BTechGeeks\", \"Python\"]\r\n# given element\r\nelement = \"BTechGeeks\"\r\n# checking if the given element is present in given list or not using in opertor\r\n# it returns true if is present else it returns false\r\nprint(element in given_list)"}
{"nl": "You are given an integer array nums. You have an integer array arr of the same length with all values set to 0 initially. You also have the following modify function:\n\nYou want to use the modify function to covert arr to nums using the minimum number of calls.\nReturn the minimum number of function calls to make nums from arr.\nThe test cases are generated so that the answer fits in a 32-bit signed integer.\n \nExample 1:\n\nInput: nums = [1,5]\nOutput: 5\nExplanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).\nDouble all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).\nIncrement by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).\nTotal of operations: 1 + 2 + 2 = 5.\n\nExample 2:\n\nInput: nums = [2,2]\nOutput: 3\nExplanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).\nDouble all the elements: [1, 1] -> [2, 2] (1 operation).\nTotal of operations: 2 + 1 = 3.\n\nExample 3:\n\nInput: nums = [4,2,5]\nOutput: 6\nExplanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5](nums).\n\n \nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109", "code": "def minOperations(self, A):\n  return sum(bin(a).count('1') for a in A) + len(bin(max(A))) - 3"}
{"nl": null, "code": null}
{"nl": "Lemmatization is the process of grouping together the different inflected forms of a word so they can be analyzed as a single item. Lemmatization is similar to stemming but it brings context to the words. So it links words with similar meanings to one word.\r\nText preprocessing includes both Stemming as well as Lemmatization. Many times people find these two terms confusing. Some treat these two as the same. Actually, lemmatization is preferred over Stemming because lemmatization does morphological analysis of the words.\r\nApplications of lemmatization are: \r\n \r\n\r\nUsed in comprehensive retrieval systems like search engines.\r\nUsed in compact indexing.", "code": "# from textblob lib import Word method\r\nfrom textblob import Word\r\n \r\n# create a Word object.\r\nu = Word(\"rocks\")\r\n \r\n# apply lemmatization.\r\nprint(\"rocks :\", u.lemmatize())\r\n \r\n# create a Word object.\r\nv = Word(\"corpora\")\r\n \r\n# apply lemmatization.\r\nprint(\"corpora :\", v.lemmatize())\r\n \r\n# create a Word object.\r\nw = Word(\"better\")\r\n  \r\n# apply lemmatization with\r\n# parameter \"a\", \"a\" denotes adjective.\r\nprint(\"better :\", w.lemmatize(\"a\"))"}
{"nl": "Create a function to count the number of 1s in a 2D list.\nExamples\ncount_ones([\n  [1, 0],\n  [0, 0]\n]) \u279e 1\n\ncount_ones([\n  [1, 1, 1],\n  [0, 0, 1],\n  [1, 1, 1]\n]) \u279e 7\n\ncount_ones([\n  [1, 2, 3],\n  [0, 2, 1],\n  [5, 7, 33]\n]) \u279e 2\nNotes\nN/A", "code": "def count_ones(matrix):\n  return sum([row.count(1) for row in matrix])"}
{"nl": "Create a function that converts dates from one of five string formats:\r\n\r\n\"January 9, 2019\" (MM D, YYYY)\r\n\"Jan 9, 2019\" (MM D, YYYY)\r\n\"01/09/2019\" (MM/DD/YYYY)\r\n\"01-09-2019\" (MM-DD-YYYY)\r\n\"01.09.2019\" (MM.DD.YYYY)\r\nThe return value will be a list formatted like: [MM, DD, YYYY], where MM, DD, and YYYY are all integers. Using the examples above:\r\n\r\nExamples\r\nconvert_date(\"January 9, 2019\") \u279e [1, 9, 2019]\r\n\r\nconvert_date(\"Jan 9, 2019\") \u279e [1, 9, 2019]\r\n\r\nconvert_date(\"01/09/2019\") \u279e [1, 9, 2019]\r\n\r\nconvert_date(\"01-09-2019\") \u279e [1, 9, 2019]\r\n\r\nconvert_date(\"01.09.2019\") \u279e [1, 9, 2019]", "code": "import dateutil.parser\r\ndef convert_date(date):\r\n\tdate = dateutil.parser.parse(date)\r\n\treturn [date.month, date.day, date.year]"}
{"nl": "I am trying to filter out empty arrays from an array. In other words, I want to transform something that looks like this: [\"a\", \"b\", [], [], [1, 2, 3]] to look like [\"a\", \"b\", [1, 2, 3]]. My code looks like this:\ndef remove_empty_arrays(arr):\n    return [x for x in arr if len(x) != 0]\nHowever, it seems that I've run into a problem, with an error message of object of type 'int' has no len(). Fix my code so that all tests pass.\nExamples\n# What I want:\nremove_empty_arrays([1, 2, [], 4]) \u279e [1, 2, 4]\n\n# What I am getting:\nERROR: Traceback:\n   in <module>\n   in remove_empty_arrays\n   in <listcomp>\nTypeError: object of type 'int' has no len()\nNotes\nN/A", "code": "def remove_empty_arrays(arr):\n    return [x for x in arr if x != []]"}
{"nl": "Here, we will discuss the matrix addition program in Python. For adding any two matrices, both of the matrices should be of the same dimension. We carry out the addition by adding corresponding elements together. Similar to the add operation, we can also implement other mathematical operations.", "code": "import numpy as np m1 = np.array([[3, 4], [5, 6]]) m2 = np.array([[8, 9], [0, 6]]) result = np.add(m1, m2) print(result)"}
{"nl": "Create a function that takes a list of numbers and return its median. If the input list is even length, take the average of the two medians, else, take the single median.\nExamples\nmedian([2, 5, 6, 2, 6, 3, 4]) \u279e 4\n\nmedian([21.4323, 432.54, 432.3, 542.4567]) \u279e 432.4\n\nmedian([-23, -43, -29, -53, -67]) \u279e -43\nNotes\nInput can be any negative or positive number.\nInput list will contain at least four numbers.\nSee Resources tab for info on calculating the median.", "code": "def median(lst):\n  lst.sort()\n  n = len(lst)\n  m = n // 2\n  if n % 2 == 0:\n    return (lst[m - 1] + lst[m]) / 2\n  else:\n    return lst[m]"}
{"nl": "Given a dictionary of some items with star ratings and a specified star rating, return a new dictionary of items which match the specified star rating. Return \"No results found\" if no item matches the star rating given.\n\nExamples\nfilter_by_rating({\n  \"Luxury Chocolates\" : \"*****\",\n  \"Tasty Chocolates\" : \"****\",\n  \"Aunty May Chocolates\" : \"*****\",\n  \"Generic Chocolates\" : \"***\"\n}, \"*****\") \u279e {\n  \"Luxury Chocolates\" : \"*****\",\n  \"Aunty May Chocolates\" : \"*****\"\n}\n\nfilter_by_rating({\n  \"Continental Hotel\" : \"****\",\n  \"Big Street Hotel\" : \"**\",\n  \"Corner Hotel\" : \"**\",\n  \"Trashviews Hotel\" : \"*\",\n  \"Hazbins\" : \"*****\"\n}, \"*\") \u279e {\n  \"Trashviews Hotel\" : \"*\"\n}\n\nfilter_by_rating({\n  \"Solo Restaurant\" : \"***\",\n  \"Finest Dinings\" : \"*****\",\n  \"Burger Stand\" : \"***\"\n}, \"****\") \u279e \"No results found\"\n", "code": "def filter_by_rating(d, rating):\n\treturn {k:v for k,v in d.items() if d[k]==rating} or 'No results found'"}
{"nl": "You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.\nReturn the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.\n \nExample 1:\n\nInput: nums = [1,2,3,4], n = 4, left = 1, right = 5\nOutput: 13 \nExplanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. \n\nExample 2:\n\nInput: nums = [1,2,3,4], n = 4, left = 3, right = 4\nOutput: 6\nExplanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.\n\nExample 3:\n\nInput: nums = [1,2,3,4], n = 4, left = 1, right = 10\nOutput: 50\n\n \nConstraints:\n\nn == nums.length\n1 <= nums.length <= 1000\n1 <= nums[i] <= 100\n1 <= left <= right <= n * (n + 1) / 2", "code": "class Solution:\n  def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n  h = [(x, i) for i, x in enumerate(nums)] #min-heap \n  heapify(h)\n  \n  ans = 0\n  for k in range(1, right+1): #1-indexed\n  x, i = heappop(h)\n  if k >= left: ans += x\n  if i+1 < len(nums): \n  heappush(h, (x + nums[i+1], i+1))\n  \n  return ans % 1_000_000_007"}
{"nl": "There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities.\n\nThere are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively.\n\nGiven an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all.\n\nA subpath of a path is a contiguous sequence of cities within that path.", "code": "class Solution:\n        def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n                def helper(mid):\n                        base = 10**5+1\n                        mod = 2**128\n                        a = pow(base,mid,mod)\n                        hashSet = set()\n\n                        for i,path in enumerate(paths):\n                                hashset2 = set()\n                                curHash = 0\n\n                                for j in range(len(path)):\n                                        curHash = curHash*base+path[j]\n                                        if j >= mid:\n                                                curHash -= path[j-mid] * a\n\n                                        curHash %= mod\n                                        if j >= mid-1:\n                                                hashset2.add(curHash)\n\n                                if i == 0:\n                                        hashSet = hashset2\n                                else:\n                                        hashSet = hashSet.intersection(hashset2)\n\n                                if i > 0 and not hashSet:\n                                        break\n\n                        return len(hashSet) > 0\n\n                l = 0\n                r = min(len(path) for path in paths)\n\n                while l < r:\n                        mid = l +(r-l+1) // 2\n                        if helper(mid):\n                                l = mid\n                        else:\n                                r = mid-1\n\n                return l"}
{"nl": "Create a function that inverts words or the phrase depending on the value of parameter type. A \"P\" means to invert the entire phrase, while a \"W\" means to invert every word in the phrase. See the following examples for clarity.\nExamples\ninverter(\"This is Valhalla\", \"P\") \u279e \"Valhalla is this\"\n\ninverter(\"One fine day to start\", \"W\") \u279e \"Eno enif yad ot trats\"\n\ninverter(\"Division by powers of two\", \"P\") \u279e \"Two of powers by division\"\nNotes\nThe first character of the returned string should be in uppercase and the rest are in lowercase.\nThere will be no empty strings as inputs. Punctuation marks, though quite important for grammatical correctness, are discounted in the input phrases.", "code": "def inverter(txt, T):\n  if T == 'P':\n    return ' '.join(txt.split()[::-1]).capitalize()\n  else:\n    return ' '.join(w[::-1] for w in txt.split()).capitalize()"}
{"nl": "Clear nth Bit of a Number Using Bitwise &(and) Operator (Static Input)", "code": "# Give the number as static input and store it in a variable.\r\ngvn_numb = 60\r\n# Give the bit position as static input and store it in another variable.\r\nbitpositin = 3\r\n# Apply the left shift operator to 1 and the above-given bit position and\r\n# store it in another variable.\r\nnumbr_bit = (1 << bitpositin)\r\n# Apply the complement operator (which converts 0 to 1 and vice-versa) to the above result\r\n# and store it in another variable.\r\ncomplemt = (~numbr_bit)\r\n# Apply bitwise & operation for the given number and the above result and store it in\r\n# another variable say rslt_numb.\r\nrslt_numb = gvn_numb & complemt\r\n# Print the number after clearing the bit at the given position for a given number.\r\nprint(\"The Number after clearing the bit at the given position{\",\r\n      bitpositin, \"} for a given number{\", gvn_numb, \"} =\", rslt_numb)"}
{"nl": "The task is to check if the product of digits at even places of a given number is divisible by the another given input number say K.\n", "code": "# Give the number as static input and store it in a variable.\ngvn_numb = 123456\n# Give the other number k as static input and store it in another variable.\ngvn_k = 5\n# Convert the given number to a string using the str() function and store it in\n# another variable.\nstringnum = str(gvn_numb)\n# Create a list of digits say \"digtslst\" using map(),list(),int functions.\ndigtslst = list(map(int, stringnum))\n# Take another variable say \"evn_prodt\" and initialize it with 1.\nevn_prodt = 1\n# Loop in the above list of digits until the length of the \"digtslst\" using the for loop.\nfor itr in range(len(digtslst)):\n    # Check if the iterator value is even or not using\n    # the if conditional statement.\n    if(itr % 2 == 0):\n        # If the statement is true, then multiply the element of digits list at iterator value to\n        # the \"evn_prodt\" and store it in the same variable evn_prodt.\n        evn_prodt *= digtslst[itr]\n# Check if the evn_prodt modulus given number k is equal to 0 or not using the if conditional\n# statement.\nif(evn_prodt % gvn_k == 0):\n    # If the statement is true, then print \"The product of digits at even places of the given\n    # number is divisible by the another given number k.\n    print(\"The Product of digits at even places of the given number{\", gvn_numb,\n          \"} is divisible by the another given number k{\", gvn_k, \"}\")\nelse:\n    # If the statement is false, then print \"The product of digits at even places of the given\n    # number is Not divisible by the another given number k.\n    print(\"The Product of digits at even places of the given number{\", gvn_numb,\n          \"} is not divisible by the another given number k{\", gvn_k, \"}\")"}
{"nl": "Write a function that sorts only the odd numbers in a list in ascending order, keeping the even numbers in their current place.\nFor example, if our input list is: [5, 2, 6, 6, 1, 4, 9, 3]:\n[_, 2, 6, 6, _, 4, _, _]  # Keep evens in place.\n\n# Sort odds: [5, 1, 9, 3] => [1, 3, 5, 9]\n\n[1, 2, 6, 6, 3, 4, 5, 9] # Final list.\nExamples\nodd_sort([7, 5, 2, 3, 1]) \u279e [1, 3, 2, 5, 7]\n\nodd_sort([3, 7, 0, 9, 3, 2, 4, 8]) \u279e [3, 3, 0, 7, 9, 2, 4, 8]\n\nodd_sort([2, 2, 8, 4]) \u279e [2, 2, 8, 4]\n\nodd_sort([7, 9, 7]) \u279e [7, 7, 9]\nNotes\nLists may contain duplicate numbers.", "code": "def odd_sort(lst): \n  odds = iter(sorted(i for i in lst if i%2))\n  return [next(odds) if n%2 else n for n in lst]"}
{"nl": "Given the arrival and departure times of all trains that reach a railway station, the task is to find the minimum number of platforms required for the railway station so that no train waits. \r\nWe are given two arrays that represent the arrival and departure times of trains that stop.", "code": "\r\n# Program to find minimum\r\n# number of platforms\r\n# required on a railway\r\n# station\r\n \r\n# Returns minimum number\r\n# of platforms required\r\n \r\n \r\ndef findPlatform(arr, dep, n):\r\n \r\n    # Sort arrival and\r\n    # departure arrays\r\n    arr.sort()\r\n    dep.sort()\r\n \r\n    # plat_needed indicates\r\n    # number of platforms\r\n    # needed at a time\r\n    plat_needed = 1\r\n    result = 1\r\n    i = 1\r\n    j = 0\r\n \r\n    # Similar to merge in\r\n    # merge sort to process\r\n    # all events in sorted order\r\n    while (i < n and j < n):\r\n \r\n        # If next event in sorted\r\n        # order is arrival,\r\n        # increment count of\r\n        # platforms needed\r\n        if (arr[i] <= dep[j]):\r\n \r\n            plat_needed += 1\r\n            i += 1\r\n \r\n        # Else decrement count\r\n        # of platforms needed\r\n        elif (arr[i] > dep[j]):\r\n \r\n            plat_needed -= 1\r\n            j += 1\r\n \r\n        # Update result if needed\r\n        if (plat_needed > result):\r\n            result = plat_needed\r\n \r\n    return result\r\n \r\n# Driver code\r\n \r\n \r\narr = [900, 940, 950, 1100, 1500, 1800]\r\ndep = [910, 1200, 1120, 1130, 1900, 2000]\r\nn = len(arr)\r\n \r\nprint(\"Minimum Number of Platforms Required = \",\r\n      findPlatform(arr, dep, n))\r\n \r\n# This code is contributed\r\n# by Anant Agarwal."}
{"nl": "Create a function that takes a string and returns the sum of vowels, where some vowels are considered numbers.\n\nVowel Number\nA 4\nE 3\nI 1\nO 0\nU 0\n\nExamples\n\nsum_of_vowels(\"Let\\'s test this function.\") \u279e 8\n\nsum_of_vowels(\"Do I get the correct output?\") \u279e 10\n\nsum_of_vowels(\"I love edabit!\") \u279e 12\nNotes\n\nVowels are case-insensitive (e.g. A = 4 and a = 4).", "code": "def sum_of_vowels(sentence):\n  v = {'a':4, 'e':3, 'i':1}\n  return sum(v[ch] for ch in sentence.lower() if ch in v)"}
{"nl": "You are given an m x n integer matrix grid\u200b\u200b\u200b.\n\nA rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid\u200b\u200b\u200b. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum:\n\n\nNote that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.\n\nReturn the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them.", "code": "class Solution:\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n        n, m = len(grid), len(grid[0])\n        sumD1 = [[grid[i][j] for j in range(m)] for i in range(n)]\n        sumD2 = [[grid[i][j] for j in range(m)] for i in range(n)]\n        \n        ans = set([grid[i][j] for i in range(n) for j in range(m)])\n        ans = list(ans)\n        ans.sort(reverse = True)\n        ans = ans[:3]\n        \n        for i in range(1, n):\n            for j in range(1, m):\n                sumD1[i][j] += sumD1[i - 1][j - 1]\n        \n        for i in range(1, n):\n            for j in range(m - 1):\n                sumD2[i][j] += sumD2[i - 1][j + 1]\n        \n        for i in range(1, n - 1):\n            for j in range(1, m - 1):                \n                d = 1\n                while 0 <= i - d and i + d < n and 0 <= j - d and j + d < m: \n                    TR = sumD1[i][j + d]\n                    TR -= sumD1[i - d - 1][j - 1] if j - 1 >= 0 and i - d - 1 >= 0 else 0 \n                    \n                    BL = sumD1[i + d][j]\n                    BL -= sumD1[i - 1][j - d - 1] if i - 1 >= 0 and j - d - 1 >= 0 else 0\n                    \n                    TL = sumD2[i - 1][j - d + 1] - sumD2[i - d][j] \n                    \n                    BR = sumD2[i + d - 1][j + 1] - sumD2[i][j + d]\n                    \n                    perimeter = TR + BL + TL + BR\n                    \n                    if perimeter not in ans: \n                        ans.append(perimeter)\n                        ans.sort(reverse = True)\n                        ans = ans[:3]\n                    d += 1\n               \n        return ans\n                    "}
{"nl": "Let us consider the following problem to understand Segment Trees.\r\nWe have an array arr[0 . . . n-1]. We should be able to \r\n1 Find the sum of elements from index l to r where 0 <= l <= r <= n-1\r\n2 Change value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 <= i <= n-1.\n\nRepresentation of Segment trees \r\n1. Leaf Nodes are the elements of the input array. \r\n2. Each internal node represents some merging of the leaf nodes. The merging may be different for different problems. For this problem, merging is sum of leaves under a node.\r\nAn array representation of tree is used to represent Segment Trees. For each node at index i, the left child is at index 2*i+1, right child at 2*i+2 and the parent is at  \u230a(i \u2013 1) / 2\u230b.", "code": "# Python3 program to show segment tree operations like\r\n# construction, query and update\r\nfrom math import ceil, log2;\r\n \r\n# A utility function to get the\r\n# middle index from corner indexes.\r\ndef getMid(s, e) :\r\n    return s + (e -s) // 2;\r\n \r\n\"\"\" A recursive function to get the sum of values\r\n    in the given range of the array. The following\r\n    are parameters for this function.\r\n \r\n    st --> Pointer to segment tree\r\n    si --> Index of current node in the segment tree.\r\n           Initially 0 is passed as root is always at index 0\r\n    ss & se --> Starting and ending indexes of the segment\r\n                represented by current node, i.e., st[si]\r\n    qs & qe --> Starting and ending indexes of query range \"\"\"\r\ndef getSumUtil(st, ss, se, qs, qe, si) :\r\n \r\n    # If segment of this node is a part of given range,\r\n    # then return the sum of the segment\r\n    if (qs <= ss and qe >= se) :\r\n        return st[si];\r\n \r\n    # If segment of this node is\r\n    # outside the given range\r\n    if (se < qs or ss > qe) :\r\n        return 0;\r\n \r\n    # If a part of this segment overlaps\r\n    # with the given range\r\n    mid = getMid(ss, se);\r\n     \r\n    return getSumUtil(st, ss, mid, qs, qe, 2 * si + 1) +\r\n           getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2);\r\n \r\n\"\"\" A recursive function to update the nodes\r\nwhich have the given index in their range.\r\nThe following are parameters st, si, ss and se\r\nare same as getSumUtil()\r\ni --> index of the element to be updated.\r\n      This index is in the input array.\r\ndiff --> Value to be added to all nodes\r\nwhich have i in range \"\"\"\r\ndef updateValueUtil(st, ss, se, i, diff, si) :\r\n \r\n    # Base Case: If the input index lies\r\n    # outside the range of this segment\r\n    if (i < ss or i > se) :\r\n        return;\r\n \r\n    # If the input index is in range of this node,\r\n    # then update the value of the node and its children\r\n    st[si] = st[si] + diff;\r\n     \r\n    if (se != ss) :\r\n     \r\n        mid = getMid(ss, se);\r\n        updateValueUtil(st, ss, mid, i,\r\n                        diff, 2 * si + 1);\r\n        updateValueUtil(st, mid + 1, se, i,\r\n                         diff, 2 * si + 2);\r\n \r\n# The function to update a value in input array\r\n# and segment tree. It uses updateValueUtil()\r\n# to update the value in segment tree\r\ndef updateValue(arr, st, n, i, new_val) :\r\n \r\n    # Check for erroneous input index\r\n    if (i < 0 or i > n - 1) :\r\n         \r\n        print(\"Invalid Input\", end = \"\");\r\n        return;\r\n \r\n    # Get the difference between\r\n    # new value and old value\r\n    diff = new_val - arr[i];\r\n \r\n    # Update the value in array\r\n    arr[i] = new_val;\r\n \r\n    # Update the values of nodes in segment tree\r\n    updateValueUtil(st, 0, n - 1, i, diff, 0);\r\n \r\n# Return sum of elements in range from\r\n# index qs (query start) to qe (query end).\r\n# It mainly uses getSumUtil()\r\ndef getSum(st, n, qs, qe) :\r\n \r\n    # Check for erroneous input values\r\n    if (qs < 0 or qe > n - 1 or qs > qe) :\r\n \r\n        print(\"Invalid Input\", end = \"\");\r\n        return -1;\r\n     \r\n    return getSumUtil(st, 0, n - 1, qs, qe, 0);\r\n \r\n# A recursive function that constructs\r\n# Segment Tree for array[ss..se].\r\n# si is index of current node in segment tree st\r\ndef constructSTUtil(arr, ss, se, st, si) :\r\n \r\n    # If there is one element in array,\r\n    # store it in current node of\r\n    # segment tree and return\r\n    if (ss == se) :\r\n     \r\n        st[si] = arr[ss];\r\n        return arr[ss];\r\n     \r\n    # If there are more than one elements,\r\n    # then recur for left and right subtrees\r\n    # and store the sum of values in this node\r\n    mid = getMid(ss, se);\r\n     \r\n    st[si] = constructSTUtil(arr, ss, mid, st, si * 2 + 1) +\r\n             constructSTUtil(arr, mid + 1, se, st, si * 2 + 2);\r\n     \r\n    return st[si];\r\n \r\n\"\"\" Function to construct segment tree\r\nfrom given array. This function allocates memory\r\nfor segment tree and calls constructSTUtil() to\r\nfill the allocated memory \"\"\"\r\ndef constructST(arr, n) :\r\n \r\n    # Allocate memory for the segment tree\r\n \r\n    # Height of segment tree\r\n    x = (int)(ceil(log2(n)));\r\n \r\n    # Maximum size of segment tree\r\n    max_size = 2 * (int)(2**x) - 1;\r\n     \r\n    # Allocate memory\r\n    st = [0] * max_size;\r\n \r\n    # Fill the allocated memory st\r\n    constructSTUtil(arr, 0, n - 1, st, 0);\r\n \r\n    # Return the constructed segment tree\r\n    return st;\r\n \r\n# Driver Code\r\nif __name__ == \"__main__\" :\r\n \r\n    arr = [1, 3, 5, 7, 9, 11];\r\n    n = len(arr);\r\n \r\n    # Build segment tree from given array\r\n    st = constructST(arr, n);\r\n \r\n    # Print sum of values in array from index 1 to 3\r\n    print(\"Sum of values in given range = \",\r\n                       getSum(st, n, 1, 3));\r\n \r\n    # Update: set arr[1] = 10 and update\r\n    # corresponding segment tree nodes\r\n    updateValue(arr, st, n, 1, 10);\r\n \r\n    # Find sum after the value is updated\r\n    print(\"Updated sum of values in given range = \",\r\n                     getSum(st, n, 1, 3), end = \"\");\r\n     \r\n# This code is contributed by AnkitRai01"}
{"nl": "You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence:\n\nType-1: Remove the character at the start of the string s and append it to the end of the string.\nType-2: Pick any character in s and flip its value, i.e., if its value is '0' it becomes '1' and vice-versa.\nReturn the minimum number of type-2 operations you need to perform such that s becomes alternating.\n\nThe string is called alternating if no two adjacent characters are equal.\n\nFor example, the strings \"010\" and \"1010\" are alternating, while the string \"0100\" is not.", "code": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        diff1,diff2 = 0,0\n        alt1,alt2 = \"\",\"\"\n        s=s+s\n        alt1, alt2 = \"01\" * n, \"10\" * n\n        l=0\n        res = len(s)\n        for r in range(len(s)):\n            if s[r]!=alt1[r]:\n                diff1+=1\n            if s[r]!=alt2[r]:\n                diff2+=1\n            if r>=n:\n                if n%2!=0: # if 0th(Lth) bit are different with alt1,alt2 then n+1 bit will be same and vice versa\n                    if s[l]!=alt1[l]:\n                        diff1-=1\n                    if s[l]!=alt2[l]:\n                        diff2-=1\n                l+=1\n            if r >= n-1:\n                res = min(res,diff1,diff2)\n        return res"}
{"nl": "Create a function which concatenates the number 7 to the end of every chord in a list. Ignore all chords which already end with 7.\nExamples\njazzify([\"G\", \"F\", \"C\"]) \u279e [\"G7\", \"F7\", \"C7\"]\n\njazzify([\"Dm\", \"G\", \"E\", \"A\"]) \u279e [\"Dm7\", \"G7\", \"E7\", \"A7\"]\n\njazzify([\"F7\", \"E7\", \"A7\", \"Ab7\", \"Gm7\", \"C7\"]) \u279e [\"F7\", \"E7\", \"A7\", \"Ab7\", \"Gm7\", \"C7\"]\n\njazzify([]) \u279e []\nNotes\nReturn an empty list if the given list is empty.\nYou can expect all the tests to have valid chords.", "code": "def jazzify(lst):\n  return [i if i.endswith('7') else i + '7' for i in lst]"}
{"nl": "Given the Hemisphere\u2019s radius and the task is to calculate the surface area and volume of the given Hemisphere.", "code": "# Import the math module using the import keyword.\nimport math\n# Give the hemisphere's radius as user input using the float(input()) function and\n# store it in a variable.\ngvn_radus = float(input(\"Enter some random variable = \"))\n# Take a variable and initialize it with the value of pi as 3.14 .\nvalof_pi = 3.14\n# Calculate the surface area of the given hemisphere using the above given mathematical\n# formula and math.pow() function.\n# Store it in another variable.\nhemi_surfceara = 3*valof_pi*math.pow(gvn_radus, 2)\n# Calculate the volume of the given hemisphere using the above given mathematical formula\n# and math.pow() function.\n# Store it in another variable.\nhemi_volum = (2.0/3.0)*valof_pi*math.pow(gvn_radus, 3)\n# Print the hemisphere's surface area with the given radius of the hemisphere.\nprint(\"The Surface Area of the given Hemisphere with radius {\",\n      gvn_radus, \" } = \", hemi_surfceara)\n# Print the hemisphere's perimeter with the given radius of the hemisphere.\nprint(\"The Volume of the given Hemisphere with radius {\",\n      gvn_radus, \"} = \", hemi_volum)"}
{"nl": "Static Input: Print nth Iteration of Lucas Sequence", "code": "# Give the First term =2 (since the first term in Lucas Sequence is 2 which is a constant)\n# as static input and store it in a variable.\nfst_trm = 2\n# Give the Second term =1 (since the second term in Lucas Sequence is 1 which is a constant)\n# as static input and store it in another variable.\nsecnd_trm = 1\n# Give the number as static input and store it in another variable.\ngvn_n_vlue = 6\n# Loop from '1' to the above given n+1 value (since doesn't include last term) range\n# using For loop.\nfor i in range(1, gvn_n_vlue+1):\n # Inside the loop , get the third term which is the sum of first and the second term\n    # and store it in a variable.\n    third_trm = fst_trm+secnd_trm\n # Assign the value of second term to the first term.\n    fst_trm = secnd_trm\n  # Assign the value of the third term to the second term and come out of For Loop.\n    secnd_trm = third_trm\n# Print the Value of above given nth iteration of Lucas Sequence(i.e. first term).\nprint(\"The above Given nth iteration of Lucas Sequence = \", fst_trm)"}
{"nl": "Create a function that takes in a sentence and a character to find. Return a dictionary of each word in the sentence, with the number of the specified character as the value.", "code": "def find_occurrences(txt, ch):\n        return {w:w.count(ch.lower()) for w in txt.lower().split()}"}
{"nl": "Given a binary tree and a key(node) value, find the floor and ceil value for that particular key value.\n\nFloor Value Node: Node with the greatest data lesser than or equal to the key value. \nCeil Value Node: Node with the smallest data larger than or equal to the key value.\n\nFor example, Let\u2019s consider the Binary Tree below \u2013 \n\n          8\n        /   \\    \n      4      12\n    /  \\    /  \\\n   2    6  10   14\n\nKey: 11  Floor: 10  Ceil: 12\nKey: 1   Floor: -1  Ceil: 2\nKey: 6   Floor: 6   Ceil: 6\nKey: 15  Floor: 14  Ceil: -1", "code": "# Python3 program to find floor and\n# ceil of a given key in BST\n\n# A binary tree node has key,\n#. left child and right child\nclass Node:\n\t\n\tdef __init__(self, x):\n\t\t\n\t\tself.data = x\n\t\tself.left = None\n\t\tself.right = None\n\n# Helper function to find floor and\n# ceil of a given key in BST\ndef floorCeilBSTHelper(root, key):\n\t\n\tglobal floor, ceil\n\n\twhile (root):\n\t\tif (root.data == key):\n\t\t\tceil = root.data\n\t\t\tfloor = root.data\n\t\t\treturn\n\t\tif (key > root.data):\n\t\t\tfloor = root.data\n\t\t\troot = root.right\n\t\telse:\n\t\t\tceil = root.data\n\t\t\troot = root.left\n\n# Display the floor and ceil of a given\n# key in BST. If key is less than the min\n# key in BST, floor will be -1; If key is\n# more than the max key in BST, ceil will be -1;\ndef floorCeilBST(root, key):\n\t\n\tglobal floor, ceil\n\n\t# Variables 'floor' and 'ceil'\n\t# are passed by reference\n\tfloor = -1\n\tceil = -1\n\n\tfloorCeilBSTHelper(root, key)\n\n\tprint(key, floor, ceil)\n\n# Driver code\nif __name__ == '__main__':\n\t\n\tfloor, ceil = -1, -1\n\t\n\troot = Node(8)\n\troot.left = Node(4)\n\troot.right = Node(12)\n\troot.left.left = Node(2)\n\troot.left.right = Node(6)\n\troot.right.left = Node(10)\n\troot.right.right = Node(14)\n\n\tfor i in range(16):\n\t\tfloorCeilBST(root, i)\n\n# This code is contributed by mohit kumar 29"}
{"nl": "Mona has created a method to sort a list in ascending order.\nStarting from the left of the list, she compares numbers by pairs. If the first pair is ordered [smaller number, larger number], she moves on. If the first pair is ordered [larger number, smaller number], she swaps the two integers before moving on to the next pair. She repeats this process until she reaches the end of the list.\nThen, she moves back to the beginning of the list and repeats this process until the entire list is sorted.\nIf the unsorted list is: [3, 9, 7, 4], she will perform the following steps (note Swaps here refers to cumulative swaps):\nShe starts with the first pair.\n[3, 9] is in order, move on. List: [3, 9, 7, 4]. Swaps: 0.\n[9, 7] is not. Swap. List: [3, 7, 9, 4]. Swaps: 1\n[9, 4] is not. Swap. List: [3, 7, 4, 9]. Swaps: 2\nCheck if list is sorted. It is not, so start over at first pair.\n[3, 7] is in order, move on. List: [3, 7, 4, 9]. Swaps: 2\n[7, 4] is not. Swap. List: [3, 4, 7, 9]. Swaps: 3.\n[7, 9] is in order, move on. List: [3, 4, 7, 9]. Swaps: 3.\nCheck if list is sorted. It is. End.\nSorting the list [3, 9, 7, 4] takes her 3 swaps. Write a function that takes in an unsorted list and returns the number of swaps it takes for the list to be sorted according to Mona's algorithm.\nExamples\nnumber_of_swaps([5, 4, 3]) \u279e 3\n\nnumber_of_swaps([1, 3, 4, 5]) \u279e 0\n\nnumber_of_swaps([5, 4, 3, 2]) \u279e 6\nNotes\nN/A", "code": "def number_of_swaps(lst):\n  swaps, target = 0, sorted(lst)\n  while lst != target:\n    for i in range(len(lst) - 1):\n      if lst[i] > lst[i+1]:\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n        swaps += 1\n  return swaps"}
{"nl": "Create a function that takes a list of names of superheroes and superheroines and returns a list of only the names of superheroes ending in \"man\" in alphabetical order.\r\n\r\nExamples\r\nsuperheroes([\"Batman\", \"Superman\", \"Spider-man\", \"Hulk\", \"Wolverine\", \"Wonder-Woman\"])\r\n\u279e [\"Batman\", \"Spider-man\", \"Superman\"]\r\n\r\nsuperheroes([\"Catwoman\", \"Deadpool\", \"Dr.Strange\", \"Captain-America\", \"Aquaman\", \"Hawkeye\"])\r\n\u279e [\"Aquaman\"]\r\n\r\nsuperheroes([\"Wonder-Woman\", \"Catwoman\", \"Invisible-Woman\"])\r\n\u279e []\r\nNotes\r\nWonder-Woman, Catwoman and Invisible-Woman are superheroines.", "code": "def superheroes(heroes):\r\n  return sorted([i for i in heroes if i.endswith(\"man\") and not i.lower().endswith(\"woman\")])"}
{"nl": "Math Module :\n\nPython\u2019s math module is a built-in module. By importing this module, we can perform mathematical computations.\n\n\n\nNumerous mathematical operations like ceil( ),floor( ),factorial( ),mod( ),value of pi ,\u2026..etc .can be computed with the help of math module.\n\nHemisphere:\n\nThe word hemisphere can be broken down into hemi and sphere, where hemi means half and sphere is a 3D geometric shape used in mathematics.\n\nAs a result, a hemisphere is a three-dimensional geometric shape that is half of a sphere, with one side flat and the other as a circular bowl.\n\n\n\nFormula to calculate the surface area of a Hemisphere:\n\nsurface area = 3\ud835\uded1r\u00b2\n\nIn which, r is the radius of the hemisphere.\n\nFormula to calculate the volume of a Hemisphere:\n\n\n\nVolume = (2/3)*\ud835\uded1*r3\n\n\n\nGiven the Hemisphere\u2019s radius and the task is to calculate the surface area and volume of the given Hemisphere.\n\nExamples:\nExample1:\nInput:\nGiven Hemisphere's Radius = 9\nOutput:\nThe Surface Area of the given Hemisphere with radius { 9  } =  763.02\nThe Volume of the given Hemisphere with radius { 9 } =  1526.04\nExample2:\nInput:\nGiven Hemisphere's Radius = 12.5\nOutput:\nThe Surface Area of the given Hemisphere with radius { 12.5 } = 1471.875\nThe Volume of the given Hemisphere with radius { 12.5 } = 4088.5416666666665\nProgram to Calculate the Surface Area and Volume of a Hemisphere in Python\nBelow are the ways to Calculate the surface area and volume of a hemisphere with the given hemisphere\u2019s  radius :\nUsing Mathematical Formula (Static Input)\nUsing Mathematical Formula (User Input)\nMethod #1: Using Mathematical Formula (Static Input)\nApproach:\nImport the math module using the import keyword.\nGive the hemisphere\u2019s radius as static input and store it in a variable.\nTake a variable and initialize it with the value of pi as 3.14.\nCalculate the surface area of the given hemisphere using the above given mathematical formula and math.pow() function.\nStore it in another variable.\nCalculate the volume of the given hemisphere using the above given mathematical formula and math.pow() function.\nStore it in another variable.\nPrint the hemisphere\u2019s surface area with the given radius of the hemisphere.\nPrint the hemisphere\u2019s perimeter with the given radius of the hemisphere.\nThe Exit of the program.\nBelow is the implementation:\n# Import the math module using the import keyword.\nimport math\n# Give the hemisphere's radius as static input and store it in a variable.\ngvn_radus = 9\n# Take a variable and initialize it with the value of pi as 3.14 .\nvalof_pi = 3.14\n# Calculate the surface area of the given hemisphere using the above given mathematical\n# formula and math.pow() function.\n# Store it in another variable.\nhemi_surfceara = 3*valof_pi*math.pow(gvn_radus, 2)\n# Calculate the volume of the given hemisphere using the above given mathematical formula\n# and math.pow() function.\n# Store it in another variable.\nhemi_volum = (2.0/3.0)*valof_pi*math.pow(gvn_radus, 3)\n# Print the hemisphere's surface area with the given radius of the hemisphere.\nprint(\"The Surface Area of the given Hemisphere with radius {\",\n  gvn_radus, \" } = \", hemi_surfceara)\n# Print the hemisphere's perimeter with the given radius of the hemisphere.\nprint(\"The Volume of the given Hemisphere with radius {\",\n  gvn_radus, \"} = \", hemi_volum)\nOutput:\nThe Surface Area of the given Hemisphere with radius { 9  } =  763.02\nThe Volume of the given Hemisphere with radius { 9 } =  1526.04\nMethod #2: Using Mathematical Formula (User Input)\nApproach:\nImport the math module using the import keyword.\nGive the hemisphere\u2019s radius as user input using the float(input()) function and store it in a variable.\nTake a variable and initialize it with the value of pi as 3.14.\nCalculate the surface area of the given hemisphere using the above given mathematical formula and math.pow() function.\nStore it in another variable.\nCalculate the volume of the given hemisphere using the above given mathematical formula and math.pow() function.\nStore it in another variable.\nPrint the hemisphere\u2019s surface area with the given radius of the hemisphere.\nPrint the hemisphere\u2019s perimeter with the given radius of the hemisphere.\nThe Exit of the program.\nBelow is the implementation:\n# Import the math module using the import keyword.\nimport math\n# Give the hemisphere's radius as user input using the float(input()) function and\n# store it in a variable.\ngvn_radus = float(input(\"Enter some random variable = \"))\n# Take a variable and initialize it with the value of pi as 3.14 .\nvalof_pi = 3.14\n# Calculate the surface area of the given hemisphere using the above given mathematical\n# formula and math.pow() function.\n# Store it in another variable.\nhemi_surfceara = 3*valof_pi*math.pow(gvn_radus, 2)\n# Calculate the volume of the given hemisphere using the above given mathematical formula\n# and math.pow() function.\n# Store it in another variable.\nhemi_volum = (2.0/3.0)*valof_pi*math.pow(gvn_radus, 3)\n# Print the hemisphere's surface area with the given radius of the hemisphere.\nprint(\"The Surface Area of the given Hemisphere with radius {\",\n  gvn_radus, \" } = \", hemi_surfceara)\n# Print the hemisphere's perimeter with the given radius of the hemisphere.\nprint(\"The Volume of the given Hemisphere with radius {\",\n  gvn_radus, \"} = \", hemi_volum)\nOutput:\nEnter some random variable = 12.5\nThe Surface Area of the given Hemisphere with radius { 12.5 } = 1471.875\nThe Volume of the given Hemisphere with radius { 12.5 } = 4088.5416666666665\n\nExplore more instances related to python concepts from Python Programming Examples Guide and get promoted from beginner to professional programmer level in Python Programming Language.\n\nPython Program to Find the Type of Triangle with Given Sides\nPython Program to Calculate the Income Tax\nPython Program to Calculate Electricity Bill\nPython Program to Check Whether given Array or List Can Form Arithmetic Progression\n\nRelated\nPython Program to Calculate Volume and Surface Area of Hemisphere\nSeptember 29, 2021\nIn \"Python\"\nPython Program to Calculate Surface Area and Volume of a Cylinder\nAugust 12, 2021\nIn \"Python\"\nPython Program to Find Volume and Surface Area of a Cone\nAugust 26, 2021\nIn \"Python\"", "code": "# Import the math module using the import keyword.\n import math\n # Give the hemisphere's radius as static input and store it in a variable.\n gvn_radus = 9\n # Take a variable and initialize it with the value of pi as 3.14 .\n valof_pi = 3.14\n # Calculate the surface area of the given hemisphere using the above given mathematical\n # formula and math.pow() function.\n # Store it in another variable.\n hemi_surfceara = 3*valof_pi*math.pow(gvn_radus, 2)\n # Calculate the volume of the given hemisphere using the above given mathematical formula\n # and math.pow() function.\n # Store it in another variable.\n hemi_volum = (2.0/3.0)*valof_pi*math.pow(gvn_radus, 3)\n # Print the hemisphere's surface area with the given radius of the hemisphere.\n print(\"The Surface Area of the given Hemisphere with radius {\",\n  gvn_radus, \" } = \", hemi_surfceara)\n # Print the hemisphere's perimeter with the given radius of the hemisphere.\n print(\"The Volume of the given Hemisphere with radius {\",\n  gvn_radus, \"} = \", hemi_volum)"}
{"nl": "Given a list of scrabble tiles (as dictionaries), create a function that outputs the maximum possible score a player can achieve by summing up the total number of points for all the tiles in their hand. Each hand contains 7 scrabble tiles.\nHere's an example hand:\n[\n  { \"tile\": \"N\", \"score\": 1 },\n  { \"tile\": \"K\", \"score\": 5 },\n  { \"tile\": \"Z\", \"score\": 10 },\n  { \"tile\": \"X\", \"score\": 8 },\n  { \"tile\": \"D\", \"score\": 2 },\n  { \"tile\": \"A\", \"score\": 1 },\n  { \"tile\": \"E\", \"score\": 1 }\n]\nThe player's maximum_score from playing all these tiles would be 1 + 5 + 10 + 8 + 2 + 1 + 1, or 28.\nExamples\nmaximum_score([\n  { \"tile\": \"N\", \"score\": 1 },\n  { \"tile\": \"K\", \"score\": 5 },\n  { \"tile\": \"Z\", \"score\": 10 },\n  { \"tile\": \"X\", \"score\": 8 },\n  { \"tile\": \"D\", \"score\": 2 },\n  { \"tile\": \"A\", \"score\": 1 },\n  { \"tile\": \"E\", \"score\": 1 }\n]) \u279e 28\n\nmaximum_score([\n  { \"tile\": \"B\", \"score\": 2 },\n  { \"tile\": \"V\", \"score\": 4 },\n  { \"tile\": \"F\", \"score\": 4 },\n  { \"tile\": \"U\", \"score\": 1 },\n  { \"tile\": \"D\", \"score\": 2 },\n  { \"tile\": \"O\", \"score\": 1 },\n  { \"tile\": \"U\", \"score\": 1 }\n]) \u279e 15\nNotes\nHere, each tile is represented as an dictionary with two keys: tile and score.", "code": "def maximum_score(tile_hand):\n  return sum([i['score'] for i in tile_hand])"}
{"nl": "Given a binary matrix, print all unique rows of the given matrix.\u00a0", "code": "# Given a binary matrix of M X N of\n# integers, you need to return only\n# unique rows of binary array\nROW = 4\nCOL = 5\n\u00a0\n# The main function that prints\n# all unique rows in a given matrix.\ndef findUniqueRows(M):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse through the matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(ROW):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if there is similar column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is already printed, i.e if i and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# jth column match.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(i):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(COL):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (M[i][k] != M[j][k]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (flag == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If no row is similar\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (flag == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print the row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(COL):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(M[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\u00a0\u00a0\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0M = [ [ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 0, 0 ] ]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0findUniqueRows(M)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Write a Python program to print right triangle of numbers in reverse order pattern using for loop.", "code": "rows = int(input(\"Right Triangle Reverse Numbers Rows = \"))\n\nprint(\"==Right Triangle of Numbers in Reverse Order Pattern==\")\n\nfor i in range(rows, 0, -1):\n    for j in range(rows, i - 1, -1):\n        print(j, end = ' ')\n    print()"}
{"nl": "Given a side of a Dodecahedron, the task is to find the volume of the Dodecahedron in Python.", "code": "# Import the math module using the math keyword.\r\nimport math\r\n# Give the side of the Dodecahedron as static input and store it in a variable.\r\nsideval = 5\r\n# Calculate the volume of the Dodecahedron using the above mathematical formula\r\n# ( (15 + 7\u221a5)*s3/4).\r\n# We Calculate the \u221a5 in the above formula using the sqrt() function.\r\n# We can calculate the s^3 using the pow() function or '**' operator.\r\n# By using the above functions we calculate the volume of the Dodecahedron\r\n# and store it in a variable say volDode.\r\nvolDode = (((15 + (7 * (math.sqrt(5)))) / 4) * (math.pow(sideval, 3)))\r\n# Print the volDode value.\r\nprint(\r\n    'The Volume of the Dodecahedron with side {', sideval, '} is = ', volDode)"}
{"nl": "Python\u2019s Sklearn library provides a great sample dataset generator which will help you to create your own custom dataset. It\u2019s fast and very easy to use.", "code": "# Creating Test DataSets using sklearn.datasets.make_moon\r\nfrom sklearn.datasets import make_moons\r\nfrom matplotlib import pyplot as plt\r\nfrom matplotlib import style\r\n \r\nX, y = make_moons(n_samples = 1000, noise = 0.1)\r\nplt.scatter(X[:, 0], X[:, 1], s = 40, color ='g')\r\nplt.xlabel(\"X\")\r\nplt.ylabel(\"Y\")\r\n \r\nplt.show()\r\nplt.clf()"}
{"nl": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\n \n\nExample 1:\n\n\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\nExample 2:\n\nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n \n\nConstraints:\n\n1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.", "code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        def helper(in_left, in_right):\n            # if there is no elements to construct subtrees\n            if in_left > in_right:\n                return None\n            \n            # pick up the last element as a root\n            val = postorder.pop()\n            root = TreeNode(val)\n\n            # root splits inorder list\n            # into left and right subtrees\n            index = idx_map[val]\n \n            # build right subtree\n            root.right = helper(index + 1, in_right)\n            # build left subtree\n            root.left = helper(in_left, index - 1)\n            return root\n        \n        # build a hashmap value -> its index\n        idx_map = {val:idx for idx, val in enumerate(inorder)} \n        return helper(0, len(inorder) - 1)"}
{"nl": "Fibonacci series in Python | In the Fibonacci series, the next element will be the sum of the previous two elements. The Fibonacci sequence is a series of numbers where a number is found by adding up the two numbers before it. Starting with 0 and 1, the sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on\u2026", "code": "# Python program to print fibonacci series up to n-th term # take input num = int(input('Enter number of terms: ')) # print fibonacci series a, b = 0, 1 i = 0 # check if the number of terms is valid if num <= 0: print('Please enter a positive integer.') elif num == 1: print('The Fibonacci series: ') print(a) else: print('The Fibonacci series: ') while i < num: print(a, end=' ') c = a + b a = b b = c i = i+1"}
{"nl": "Find XOR of Two Numbers Without Using XOR operator Using Bitwise And(&), Or(|) Operators (Static Input)", "code": "# Create a function XOR_result() which accepts the given two numbers as the argument and\r\n# returns the XOR result of the given first and second numbers.\r\n\r\n\r\ndef XOR_result(gvnfst_numb, gvnscnd_numb):\r\n    # Inside the XOR_result() function.\r\n    # Calculate and the value of (gvnfst_numb | gvnscnd_numb) & (~gvnfst_numb | ~gvnscnd_numb)\r\n    # which gives the XOR result of the given first and second numbers and store it in a\r\n    # variable say xor_rslt.\r\n\r\n    xor_rslt = (gvnfst_numb | gvnscnd_numb) & (~gvnfst_numb | ~gvnscnd_numb)\r\n    # Return the value of xor_rslt (Which is the XOR result of the given first and\r\n    # second numbers).\r\n    return(xor_rslt)\r\n\r\n\r\n# Inside the main code.\r\n# Give the first number as static input and store it in a variable.\r\ngvnfst_numb = 4\r\n# Give the second number as static input and store it in another variable.\r\ngvnscnd_numb = 2\r\n# Pass the given first and second numbers as the arguments to XOR_result() function and\r\n# store the result in a variable (xorreslt_val).\r\nxorreslt_val = XOR_result(gvnfst_numb, gvnscnd_numb)\r\n# Print the xorreslt_val value.\r\nprint(\"The XOR result of the given first and second numbers{\",\r\n      gvnfst_numb, \",\", gvnscnd_numb, \"} =\", xorreslt_val)"}
{"nl": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.\n \nExample 1:\n\nInput: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".\n\nExample 2:\n\nInput: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.\n\nExample 3:\n\nInput: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required.\n\n \nConstraints:\n\n1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.", "code": "class Solution:\n  def areAlmostEqual(self, s1: str, s2: str) -> bool:\n  diff = [[x, y] for x, y in zip(s1, s2) if x != y]\n  return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]"}
{"nl": "The following are the common definitions of Binomial Coefficients. \n\nA binomial coefficient C(n, k) can be defined as the coefficient of x^k in the expansion of (1 + x)^n.\n\n\n\nA binomial coefficient C(n, k) also gives the number of ways, disregarding order, that k objects can be chosen from among n objects more formally, the number of k-element subsets (or k-combinations) of a n-element set.", "code": "# A Dynamic Programming based Python\n# Program that uses table C[][]\n# to calculate the Binomial Coefficient\n\n# Returns value of Binomial Coefficient C(n, k)\n\n\ndef binomialCoef(n, k):\n\tC = [[0 for x in range(k+1)] for x in range(n+1)]\n\n\t# Calculate value of Binomial\n\t# Coefficient in bottom up manner\n\tfor i in range(n+1):\n\t\tfor j in range(min(i, k)+1):\n\t\t\t# Base Cases\n\t\t\tif j == 0 or j == i:\n\t\t\t\tC[i][j] = 1\n\n\t\t\t# Calculate value using\n\t\t\t# previously stored values\n\t\t\telse:\n\t\t\t\tC[i][j] = C[i-1][j-1] + C[i-1][j]\n\n\treturn C[n][k]\n\n\n# Driver program to test above function\nn = 5\nk = 2\nprint(\"Value of C[\" + str(n) + \"][\" + str(k) + \"] is \"\n\t+ str(binomialCoef(n, k)))\n\n# This code is contributed by Bhavya Jain"}
{"nl": "We have discussed BST search and insert operations. In this post, the delete operation is discussed. When we delete a node, three possibilities arise. \n1) Node to be deleted is the leaf: Simply remove from the tree. \n\n              50                            50\n           /     \\         delete(20)      /   \\\n          30      70       --------->    30     70 \n         /  \\    /  \\                     \\    /  \\ \n       20   40  60   80                   40  60   80\n2) Node to be deleted has only one child: Copy the child to the node and delete the child                                                  .            50                                 50\n           /     \\         delete(30)      /   \\\n          30      70       --------->    40     70 \n            \\    /  \\                          /  \\ \n            40  60   80                       60   80\n3) Node to be deleted has two children: Find inorder successor of the node. Copy contents of the inorder successor to the node and delete the inorder successor. Note that inorder predecessor can also be used. \n\n              50                            60\n           /     \\         delete(50)      /   \\\n          40      70       --------->    40    70 \n                 /  \\                            \\ \n                60   80                           80\nThe important thing to note is, inorder successor is needed only when the right child is not empty. In this particular case, inorder successor can be obtained by finding the minimum value in the right child of the node.\n\nTime Complexity: The worst case time complexity of delete operation is O(h) where h is the height of the Binary Search Tree. In worst case, we may have to travel from the root to the deepest leaf node. The height of a skewed tree may become n and the time complexity of delete operation may become O(n)\n \n\nOptimization to above code for two children case : \nIn the above recursive code, we recursively call delete() for the successor. We can avoid recursive calls by keeping track of the parent node of the successor so that we can simply remove the successor by making the child of a parent NULL. We know that the successor would always be a leaf node.", "code": "# Python3 program to implement\n# optimized delete in BST.\n\nclass Node:\n\n\t# Constructor to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\n# A utility function to do\n# inorder traversal of BST\ndef inorder(root):\n\tif root is not None:\n\t\tinorder(root.left)\n\t\tprint(root.key, end=\" \")\n\t\tinorder(root.right)\n\n# A utility function to insert a\n# new node with given key in BST\ndef insert(node, key):\n\n\t# If the tree is empty,\n\t# return a new node\n\tif node is None:\n\t\treturn Node(key)\n\n\t# Otherwise recur down the tree\n\tif key < node.key:\n\t\tnode.left = insert(node.left, key)\n\telse:\n\t\tnode.right = insert(node.right, key)\n\n\t# return the (unchanged) node pointer\n\treturn node\n\n\n# Given a binary search tree\n# and a key, this function\n# delete the key and returns the new root\ndef deleteNode(root, key):\n\n\t# Base Case\n\tif root is None:\n\t\treturn root\n\n\t# Recursive calls for ancestors of\n\t# node to be deleted\n\tif key < root.key:\n\t\troot.left = deleteNode(root.left, key)\n\t\treturn root\n\n\telif(key > root.key):\n\t\troot.right = deleteNode(root.right, key)\n\t\treturn root\n\n\t# We reach here when root is the node\n\t# to be deleted.\n\t\n\t# If root node is a leaf node\n\t\n\tif root.left is None and root.right is None:\n\t\treturn None\n\n\t# If one of the children is empty\n\n\tif root.left is None:\n\t\ttemp = root.right\n\t\troot = None\n\t\treturn temp\n\n\telif root.right is None:\n\t\ttemp = root.left\n\t\troot = None\n\t\treturn temp\n\n\t# If both children exist\n\n\tsuccParent = root\n\n\t# Find Successor\n\n\tsucc = root.right\n\n\twhile succ.left != None:\n\t\tsuccParent = succ\n\t\tsucc = succ.left\n\n\t# Delete successor.Since successor\n\t# is always left child of its parent\n\t# we can safely make successor's right\n\t# right child as left of its parent.\n\t# If there is no succ, then assign\n\t# succ->right to succParent->right\n\tif succParent != root:\n\t\tsuccParent.left = succ.right\n\telse:\n\t\tsuccParent.right = succ.right\n\n\t# Copy Successor Data to root\n\n\troot.key = succ.key\n\n\treturn root\n\n\n# Driver code\n\"\"\" Let us create following BST\n\t\t\t50\n\t\t/\t \\\n\t\t30\t 70\n\t\t/ \\ / \\\n\t20 40 60 80 \"\"\"\n\nroot = None\nroot = insert(root, 50)\nroot = insert(root, 30)\nroot = insert(root, 20)\nroot = insert(root, 40)\nroot = insert(root, 70)\nroot = insert(root, 60)\nroot = insert(root, 80)\n\nprint(\"Inorder traversal of the given tree\")\ninorder(root)\n\nprint(\"\\nDelete 20\")\nroot = deleteNode(root, 20)\nprint(\"Inorder traversal of the modified tree\")\ninorder(root)\n\nprint(\"\\nDelete 30\")\nroot = deleteNode(root, 30)\nprint(\"Inorder traversal of the modified tree\")\ninorder(root)\n\nprint(\"\\nDelete 50\")\nroot = deleteNode(root, 50)\nprint(\"Inorder traversal of the modified tree\")\ninorder(root)\n\n# This code is contributed by Shivam Bhat (shivambhat45)\n"}
{"nl": "Tower of Hanoi is a mathematical puzzle where we have three rods and n disks. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules: \n\nOnly one disk can be moved at a time.\nEach move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.\nNo disk may be placed on top of a smaller disk.", "code": "# Recursive Python function to solve tower of hanoi\n\ndef TowerOfHanoi(n , from_rod, to_rod, aux_rod):\n\tif n == 0:\n\t\treturn\n\tTowerOfHanoi(n-1, from_rod, aux_rod, to_rod)\n\tprint(\"Move disk\",n,\"from rod\",from_rod,\"to rod\",to_rod)\n\tTowerOfHanoi(n-1, aux_rod, to_rod, from_rod)\n\t\t\n# Driver code\nn = 4\nTowerOfHanoi(n, 'A', 'C', 'B')\n# A, C, B are the name of rods\n\n# Contributed By Harshit Agrawal"}
{"nl": "Create a function that finds a target number in a list of prime numbers. Implement a binary search algorithm in your function. The target number will be from 2 through 97. If the target is prime then return \"yes\" else return \"no\".\nExamples\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n\nis_prime(primes, 3) \u279e \"yes\"\n\nis_prime(primes, 4) \u279e \"no\"\n\nis_prime(primes, 67) \u279e \"yes\"\n\nis_prime(primes, 36) \u279e \"no\"\nNotes\nYou could use built-in functions to solve this, but the point of this challenge is to see if you understand the binary search algorithm.\nThe solution is in the Resources tab.", "code": "def is_prime(p,n,l=0,r=None):\n  r=len(p)-1\n  while r>=l:\n    m=l+(r-l)//2\n    if p[m]==n:return'yes'\n    elif p[m]>n:r=m-1 \n    else:l=m+1\n  return'no'"}
{"nl": "The program creates a queue and allows the user to perform enqueue and dequeue operations on it.", "code": "class Queue:\n    def __init__(self):\n        self.items = []\n\u00a0\n    def is_empty(self):\n        return self.items == []\n\u00a0\n    def enqueue(self, data):\n        self.items.append(data)\n\u00a0\n    def dequeue(self):\n        return self.items.pop(0)\n\u00a0\n\u00a0\nq = Queue()\nwhile True:\n    print('enqueue <value>')\n    print('dequeue')\n    print('quit')\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'enqueue':\n        q.enqueue(int(do[1]))\n    elif operation == 'dequeue':\n        if q.is_empty():\n            print('Queue is empty.')\n        else:\n            print('Dequeued value: ', q.dequeue())\n    elif operation == 'quit':\n        break"}
{"nl": "Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of path between two nodes is represented by the number of edges between them.\nExamples: \n \n\nInput :\n              2\n             / \\\n            7   2\n           / \\   \\\n          1   1   2\nOutput : 2\n\nInput :\n              4\n             / \\\n            4   4\n           / \\   \\\n          4   9   5\nOutput : 3", "code": "# Python3 program to find the length of longest\n# path with same values in a binary tree.\n\n# Helper function that allocates a\n# new node with the given data and\n# None left and right pointers.\nclass newNode:\ndef __init__(self, data):\n\tself.val = data\n\tself.left = self.right = None\n\t\n# Function to print the longest path\n# of same values\ndef length(node, ans):\nif (not node):\n\treturn 0\n\t\n# Recursive calls to check for subtrees\nleft = length(node.left, ans)\nright = length(node.right, ans)\n\t\n# Variables to store maximum lengths\n# in two directions\nLeftmax = 0\nRightmax = 0\n\t\n# If curr node and it's left child has same value\nif (node.left and node.left.val == node.val):\n\tLeftmax += left + 1\n\t\n# If curr node and it's right child has same value\nif (node.right and node.right.val == node.val):\n\tRightmax += right + 1\n\t\nans[0] = max(ans[0], Leftmax + Rightmax)\nreturn max(Leftmax, Rightmax)\n\t\n# Driver function to find length of\n# longest same value path\ndef longestSameValuePath(root):\nans = [0]\nlength(root, ans)\nreturn ans[0]\n\t\n# Driver code\nif __name__ == '__main__':\n\t\n# Let us construct a Binary Tree\n#\t 4\n#\t / \\\n# 4 4\n# / \\ \\\n# 4 9 5\nroot = None\nroot = newNode(4)\nroot.left = newNode(4)\nroot.right = newNode(4)\nroot.left.left = newNode(4)\nroot.left.right = newNode(9)\nroot.right.right = newNode(5)\nprint(longestSameValuePath(root))\n\n# This code is contributed by PranchalK"}
{"nl": "Given an expression with only \u2018}\u2019 and \u2018{\u2018. The expression may not be balanced. Find minimum number of bracket reversals to make the expression balanced.", "code": "# Python3 program to find minimum number of\n# reversals required to balance an expression\n\u00a0\n# Returns count of minimum reversals\n# for making expr balanced. Returns -1\n# if expr cannot be balanced.\n\u00a0\n\u00a0\ndef countMinReversals(expr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0lenn = len(expr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# length of expression must be even\n\u00a0\u00a0\u00a0\u00a0# to make it balanced by using reversals.\n\u00a0\u00a0\u00a0\u00a0if (lenn % 2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# After this loop, stack contains\n\u00a0\u00a0\u00a0\u00a0# unbalanced part of expression,\n\u00a0\u00a0\u00a0\u00a0# i.e., expression of the form \"....\"\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\u00a0\u00a0\u00a0for i in range(lenn):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (expr[i] == '' and len(s)):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (s[0] == ''):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.insert(0, expr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.insert(0, expr[i])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Length of the reduced expression\n\u00a0\u00a0\u00a0\u00a0# red_len = (m+n)\n\u00a0\u00a0\u00a0\u00a0red_len = len(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# count opening brackets at the\n\u00a0\u00a0\u00a0\u00a0# end of stack\n\u00a0\u00a0\u00a0\u00a0n = 0\n\u00a0\u00a0\u00a0\u00a0while (len(s)and s[0] == ''):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return ceil(m/2) + ceil(n/2) which\n\u00a0\u00a0\u00a0\u00a0# is actually equal to (m+n)/2 + n%2\n\u00a0\u00a0\u00a0\u00a0# when m+n is even.\n\u00a0\u00a0\u00a0\u00a0return (red_len // 2 + n % 2)\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0expr = \"}}{{\"\n\u00a0\u00a0\u00a0\u00a0print(countMinReversals(expr.strip()))\n\u00a0\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Given a binary tree, find the deep\u00adest node in it.\nExamples: \n \n\nInput : Root of below tree\n            1\n          /   \\\n         2      3\n        / \\    / \\ \n       4   5  6   7\n                   \\\n                    8\nOutput : 8\n\nInput : Root of below tree\n            1\n          /   \\\n         2      3\n               / \n              6  \nOutput : 6", "code": "\"\"\"Python3 program to find value of the\ndeepest node in a given binary tree\"\"\"\n\n# A Binary Tree Node\n# Utility function to create a\n# new tree node\nclass newNode:\n\n\t# Constructor to create a newNode\n\tdef __init__(self, data):\n\t\tself.data= data\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.visited = False\n\n# maxLevel : keeps track of maximum\n# level seen so far.\n# res : Value of deepest node so far.\n# level : Level of root\ndef find(root, level, maxLevel, res):\n\n\tif (root != None):\n\t\tlevel += 1\n\t\tfind(root.left, level, maxLevel, res)\n\n\t\t# Update level and rescue\n\t\tif (level > maxLevel[0]):\n\t\t\n\t\t\tres[0] = root.data\n\t\t\tmaxLevel[0] = level\n\t\t\n\t\tfind(root.right, level, maxLevel, res)\n\t\t\n# Returns value of deepest node\ndef deepestNode(root) :\n\n\t# Initialize result and max level\n\tres = [-1]\n\tmaxLevel = [-1]\n\n\t# Updates value \"res\" and \"maxLevel\"\n\t# Note that res and maxLen are passed\n\t# by reference.\n\tfind(root, 0, maxLevel, res)\n\treturn res[0]\n\t\t\t\t\t\t\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.right.left = newNode(5)\n\troot.right.right = newNode(6)\n\troot.right.left.right = newNode(7)\n\troot.right.right.right = newNode(8)\n\troot.right.left.right.left = newNode(9)\n\tprint(deepestNode(root))\n\n# This code is contributed by\n# SHUBHAMSINGH10\n"}
{"nl": "Given a matrix, the task is to find the sum of all odd Frequency elements of the given Matrix in Python.", "code": "# import the Counter Function from collections using the import keyword\r\nfrom collections import Counter\r\n# Give the matrix as static input and store it in a variable.\r\nmtrx = [[1, 2, 2], [3, 4, 2], [5, 1, 5]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# take a list and initialize it to empty using [] or list() function\r\nmtrxlist = []\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n    # Inside the For loop, Iterate till the given number of columns using another\r\n    # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # add the gvnmatrix[n][m] value to the list using the append() function\r\n        # where n is the iterator value of the parent For loop and m is the iterator\r\n        # value of the inner For loop.\r\n        mtrxlist.append(mtrx[n][m])\r\n# Apply the Counter function to the matrix elements list which stores the matrix element\r\n# as key and its frequency as value\r\nmtrxfreq = Counter(mtrxlist)\r\n# Take a variable(say oddFreqSum) that stores the sum of all the odd frequency elements\r\n# of the matrix and initialize its value to 0.\r\noddFreqSum = 0\r\n# Loop in this frequency dictionary using the For loop.\r\nfor key in mtrxfreq:\r\n    # Check if any key has frequency odd using the if conditional statement.\r\n    if(mtrxfreq[key] % 2 != 0):\r\n        # If it is true then add the key(Matrix Element) to the oddFreqSum.\r\n        oddFreqSum = oddFreqSum+key\r\n# Print the oddFreqSum.\r\nprint(\r\n    'The sum of all the odd frequency elements in the given matrix is = {', oddFreqSum, '}')"}
{"nl": "Given a list and the task is to find the elements in a list that are greater than half of the total number of elements in the given list.\r\n\r\nIn the case of odd elements, we must print elements greater than floor(n/2) where n is the total number of elements in the given list.", "code": "# Create a function to say getElementsLarger() which takes the given list and length of\r\n# the given list as the arguments and prints the elements in a list that are greater than\r\n# half of the total number of elements in the given list.\r\n\r\n\r\ndef getElementsLarger(gvn_lst, lengt_lst):\r\n        # Inside the function, sort the given list using the sorted() function and store\r\n        # it in a variable.\r\n    k = sorted(gvn_lst)\r\n    # Loop from half the length of the given list to the length of the given list-1\r\n    # using the for loop.\r\n    for itr in range(lengt_lst//2, lengt_lst):\r\n     # Inside the loop, print the element present at the iterator value of the\r\n     # above-sorted list.\r\n\r\n        print(k[itr])\r\n\r\n\r\n# Give the list as static input and store it in a variable.\r\ngvn_lst = [4, 6, 3, 1, 8, 9]\r\n# Calculate the length of the given list using the len() function and store it in\r\n# another variable.\r\nlengt_lst = len(gvn_lst)\r\nprint(\"The elements in a list that are greater than half of the total number of elements in the given list\")\r\n# Pass the given list and length of the given list as the arguments to the\r\n# getElementsLarger() function.\r\ngetElementsLarger(gvn_lst, lengt_lst)"}
{"nl": "You're given a string of words. You need to find the word \"Nemo\", and return a string like this: \"I found Nemo at [the order of the word you find Nemo]!\".\r\n\r\nIf you can't find Nemo, return \"I can't find Nemo :(\".\r\n\r\nExamples\r\nfind_nemo(\"I am finding Nemo !\") \u279e \"I found Nemo at 4!\"\r\n\r\nfind_nemo(\"Nemo is me\") \u279e \"I found Nemo at 1!\"\r\n\r\nfind_nemo(\"I Nemo am\") \u279e \"I found Nemo at 2!\"\r\nNotes\r\n! , ? . are always separated from the last word.\r\nNemo will always look like Nemo, and not NeMo or other capital variations.\r\nNemo's, or anything that says Nemo with something behind it, doesn't count as Finding Nemo.\r\nIf there are multiple Nemo's in the sentence, only return the first one.", "code": "def find_nemo(sentence):\r\n    s=sentence.split()\r\n    if 'Nemo' in s:\r\n        return 'I found Nemo at {}!'.format(s.index('Nemo')+1)\r\n    return \"I can't find Nemo :(\"\r"}
{"nl": "Write a function that reverses a string. Make your function recursive.\nExamples\nreverse(\"hello\") \u279e \"olleh\"\n\nreverse(\"world\") \u279e \"dlrow\"\n\nreverse(\"a\") \u279e \"a\"\n\nreverse(\"\") \u279e \"\"\nNotes\nFor non-base cases, your function must call itself at least once.\nCheck the Resources tab for info on recursion.", "code": "def reverse(str):\n  return reverse(str[1:]) + str[0] if str else str"}
{"nl": "Given a Weighted Directed Acyclic Graph (DAG) and a source vertex s in it, find the longest distances from s to all other vertices in the given graph.\nThe longest path problem for a general graph is not as easy as the shortest path problem because the longest path problem doesn\u2019t have optimal substructure property. In fact, the Longest Path problem is NP-Hard for a general graph. However, the longest path problem has a linear time solution for directed acyclic graphs. The idea is similar to linear time solution for shortest path in a directed acyclic graph., we use Topological Sorting.\u00a0\nWe initialize distances to all vertices as minus infinite and distance to source as 0, then we find a topological sorting of the graph. Topological Sorting of a graph represents a linear ordering of the graph (See below, figure (b) is a linear representation of figure (a) ). Once we have topological order (or linear representation), we one by one process all vertices in topological order. For every vertex being processed, we update distances of its adjacent using distance of current vertex.\nFollowing figure shows step by step process of finding longest paths.\nFollowing is complete algorithm for finding longest distances. \n1) Initialize dist[] = {NINF, NINF, \u2026.} and dist[s] = 0 where s is the source vertex. Here NINF means negative infinite. \n2) Create a topological order of all vertices. \n3) Do following for every vertex u in topological order. \n\u2026\u2026\u2026..Do following for every adjacent vertex v of u \n\u2026\u2026\u2026\u2026\u2026\u2026if (dist[v] < dist[u] + weight(u, v)) \n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026dist[v] = dist[u] + weight(u, v) \n\n", "code": "# A recursive function used by longestPath. See below\n# link for details\n# https:#www.geeksforgeeks.org/topological-sorting/\ndef topologicalSortUtil(v):\n\u00a0\u00a0\u00a0\u00a0global Stack, visited, adj\n\u00a0\u00a0\u00a0\u00a0visited[v] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for all the vertices adjacent to this vertex\n\u00a0\u00a0\u00a0\u00a0# list<AdjListNode>::iterator i\n\u00a0\u00a0\u00a0\u00a0for i in adj[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not visited[i[0]]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0topologicalSortUtil(i[0])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Push current vertex to stack which stores topological\n\u00a0\u00a0\u00a0\u00a0# sort\n\u00a0\u00a0\u00a0\u00a0Stack.append(v)\n\u00a0\n# The function to find longest distances from a given vertex.\n# It uses recursive topologicalSortUtil() to get topological\n# sorting.\ndef longestPath(s):\n\u00a0\u00a0\u00a0\u00a0global Stack, visited, adj, V\n\u00a0\u00a0\u00a0\u00a0dist = [-10**9 for i in range(V)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Call the recursive helper function to store Topological\n\u00a0\u00a0\u00a0\u00a0# Sort starting from all vertices one by one\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited[i] == False):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0topologicalSortUtil(i)\n\u00a0\u00a0\u00a0\u00a0# print(Stack)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize distances to all vertices as infinite and\n\u00a0\u00a0\u00a0\u00a0# distance to source as 0\n\u00a0\u00a0\u00a0\u00a0dist[s] = 0\n\u00a0\u00a0\u00a0\u00a0# Stack.append(1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Process vertices in topological order\n\u00a0\u00a0\u00a0\u00a0while (len(Stack) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the next vertex from topological order\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = Stack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0del Stack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#print(u)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update distances of all adjacent vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# list<AdjListNode>::iterator i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dist[u] != 10**9):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in adj[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# print(u, i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dist[i[0]] < dist[u] + i[1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i[0]] = dist[u] + i[1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print calculated longest distances\n\u00a0\u00a0\u00a0\u00a0# print(dist)\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"INF \",end=\"\") if (dist[i] == -10**9) else print(dist[i],end=\" \")\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0V, Stack, visited = 6, [], [False for i in range(7)]\n\u00a0\u00a0\u00a0\u00a0adj = [[] for i in range(7)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a graph given in the above diagram.\n\u00a0\u00a0\u00a0\u00a0# Here vertex numbers are 0, 1, 2, 3, 4, 5 with\n\u00a0\u00a0\u00a0\u00a0# following mappings:\n\u00a0\u00a0\u00a0\u00a0# 0=r, 1=s, 2=t, 3=x, 4=y, 5=z\n\u00a0\u00a0\u00a0\u00a0adj[0].append([1, 5])\n\u00a0\u00a0\u00a0\u00a0adj[0].append([2, 3])\n\u00a0\u00a0\u00a0\u00a0adj[1].append([3, 6])\n\u00a0\u00a0\u00a0\u00a0adj[1].append([2, 2])\n\u00a0\u00a0\u00a0\u00a0adj[2].append([4, 4])\n\u00a0\u00a0\u00a0\u00a0adj[2].append([5, 2])\n\u00a0\u00a0\u00a0\u00a0adj[2].append([3, 7])\n\u00a0\u00a0\u00a0\u00a0adj[3].append([5, 1])\n\u00a0\u00a0\u00a0\u00a0adj[3].append([4, -1])\n\u00a0\u00a0\u00a0\u00a0adj[4].append([5, -2])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0s = 1\n\u00a0\u00a0\u00a0\u00a0print(\"Following are longest distances from source vertex \",s)\n\u00a0\u00a0\u00a0\u00a0longestPath(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by mohit kumar 29.\n"}
{"nl": "A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm is an algorithm that performs two useful operations on such a data structure:\n\nFind: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.\nUnion: Join two subsets into a single subset. Here first we have to check if the two subsets belong to same set. If no, then we cannot perform union.\n\nIn this post, we will discuss the application of Disjoint Set Data Structure. The application is to check whether a given graph contains a cycle or not.\n\nUnion-Find Algorithm can be used to check whether an undirected graph contains cycle or not. Note that we have discussed an algorithm to detect cycle. This is another method based on Union-Find. This method assumes that the graph doesn\u2019t contain any self-loops. \n\nWe can keep track of the subsets in a 1D array, let\u2019s call it parent[].\n", "code": "# Python Program for union-find algorithm to detect cycle in a undirected graph\n# we have one egde for any two vertex i.e 1-2 is either 1-2 or 2-1 but not both\n\nfrom collections import defaultdict\n\n#This class represents a undirected graph using adjacency list representation\nclass Graph:\n\n\tdef __init__(self,vertices):\n\t\tself.V= vertices #No. of vertices\n\t\tself.graph = defaultdict(list) # default dictionary to store graph\n\n\n\t# function to add an edge to graph\n\tdef addEdge(self,u,v):\n\t\tself.graph[u].append(v)\n\n\t# A utility function to find the subset of an element i\n\tdef find_parent(self, parent,i):\n\t\tif parent[i] == -1:\n\t\t\treturn i\n\t\tif parent[i]!= -1:\n\t\t\treturn self.find_parent(parent,parent[i])\n\n\t# A utility function to do union of two subsets\n\tdef union(self,parent,x,y):\n\t\tparent[x] = y\n\n\n\n\t# The main function to check whether a given graph\n\t# contains cycle or not\n\tdef isCyclic(self):\n\t\t\n\t\t# Allocate memory for creating V subsets and\n\t\t# Initialize all subsets as single element sets\n\t\tparent = [-1]*(self.V)\n\n\t\t# Iterate through all edges of graph, find subset of both\n\t\t# vertices of every edge, if both subsets are same, then\n\t\t# there is cycle in graph.\n\t\tfor i in self.graph:\n\t\t\tfor j in self.graph[i]:\n\t\t\t\tx = self.find_parent(parent, i)\n\t\t\t\ty = self.find_parent(parent, j)\n\t\t\t\tif x == y:\n\t\t\t\t\treturn True\n\t\t\t\tself.union(parent,x,y)\n\n\n# Create a graph given in the above diagram\ng = Graph(3)\ng.addEdge(0, 1)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\n\nif g.isCyclic():\n\tprint (\"Graph contains cycle\")\nelse :\n\tprint (\"Graph does not contain cycle \")\n\n#This code is contributed by Neelam Yadav"}
{"nl": "Given an array that represents Inorder Traversal, find all possible Binary Trees with the given Inorder traversal and print their preorder traversals.", "code": "# Python program to find binary tree with given\r\n# inorder traversal\r\n\r\n# Node Structure\r\nclass Node:\r\n\r\n\t# Utility to create a new node\r\n\tdef __init__(self , item):\r\n\t\tself.key = item\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# A utility function to do preorder traversal of BST\r\ndef preorder(root):\r\n\tif root is not None:\r\n\t\tprint (root.key,end=\" \")\r\n\t\tpreorder(root.left)\r\n\t\tpreorder(root.right)\r\n\r\n\r\n# Function for constructing all possible trees with\r\n# given inorder traversal stored in an array from\r\n# arr[start] to arr[end]. This function returns a\r\n# vector of trees.\r\ndef getTrees(arr , start , end):\r\n\r\n\t# List to store all possible trees\r\n\ttrees = []\r\n\t\r\n\t\"\"\" if start > end then subtree will be empty so\r\n\treturning NULL in the list \"\"\"\r\n\tif start > end :\r\n\t\ttrees.append(None)\r\n\t\treturn trees\r\n\t\r\n\r\n\t\"\"\" Iterating through all values from start to end\r\n\t\tfor constructing left and right subtree\r\n\t\trecursively \"\"\"\r\n\tfor i in range(start , end+1):\r\n\r\n\t\t# Constructing left subtree\r\n\t\tltrees = getTrees(arr , start , i-1)\r\n\t\t\r\n\t\t# Constructing right subtree\r\n\t\trtrees = getTrees(arr , i+1 , end)\r\n\t\t\r\n\t\t\"\"\" Looping through all left and right subtrees\r\n\t\tand connecting to ith root below\"\"\"\r\n\t\tfor j in ltrees :\r\n\t\t\tfor k in rtrees :\r\n\r\n\t\t\t\t# Making arr[i] as root\r\n\t\t\t\tnode = Node(arr[i])\r\n\t\r\n\t\t\t\t# Connecting left subtree\r\n\t\t\t\tnode.left = j\r\n\r\n\t\t\t\t# Connecting right subtree\r\n\t\t\t\tnode.right = k\r\n\r\n\t\t\t\t# Adding this tree to list\r\n\t\t\t\ttrees.append(node)\r\n\treturn trees\r\n\r\n# Driver program to test above function\r\ninp = [4 , 5, 7]\r\nn = len(inp)\r\n\r\ntrees = getTrees(inp , 0 , n-1)\r\n\r\nprint (\"Preorder traversals of different possible\\\r\nBinary Trees are \")\r\nfor i in trees :\r\n\tpreorder(i);\r\n\tprint (\"\")\r\n\r\n# This program is contributed by Nikhil Kumar Singh(nickzuck_007)\r"}
{"nl": "This python program calculates Highest Common Factor (HCF) & Lowest Common Multiple (LCM) of two numbers given by user. HCF is also known as Greatest Common Divisor (GCD).\r\nHighest Common Factor (HCF): The greatest common factor to any two or more than two integer numbers is known as HCF of these numbers. For example, HCF of 12 and 18 is 6.\r\n\r\nLowest Common Multiple (LCM): The smallest or lowest common multiple of any two or more than two integer numbers is termed as LCM. For example, LCM of 12 and 18 is 36.", "code": "# Python program to find hcf (gcd) & lcm\r\n\r\n# Defining function to calculate hcf\r\ndef find_gcd(a,b):\r\n    gcd = 1\r\n    for i in range(1,a+1):\r\n        if a%i==0 and b%i==0:\r\n           gcd = i\r\n    return gcd\r\n\r\n# Reading numbers from user\r\nfirst = int(input('Enter first number: '))\r\nsecond = int(input('Enter second number: '))\r\n\r\n# Function call & displaying output HCF (GCD)\r\nprint('HCF or GCD of %d and %d is %d' %(first, second, find_gcd(first, second)))\r\n\r\n# Calculating LCM\r\nlcm = first * second / find_gcd(first, second)\r\nprint('LCM of %d and %d is %d' %(first, second, lcm))"}
{"nl": "Given a number N the task is to find the Nth Pentagonal Number in Python.\r\n\r\nNth Pentagonal Number:\r\n\r\nn is the nth pentagonal number. When the pentagons are overlapped so that they share one vertex, Pn is the number of different dots in a pattern of dots consisting of the outlines of regular pentagons with sides up to n dots.\r\n\r\nA polygonal number (triangular number, square number, and so on) is a number that is represented as dots or pebbles ordered in the shape of a regular polygon. The first few pentagonal numbers are as follows: 1, 5, 12, and so on.", "code": "# Create a function nthPentagonalNumb() which accepts the given number\r\n# as an argument and returns the nth pentagonal number.\r\n\r\n\r\ndef nthPentagonalNumb(numb):\r\n        # Inside the nthPentagonalNumb() function.\r\n        # Calculate the value of (3*n*n - n)/2 where n is the argument and\r\n    # store it in a variable say reslt.\r\n    reslt = (3*numb*numb - numb)/2\r\n    # Return the reslt.\r\n    return int(reslt)\r\n\r\n\r\n# Give the number N as static Input and store it in a variable.\r\ngvnnumb = 4\r\n# Pass the given Number as an argument to nthPentagonalNumb() \r\n# function and store the result returned from the function in a variable say nthNumb.\r\nnthNumb = nthPentagonalNumb(gvnnumb)\r\n# Print the nthNumb value.\r\nprint('The {', gvnnumb, '} pentagonal number = ', nthNumb)"}
{"nl": "Check a Binary Number is Divisible by a Number N (User input)", "code": "# Give the binary number as user input using int(input()) and store it in a variable.\r\nbinry = int(input(\"Enter some random number = \"))\r\n# Given the number as user input using int(input()) and store it in another variable.\r\nnum = int(input(\"Enter some random number = \"))\r\n# Convert the given binary number into a decimal number using int(str(binary number),2)\r\n# function and store it in another variable say \"deci\".\r\ndeci = int(str(binry), 2)\r\n# Check if the above-obtained decimal number modulus given number is equal to 0 using the if\r\n# conditional statement.\r\nif deci % num == 0:\r\n    # If the statement is true, then print \"The binary number is divisible by the given\r\n    # input number\".\r\n    print(\"The given binary number is divisible by{\", num, \"}\")\r\nelse:\r\n # Else print \"\"The binary number is not divisible by the given input number\".\r\n    print(\"The given binary number is not divisible by{\", num, \"}\")"}
{"nl": "In the previous article, we have discussed Python Program to Get n Random Items from a List\n Random Module in python :\n As this Random module is one of Python\u2019s predefined modules, its methods return random values.\n It selects integers uniformly from a range. For sequences, it has a function to generate a random permutation of a list in-place, as well as a function to generate a random sampling without replacement. Let\u2019s take a look at how to import the Random Module.\n The random module in Python is made up of various built-in Methods.\n choice(): choice() is used to select an item at random from a list, tuple, or other collection.\n Because the choice() method returns a single element, we will be using it in looping statements.\n sample(): To meet our needs, we\u2019ll use sample() to select multiple values.\n Examples:\n Example1:\n Input:\n Given no of random numbers to be generated = 3\n \n Given tuple = (\"btechgeeks\", 321, \"good morning\", [7, 8, 5, 33], 35.8)\n Output:\n Example 2:\n Input:\n Given no of random numbers to be generated = 4\n \n Given tuple = (255, \"hello\", \"btechgeeks\", 150,\"good morning\", [1, 2, 3, 4], 100, 98)\n Output:\n The given 4 Random numbers are :\n \n [1, 2, 3, 4]\n \n 255\n \n 255\n \n 98", "code": "# Import random module using the import keyword.\n \n import random\n \n # Give the tuple as static input and store it in a variable.\n \n gvn_tupl = (255, \"hello\", \"btechgeeks\", 150,\n \n  \"good morning\", [1, 2, 3, 4], 100, 98)\n \n # Apply random.choice() method for the above given tuple and store it in another variable.\n \n reslt = random.choice(gvn_tupl)\n \n # Print the random element from the above given tuple\n \n print(\"The random element from the above given tuple = \", reslt)\n \n </pre>"}
{"nl": "In this program, you'll learn to display Fibonacci sequence using a recursive function.", "code": "# Python program to display the Fibonacci sequence\n\ndef recur_fibo(n):\n   if n <= 1:\n       return n\n   else:\n       return(recur_fibo(n-1) + recur_fibo(n-2))\n\nnterms = 10\n\n# check if the number of terms is valid\nif nterms <= 0:\n   print(\"Plese enter a positive integer\")\nelse:\n   print(\"Fibonacci sequence:\")\n   for i in range(nterms):\n       print(recur_fibo(i))"}
{"nl": "Write a Python program to print triangle numbers pattern using for loop.\n\n", "code": "rows = int(input(\"Enter Triangle Numbers Pattern Rows = \"))\n\nprint(\"====The Triangle Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(rows, i, -1):\n        print(end = ' ')\n    for k in range(1, i + 1):\n        print(k, end = ' ')\n    print()"}
{"nl": "In this example, you will learn to check if a string is a number (float).", "code": "def isfloat(num):\n    try:\n        float(num)\n        return True\n    except ValueError:\n        return False\n\nprint(isfloat('s12'))\nprint(isfloat('1.123'))"}
{"nl": "Given two integers x and n, write a function to compute xn. We may assume that x and n are small and overflow doesn\u2019t happen.", "code": "# Python3 code for extended version\n# of power function that can work\n# for float x and negative y\n\ndef power(x, y):\n\n\tif(y == 0): return 1\n\ttemp = power(x, int(y / 2))\n\t\n\tif (y % 2 == 0):\n\t\treturn temp * temp\n\telse:\n\t\tif(y > 0): return x * temp * temp\n\t\telse: return (temp * temp) / x\n\t\n# Driver Code\nx, y = 2, -3\nprint('%.6f' %(power(x, y)))\n\n# This code is contributed by Smitha Dinesh Semwal.\n"}
{"nl": "Method #1: Using For Loop (Static Input)\r\nApproach:\r\n\r\nGive the number of rows as static input and store it in a variable.\r\nTake a variable and initialize it with 2*double the number of rows say lastnumb.\r\nTake another variable and initialize it with the lastnumb say evennumb.\r\nLoop from 1 to the number of rows using For loop.\r\nInitialize the evennumb with the lastnumb.\r\nLoop from 0 to the iterator value of the parent For loop using another for loop(Nested For loop).\r\nPrint the evennumb.\r\nReduce the evennumb by 2.\r\nPrint the Newline character after the end of the inner loop.\r\nThe Exit of the Program.", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumberOfRows = 10\r\n# Take a variable and initialize it with 2*double the number of rows say lastnumb.\r\nlastnumb = 2*numberOfRows\r\n# Take another variable and initialize it with the lastnumb say evennumb.\r\nevennumb = lastnumb\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numberOfRows+1):\r\n    # Initialize the evennumb with the lastnumb.\r\n    evennumb = lastnumb\r\n    # Loop from 0 to the iterator value of the parent For loop using\r\n    # another for loop(Nested For loop).\r\n    for n in range(0, m):\r\n        # Print the evennumb.\r\n        print(evennumb, end=' ')\r\n        # Reduce the evennumb by 2.\r\n        evennumb = evennumb-2\r\n\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "Now in this post, we will discuss how to count consonants in a string in python using various methods. The alphabets \u2018A\u2019, \u2018E\u2019, \u2018I\u2019, \u2018O\u2019, \u2018U\u2019 (in uppercase) and \u2018a\u2019, \u2018e\u2019, \u2018i\u2019, \u2018o\u2019, \u2018u\u2019 are vowels, and remaining alphabets are called consonants.", "code": "# Python program to count consonant in a string def countConsonants(string): num_consonants = 0 # to count the consonants for char in string: if char not in \"aeiouAEIOU \": num_consonants += 1 return num_consonants # take input string = input('Enter any string: ') # calling function and display result print('No of consonants:',countConsonants(string))"}
{"nl": "Create a function that filters out a list to include numbers that only have a certain number of digits.\nExamples\nfilter_digit_length([88, 232, 4, 9721, 555], 3) \u279e [232, 555]\n# Include only numbers with 3 digits.\n\nfilter_digit_length([2, 7, 8, 9, 1012], 1) \u279e [2, 7, 8, 9]\n# Include only numbers with 1 digit.\n\nfilter_digit_length([32, 88, 74, 91, 300, 4050], 1) \u279e []\n# No numbers with only 1 digit exist => return empty list.\n\nfilter_digit_length([5, 6, 8, 9], 1) \u279e [5, 6, 8, 9]\n# All numbers in the list have 1 digit only => return original list.\nNotes\nIf no numbers of the specified digit length exist, return an empty list.\nIf all numbers in the list have the specified digit length, return the original list.\nThe sub-list returned should have the same relative order as the original list.", "code": "def filter_digit_length(lst, num):\n    return [number for number in lst if len(str(number)) == num]"}
{"nl": "A Python dictionary is stored the data in the pair of key-value. It organizes the data in a unique manner where some specific value exists for some particular key. It is a mutable data-structure; its element can be modified after creation. Before creating a dictionary, we should remember the following points.\n\nKeys must be unique and must contain a single value.\nValues can be any type, such as integer, list, tuple, string, etc.\nKeys must be immutable.", "code": "dict = {}  \nprint(\"Empty Dictionary is: \")  \nprint(dict)  \n  \n# Creating a Dictionary  \n# using the dict() method  \ndict1 = dict({1: 'Hello', 2: 'Hi', 3: 'Hey'})  \nprint(\"\\nCreate Dictionary by using the dict() method : \")  \nprint(dict1)  \n  \n# Creating a Dictionary  \n# with each item as a Pair  \ndict2 = dict([('Devansh', 90014), ('Arun', 90015)])  \nprint(\"\\nDictionary with each item as a pair: \")  \nprint(dict2)  "}
{"nl": "Tuple Length\r\nTo determine how many items a tuple has, use the len() method:", "code": "thistuple = (\"apple\", \"banana\", \"cherry\")\r\nprint(len(thistuple))"}
{"nl": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\n\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\n\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\n\nA substring is a contiguous sequence of characters within the string.\n\n ", "code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        l = r = 0\n        n = len(num)\n        result = ''\n        while r<n:\n            curr_digit = int(num[r])\n            new_digit = change[curr_digit]\n            if curr_digit >= new_digit and l == r:\n                result += num[r]\n                l += 1\n                r += 1\n                continue\n\n            if l < r and new_digit < curr_digit:\n                break\n            \n            result += str(change[curr_digit])\n            r += 1\n\n        while r<n:\n            result += num[r]\n            r += 1\n        \n        return result"}
{"nl": "Instructions\nGiven a 3 x 4 grid of pipes, underscores, and spaces, determine which number is represented, or whether it is garbled.\n\nStep One\nTo begin with, convert a simple binary font to a string containing 0 or 1.\n\nThe binary font uses pipes and underscores, four rows high and three columns wide.\n\n     _   #\n    | |  # zero.\n    |_|  #\n         # the fourth row is always blank\nIs converted to \"0\"\n\n         #\n      |  # one.\n      |  #\n         # (blank fourth row)\nIs converted to \"1\"\n\nIf the input is the correct size, but not recognizable, your program should return '?'\n\nIf the input is the incorrect size, your program should return an error.\n\nStep Two\nUpdate your program to recognize multi-character binary strings, replacing garbled numbers with ?\n\nStep Three\nUpdate your program to recognize all numbers 0 through 9, both individually and as part of a larger string.\n\n _\n _|\n|_\n\nIs converted to \"2\"\n\n      _  _     _  _  _  _  _  _  #\n    | _| _||_||_ |_   ||_||_|| | # decimal numbers.\n    ||_  _|  | _||_|  ||_| _||_| #\n                                 # fourth line is always blank\nIs converted to \"1234567890\"\n\nStep Four\nUpdate your program to handle multiple numbers, one per line. When converting several lines, join the lines with commas.\n\n    _  _\n  | _| _|\n  ||_  _|\n\n    _  _\n|_||_ |_\n  | _||_|\n\n _  _  _\n  ||_||_|\n  ||_| _|\n\nIs converted to \"123,456,789\"\n\nException messages\nSometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.\n\nThis particular exercise requires that you use the raise statement to \"throw\" a ValueError when the convert() function receives a string that isn't a valid OCR number. The tests will only pass if you both raise the exception and include a message with it.\n\nTo raise a ValueError with a message, write the message as an argument to the exception type:\n\n# when the rows aren't multiples of 4\nraise ValueError(\"Number of input lines is not a multiple of four\")\n\n# when the columns aren't multiples of 3\nraise ValueError(\"Number of input columns is not a multiple of three\")", "code": "VALID_NUMBERS = [[\" _ \", \"| |\", \"|_|\", \"   \"], [\"   \", \"  |\", \"  |\", \"   \"], [\" _ \", \" _|\", \"|_ \", \"   \"], [\" _ \", \" _|\", \" _|\", \"   \"], [\"   \",\"|_|\", \"  |\", \"   \"],    [\" _ \", \"|_ \", \" _|\", \"   \"], [\" _ \", \"|_ \", \"|_|\", \"   \"], [\" _ \", \"  |\", \"  |\", \"   \"], [\" _ \", \"|_|\", \"|_|\", \"   \"], [\" _ \", \"|_|\", \" _|\", \"   \"]]\r\ndef convert(input_grid):\r\n    if len(input_grid) % 4 != 0:\r\n        raise ValueError(\"Number of input lines is not a multiple of four\")\r\n    for line in input_grid:\r\n        if len(line) % 3 != 0:\r\n            raise ValueError(\"Number of input columns is not a multiple of three\")\r\n    \r\n    rows = [[input_grid[i+j][k:k+3]\r\n            for k in range(0, len(input_grid[0]), 3)\r\n            for j in range(0, 4) ]\r\n            for i in range(0, len(input_grid), 4)\r\n           ]\r\n    # print(rows)\r\n    result = \"\"\r\n    for row in rows:\r\n        for i in range(0, len(row), 4):\r\n            result += convert_single_digit(row[i: i+4])\r\n        result += \",\"\r\n    return result[0:-1] #slice off the last comma\r\n            \r\ndef convert_single_digit(input):\r\n    print(input)\r\n    if input in VALID_NUMBERS:\r\n        return str(VALID_NUMBERS.index(input))\r\n    return \"?\"\r\n"}
{"nl": "Object-Oriented Programming(OOPS):\n\nObject-Oriented Programming (OOP) is a programming paradigm based on the concepts of classes and objects. It is used to organize a software program into simple, reusable code blueprints (typically referred to as classes), which are then used to build individual instances of objects. Object-oriented programming languages include JavaScript, C++, Java, and Python, among others.\n\nA class is a generic blueprint that can be used to generate more specific, concrete things. Classes are frequently used to represent broad groups, such as Cars or Dogs, that share property. These classes indicate what properties, such as color, an instance of this type will have, but not the value of those attributes for a specific object.\n\n\n\nAn object comprises data, such as the raw or preprocessed materials at each step of an assembly line, as well as behavior, such as the action performed by each assembly line component.\n\nPython, like other general-purpose programming languages, has always been an object-oriented language. It enables us to create a program with an Object-Oriented approach. Classes and objects are simple to build and utilize in Python.\n\nLists in Python:\n\nIn Python, a list is a data structure that works as a container for several values. A Python list is an ordered sequence of values that can be added to, deleted from, and replaced with new values. As a result, a list in Python can expand and contract in size. Each item in a list is referred to as an element, a list item, or simply an item.\n\nGiven a list, the task is to print all the subsets of the given list using classes.\n\nExamples:\n\nExample1:\n\nInput:\n\ngiven list = [4, 19, 2, 5, 3]\nOutput:\n\nSubsets of the given list [4, 19, 2, 5, 3] :\n[[], [19], [5], [5, 19], [4], [4, 19], [4, 5], [4, 5, 19], [3], [3, 19], [3, 5], [3, 5, 19], [3, 4], [3, 4, 19], [3, 4, 5], [3, 4, 5, 19],\n [2], [2, 19], [2, 5], [2, 5, 19], [2, 4], [2, 4, 19], [2, 4, 5], [2, 4, 5, 19], [2, 3], [2, 3, 19], [2, 3, 5], [2, 3, 5, 19], [2, 3, 4], \n[2, 3, 4, 19], [2, 3, 4, 5], [2, 3, 4, 5, 19]]\nExample2:\n\nInput:\n\ngiven list = ['hello', 'this', 'is', 'btechgeeks']\nOutput:\n\nSubsets of the given list ['hello', 'this', 'is', 'btechgeeks'] :\n[[], ['this'], ['is'], ['is', 'this'], ['hello'], ['hello', 'this'], ['hello', 'is'], ['hello', 'is', 'this'], ['btechgeeks'], ['btechgeeks', 'this'],\n ['btechgeeks', 'is'], ['btechgeeks', 'is', 'this'], ['btechgeeks', 'hello'], ['btechgeeks', 'hello', 'this'], ['btechgeeks', 'hello',\n 'is'], ['btechgeeks', 'hello', 'is', 'this']]", "code": "class sublist:\n  def sortlist(self, given_list):\n  # To compute all possible subsets of the list, the method\n  # printSubsets() is called from sortlist() method.\n  return self.printSubsets([], sorted(given_list))\n  # The printSubsetsis used to return all possible sublists of the given list.\n  def printSubsets(self, curr, given_list):\n  if given_list:\n  return self.printSubsets(curr, given_list[1:]) + self.printSubsets(curr + [given_list[0]], given_list[1:])\n  return [curr]\n# given list\ngiven_list = [4, 19, 2, 5, 3]\n# Create an object to represent the class.\nlistobj = sublist()\n# Call the sortlist method with the object created above.\nprint(\"Subsets of the given list\", given_list, \":\")\nprint(sublist().sortlist(given_list))"}
{"nl": "Given a list, the task is to find Kth\u2019s Smallest and largest element in the given Unsorted list in Python.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given List =[19, 24, 25, 36, 81, 144, 600, 900, 225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n Given k=6\n Output:\n \n The given list before sorting is [19, 24, 25, 36, 81, 144, 600, 900, 225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n The given list after sorting is [1, 4, 9, 10, 16, 19, 23, 24, 25, 25, 25, 36, 49, 49, 81, 144, 225, 600, 900]\n The 6 th smallest element in the given list is [ 19 ]\n The 6 th largest element in the given list is [ 49 ]\n Example2:\n \n Input:\n \n Given list = [8, 45, 29, 19, 75, 68, 42, 13, 7, 9, 6, 4, 5, 96, 97, 91, 49, 72]\n Given K =3\n Output:\n \n The given list before sorting is [8, 45, 29, 19, 75, 68, 42, 13, 7, 9, 6, 4, 5, 96, 97, 91, 49, 72]\n The given list after sorting is [4, 5, 6, 7, 8, 9, 13, 19, 29, 42, 45, 49, 68, 72, 75, 91, 96, 97]\n The 3 th smallest element in the given list is [ 6 ]\n The 3 th largest element in the given list is [ 91 ]", "code": "# Give the list as static input and store it in a variable.\n gvnlst = [19, 24, 25, 36, 81, 144, 600, 900,\n  225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n print('The given list before sorting is', gvnlst)\n # Give the value of K as static input and store it in a variable.\n kth = 6\n # Sort the given list using the sort() function\n # which sorts the given list in ascending order.\n gvnlst.sort()\n print('The given list after sorting is', gvnlst)\n # We can get the Kth smallest element in the given list\n # by printing the k-1 index element in this sorted list.\n print('The', kth,\n  'th smallest element in the given list is [', gvnlst[kth-1], ']')\n # We can get the Kth largest element in the given list\n # by printing the -k index element in this sorted list\n # ( '-' refers to negative indexing).\n print('The', kth,\n  'th largest element in the given list is [', gvnlst[-kth], ']')"}
{"nl": "You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\nYou are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\nYou can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\nReturn the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.\n \nExample 1:\n\n\nInput: customers = [8,3], boardingCost = 5, runningCost = 6\nOutput: 3\nExplanation: The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.\n\nExample 2:\n\nInput: customers = [10,9,6], boardingCost = 6, runningCost = 4\nOutput: 7\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\n\nExample 3:\n\nInput: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\nOutput: -1\nExplanation:\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1.\n\n \nConstraints:\n\nn == customers.length\n1 <= n <= 105\n0 <= customers[i] <= 50\n1 <= boardingCost, runningCost <= 100", "code": "import sys\nMIN_INT = -sys.maxsize-1\nclass Solution:\n  def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n  maxx = MIN_INT\n  rotate = total =  ans = money = num = i = 0\n  for i in range(len(customers)):\n  total += customers[i]\n  rotate = i+1\n  if total >= 4:\n  num += 4\n  total -= 4\n  else: \n  num += total\n  total = 0\n  money = num * boardingCost - rotate * runningCost\n  if maxx < money:\n  maxx = money\n  ans = rotate\n  i+=1\n  while(total > 0):\n  rotate = i+1\n  if total >= 4:\n  num += 4\n  total -= 4\n  else: \n  num += total\n  total = 0\n  money = num * boardingCost - rotate * runningCost\n  if maxx < money:\n  maxx = money\n  ans = rotate\n  i+=1\n  if maxx < 0: return -1\n  return ans"}
{"nl": "Generate Strong Numbers in an Interval (User input)", "code": "# Import the math module using import keyword.\r\nimport math\r\n#Give the lower limit range as user input using int(input()) and\r\n#store it in a variable.\r\ngvn_lower_lmt = int(input(\"Enter some random number = \"))\r\n#Give the upper limit range as user input using int(input()) and \r\n#store it in another variable.\r\ngvn_upper_lmt = int(input(\"Enter some random number = \"))\r\n# Loop from lower limit range to upper limit range using For loop.\r\nprint(\"The Strong Numbers in a given range\",\r\n      gvn_lower_lmt, \"and\", gvn_upper_lmt, \"are :\")\r\nfor itr in range(gvn_lower_lmt, gvn_upper_lmt+1):\r\n   # Taking a variable totalSum and initializing it with 0\r\n    totalSum = 0\r\n    # Put the iterator value in a temporary variable called tempNum.\r\n    tempNum = itr\r\n    # using while to extract digit by digit of the given iterator value\r\n    while(itr):\r\n        s = 1\r\n        factNum = 1\r\n        # Getting the last digit of the iterator value\r\n        remainder = itr % 10\r\n        # calculating the factorial of the digit(extracted by remainder variable)\r\n        # using math.fatorial function\r\n        factNum = math.factorial(remainder)\r\n        # Adding the factorial to the totalSum\r\n        totalSum = totalSum + factNum\r\n        # Dividing the given itertor value by 10\r\n        itr = itr//10\r\n    # checking if the totalSum is equal to the iterator value\r\n    # if it is true then it is strong number then return true\r\n    if(totalSum == tempNum):\r\n        print(tempNum, end=' ')"}
{"nl": "Given that integers are read from a data stream. Find median of elements read so for in an efficient way. For simplicity assume, there are no duplicates. ", "code": "# code\r\nfrom heapq import heappush, heappop, heapify\r\nimport math\r\nminHeap=[]\r\nheapify(minHeap)\r\nmaxHeap=[]\r\nheapify(maxHeap)\r\ndef insertHeaps(num):\r\n\theappush(maxHeap,-num)\t\t\t ### Pushing negative element to obtain a minHeap for\r\n\theappush(minHeap,-heappop(maxHeap)) ### the negative counterpart\r\n\r\n\tif len(minHeap) > len(maxHeap):\r\n\t\theappush(maxHeap,-heappop(minHeap))\r\n\t\r\ndef getMedian():\r\n\tif len(minHeap)!= len(maxHeap):\r\n\t\treturn -maxHeap[0]\r\n\telse:\r\n\t\treturn (minHeap[0]- maxHeap[0])/2\r\n\r\n\r\nif __name__== '__main__':\r\n\tA= [5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4]\r\n\tn= len(A)\r\n\tfor i in range(n):\r\n\t\tinsertHeaps(A[i])\r\n\t\tprint(math.floor(getMedian()))\r"}
{"nl": "Logistic Regression and Decision Tree classification are two of the most popular and basic classification algorithms being used today. None of the algorithms is better than the other and one\u2019s superior performance is often credited to the nature of the data being worked upon. ", "code": "\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\ncd C:\\Users\\Dev\\Desktop\\Kaggle\\Sinking Titanic\n# Changing the working location to the location of the file\ndf = pd.read_csv('_train.csv')\ny = df['Survived']\n \nX = df.drop('Survived', axis = 1)\nX = X.drop(['Name', 'Ticket', 'Cabin', 'Embarked'], axis = 1)\n \nX = X.replace(['male', 'female'], [2, 3])\n# Hot-encoding the categorical variables\n \nX.fillna(method ='ffill', inplace = True)\n# Handling the missing values\nX_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size = 0.3, random_state = 0)\n \nlr = LogisticRegression()\nlr.fit(X_train, y_train)\nprint(lr.score(X_test, y_test))\r\ncriteria = ['gini', 'entropy']\r\nscores = {}\r\n \r\nfor c in criteria:\r\n    dt = DecisionTreeClassifier(criterion = c)\r\n    dt.fit(X_train, y_train)\r\n    test_score = dt.score(X_test, y_test)\r\n    scores = test_score\r\n \r\nprint(scores)"}
{"nl": "We have already discussed the idea of Skip list and how they work in Skip List | Set 1 (Introduction). In this article, we will be discussing how to insert an element in Skip list.\n\nDeciding nodes level\n\nEach element in the list is represented by a node, the level of the node is chosen randomly while insertion in the list. Level does not depend on the number of elements in the node. The level for node is decided by the following algorithm \u2013\n\nrandomLevel()\nlvl := 1\n//random() that returns a random value in [0...1)\nwhile random() < p and lvl < MaxLevel do\nlvl := lvl + 1\nreturn lvl", "code": "# Python3 code for inserting element in skip list\n\nimport random\n\nclass Node(object):\n\t'''\n\tClass to implement node\n\t'''\n\tdef __init__(self, key, level):\n\t\tself.key = key\n\n\t\t# list to hold references to node of different level\n\t\tself.forward = [None]*(level+1)\n\nclass SkipList(object):\n\t'''\n\tClass for Skip list\n\t'''\n\tdef __init__(self, max_lvl, P):\n\t\t# Maximum level for this skip list\n\t\tself.MAXLVL = max_lvl\n\n\t\t# P is the fraction of the nodes with level\n\t\t# i references also having level i+1 references\n\t\tself.P = P\n\n\t\t# create header node and initialize key to -1\n\t\tself.header = self.createNode(self.MAXLVL, -1)\n\n\t\t# current level of skip list\n\t\tself.level = 0\n\t\n\t# create new node\n\tdef createNode(self, lvl, key):\n\t\tn = Node(key, lvl)\n\t\treturn n\n\t\n\t# create random level for node\n\tdef randomLevel(self):\n\t\tlvl = 0\n\t\twhile random.random()<self.P and \\\n\t\t\tlvl<self.MAXLVL:lvl += 1\n\t\treturn lvl\n\n\t# insert given key in skip list\n\tdef insertElement(self, key):\n\t\t# create update array and initialize it\n\t\tupdate = [None]*(self.MAXLVL+1)\n\t\tcurrent = self.header\n\n\t\t'''\n\t\tstart from highest level of skip list\n\t\tmove the current reference forward while key\n\t\tis greater than key of node next to current\n\t\tOtherwise inserted current in update and\n\t\tmove one level down and continue search\n\t\t'''\n\t\tfor i in range(self.level, -1, -1):\n\t\t\twhile current.forward[i] and \\\n\t\t\t\tcurrent.forward[i].key < key:\n\t\t\t\tcurrent = current.forward[i]\n\t\t\tupdate[i] = current\n\n\t\t'''\n\t\treached level 0 and forward reference to\n\t\tright, which is desired position to\n\t\tinsert key.\n\t\t'''\n\t\tcurrent = current.forward[0]\n\n\t\t'''\n\t\tif current is NULL that means we have reached\n\t\tto end of the level or current's key is not equal\n\t\tto key to insert that means we have to insert\n\t\tnode between update[0] and current node\n\t'''\n\t\tif current == None or current.key != key:\n\t\t\t# Generate a random level for node\n\t\t\trlevel = self.randomLevel()\n\n\t\t\t'''\n\t\t\tIf random level is greater than list's current\n\t\t\tlevel (node with highest level inserted in\n\t\t\tlist so far), initialize update value with reference\n\t\t\tto header for further use\n\t\t\t'''\n\t\t\tif rlevel > self.level:\n\t\t\t\tfor i in range(self.level+1, rlevel+1):\n\t\t\t\t\tupdate[i] = self.header\n\t\t\t\tself.level = rlevel\n\n\t\t\t# create new node with random level generated\n\t\t\tn = self.createNode(rlevel, key)\n\n\t\t\t# insert node by rearranging references\n\t\t\tfor i in range(rlevel+1):\n\t\t\t\tn.forward[i] = update[i].forward[i]\n\t\t\t\tupdate[i].forward[i] = n\n\n\t\t\tprint(\"Successfully inserted key {}\".format(key))\n\n\t# Display skip list level wise\n\tdef displayList(self):\n\t\tprint(\"\\n*****Skip List******\")\n\t\thead = self.header\n\t\tfor lvl in range(self.level+1):\n\t\t\tprint(\"Level {}: \".format(lvl), end=\" \")\n\t\t\tnode = head.forward[lvl]\n\t\t\twhile(node != None):\n\t\t\t\tprint(node.key, end=\" \")\n\t\t\t\tnode = node.forward[lvl]\n\t\t\tprint(\"\")\n\n# Driver to test above code\ndef main():\n\tlst = SkipList(3, 0.5)\n\tlst.insertElement(3)\n\tlst.insertElement(6)\n\tlst.insertElement(7)\n\tlst.insertElement(9)\n\tlst.insertElement(12)\n\tlst.insertElement(19)\n\tlst.insertElement(17)\n\tlst.insertElement(26)\n\tlst.insertElement(21)\n\tlst.insertElement(25)\n\tlst.displayList()\n\nmain()\n"}
{"nl": "Given two strings comprised of + and -, return a new string which shows how the two strings interact in the following way:\n\nWhen positives and positives interact, they remain positive.\nWhen negatives and negatives interact, they remain negative.\nBut when negatives and positives interact, they become neutral, and are shown as the number 0.\n\nWorked Example\n\nneutralise(\"+-+\", \"+--\") \u279e \"+-0\"\n# Compare the first characters of each string, then the next in turn.\n# \"+\" against a \"+\" returns another \"+\".\n# \"-\" against a \"-\" returns another \"-\".\n# \"+\" against a \"-\" returns \"0\".\n# Return the string of characters.\nExamples\n\nneutralise(\"--++--\", \"++--++\") \u279e \"000000\"\n\nneutralise(\"-+-+-+\", \"-+-+-+\") \u279e \"-+-+-+\"\n\nneutralise(\"-++-\", \"-+-+\") \u279e \"-+00\"\nNotes\n\nThe two strings will be the same length.", "code": "def neutralise(s1, s2):\n  return ''.join(a if a == b else '0' for a, b in zip(s1, s2))"}
{"nl": "Write a Python program to print inverted right triangle of decreasing order numbers pattern using for loop.", "code": "rows = int(input(\"Inverted Right Triangle Numbers in Decreasing Ord Rows = \"))\n\nprint(\"==Inverted Right Triangle of Numbers in Decreasing Order Pattern==\")\n\nfor i in range(rows, 0, -1):\n    for j in range(i, 0, -1):\n        print(j, end = ' ')\n    print()"}
{"nl": "In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inorder traversal. \n\nIn Binary Search Tree, Inorder Successor of an input node can also be defined as the node with the smallest key greater than the key of the input node. So, it is sometimes important to find next node in sorted order.\n\nMethod 1 (Uses Parent Pointer) \nIn this method, we assume that every node has a parent pointer. \nThe Algorithm is divided into two cases on the basis of the right subtree of the input node being empty or not.\n\nInput: node, root // node is the node whose Inorder successor is needed. \nOutput: succ // succ is Inorder successor of node.\n\nIf right subtree of node is not NULL, then succ lies in right subtree. Do the following. \nGo to right subtree and return the node with minimum key value in the right subtree.\nIf right subtree of node is NULL, then succ is one of the ancestors. Do the following. \nTravel up using the parent pointer until you see a node which is left child of its parent. The parent of such a node is the succ.", "code": "# Python program to find the inorder successor in a BST\n\u00a0\n# A binary tree node\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\ndef inOrderSuccessor(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Step 1 of the above algorithm\n\u00a0\u00a0\u00a0\u00a0if n.right is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return minValue(n.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Step 2 of the above algorithm\n\u00a0\u00a0\u00a0\u00a0p = n.parent\n\u00a0\u00a0\u00a0\u00a0while( p is not None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if n != p.right :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n = p\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p = p.parent\n\u00a0\u00a0\u00a0\u00a0return p\n\u00a0\n# Given a non-empty binary search tree, return the\n# minimum data value found in that tree. Note that the\n# entire tree doesn't need to be searched\ndef minValue(node):\n\u00a0\u00a0\u00a0\u00a0current = node\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# loop down to find the leftmost leaf\n\u00a0\u00a0\u00a0\u00a0while(current is not None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current.left is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = current.left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return current\n\u00a0\n\u00a0\n# Given a binary search tree and a number, inserts a\n# new node with the given number in the correct place\n# in the tree. Returns the new root pointer which the\n# caller should then use( the standard trick to avoid\n# using reference parameters)\ndef insert( node, data):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 1) If tree is empty then return a new singly node\n\u00a0\u00a0\u00a0\u00a0if node is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(data)\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# 2) Otherwise, recur down the tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if data <= node.data:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = insert(node.left, data)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.left = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.parent = node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = insert(node.right, data)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.right = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.parent = node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# return\u00a0 the unchanged node pointer\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\n\u00a0\n# Driver program to test above function\n\u00a0\nroot = None\n\u00a0\n# Creating the tree given in the above diagram\nroot = insert(root, 20)\nroot = insert(root, 8);\nroot = insert(root, 22);\nroot = insert(root, 4);\nroot = insert(root, 12);\nroot = insert(root, 10);\u00a0\nroot = insert(root, 14);\u00a0\u00a0\u00a0\ntemp = root.left.right.right\n\u00a0\nsucc = inOrderSuccessor(temp)\nif succ is not None:\n\u00a0\u00a0\u00a0\u00a0print (\"\\nInorder Successor of % d is % d \"%(temp.data, succ.data))\nelse:\n\u00a0\u00a0\u00a0\u00a0print (\"\\nInorder Successor doesn't exist\")\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "The program creates a stack and allows the user to perform push and pop operations on it.", "code": "class Stack:\n    def __init__(self):\n        self.items = []\n\u00a0\n    def is_empty(self):\n        return self.items == []\n\u00a0\n    def push(self, data):\n        self.items.append(data)\n\u00a0\n    def pop(self):\n        return self.items.pop()\n\u00a0\n\u00a0\ns = Stack()\nwhile True:\n    print('push <value>')\n    print('pop')\n    print('quit')\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'push':\n        s.push(int(do[1]))\n    elif operation == 'pop':\n        if s.is_empty():\n            print('Stack is empty.')\n        else:\n            print('Popped value: ', s.pop())\n    elif operation == 'quit':\n        break"}
{"nl": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\n \n\nExample 1:\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\nExample 2:\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\nExample 3:\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n \n\nConstraints:\n\n1 <= s.length <= 20\ns consists of digits only.", "code": "class Solution:\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def valid(segment):\n            \"\"\"\n            Check if the current segment is valid :\n            1. less or equal to 255      \n            2. the first character could be '0' \n               only if the segment is equal to '0'\n            \"\"\"\n            return int(segment) <= 255 if segment[0] != '0' else len(segment) == 1\n            \n        def update_output(curr_pos):\n            \"\"\"\n            Append the current list of segments \n            to the list of solutions\n            \"\"\"\n            segment = s[curr_pos + 1:n]\n            if valid(segment):\n                segments.append(segment)\n                output.append('.'.join(segments))\n                segments.pop()    \n            \n        def backtrack(prev_pos = -1, dots = 3):\n            \"\"\"\n            prev_pos : the position of the previously placed dot\n            dots : number of dots to place\n            \"\"\"\n            # The current dot curr_pos could be placed \n            # in a range from prev_pos + 1 to prev_pos + 4.\n            # The dot couldn't be placed \n            # after the last character in the string.\n            for curr_pos in range(prev_pos + 1, min(n - 1, prev_pos + 4)):\n                segment = s[prev_pos + 1:curr_pos + 1]\n                if valid(segment):\n                    segments.append(segment)  # place dot\n                    if dots - 1 == 0:  # if all 3 dots are placed\n                        update_output(curr_pos)  # add the solution to output\n                    else:\n                        backtrack(curr_pos, dots - 1)  # continue to place dots\n                    segments.pop()  # remove the last placed dot\n        \n        n = len(s)\n        output, segments = [], []\n        backtrack() "}
{"nl": "Given a matrix and the task is to check matrix is involutory matrix or not.\u00a0\n\n\nInvolutory Matrix: A matrix is said to be involutory matrix if matrix multiply by itself return the identity matrix. Involutory matrix is the matrix that is its own inverse. The matrix A is said to be involutory matrix if A * A = I. Where I is the identity matrix.\u00a0\n\n\n\u00a0", "code": "# Program to implement involutory matrix.\nN = 3;\n\u00a0\n# Function for matrix multiplication.\ndef multiply(mat, res):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[i][j] = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[i][j] += mat[i][k] * mat[k][j];\n\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\n# Function to check involutory matrix.\ndef InvolutoryMatrix(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0res=[[0 for i in range(N)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# multiply function call.\n\u00a0\u00a0\u00a0\u00a0res = multiply(mat, res);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == j and res[i][j] != 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i != j and res[i][j] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0\u00a0\u00a0return True;\n\u00a0\n# Driver Code\nmat = [[1, 0, 0], [0, -1, 0], [0, 0, -1]];\n\u00a0\n# Function call. If function\n# return true then if part\n# will execute otherwise\n# else part will execute.\nif (InvolutoryMatrix(mat)):\n\u00a0\u00a0\u00a0\u00a0print(\"Involutory Matrix\");\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"Not Involutory Matrix\");\n\u00a0\n# This code is contributed by mits\n"}
{"nl": "It is given by Kaggle from UCI Machine Learning Repository, in one of its challenge \r\nhttps://www.kaggle.com/uciml/breast-cancer-wisconsin-data. It is a dataset of Breast Cancer patients with Malignant and Benign tumor. \r\nLogistic Regression is used to predict whether the given patient is having Malignant or Benign tumor based on the attributes in the given dataset. ", "code": "\n# performing linear algebra\nimport numpy as np\n \n# data processing\nimport pandas as pd\n \n# visualisation\nimport matplotlib.pyplot as plt\ndata = pd.read_csv(\"..\\\\breast-cancer-wisconsin-data\\\\data.csv\")\n \nprint (data.head)\ndata.info()\ndata.drop(['Unnamed: 32', 'id'], axis = 1)\ndata.diagnosis = [1 if each == \"M\" else 0 for each in data.diagnosis]\ny = data.diagnosis.values\nx_data = data.drop(['diagnosis'], axis = 1)\nx = (x_data - np.min(x_data))/(np.max(x_data) - np.min(x_data)).values\nfrom sklearn.model_selection import train_test_split\nx_train, x_test, y_train, y_test = train_test_split(\n    x, y, test_size = 0.15, random_state = 42)\n \nx_train = x_train.T\nx_test = x_test.T\ny_train = y_train.T\ny_test = y_test.T\n \nprint(\"x train: \", x_train.shape)\nprint(\"x test: \", x_test.shape)\nprint(\"y train: \", y_train.shape)\nprint(\"y test: \", y_test.shape)\ndef initialize_weights_and_bias(dimension):\n    w = np.full((dimension, 1), 0.01)\n    b = 0.0\n    return w, b\n# z = np.dot(w.T, x_train)+b\ndef sigmoid(z):\n    y_head = 1/(1 + np.exp(-z))\n    return y_head\ndef forward_backward_propagation(w, b, x_train, y_train):\n    z = np.dot(w.T, x_train) + b\n    y_head = sigmoid(z)\n    loss = - y_train * np.log(y_head) - (1 - y_train) * np.log(1 - y_head)\n    # x_train.shape[1]  is for scaling\n    cost = (np.sum(loss)) / x_train.shape[1]     \n \n    # backward propagation\n    derivative_weight = (np.dot(x_train, (\n        (y_head - y_train).T))) / x_train.shape[1]\n    derivative_bias = np.sum(\n        y_head-y_train) / x_train.shape[1]                \n    gradients = {\"derivative_weight\": derivative_weight,\n                 \"derivative_bias\": derivative_bias}\n    return cost, gradients\ndef update(w, b, x_train, y_train, learning_rate, number_of_iterarion):\n    cost_list = []\n    cost_list2 = []\n    index = []\n \n    # updating(learning) parameters is number_of_iterarion times\n    for i in range(number_of_iterarion):\n        # make forward and backward propagation and find cost and gradients\n        cost, gradients = forward_backward_propagation(w, b, x_train, y_train)\n        cost_list.append(cost)\n \n        # lets update\n        w = w - learning_rate * gradients[\"derivative_weight\"]\n        b = b - learning_rate * gradients[\"derivative_bias\"]\n        if i % 10 == 0:\n            cost_list2.append(cost)\n            index.append(i)\n            print (\"Cost after iteration % i: % f\" %(i, cost))\n \n    # update(learn) parameters weights and bias\n    parameters = {\"weight\": w, \"bias\": b}\n    plt.plot(index, cost_list2)\n    plt.xticks(index, rotation ='vertical')\n    plt.xlabel(\"Number of Iterarion\")\n    plt.ylabel(\"Cost\")\n    plt.show()\n    return parameters, gradients, cost_list"}
{"nl": "Design a queue that supports push and pop operations in the front, middle, and back.\nImplement the FrontMiddleBack class:\n\nFrontMiddleBack() Initializes the queue.\nvoid pushFront(int val) Adds val to the front of the queue.\nvoid pushMiddle(int val) Adds val to the middle of the queue.\nvoid pushBack(int val) Adds val to the back of the queue.\nint popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.\nint popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.\nint popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.\n\nNotice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:\n\nPushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].\nPopping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].\n\n \nExample 1:\n\nInput:\n[\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n[[], [1], [2], [3], [4], [], [], [], [], []]\nOutput:\n[null, null, null, null, null, 1, 3, 4, 2, -1]\n\nExplanation:\nFrontMiddleBackQueue q = new FrontMiddleBackQueue();\nq.pushFront(1);  // [1]\nq.pushBack(2);  // [1, 2]\nq.pushMiddle(3);  // [1, 3, 2]\nq.pushMiddle(4);  // [1, 4, 3, 2]\nq.popFront();  // return 1 -> [4, 3, 2]\nq.popMiddle();  // return 3 -> [4, 2]\nq.popMiddle();  // return 4 -> [2]\nq.popBack();  // return 2 -> []\nq.popFront();  // return -1 -> [] (The queue is empty)\n\n \nConstraints:\n\n1 <= val <= 109\nAt most 1000 calls will be made to pushFront, pushMiddle, pushBack, popFront, popMiddle, and popBack.", "code": "class FrontMiddleBackQueue(object):\n\n  def __init__(self):\n  self.A, self.B = collections.deque(), collections.deque()\n\n  def pushFront(self, val):\n  self.A.appendleft(val)\n  self.balance()\n\n  def pushMiddle(self, val):\n  if len(self.A) > len(self.B):\n  self.B.appendleft(self.A.pop())\n  self.A.append(val)\n\n  def pushBack(self, val):\n  self.B.append(val)\n  self.balance()\n\n  def popFront(self):\n  val = self.A.popleft() if self.A else -1\n  self.balance()\n  return val\n\n  def popMiddle(self):\n  val = (self.A or [-1]).pop()\n  self.balance()\n  return val\n\n  def popBack(self):\n  val = (self.B or self.A or [-1]).pop()\n  self.balance()\n  return val\n\n  # keep A.size() >= B.size()\n  def balance(self):\n  if len(self.A) > len(self.B) + 1:\n  self.B.appendleft(self.A.pop())\n  if len(self.A) < len(self.B):\n  self.A.append(self.B.popleft())"}
{"nl": "The math.atan2() method returns the arc tangent of y/x, in radians. Where x and y are the coordinates of a point (x,y).\r\n\r\nThe returned value is between PI and -PI.\r\n\r\n", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the arc tangent of y/x in radians\r\nprint(math.atan2(8, 5))\r\nprint(math.atan2(20, 10))\r\nprint(math.atan2(34, -7))"}
{"nl": "Wild Roger is tasked with shooting down 6 bottles with 6 shots as fast as possible. Here are the different types of shots he could make:\nHe could use one pistol to shoot a bottle with a \"Bang!\" in 0.5 seconds.\nOr he could use both pistols at once with a \"BangBang!\" to shoot two bottles in 0.5 seconds.\nGiven a list of Bangs and BangBangs return the time (in seconds) it took to shoot down all 6 bottles. Make sure to only count Bangs and BangBangs. Anything else doesn't count.\nExamples\nroger_shots([\"Bang!\", \"Bang!\", \"Bang!\", \"Bang!\", \"Bang!\", \"Bang!\"]) \u279e 3\n\nroger_shots([\"Bang!\", \"Bang!\", \"Bang!\", \"Bang!\", \"BangBang!\"]) \u279e 2.5\n\nroger_shots([\"Bang!\", \"BangBangBang!\", \"Boom!\", \"Bang!\", \"BangBang!\", \"BangBang!\"]) \u279e 2\nNotes\nAll the bottles will be shot down in all the tests.", "code": "def roger_shots(lst):\n  return sum(i in ('Bang!', 'BangBang!') for i in lst)/2"}
{"nl": "Definition and Usage\r\nThe break keyword is used to break out a for loop, or a while loop.\r\n\r\n", "code": "for i in range(9):\r\n  if i > 3:\r\n    break\r\n  print(i)"}
{"nl": "Given the Octagon\u2019s side length and the task is to calculate the area and perimeter of the given Octagon.", "code": "# Import the math module using the import keyword.\nimport math\n# Give the Octagon's side length as user input using float(input()) function and\n# store it in a variable.\nside_len = float(input(\"Enter some random number = \"))\n# Calculate the area of the given Octagon using the above given mathematical formula\n# and sqrt(), math.pow() functions.\n# Store it in another variable.\noctgn_area = (2*(1+math.sqrt(2))*math.pow(side_len, 2))\n# Calculate the perimeter of the given Octagon using the above given mathematical formula.\n# Store it in another variable.\noctgn_perimetr = (8*side_len)\n# Print the Octagon's area with the given side length.\nprint(\n    \"The Octagon's Area with given side length {\", side_len, \"} =\", octgn_area)\n# Print the Octagon's perimeter with the given side length.\nprint(\n    \"The Octagon's Perimeter with the given side length {\", side_len, \"} =\", octgn_perimetr)"}
{"nl": "Dictionary in python :\n\nA dictionary is a set of elements that have key-value pairs. The values in the elements are accessed using the element\u2019s keys.\n\nexample:\n\ndict = {\u2018january\u2019 :1, \u2018febrauary\u2019: 2, \u2018march\u2019: 3 }\n\nGiven a dictionary, and the task is to find the Product of values of elements in a dictionary.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven dictionary = {'jan': 10, 'Feb': 5, 'Mar': 22, 'April': 32, 'May': 6}\nOutput:\n\nThe Product of values in a given dictionary =  211200\nExample2:\n\nInput: \n\nGiven dictionary = {'a': 1, 'b': 5, 'c': 2, 'd': 4, 'e': 7, 'f': 2}\nOutput:\n\nThe Product of values in a given dictionary =  560", "code": "# Give the dictionary as static input and store it in a variable.\ngvn_dict = {'jan': 10, 'Feb': 5, 'Mar': 22, 'April': 32, 'May': 6}\n# Get all the values of given dictionary using dictionary.values() method\n# and store it in another variable.\ndict_vlue = gvn_dict.values()\n# Take a variable say 'product' and initialize it's value with '1'\nfnl_prod = 1\n# Iterate in the above given dictionary values using using For loop.\nfor itrator in dict_vlue:\n  # Inside the loop, Multiply the above initialized product variable with the iterator\n  # and store it in a same variable.\n  fnl_prod = fnl_prod*itrator\n# Print the product of values for the above given dictionary.\nprint(\"The Product of values in a given dictionary = \", fnl_prod)"}
{"nl": "Sort a List of Integer Tuples in Increasing Order by the Last Element in Each Tuple Using sort function", "code": "def sortlastElementTuple(listTuple):\r\n    # The key has been configured to sort using the\r\n    # last element of the sublist lambda has been used\r\n    listTuple.sort(key=lambda k: k[-1])\r\n    # returning the sorted list of tuples\r\n    return listTuple\r\n\r\n\r\nlistofTuples = [(5, 12, 98), (7, 1), (4, 19, 11, 9),\r\n                (36, 82, 19, 1, 2, 5, 3, 6, 9, 6)]\r\n# printing the sorted list of tuples by last element\r\nprint(\"Printing the sorted list of tuples : \")\r\n# Passing the given list of tuples to sortlastElementTuple function\r\nprint(sortlastElementTuple(listofTuples))"}
{"nl": "Given an array of n elements. Our task is to write a program to rearrange the array such that elements at even positions are greater than all elements before it and elements at odd positions are less than all elements before it.\nExamples: \n \n\nInput : arr[] = {1, 2, 3, 4, 5, 6, 7}\nOutput : 4 5 3 6 2 7 1\n\nInput : arr[] = {1, 2, 1, 4, 5, 6, 8, 8} \nOutput : 4 5 2 6 1 8 1 8", "code": "# Python3 code to rearrange the array\n# as per the given condition\nimport array as a\nimport numpy as np\n\n# function to rearrange the array\ndef rearrangeArr(arr, n):\n\t\n\t# total even positions\n\tevenPos = int(n / 2)\n\n\t# total odd positions\n\toddPos = n - evenPos\n\n\t# initialising empty array in python\n\ttempArr = np.empty(n, dtype = object)\n\n\t# copy original array in an\n\t# auxiliary array\n\tfor i in range(0, n):\n\t\t\n\t\ttempArr[i] = arr[i]\n\n\t# sort the auxiliary array\n\ttempArr.sort()\n\n\tj = oddPos - 1\n\n\t# fill up odd position in original\n\t# array\n\tfor i in range(0, n, 2):\n\n\t\tarr[i] = tempArr[j]\n\t\tj = j - 1\n\t\n\tj = oddPos\n\n\t# fill up even positions in original\n\t# array\n\tfor i in range(1, n, 2):\n\t\tarr[i] = tempArr[j]\n\t\tj = j + 1\n\t\n\t# display array\n\tfor i in range(0, n):\n\t\tprint (arr[i], end = ' ')\n\n# Driver code\narr = a.array('i', [ 1, 2, 3, 4, 5, 6, 7 ])\nrearrangeArr(arr, 7)\n\n# This code is contributed by saloni1297"}
{"nl": "Definition and Usage\r\nThe writable() method returns True if the file is writable, False if not.\r\n\r\nA file is writable if it is opened using \"a\" for append or \"w\" for write.", "code": "f = open(\"demofile.txt\", \"a\")\r\nprint(f.writable())\r\n"}
{"nl": "Given a moment, determine the moment that would be after a gigasecond has passed.\n\nA gigasecond is 10^9 (1,000,000,000) seconds.", "code": "from datetime import datetime, timedelta\nGIGASECOND = timedelta(seconds=10**9)\ndef add(moment: datetime) -> datetime:\n    return moment + GIGASECOND"}
{"nl": "Given a word, write a function that returns the first index and the last index of a character.\nExamples\nchar_index(\"hello\", \"l\") \u279e [2, 3]\n# The first \"l\" has index 2, the last \"l\" has index 3.\n\nchar_index(\"circumlocution\", \"c\") \u279e [0, 8]\n# The first \"c\" has index 0, the last \"c\" has index 8.\n\nchar_index(\"happy\", \"h\") \u279e [0, 0]\n# Only one \"h\" exists, so the first and last index is 0.\n\nchar_index(\"happy\", \"e\") \u279e None\n# \"e\" does not exist in \"happy\", so we return undefined.\nNotes\nIf the character does not exist in the word, return None.\nIf only one instance of the character exists, the first and last index will be the same.\nCheck the Resources tab for hints.", "code": "def char_index(word, char):\n  return None if char not in word else [word.index(char), word.rindex(char)]"}
{"nl": "Instructions\r\nImplement the classic method for composing secret messages called a square code.\r\n\r\nGiven an English text, output the encoded version of that text.\r\n\r\nFirst, the input is normalized: the spaces and punctuation are removed from the English text and the message is down-cased.\r\n\r\nThen, the normalized characters are broken into rows. These rows can be regarded as forming a rectangle when printed with intervening newlines.\r\n\r\nFor example, the sentence\r\n\r\n\"If man was meant to stay on the ground, god would have given us roots.\"\r\nis normalized to:\r\n\r\n\"ifmanwasmeanttostayonthegroundgodwouldhavegivenusroots\"\r\nThe plaintext should be organized in to a rectangle. The size of the rectangle should be decided by the length of the message.\r\n\r\nIf c is the number of columns and r is the number of rows, then for the rectangle r x c find the smallest possible integer c such that:\r\n\r\nr * c >= length(message),\r\nand c >= r,\r\nand c - r <= 1.\r\nOur normalized text is 54 characters long, dictating a rectangle with c = 8 and r = 7:\r\n\r\n\"ifmanwas\"\r\n\"meanttos\"\r\n\"tayonthe\"\r\n\"groundgo\"\r\n\"dwouldha\"\r\n\"vegivenu\"\r\n\"sroots  \"\r\nThe coded message is obtained by reading down the columns going left to right.\r\n\r\nThe message above is coded as:\r\n\r\n\"imtgdvsfearwermayoogoanouuiontnnlvtwttddesaohghnsseoau\"\r\nOutput the encoded text in chunks that fill perfect rectangles (r X c), with c chunks of r length, separated by spaces. For phrases that are n characters short of the perfect rectangle, pad each of the last n chunks with a single trailing space.\r\n\r\n\"imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn  sseoau \"\r\nNotice that were we to stack these, we could visually decode the ciphertext back in to the original message:\r\n\r\n\"imtgdvs\"\r\n\"fearwer\"\r\n\"mayoogo\"\r\n\"anouuio\"\r\n\"ntnnlvt\"\r\n\"wttddes\"\r\n\"aohghn \"\r\n\"sseoau \"", "code": "import math\r\nimport string\r\ndef cipher_text(plain_text):\r\n    text = sanitize_text(plain_text)\r\n    if len(text) == 0:\r\n        return ''\r\n    cols = math.ceil(math.sqrt(len(text)))\r\n    rows = math.ceil(len(text) / cols)\r\n    text += ' ' * ((cols * rows) - len(text))\r\n    return ' '.join(text[i::cols] for i in range(cols))\r\ndef sanitize_text(plain_text):\r\n    trantab = str.maketrans('', '', string.punctuation + string.whitespace)\r\n    return plain_text.lower().strip().translate(trantab)"}
{"nl": "Match Object\r\nA Match Object is an object containing information about the search and the result.", "code": "import re\r\n\r\ntxt = \"The rain in Spain\"\r\nx = re.search(\"ai\", txt)\r\nprint(x) #this will print an object"}
{"nl": "Inversion Count for an array indicates \u2013 how far (or close) the array is from being sorted. If the array is already sorted, then the inversion count is 0, but if the array is sorted in the reverse order, the inversion count is the maximum. \r\nFormally speaking, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j ", "code": "from heapq import heappush, heappop\r\nfrom bisect import bisect, insort\r\n\r\n\r\ndef getNumOfInversions(A):\r\n\tN = len(A)\r\n\tif N <= 1:\r\n\t\treturn 0\r\n\r\n\tsortList = []\r\n\tresult = 0\r\n\r\n\t# heapsort, O(N*log(N))\r\n\tfor i, v in enumerate(A):\r\n\t\theappush(sortList, (v, i))\r\n\r\n\tx = [] # create a sorted list of indexes\r\n\twhile sortList: # O(N)\r\n\t\tv, i = heappop(sortList) # O(log(N))\r\n\t\t# find the current minimum's index\r\n\t\t# the index y can represent how many minimums on the left\r\n\t\ty = bisect(x, i) # O(log(N))\r\n\t\t# i can represent how many elements on the left\r\n\t\t# i - y can find how many bigger nums on the left\r\n\t\tresult += i - y\r\n\r\n\t\tinsort(x, i) # O(log(N))\r\n\r\n\treturn result\r\n\r\n# Driver Code\r\n# Given array is\r\nA = [-1, 6, 3, 4, 7, 4]\r\nresult = getNumOfInversions(A)\r\nprint(f'Number of inversions are {result}')\r"}
{"nl": "Determine if a sentence is a pangram. A pangram (Greek: \u03c0\u03b1\u03bd \u03b3\u03c1\u03ac\u03bc\u03bc\u03b1, pan gramma, \"every letter\") is a sentence using every letter of the alphabet at least once. The best known English pangram is:\r\n\r\nThe quick brown fox jumps over the lazy dog.\r\n\r\nThe alphabet used consists of ASCII letters a to z, inclusive, and is case insensitive. Input will not contain non-ASCII symbols.", "code": "from string import ascii_lowercase\nALPHABET = set(ascii_lowercase)\ndef is_pangram(string):\n    return ALPHABET.issubset(string.lower())"}
{"nl": "You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.\n\nAn island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.\n\nReturn the number of islands in grid2 that are considered sub-islands.", "code": "class Solution:\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\n        m, n = len(grid2), len(grid2[0])\n        \n        def dfs(i, j):\n            if i < 0 or j < 0 or i == m or j == n or grid2[i][j] == 0:\n                return True\n            \n            is_subisland = True\n            if grid1[i][j] == 0:\n                is_subisland = False\n            \n            grid2[i][j] = 0\n            \n            is_subisland = dfs(i+1, j) and is_subisland\n            is_subisland = dfs(i-1, j) and is_subisland\n            is_subisland = dfs(i, j+1) and is_subisland\n            is_subisland = dfs(i, j-1) and is_subisland\n            \n            return is_subisland\n        \n        sub_islands = sum(grid2[i][j] and dfs(i, j) for i in range(m) for j in range(n))\n        return sub_islands"}
{"nl": "The program sorts a list by counting sort.", "code": "def counting_sort(alist, largest):\n    c = [0]*(largest + 1)\n    for i in range(len(alist)):\n        c[alist[i]] = c[alist[i]] + 1\n\u00a0\n    # Find the last index for each element\n    c[0] = c[0] - 1 # to decrement each element for zero-based indexing\n    for i in range(1, largest + 1):\n        c[i] = c[i] + c[i - 1]\n\u00a0\n    result = [None]*len(alist)\n\u00a0\n    # Though it is not required here,\n    # it becomes necessary to reverse the list\n    # when this function needs to be a stable sort\n    for x in reversed(alist):\n        result[c[x]] = x\n        c[x] = c[x] - 1\n\u00a0\n    return result\n\u00a0\n\u00a0\nalist = input('Enter the list of (nonnegative) numbers: ').split()\nalist = [int(x) for x in alist]\nk = max(alist)\nsorted_list = counting_sort(alist, k)\nprint('Sorted list: ', end='')\nprint(sorted_list)"}
{"nl": "In this program, you'll learn to print all prime numbers within an interval using for loops and display it.", "code": "# Python program to display all the prime numbers within an interval\n\nlower = 900\nupper = 1000\n\nprint(\"Prime numbers between\", lower, \"and\", upper, \"are:\")\n\nfor num in range(lower, upper + 1):\n   # all prime numbers are greater than 1\n   if num > 1:\n       for i in range(2, num):\n           if (num % i) == 0:\n               break\n       else:\n           print(num)"}
{"nl": "Write a function that maps files to their extension names.\nExamples\nget_extension([\"code.html\", \"code.css\"])\n\u279e [\"html\", \"css\"]\n\nget_extension([\"project1.jpg\", \"project1.pdf\", \"project1.mp3\"])\n\u279e [\"jpg\", \"pdf\", \"mp3\"]\n\nget_extension([\"ruby.rb\", \"cplusplus.cpp\", \"python.py\", \"javascript.js\"])\n\u279e [\"rb\", \"cpp\", \"py\", \"js\"]\nNotes\nN/A", "code": "def get_extension(lst):\n  return [i.split(\".\")[1] for i in lst]"}
{"nl": "Spectral Clustering is a growing clustering algorithm which has performed better than many traditional clustering algorithms in many cases. It treats each data point as a graph-node and thus transforms the clustering problem into a graph-partitioning problem. A typical implementation consists of three fundamental steps:-", "code": "\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nfrom sklearn.cluster import SpectralClustering\r\nfrom sklearn.preprocessing import StandardScaler, normalize\r\nfrom sklearn.decomposition import PCA\r\nfrom sklearn.metrics import silhouette_score\r\n\r\n# Changing the working location to the location of the data\r\ncd \"C:\\Users\\Dev\\Desktop\\Kaggle\\Credit_Card\"\r\n  \r\n# Loading the data\r\nX = pd.read_csv('CC_GENERAL.csv')\r\n  \r\n# Dropping the CUST_ID column from the data\r\nX = X.drop('CUST_ID', axis = 1)\r\n  \r\n# Handling the missing values if any\r\nX.fillna(method ='ffill', inplace = True)\r\n  \r\nX.head()\r\n\r\n\r\n# Preprocessing the data to make it visualizable\r\n  \r\n# Scaling the Data\r\nscaler = StandardScaler()\r\nX_scaled = scaler.fit_transform(X)\r\n  \r\n# Normalizing the Data\r\nX_normalized = normalize(X_scaled)\r\n  \r\n# Converting the numpy array into a pandas DataFrame\r\nX_normalized = pd.DataFrame(X_normalized)\r\n  \r\n# Reducing the dimensions of the data\r\npca = PCA(n_components = 2)\r\nX_principal = pca.fit_transform(X_normalized)\r\nX_principal = pd.DataFrame(X_principal)\r\nX_principal.columns = ['P1', 'P2']\r\n  \r\nX_principal.head()\r\n\r\n\r\n# Building the clustering model\r\nspectral_model_rbf = SpectralClustering(n_clusters = 2, affinity ='rbf')\r\n  \r\n# Training the model and Storing the predicted cluster labels\r\nlabels_rbf = spectral_model_rbf.fit_predict(X_principal)\r\n# Building the label to colour mapping\r\ncolours = {}\r\ncolours[0] = 'b'\r\ncolours[1] = 'y'\r\n  \r\n# Building the colour vector for each data point\r\ncvec = [colours[label] for label in labels_rbf]\r\n  \r\n# Plotting the clustered scatter plot\r\n  \r\nb = plt.scatter(X_principal['P1'], X_principal['P2'], color ='b');\r\ny = plt.scatter(X_principal['P1'], X_principal['P2'], color ='y');\r\n  \r\nplt.figure(figsize =(9, 9))\r\nplt.scatter(X_principal['P1'], X_principal['P2'], c = cvec)\r\nplt.legend((b, y), ('Label 0', 'Label 1'))\r\nplt.show()\r\n\r\n\r\n# Building the clustering model\r\nspectral_model_nn = SpectralClustering(n_clusters = 2, affinity ='nearest_neighbors')\r\n  \r\n# Training the model and Storing the predicted cluster labels\r\nlabels_nn = spectral_model_nn.fit_predict(X_principal)\r\n# List of different values of affinity\r\naffinity = ['rbf', 'nearest-neighbours']\r\n  \r\n# List of Silhouette Scores\r\ns_scores = []\r\n  \r\n# Evaluating the performance\r\ns_scores.append(silhouette_score(X, labels_rbf))\r\ns_scores.append(silhouette_score(X, labels_nn))\r\n  \r\nprint(s_scores)\r\n# Plotting a Bar Graph to compare the models\r\nplt.bar(affinity, s_scores)\r\nplt.xlabel('Affinity')\r\nplt.ylabel('Silhouette Score')\r\nplt.title('Comparison of different Clustering Models')\r\nplt.show()"}
{"nl": "Perfect square numbers are the square of the whole numbers.\r\n\r\nPerfect square numbers are: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, ...\r\n\r\nThis Python program checks whether a given number is perfect square or not.", "code": "# Check for perfect square\r\ndef is_perfect_sqaure(n):\r\n    root = n ** 0.5\r\n    int_root = int(root)\r\n    return int_root ** 2 == n\r\n\r\n# Function Call\r\nprint(is_perfect_sqaure(1))\r\nprint(is_perfect_sqaure(5))\r\nprint(is_perfect_sqaure(88))\r\nprint(is_perfect_sqaure(121))"}
{"nl": "Instructions\nGiven a string of digits, calculate the largest product for a contiguous substring of digits of length n.\n\nFor example, for the input '1027839564', the largest product for a series of 3 digits is 270 (9 * 5 * 6), and the largest product for a series of 5 digits is 7560 (7 * 8 * 3 * 9 * 5).\n\nNote that these series are only required to occupy adjacent positions in the input; the digits need not be numerically consecutive.\n\nFor the input '73167176531330624919225119674426574742355349194934', the largest product for a series of 6 digits is 23520.\n\nFor a series of zero digits, the largest product is 1 because 1 is the multiplicative identity. (You don't need to know what a multiplicative identity is to solve this problem; it just means that multiplying a number by 1 gives you the same number.)\n\nException messages\nSometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.\n\nThis particular exercise requires that you use the raise statement to \"throw\" a ValueError when your largest_product() function receives invalid input. The tests will only pass if you both raise the exception and include a message with it. Feel free to reuse your code from the series exercise!\n\nTo raise a ValueError with a message, write the message as an argument to the exception type:\n\n# span of numbers is longer than number series\nraise ValueError(\"span must be smaller than string length\")\n\n# span of number is zero or negative\nraise ValueError(\"span must be greater than zero\")\n\n# series includes non-number input\nraise ValueError(\"digits input must only contain digits\")", "code": "from functools import reduce\r\ndef largest_product(series: str, size: int) -> int:\r\n    if len(series) < size:\r\n        raise ValueError(\"span must be smaller than string length\")\r\n    if size < 0:\r\n        raise ValueError(\"span must not be negative\")\r\n    if len(series) > 0 and not series.isnumeric():\r\n        raise ValueError(\"digits input must only contain digits\")\r\n    series_list = [float(digit) for digit in series]\r\n    return int(max([reduce((lambda x, y: x * y), series_list[start_index:start_index + size])\r\n                    for start_index in range(0, (len(series) + 1) - size)])) if size > 0 else 1\r\n"}
{"nl": "Faker Module:\r\n\r\nThe Faker module is used to produce random data, including attributes such as name, age, and location.\r\n\r\nThe question now is, why would one require Fake data? We may require false or fake data to either fill in the blanks in the databases with artificial data or to just test an algorithm.\r\n\r\nHow to import the Faker module?\r\n\r\nTo examine the various functions and methods of the faker library, we must first import it.", "code": "# Import faker from Faker module using the import keyword.\r\nfrom faker import Faker\r\n# Create an object for the Faker library and store it in a variable.\r\nfaker_obj = Faker()\r\n# Generate a random name using faker_obj.name() function and print it\r\nprint(faker_obj.name())"}
{"nl": "In the previous article, we have discussed Python Program to Calculate the Discriminant Value\n Pronic Number:\n \n A pronic number is the product of two consecutive integers, i.e. a number of the form n(n + 1).\n \n \n \n Pronic numbers are also referred to as oblong numbers or heteromecic numbers.\n \n Pronic numbers include 0, 2, 6, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 240, 272, 306, 342, 380, 420, and 462 etc.\n \n Examples:\n \n Example 1:\n \n Input:\n \n Given number = 240\n Output: \n \n The given number{ 240 } is a pronic number\n Example 2:\n \n Input:\n \n Given number = 15\n Output: \n \n The given number{ 15 } is Not a pronic number", "code": "# Give the number as static input and store it in a variable.\n numb = 156\n # Take a variable say 'count' and initialize its value with '0'.\n count = 0\n # Loop from 0 to above-given number using for loop. \n for itr in range(numb):\n  # Inside the loop, check if the product of the iterator value and iterator+1 value\n  # (consecutive integers) is equal to the given number using the if conditional statement.\n  if itr * (itr + 1) == numb:\n  # If the statement is true, then increment the value of count (i.e. 1),\n  # give the break condition and come out of the loop.\n  count = 1\n  break\n # Check if the value of count is equal to '1' using the if conditional statement.\n if count == 1:\n  # If the statement is true, then print \"The given number is a pronic number\".\n  print(\"The given number{\",numb,\"} is a pronic number\")\n # Else print \"The given number is Not a pronic number\".\n else:\n  print(\"The given number{\",numb,\"} is Not a pronic number\")"}
{"nl": "You are given the head of a linked list, and an integer k.\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\n \nExample 1:\n\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [7,9,6,6,7,8,3,0,9,5], k = 5\nOutput: [7,9,6,6,8,7,3,0,9,5]\n\n \nConstraints:\n\nThe number of nodes in the list is n.\n1 <= k <= n <= 105\n0 <= Node.val <= 100", "code": "class Solution:\n  def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n  # Find kth node from left\n  l = r = head\n  for _ in range(k-1):\n  l = l.next\n  # Find kth node from right\n  # by finding tail node\n  tail = l\n  while tail.next:\n  r, tail = r.next, tail.next\n  # Swap values and return\n  l.val, r.val = r.val, l.val\n  return head"}
{"nl": "Given a graph, a source vertex in the graph and a number k, find if there is a simple path (without any cycle) starting from given source and ending at any other vertex such that the distance from source to that vertex is atleast \u2018k\u2019 length.\n\n\n\u00a0", "code": "# Program to find if there is a simple path with\n# weight more than k\n\u00a0\u00a0\u00a0\n# This class represents a dipathted graph using\n# adjacency list representation\nclass Graph:\n\u00a0\u00a0\u00a0\u00a0# Allocates memory for adjacency list\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj = [[] for i in range(V)]\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if graph has path more than k length\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanK(self,src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a path array with nothing included\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path = [False]*self.V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add source vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[src] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.pathMoreThanKUtil(src, k, path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Prints shortest paths from src to all other vertices\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanKUtil(self,src, k, path):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If k is 0 or negative, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get all adjacent vertices of source vertex src and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursively explore all paths from src.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while i != len(self.adj[src]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get adjacent vertex and weight of edge\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = self.adj[src][i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w = self.adj[src][i][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If vertex v is already there in path, then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# there is a cycle (we ignore this edge)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (path[v] == True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If weight of is more than k, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (w >= k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Else add this vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this adjacent can provide a path longer\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than k, return true.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (self.pathMoreThanKUtil(v, k-w, path)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Backtrack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If no adjacent could produce longer path, return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Utility function to an edge (u, v) of weight w\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u, v, w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[u].append([v, w])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[v].append([u, w])\n\u00a0\u00a0\u00a0\n# Driver program to test methods of graph class\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# create the graph given in above figure\n\u00a0\u00a0\u00a0\u00a0V = 9\n\u00a0\u00a0\u00a0\u00a0g = Graph(V)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0#\u00a0 making above shown graph\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 1, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 7, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 2, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 7, 11)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 3, 7)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 8, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 5, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 4, 9)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 5, 14)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(4, 5, 10)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(5, 6, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 7, 1)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 8, 6)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(7, 8, 7)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0src = 0\n\u00a0\u00a0\u00a0\u00a0k = 62\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0k = 60\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n"}
{"nl": "A powerful number is a positive integer number such that every prime factor and their square divides a number.\r\n\r\nExamples of powerful numbers are: 25, 27, 32, 36, 49, 64, 72, 81, 100, 108, 121, 125, 128, 144, 169, 196, ...\r\n\r\nThis Python program generates (prints) all powerful numbers in an interval given by users.", "code": "# Function definition to get all prime factors\r\ndef get_prime_factors(n):\r\n    i = 2\r\n    prime_factors = []\r\n    while i*i <= n:\r\n        if n%i == 0:\r\n            prime_factors.append(i)\r\n            n //= i\r\n        else:\r\n            i += 1\r\n    \r\n    if n>1:\r\n        prime_factors.append(n)\r\n    \r\n    return prime_factors\r\n\r\n# Function definition to check powerful number\r\ndef is_powerful(n):\r\n    # get prime factors\r\n    prime_factors = get_prime_factors(n)\r\n    \r\n    # filter to get unique prime factors\r\n    unique_prime_factors = tuple(dict.fromkeys(prime_factors))\r\n    for p in unique_prime_factors:\r\n        if n % p != 0 or n % (p*p) != 0:\r\n            return False\r\n    return True\r\n\r\n# Reading minimum and maximum number\r\nmin_num = int(input('Enter lower range: '))\r\nmax_num = int(input('Enter upper range: '))\r\n\r\nprint('All powerful numbers from %d to %d are:' %(min_num, max_num))\r\nfor i in range(min_num, max_num+1):\r\n    if is_powerful(i):\r\n        print(i, end=' ')"}
{"nl": "A city skyline can be represented as a 2-D list with 1s representing buildings. In the example below, the height of the tallest building is 4 (second-most right column).\n[[0, 0, 0, 0, 0, 0],\n[0, 0, 0, 0, 1, 0],\n[0, 0, 1, 0, 1, 0],\n[0, 1, 1, 1, 1, 0],\n[1, 1, 1, 1, 1, 1]]\nCreate a function that takes a skyline (2-D list of 0's and 1's) and returns the height of the tallest skyscraper.\nExamples\ntallest_skyscraper([\n  [0, 0, 0, 0],\n  [0, 1, 0, 0],\n  [0, 1, 1, 0],\n  [1, 1, 1, 1]\n]) \u279e 3\n\ntallest_skyscraper([\n  [0, 1, 0, 0],\n  [0, 1, 0, 0],\n  [0, 1, 1, 0],\n  [1, 1, 1, 1]\n]) \u279e 4\n\ntallest_skyscraper([\n  [0, 0, 0, 0],\n  [0, 0, 0, 0],\n  [1, 1, 1, 0],\n  [1, 1, 1, 1]\n]) \u279e 2\nNotes\nN/A", "code": "def tallest_skyscraper(lst):\n  return sum(1 for i in lst if sum(i)>0)"}
{"nl": "In operating systems that use paging for memory management, page replacement algorithm are needed to decide which page needed to be replaced when new page comes in. Whenever a new page is referred and not present in memory, page fault occurs and Operating System replaces one of the existing pages with newly needed page. Different page replacement algorithms suggest different ways to decide which page to replace. The target for all algorithms is to reduce number of page faults.\n\nFirst In First Out (FIFO) page replacement algorithm \u2013\nThis is the simplest page replacement algorithm. In this algorithm, operating system keeps track of all pages in the memory in a queue, oldest page is in the front of the queue. When a page needs to be replaced page in the front of the queue is selected for removal.\n\nExample -1. Consider page reference string 1, 3, 0, 3, 5, 6 and 3 page slots.\n\nInitially all slots are empty, so when 1, 3, 0 came they are allocated to the empty slots \u2014> 3 Page Faults.\nwhen 3 comes, it is already in memory so \u2014> 0 Page Faults.\nThen 5 comes, it is not available in memory so it replaces the oldest page slot i.e 1. \u2014>1 Page Fault.\nFinally 6 comes, it is also not available in memory so it replaces the oldest page slot i.e 3 \u2014>1 Page Fault.\n\nSo total page faults = 5.", "code": "# Python3 implementation of FIFO page\n# replacement in Operating Systems.\nfrom queue import Queue\u00a0\n\u00a0\u00a0\n# Function to find page faults using FIFO\u00a0\ndef pageFaults(pages, n, capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# To represent set of current pages.\u00a0\n\u00a0\u00a0\u00a0\u00a0# We use an unordered_set so that we\n\u00a0\u00a0\u00a0\u00a0# quickly check if a page is present\n\u00a0\u00a0\u00a0\u00a0# in set or not\u00a0\n\u00a0\u00a0\u00a0\u00a0s = set()\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# To store the pages in FIFO manner\u00a0\n\u00a0\u00a0\u00a0\u00a0indexes = Queue()\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Start from initial page\u00a0\n\u00a0\u00a0\u00a0\u00a0page_faults = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if the set can hold\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# more pages\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(s) < capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Insert it into set if not present\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# already which represents page fault\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (pages[i] not in s):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.add(pages[i])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# increment page fault\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0page_faults += 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push the current page into\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the queue\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0indexes.put(pages[i])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the set is full then need to perform FIFO\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# i.e. remove the first page of the queue from\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# set and queue both and insert the current page\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if current page is not\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# already present in the set\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (pages[i] not in s):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pop the first page from the queue\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val = indexes.queue[0]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0indexes.get()\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove the indexes page\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.remove(val)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# insert the current page\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.add(pages[i])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push the current page into\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the queue\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0indexes.put(pages[i])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Increment page faults\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0page_faults += 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return page_faults\n\u00a0\u00a0\n# Driver code\u00a0\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0pages = [7, 0, 1, 2, 0, 3, 0,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04, 2, 3, 0, 3, 2]\u00a0\n\u00a0\u00a0\u00a0\u00a0n = len(pages)\u00a0\n\u00a0\u00a0\u00a0\u00a0capacity = 4\n\u00a0\u00a0\u00a0\u00a0print(pageFaults(pages, n, capacity))\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.", "code": "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        A = [0]+A\n        result = [0]*len(A)\n        stack = [0]\n        for i in range(len(A)):\n            while A[stack[-1]] > A[i]:\n                stack.pop() \n            j = stack[-1]\n            result[i] = result[j] + (i-j)*A[i]\n            stack.append(i)\n        return sum(result) % (10**9+7)"}
{"nl": "Given an array of n integers. The task is to find the first element that occurs k number of times. If no element occurs k times the print -1. The distribution of integer elements could be in any range.\nExamples: \n\nInput: {1, 7, 4, 3, 4, 8, 7}, \nk = 2 \nOutput: 7 \nBoth 7 and 4 occur 2 times. \nBut 7 is the first that occurs 2 times. \n\nInput: {4, 1, 6, 1, 6, 4}, \nk = 1 \nOutput: -1", "code": "# Python3 implementation to\n# find first element\n# occurring k times\n\n# function to find the\n# first element occurring\n# k number of times\ndef firstElement(arr, n, k):\n\n\t# dictionary to count\n\t# occurrences of\n\t# each element\n\tcount_map = {};\n\tfor i in range(0, n):\n\t\tif(arr[i] in count_map.keys()):\n\t\t\tcount_map[arr[i]] += 1\n\t\telse:\n\t\t\tcount_map[arr[i]] = 1\n\t\ti += 1\n\t\n\tfor i in range(0, n):\n\t\t\n\t\t# if count of element == k ,\n\t\t# then it is the required\n\t\t# first element\n\t\tif (count_map[arr[i]] == k):\n\t\t\treturn arr[i]\n\t\ti += 1\n\t\t\t\n\t# no element occurs k times\n\treturn -1\n\n# Driver Code\nif __name__==\"__main__\":\n\n\tarr = [1, 7, 4, 3, 4, 8, 7];\n\tn = len(arr)\n\tk = 2\n\tprint(firstElement(arr, n, k))\n\n# This code is contributed\n# by Abhishek Sharma"}
{"nl": "Given a number N and the task is to print the series (0, 6, 10, 17, 22, 30, 36\u2026N) till the given number N in Python.", "code": "# Give the number N(limit) as static input and store it in a variable.\r\ngvn_numb = 16\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Take another variable say m and initialize its value to 0.\r\nm = 0\r\n# Take another variable say n and initialize its value to 6.\r\nn = 6\r\n# Take another variable say x and initialize its value to 10.\r\nx = 10\r\n# Take another variable say y and initialize its value to 11.\r\ny = 11\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nwhile(itr <= gvn_numb):\r\n        # Inside the loop, check if the above variable itr value is even or not using the\r\n    # if conditional statement.\r\n    if (itr % 2 == 0):\r\n        # If it is true, then print the value of n separated by spaces.\r\n        print(n, end=\" \")\r\n        # Add the above y value to n and store it in the same variable n.\r\n        n += y\r\n        # Increment the above y value by 2.\r\n        y += 2\r\n    else:\r\n        # Else, print the value of m separated by spaces.\r\n        print(m, end=\" \")\r\n        # Add the above x value to m and store it in the same variable m.\r\n        m += x\r\n        # Increment the above x value by 2.\r\n        x += 2\r\n   # Increment the above itr value by 1.\r\n    itr += 1"}
{"nl": "Create a function that takes a range object r, index i, and returns a list where the first element is the number of elements in the range object, and the second element is the element of the range object at the given index.\nExamples\nlength_element(range(2, 4), 0) \u279e [2, 2]\n\nlength_element(range(12, 15, 2), 1) \u279e [2, 14]\n\nlength_element(range(40, 50, 3), 2) \u279e [4, 46]\nNotes\nNo need to check for IndexError.", "code": "def length_element(r,i):\n    return [len(r), r[i]]"}
{"nl": "The statistics.stdev() method calculates the standard deviation from a sample of data.\r\n\r\nStandard deviation is a measure of how spread out the numbers are.\r\n\r\nA large standard deviation indicates that the data is spread out, - a small standard deviation indicates that the data is clustered closely around the mean.\r\n\r\nTip: Standard deviation is (unlike the Variance) expressed in the same units as the data.\r\n\r\nTip: Standard deviation is the square root of sample variance.\r\n\r\nTip: To calculate the standard deviation of an entire population, look at the statistics.pstdev() method. ", "code": "# Import statistics Library\r\nimport statistics\r\n\r\n# Calculate the standard deviation from a sample of data\r\nprint(statistics.stdev([1, 3, 5, 7, 9, 11]))\r\nprint(statistics.stdev([2, 2.5, 1.25, 3.1, 1.75, 2.8]))\r\nprint(statistics.stdev([-11, 5.5, -3.4, 7.1]))\r\nprint(statistics.stdev([1, 30, 50, 100]))"}
{"nl": "The Chi-Squared (\u03c7\u00b2) goodness of fit test estimates if an empirical (observed) distribution fits a theoretical (expected) distribution within reasonable margins. For example, to figure out if a die is loaded you could roll it many times and note the results. Because of randomness, you can't expect to get the same frequency for all faces, but if one or more faces turn up much more frequently than some others, it is reasonable to assume the die is loaded.\nThe formula to calculate the Chi-Square parameter is:\nBelow is an example of a die rolled 600 times:\nFace 1 2 3 4 5 6\nObserved frequency 101 116 89 108 97 89\nExpected frequency 100 100 100 100 100 100\nDifference 1 16 -11 8 -3 -11\nIn this example, the Chi-Square parameter has a value of:\n\u03c7\u00b2 = ((1)^2 + (16)^2 + (-11)^2 + (8)^2 + (-3)^2 + (-11)^2) / 100 = 5.72\nThis parameter is then compared to a critical value, calculated taking into account the number of categories and the confidence level. Here, the critical value is 11.0705. Since 5.72 < 11.0705, it is safe to assume the die is unloaded.\nGiven a list with the six observed frequencies, write a function that returns True if a die is unloaded, or False if it is loaded. Take 11.0705 as the critical value for all cases.\nExamples\nfair_die([44, 52, 33, 40, 41, 30]) \u279e True\n(\u03c7\u00b2 = 7.75) < 11.0705\n\nfair_die([34, 27, 23, 20, 32, 28]) \u279e True\n(\u03c7\u00b2 = 1.6) < 11.0705\n\nfair_die([10, 20, 11, 5, 19, 16]) \u279e False\n(\u03c7\u00b2 = 12.556) > 11.0705\nNotes\nYou can't import any modules.", "code": "def fair_die(lst):\n  avg = sum(lst) / len(lst)\n  return sum((x - avg) ** 2 / avg for x in lst) < 11.0705"}
{"nl": "Given a number, and the task is to check if the sum of even digits of a number is divisible by 4 and the sum of odd digits of a given number is divisible by 3.", "code": "# Give the number as static input and store it in a variable.\nnumb = 123452\n# Convert the given number to string using the str() function.\nstringnum = str(numb)\n# Create a list of digits say \"digtslst\" using map(),list(),int functions.\ndigtslst = list(map(int, stringnum))\n# Take a variable say \"evn_sum\" and initialize it with 0.\nevn_sum = 0\n# Take another variable say \"od_sum\" and initialize it with 0.\nod_sum = 0\n# Loop in the above list of digits until the length of the \"digtslst\" using the for loop.\nfor itr in range(len(digtslst)):\n    # Check if the element of the \"digtslst\" is even or not using the if conditional statement.\n    if(digtslst[itr] % 2 == 0):\n     # If the statement is true, then add the element of the \"digtslst\" to the \"evn_sum\"\n        # and store it in the same variable evn_sum.\n        evn_sum += digtslst[itr]\n    else:\n        # If the statement is false, then add the element of the \"digtslst\" to the \"od_sum\"\n        # and store it in the same variable od_sum.\n        od_sum += digtslst[itr]\n# Check if the evn_sum modulus 4 is equal to 0 and od_sum modulus 3 is equal to 0\n# using the if conditional statement.\nif(evn_sum % 4 == 0 and od_sum % 3 == 0):\n  # If the statement is true, print \"yes, the even digits sum and odd digits sum of a\n    # given number are divisible by 4 and 3 respectively.\n    print(\n        \"yes, the even digits sum and odd digits sum of a given number{\", numb, \"} is divisible by 4 and 3 respectively.\")\nelse:\n # If the statement is false, print \"No, the even digits sum and odd digits sum\n    # of a given number are not divisible by 4 and 3 respectively.\n    print(\n        \"No, the even digits sum and odd digits sum of a given number{\", numb, \"} is not divisible by 4 and 3 respectively.\")"}
{"nl": "You are given a 0-indexed binary string s which represents the types of buildings along a street where:\n\ns[i] = '0' denotes that the ith building is an office and\ns[i] = '1' denotes that the ith building is a restaurant.\nAs a city official, you would like to select 3 buildings for random inspection. However, to ensure variety, no two consecutive buildings out of the selected buildings can be of the same type.\n\nFor example, given s = \"001101\", we cannot select the 1st, 3rd, and 5th buildings as that would form \"011\" which is not allowed due to having two consecutive buildings of the same type.\nReturn the number of valid ways to select 3 buildings.", "code": "class Solution:\n    def numberOfWays(self, s: str) -> int:\n        ans=0\n        n=len(s)\n        left=[0]*n\n        right=[0]*n\n        zeros,ones=0,0\n        for i in range(n):\n            if s[i]==\"0\": \n                zeros+=1\n                left[i]=ones\n            else: \n                ones+=1\n                left[i]=zeros\n        zeros,ones=0,0\n        for i in range(n-1,-1,-1):\n            if s[i]==\"0\": \n                zeros+=1\n                right[i]=ones\n            else: \n                ones+=1\n                right[i]=zeros\n            ans+=left[i]*right[i]\n        return ans\n            "}
{"nl": "Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.\nAlice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.\nReturn the minimum time Bob needs to make the rope colorful.\n \nExample 1:\n\n\nInput: colors = \"abaac\", neededTime = [1,2,3,4,5]\nOutput: 3\nExplanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\nExample 2:\n\n\nInput: colors = \"abc\", neededTime = [1,2,3]\nOutput: 0\nExplanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.\n\nExample 3:\n\n\nInput: colors = \"aabaa\", neededTime = [1,2,3,4,1]\nOutput: 2\nExplanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n\n \nConstraints:\n\nn == colors.length == neededTime.length\n1 <= n <= 105\n1 <= neededTime[i] <= 104\ncolors contains only lowercase English letters.", "code": "def minCost(self, s, cost):\n  res = max_cost = 0\n  for i in xrange(len(s)):\n  if i > 0 and s[i] != s[i - 1]:\n  max_cost = 0\n  res += min(max_cost, cost[i])\n  max_cost = max(max_cost, cost[i])\n  return res"}
{"nl": "Pentagon:\n\nA pentagon (from the Greek v Pente and gonia, which mean five and angle) is any five-sided polygon or 5-gon. A simple pentagon\u2019s internal angles add up to 540\u00b0.\n\n\n\nA pentagon can be simple or complex, and it can be self-intersecting. A pentagram is a self-intersecting regular pentagon (or a star pentagon).\n\nFormula to calculate the area of a pentagon:\n In which, a= The Pentagon\u2019s side length\n\nFormula to calculate the perimeter of a pentagon:\n\nperimeter = 5a\n\n\n\nGiven the Pentagon\u2019s side length and the task is to calculate the area and perimeter of the given Pentagon.\n\n\n\nExamples:\n\nExample1:\nInput:\nGiven The Pentagon's side length = 10\nOutput:\nThe Pentagon's area with given side length { 10 } = 172.0477400588967\nThe Pentagon's Perimeter with given side length { 10 } = 50\nExample2:\nInput:\nGiven The Pentagon's side length = 5.5\nOutput:\nThe Pentagon's area with given side length { 5.5 } = 52.04444136781625\nThe Pentagon's Perimeter with given side length { 5.5 } = 27.5", "code": "# Import the math module using the import keyword.\n import math\n # Give the Pentagon's side length as static input and store it in a variable.\n side_len = 10\n # Calculate the area of the given pentagon using the above given mathematical formula and\n # math.sqrt() function.\n # Store it in another variable.\n pentgn_area = (math.sqrt(5*(5+2*math.sqrt(5)))*pow(side_len, 2))/4.0\n # Calculate the perimeter of the given pentagon using the above given mathematical formula.\n # Store it in another variable.\n pentgn_perimtr = (5*side_len)\n # Print the Pentagon's area with the given side length.\n print(\"The Pentagon's area with given side length {\", side_len, \"} =\", pentgn_area)\n # Print the Pentagon's perimeter with the given side length.\n print(\"The Pentagon's Perimeter with given side length {\", side_len, \"} =\", pentgn_perimtr)"}
{"nl": "In this challenge, you have to find the last 15 palindromes of all numbers starting from ten and up to a given limit, including the limit in the search.\nGiven an integer limit being the upper limit of the range of interest, implement a function that returns the last 15 palindromes numbers lower or equal to limit as a list sorted ascendingly.\nExamples\ngenerate_palindromes(151) \u279e [\n  11, 22, 33, 44, 55,\n  66, 77, 88, 99, 101,\n  111, 121, 131, 141, 151\n]\n\ngenerate_palindromes(600) \u279e [\n  454, 464, 474, 484, 494,\n  505, 515, 525, 535, 545,\n  555, 565, 575, 585, 595\n]\n\ngenerate_palindromes(999999) \u279e [\n  985589, 986689, 987789, 988889, 989989,\n  990099, 991199, 992299, 993399, 994499,\n  995599, 996699, 997799, 998899, 999999\n]\nNotes\nN/A", "code": "def generate_palindromes(limit):\n  is_pal = lambda n: str(n) == str(n)[::-1]\n  ans = []\n  while len(ans)<15:\n    if is_pal(limit): ans = [limit] + ans\n    limit-=1\n  return ans"}
{"nl": "Given a graph where every edge has weight as either 0 or 1. A source vertex is also given in the graph. Find the shortest path from source vertex to every other vertex.\u00a0", "code": "# Python3 program to implement single source\n# shortest path for a Binary Graph\nfrom sys import maxsize as INT_MAX\nfrom collections import deque\n\u00a0\n# no.of vertices\nV = 9\n\u00a0\n# a structure to represent edges\nclass node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, to, weight):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# two variable one denote the node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and other the weight\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.to = to\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.weight = weight\n\u00a0\n# vector to store edges\nedges = [0] * V\nfor i in range(V):\n\u00a0\u00a0\u00a0\u00a0edges[i] = []\n\u00a0\n# Prints shortest distance from\n# given source to every other vertex\ndef zeroOneBFS(src: int):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize distances from given source\n\u00a0\u00a0\u00a0\u00a0dist = [0] * V\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i] = INT_MAX\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# double ende queue to do BFS.\n\u00a0\u00a0\u00a0\u00a0Q = deque()\n\u00a0\u00a0\u00a0\u00a0dist[src] = 0\n\u00a0\u00a0\u00a0\u00a0Q.append(src)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while Q:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = Q[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.popleft()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(len(edges[v])):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# checking for the optimal distance\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dist[edges[v][i].to] >\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[v] + edges[v][i].weight):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[edges[v][i].to] = dist[v] + edges[v][i].weight\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Put 0 weight edges to front and 1 weight\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# edges to back so that vertices are processed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in increasing order of weights.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if edges[v][i].weight == 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.appendleft(edges[v][i].to)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.append(edges[v][i].to)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# printing the shortest distances\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(dist[i], end = \" \")\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\ndef addEdge(u: int, v: int, wt: int):\n\u00a0\u00a0\u00a0\u00a0edges[u].append(node(v, wt))\n\u00a0\u00a0\u00a0\u00a0edges[u].append(node(v, wt))\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(0, 1, 0)\n\u00a0\u00a0\u00a0\u00a0addEdge(0, 7, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(1, 7, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(1, 2, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(2, 3, 0)\n\u00a0\u00a0\u00a0\u00a0addEdge(2, 5, 0)\n\u00a0\u00a0\u00a0\u00a0addEdge(2, 8, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(3, 4, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(3, 5, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(4, 5, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(5, 6, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(6, 7, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(7, 8, 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# source node\n\u00a0\u00a0\u00a0\u00a0src = 0\n\u00a0\u00a0\u00a0\u00a0zeroOneBFS(src)\n\u00a0\n# This code is contributed by\n# sanjeev2552\n"}
{"nl": "In the previous article, we have discussed Python Program to Check Diagonally Dominant Matrix\n \n Given a square matrix, the task is to get the frequency of even numbers and odd numbers of a given matrix in python.\n \n What is a matrix:\n \n A matrix is a rectangular sequence of numbers divided into columns and rows. A matrix element or entry is a number that appears in a matrix.\n \n Example:\n \n \n \n Above is the matrix which contains 5 rows and 4 columns and having elements from 1 to 20.\n \n In this order, the dimensions of a matrix indicate the number of rows and columns.\n \n \n \n Here as there are 5 rows and 4 columns it is called a 5*4 matrix.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given Matrix :\n 9 0 2\n 7 5 6\n 7 1 9\n Output:\n \n The odd number frequency of the given matrix = 6\n The even number frequency of the given matrix 3\n Example2:\n \n Input:\n \n Given Matrix :\n 5 3 2\n 8 4 1\n 7 2 3\n Output:\n \n  The odd number frequency of the given matrix = 5\n The even number frequency of the given matrix 4", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[9, 0, 2],\n  [7, 5, 6],\n  [7, 1, 9]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n # Take a variable to say evnnum_freqcy and initialize its value to 0.\n evnnum_freqcy = 0\n # Take another variable to say oddnum_freqcy and initialize its value to 0.\n oddnum_freqcy = 0\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another Nested\n  # For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Check if the mtrx[n][m] is even using the if conditional statement (where n is the\n  # iterator value of the parent For loop and m is the iterator value of the\n  # inner For loop.).\n  if ((mtrx[n][m] % 2) == 0):\n  # If it is true, then increment the value of above evnnum_freqcy by 1.\n  evnnum_freqcy += 1\n  else:\n  # Else increment the value of above oddnum_freqcy by 1.\n  oddnum_freqcy += 1\n # Print the frequency of even numbers and odd numbers of a given matrix.\n print(\" The odd number frequency of the given matrix =\", oddnum_freqcy)\n print(\" The even number frequency of the given matrix \", evnnum_freqcy)"}
{"nl": "Create a function that takes a list and a string as arguments and returns the index of the string.\nExamples\nfind_index([\"hi\", \"edabit\", \"fgh\", \"abc\"], \"fgh\") \u279e 2\n\nfind_index([\"Red\", \"blue\", \"Blue\", \"Green\"], \"blue\") \u279e 1\n\nfind_index([\"a\", \"g\", \"y\", \"d\"], \"d\") \u279e 3\n\nfind_index([\"Pineapple\", \"Orange\", \"Grape\", \"Apple\"], \"Pineapple\") \u279e 0\nNotes\nDon't forget to return the result.\nIf you are stuck, find help in the Resources tab.\nThe variable for list is lst, not 1st.", "code": "def find_index(lst, str):\n  return lst.index(str)"}
{"nl": "Instructions\r\nChaitana owns a very popular theme park. She only has one ride in the very center of beautifully landscaped grounds: The Biggest Roller Coaster in the World(TM). Although there is only this one attraction, people travel from all over the world and stand in line for hours for the opportunity to ride Chaitana's hypercoaster.\r\n\r\nThere are two queues for this ride, each represented as a list:\r\n\r\nNormal Queue\r\nExpress Queue (also known as the Fast-track) - where people pay extra for priority access.\r\nYou have been asked to write some code to better manage the guests at the park. You need to implement the following functions as soon as possible before the guests (and your boss, Chaitana!) get cranky.\r\n\r\n1. Add me to the queue\r\nDefine the add_me_to_the_queue() function that takes 4 parameters <express_queue>, <normal_queue>, <ticket_type>, <person_name> and returns the appropriate queue updated with the person's name.\r\n\r\n<ticket_type> is an int with 1 == express_queue and 0 == normal_queue.\r\n<person_name> is the name (as a str) of the person to be added to the respective queue.\r\n>>> add_me_to_the_queue(express_queue=[\"Tony\", \"Bruce\"], normal_queue=[\"RobotGuy\", \"WW\"], ticket_type=1, person_name=\"RichieRich\")\r\n...\r\n[\"Tony\", \"Bruce\", \"RichieRich\"]\r\n\r\n>>> add_me_to_the_queue(express_queue=[\"Tony\", \"Bruce\"], normal_queue=[\"RobotGuy\", \"WW\"], ticket_type=0, person_name=\"HawkEye\")\r\n....\r\n[\"RobotGuy\", \"WW\", \"HawkEye\"]\r\n2. Where are my friends?\r\nOne person arrived late at the park but wants to join the queue where their friends are waiting. But they have no idea where their friends are standing and there isn't any phone reception to call them.\r\n\r\nDefine the find_my_friend() function that takes 2 parameters queue and friend_name and returns the position in the queue of the person's name.\r\n\r\n<queue> is the list of people standing in the queue.\r\n<friend_name> is the name of the friend whose index (place in the queue) you need to find.\r\nRemember: Indexing starts at 0 from the left, and -1 from the right.\r\n\r\n>>> find_my_friend(queue=[\"Natasha\", \"Steve\", \"T'challa\", \"Wanda\", \"Rocket\"], friend_name=\"Steve\")\r\n...\r\n1\r\n3. Can I please join them?\r\nNow that their friends have been found (in task #2 above), the late arriver would like to join them at their place in the queue. Define the add_me_with_my_friends() function that takes 3 parameters queue, index, and person_name.\r\n\r\n<queue> is the list of people standing in the queue.\r\n<index> is the position at which the new person should be added.\r\n<person_name> is the name of the person to add at the index position.\r\nReturn the queue updated with the late arrivals name.\r\n\r\n>>> add_me_with_my_friends(queue=[\"Natasha\", \"Steve\", \"T'challa\", \"Wanda\", \"Rocket\"], index=1, person_name=\"Bucky\")\r\n...\r\n[\"Natasha\", \"Bucky\", \"Steve\", \"T'challa\", \"Wanda\", \"Rocket\"]\r\n4. Mean person in the queue\r\nYou just heard from the queue that there is a really mean person shoving, shouting, and making trouble. You need to throw that miscreant out for bad behavior!\r\n\r\nDefine the remove_the_mean_person() function that takes 2 parameters queue and person_name.\r\n\r\n<queue> is the list of people standing in the queue.\r\n<person_name> is the name of the person that needs to be kicked out.\r\nReturn the queue updated without the mean person's name.\r\n\r\n>>> remove_the_mean_person(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Wanda\", \"Rocket\"], person_name=\"Eltran\")\r\n...\r\n[\"Natasha\", \"Steve\", \"Wanda\", \"Rocket\"]\r\n5. Namefellows\r\nYou may not have seen two unrelated people who look exactly the same, but you have definitely seen unrelated people with the exact same name (namefellows)! Today, it looks like there are a lot of them in attendance. You want to know how many times a particular name occurs in the queue.\r\n\r\nDefine the how_many_namefellows() function that takes 2 parameters queue and person_name.\r\n\r\n<queue> is the list of people standing in the queue.\r\n<person_name> is the name you think might occur more than once in the queue.\r\nReturn the number of occurrences of person_name, as an int.\r\n\r\n>>> how_many_namefellows(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Natasha\", \"Rocket\"], person_name=\"Natasha\")\r\n...\r\n2\r\n6. Remove the last person\r\nSadly, it's overcrowded at the park today and you need to remove the last person in the normal line (you will give them a voucher to come back in the fast-track on another day). You will have to define the function remove_the_last_person() that takes 1 parameter queue, which is the list of people standing in the queue.\r\n\r\nYou should update the list and also return the name of the person who was removed, so you can write them a voucher.\r\n\r\n>>> remove_the_last_person(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Natasha\", \"Rocket\"])\r\n...\r\n'Rocket'\r\n7. Sort the Queue List\r\nFor administrative purposes, you need to get all the names in a given queue in alphabetical order.\r\n\r\nDefine the sorted_names() function that takes 1 argument, queue, (the list of people standing in the queue), and returns a sorted copy of the list.\r\n\r\n>>> sorted_names(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Natasha\", \"Rocket\"])\r\n...\r\n['Eltran', 'Natasha', 'Natasha', 'Rocket', 'Steve']", "code": "\"\"\"Chaitanas Colossal Coaster\"\"\"\r\ndef add_me_to_the_queue(express_queue: list, normal_queue: list, ticket_type: int, person_name: str) -> None:\r\n    \"\"\"\r\n \r\n    :param express_queue: list - names in the Fast-track queue.\r\n    :param normal_queue:  list - names in the normal queue.\r\n    :param ticket_type:  int - type of ticket. 1 = express, 0 = normal.\r\n    :param person_name: str - name of person to add to a queue.\r\n    :return: list - the (updated) queue the name was added to.\r\n    \"\"\"\r\n    if ticket_type == 0:\r\n        normal_queue.append(person_name)\r\n        return normal_queue\r\n    if ticket_type == 1:\r\n        express_queue.append(person_name)\r\n        return express_queue\r\n    raise ValueError(\"Invalid Ticket Type\")\r\ndef find_my_friend(queue: list, friend_name: str) -> int:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param friend_name: str - name of friend to find.\r\n    :return: int - index at which the friends name was found.\r\n    \"\"\"\r\n    if friend_name in queue:\r\n        return queue.index(friend_name)\r\n    return -1\r\ndef add_me_with_my_friends(queue: list, index: int, person_name: str) -> list:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param index: int - the index at which to add the new name.\r\n    :param person_name: str - the name to add.\r\n    :return: list - queue updated with new name.\r\n    \"\"\"\r\n    queue.insert(index, person_name)\r\n    return queue\r\ndef remove_the_mean_person(queue: list, person_name: str) -> list:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name of mean person.\r\n    :return:  list - queue update with the mean persons name removed.\r\n    \"\"\"\r\n    queue.remove(person_name)\r\n    return queue\r\ndef how_many_namefellows(queue: list, person_name: str) -> int:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name you wish to count or track.\r\n    :return:  int - the number of times the name appears in the queue.\r\n    \"\"\"\r\n    count = 0\r\n    for name in queue:\r\n        if name == person_name:\r\n            count += 1\r\n    return count\r\ndef remove_the_last_person(queue: list) -> str:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :return: str - name that has been removed from the end of the queue.\r\n    \"\"\"\r\n    return queue.pop()\r\ndef sorted_names(queue: list) -> list:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :return: list - copy of the queue in alphabetical order.\r\n    \"\"\"\r\n    queue.sort()\r\n    return queue\r"}
{"nl": "Fibonacci numbers are defined by the sequence f(0) = 0, f(1) = 1 and f(n) = f(n \u2013 1) + f(n \u2013 2) for n >= 2. The program prompts the user to enter n and it prints the nth Fibonacci number.", "code": "def fibonacci(n):\n    \"\"\"Return the nth Fibonacci number.\"\"\"\n    # r[i] will contain the ith Fibonacci number\n    r = [-1]*(n + 1)\n    return fibonacci_helper(n, r)\n\u00a0\n\u00a0\ndef fibonacci_helper(n, r):\n    \"\"\"Return the nth Fibonacci number and store the ith Fibonacci number in\n    r[i] for 0 <= i <= n.\"\"\"\n    if r[n] >= 0:\n        return r[n]\n\u00a0\n    if (n == 0 or n == 1):\n        q = n\n    else:\n        q = fibonacci_helper(n - 1, r) + fibonacci_helper(n - 2, r)\n    r[n] = q\n\u00a0\n    return q\n\u00a0\n\u00a0\nn = int(input('Enter n: '))\n\u00a0\nans = fibonacci(n)\nprint('The nth Fibonacci number:', ans)"}
{"nl": "In this post, we will write a program to find the sum of digits of an integer number in Python. We can use the while loop to write the program. We can also develop a Python program to calculate the sum of digits without using the loop. The integer numbers will be given as input and the python program to compute the sum of digits in numbers using various methods.", "code": "# Python program to compute sum of digits in number def ComputeSum(num): #user-defined function sum = 0 while (num != 0): sum += (num % 10) num //= 10 return sum # take input num = int(input('Enter a number: ')) # calling function & display result print('Sum of digits in number =', ComputeSum(num))"}
{"nl": "Given three sorted arrays A, B, and C of not necessarily same sizes. Calculate the minimum absolute difference between the maximum and minimum number of any triplet A[i], B[j], C[k] such that they belong to arrays A, B and C respectively, i.e., minimize (max(A[i], B[j], C[k]) \u2013 min(A[i], B[j], C[k]))", "code": "# python code for above approach.\r\n\r\ndef solve(A, B, C):\r\n\r\n\t\t# assigning the length -1 value\r\n\t\t# to each of three variables\r\n\t\ti = len(A) - 1\r\n\t\tj = len(B) - 1\r\n\t\tk = len(C) - 1\r\n\r\n\t\t# calculating min difference\r\n\t\t# from last index of lists\r\n\t\tmin_diff = abs(max(A[i], B[j], C[k]) -\r\n\t\tmin(A[i], B[j], C[k]))\r\n\r\n\t\twhile i != -1 and j != -1 and k != -1:\r\n\t\t\tcurrent_diff = abs(max(A[i], B[j],\r\n\t\t\tC[k]) - min(A[i], B[j], C[k]))\r\n\r\n\t\t\t# checking condition\r\n\t\t\tif current_diff < min_diff:\r\n\t\t\t\tmin_diff = current_diff\r\n\r\n\t\t\t# calculating max term from list\r\n\t\t\tmax_term = max(A[i], B[j], C[k])\r\n\r\n\t\t\t# Moving to smaller value in the\r\n\t\t\t# array with maximum out of three.\r\n\t\t\tif A[i] == max_term:\r\n\t\t\t\ti -= 1\r\n\t\t\telif B[j] == max_term:\r\n\t\t\t\tj -= 1\r\n\t\t\telse:\r\n\t\t\t\tk -= 1\r\n\t\treturn min_diff\r\n\r\n# driver code\r\n\r\nA = [ 5, 8, 10, 15 ]\r\nB = [ 6, 9, 15, 78, 89 ]\r\nC = [ 2, 3, 6, 6, 8, 8, 10 ]\r\nprint(solve(A, B, C))\r\n"}
{"nl": "I recently encountered with a question in an interview at e-commerce company. The interviewer asked the following question:\nThere is BST given with root node with key part as integer only.\n\nYou need to find the inorder successor and predecessor of a given key. In case the given key is not found in BST, then return the two values within which this key will lie.\n\nFollowing is the algorithm to reach the desired result. Its a recursive method: \n\nInput: root node, key\noutput: predecessor node, successor node\n\n1. If root is NULL\n      then return\n2. if key is found then\n    a. If its left subtree is not null\n        Then predecessor will be the right most \n        child of left subtree or left child itself.\n    b. If its right subtree is not null\n        The successor will be the left most child \n        of right subtree or right child itself.\n    return\n3. If key is smaller then root node\n        set the successor as root\n        search recursively into left subtree\n    else\n        set the predecessor as root\n        search recursively into right subtree", "code": "# Python program to find the inorder successor in a BST\n\n# A binary tree node\nclass Node:\n\n        # Constructor to create a new node\n        def __init__(self, key):\n                self.data = key\n                self.left = None\n                self.right = None\n\ndef inOrderSuccessor(n):\n        \n        # Step 1 of the above algorithm\n        if n.right is not None:\n                return minValue(n.right)\n\n        # Step 2 of the above algorithm\n        p = n.parent\n        while( p is not None):\n                if n != p.right :\n                        break\n                n = p\n                p = p.parent\n        return p\n\n# Given a non-empty binary search tree, return the\n# minimum data value found in that tree. Note that the\n# entire tree doesn't need to be searched\ndef minValue(node):\n        current = node\n\n        # loop down to find the leftmost leaf\n        while(current is not None):\n                if current.left is None:\n                        break\n                current = current.left\n\n        return current\n\n\n# Given a binary search tree and a number, inserts a\n# new node with the given number in the correct place\n# in the tree. Returns the new root pointer which the\n# caller should then use( the standard trick to avoid\n# using reference parameters)\ndef insert( node, data):\n\n        # 1) If tree is empty then return a new singly node\n        if node is None:\n                return Node(data)\n        else:\n                \n                # 2) Otherwise, recur down the tree\n                if data <= node.data:\n                        temp = insert(node.left, data)\n                        node.left = temp\n                        temp.parent = node\n                else:\n                        temp = insert(node.right, data)\n                        node.right = temp\n                        temp.parent = node\n                \n                # return the unchanged node pointer\n                return node\n\n\n# Driver program to test above function\n\nroot = None\n\n# Creating the tree given in the above diagram\nroot = insert(root, 20)\nroot = insert(root, 8);\nroot = insert(root, 22);\nroot = insert(root, 4);\nroot = insert(root, 12);\nroot = insert(root, 10);\nroot = insert(root, 14);\ntemp = root.left.right.right\n\nsucc = inOrderSuccessor(temp)\nif succ is not None:\n        print (\"\\nInorder Successor of % d is % d \"%(temp.data, succ.data))\nelse:\n        print (\"\\nInorder Successor doesn't exist\")\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Write a function that returns True if a year is a leap, otherwise return False.\nA year is a \"leap year\" if it lasts 366 days, instead of 365 in a typical year. That extra day is added to the end of the shortest month, creating February 29.\nA leap year occurs every four years, and will take place if the year is a multiple of four. The exception to this is a year at the beginning of a century (for example, 1900 or 2000), where the year must be divisible by 400 to be a leap year.\nLook at the examples, and if you need help, look at the resources panel.\nExamples\nleap_year(1990) \u279e False\n\nleap_year(1924) \u279e True\n\nleap_year(2021) \u279e False\nNotes\nDo not overthink this challenge.\nYou can solve the problem with a few lines of code.", "code": "from calendar import isleap as leapYear"}
{"nl": "We need not to do anything if a number is positive. We want to change only negative numbers. Since negative numbers are stored in 2\u2019s complement form, to get the absolute value of a negative number we have to toggle bits of the number and add 1 to the result.\nFor example -2 in a 8 bit system is stored as follows 1 1 1 1 1 1 1 0 where leftmost bit is the sign bit. To get the absolute value of a negative number, we have to toggle all bits and add 1 to the toggled number i.e, 0 0 0 0 0 0 0 1 + 1 will give the absolute value of 1 1 1 1 1 1 1 0. Also remember, we need to do these operations only if the number is negative (sign bit is set).", "code": "# Python3 implementation of above approach\nCHARBIT = 8;\nSIZE_INT = 8;\n\n# This function will return\n# absolute value of n\ndef getAbs(n):\n\tmask = n >> (SIZE_INT * CHARBIT - 1);\n\treturn ((n + mask) ^ mask);\n\n# Driver Code\nn = -6;\nprint(\"Absolute value of\",n,\"is\",getAbs(n));\n\n# This code is contributed by mits\n"}
{"nl": "Given a string, which contains duplicate characters the task is to remove the adjacent duplicate characters from the given string.", "code": "# Function to remove adjacent duplicates characters from a string\ndef remAdj(givenstrng):\n    # convert the given string to list using list() function\n    charslist = list(givenstrng)\n    prevele = None\n    p = 0\n    # Traverse the given string\n    for chars in givenstrng:\n        if prevele != chars:\n            charslist[p] = chars\n            prevele = chars\n            p = p + 1\n    # join the list which contains characters to string using join function and return it\n    return ''.join(charslist[:p])\n\n\n# Driver code\n# Give the string as user input using the input() function.\n# Store it in a variable.\ngivenstrng = input('Enter some random string = ')\n# printing the given string before removing adjacent duplicate characters\nprint('given string before removing adjacent duplicate characters = ', givenstrng)\n# Pass the given string to the remAdj function which accepts\n# the given string as the argument\n# and returns the modified string with no adjacent duplicates.\nmodistring = remAdj(givenstrng)\n# printing the given string after removing adjacent duplicate characters\nprint('given string without after adjacent duplicate characters = ', modistring)"}
{"nl": "Given an array of n elements and q queries, for each query that has index i, find the next greater element and print its value. If there is no such greater element to its right then print -1.\u00a0\n\n\u00a0", "code": "# Python3 program to print\n# next greater number\n# of Q queries\n\u00a0\n# array to store the next\n# greater element index\ndef next_greatest(next, a, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# use of stl\n\u00a0\u00a0\u00a0\u00a0# stack in c++\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# push the 0th\n\u00a0\u00a0\u00a0\u00a0# index to the stack\n\u00a0\u00a0\u00a0\u00a0s.append(0);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# traverse in the\n\u00a0\u00a0\u00a0\u00a0# loop from 1-nth index\n\u00a0\u00a0\u00a0\u00a0for\u00a0 i in range(1, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# iterate till loop is empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (len(s) != 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# get the topmost\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# index in the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = s[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if the current element is\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# greater then the top indexth\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element, then this will be\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the next greatest index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# of the top indexth element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (a[cur] < a[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# initialise the cur\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# index position's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next greatest as index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next[cur] = i;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop the cur index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as its greater\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element has been found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if not greater\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push the i index so that its\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next greatest can be found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(i);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# iterate for all other\n\u00a0\u00a0\u00a0\u00a0# index left inside stack\n\u00a0\u00a0\u00a0\u00a0while(len(s) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = s[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark it as -1 as no\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element in greater\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then it in right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next[cur] = -1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# answers all\n# queries in O(1)\ndef answer_query(a, next, n, index):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# stores the next greater\n\u00a0\u00a0\u00a0\u00a0# element positions\n\u00a0\u00a0\u00a0\u00a0position = next[index];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if position is -1 then no\n\u00a0\u00a0\u00a0\u00a0# greater element is at right.\n\u00a0\u00a0\u00a0\u00a0if(position == -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if there is a index that\n\u00a0\u00a0\u00a0\u00a0# has greater element\n\u00a0\u00a0\u00a0\u00a0# at right then return its\n\u00a0\u00a0\u00a0\u00a0# value as a[position]\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return a[position];\n\u00a0\n# Driver Code\nif __name__=='__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0a = [3, 4, 2, 7, 5, 8, 10, 6 ]\n\u00a0\u00a0\u00a0\u00a0n = len(a)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# initializes the\n\u00a0\u00a0\u00a0\u00a0# next array as 0\n\u00a0\u00a0\u00a0\u00a0next=[0 for i in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# calls the function\n\u00a0\u00a0\u00a0\u00a0# to pre-calculate\n\u00a0\u00a0\u00a0\u00a0# the next greatest\n\u00a0\u00a0\u00a0\u00a0# element indexes\n\u00a0\u00a0\u00a0\u00a0next_greatest(next, a, n);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# query 1 answered\n\u00a0\u00a0\u00a0\u00a0print(answer_query(a, next, n, 3), end = ' ')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# query 2 answered\n\u00a0\u00a0\u00a0\u00a0print(answer_query(a, next, n, 6), end = ' ')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# query 3 answered\n\u00a0\u00a0\u00a0\u00a0print(answer_query(a, next, n, 1), end = ' ')\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "Given a list of tickets, find itinerary in order using the given list.\nExample: \n \n\nInput:\n\"Chennai\" -> \"Banglore\"\n\"Bombay\" -> \"Delhi\"\n\"Goa\"    -> \"Chennai\"\n\"Delhi\"  -> \"Goa\"\n\nOutput: \nBombay->Delhi, Delhi->Goa, Goa->Chennai, Chennai->Banglore,", "code": "class Solution():\n        #Solution class carries method for printing itinerary\n        def __init__(self):\n                pass\n        #method for printing itinerary\n        def printitinerary(self,d):\n                # First step : create a reversed mapping. Here also for storing key value pairs dictionary is used.\n                reverse_d = dict()\n                for i in d:\n                        reverse_d[d[i]] = i\n                # Second step : find the starting point. Starting point will be that value which is not present in 'd' as key.\n                for i in reverse_d:\n                        if reverse_d[i] not in reverse_d:\n                                starting_pt = reverse_d[i]\n                                break;\n                #Third step : simply proceed one by one to print whole route. Assuming that there exist Starting point.\n                while(starting_pt in d):\n                        print(starting_pt,\"->\",d[starting_pt],end=\", \")\n                        starting_pt = d[starting_pt]\n                #method prints here only. Does not return anything.\n\n\nif __name__==\"__main__\":\n        # Mapping using inbuilt data structure 'dictionary'\n        d = dict()\n        d[\"Chennai\"] = \"Banglore\"\n        d[\"Bombay\"] = \"Delhi\"\n        d[\"Goa\"] = \"Chennai\"\n        d[\"Delhi\"] = \"Goa\"\n\n        # call for method that would print itinerary.\n        obj = Solution()\n        obj.printIterary(d)\n"}
{"nl": "Create a function that takes a list and returns the number of ALL elements within it (including those within the sub-level list(s)).\nExamples\ndeep_count([1, 2, 3]) \u279e 3\n\ndeep_count([[1], [2], [3]]) \u279e 6\n\ndeep_count([\"x\", \"y\", [\"z\"]]) \u279e 4\n\ndeep_count([\"a\", \"b\", [\"c\", \"d\", [\"e\"]]]) \u279e 7\nNotes\nIn the examples above, notice how the sub-lists within the main list count as an element as well as the elements within that sub-list.", "code": "def deep_count(lst):\n    if not isinstance(lst, list):\n        return 0\n    return len(lst) + sum(map(deep_count, lst))"}
{"nl": "Now in this post, we will develop a palindrome number in python. It will check the given number is a palindrome number or not.", "code": "# Python program to check if number is Palindrome # take inputs num = int(input('Enter the number : ')) # calculate reverse of number reverse = 0 number = num while(num != 0): remainder = num % 10 reverse = reverse * 10 + remainder num = int(num / 10) # compare reverse to original number if(number == reverse): print(number,'is a Palindrome') else: print(number,'is not a Palindrome')"}
{"nl": "Given the radius, find the volume and surface area of the given sphere.", "code": "# Give the radius of a sphere as user input using the float(input()) function\n# and store it in a variable\ngvn_radis = float(input(\"Enter some random variable = \"))\n# Take a variable and initialize it with the \"pi\" value i.e. 3.14 and\n# store it in another variable.\nstandard_pi_val = 3.14\n# Calculate the surface area of the given sphere using the above mathematical formula\n# and store it in another variable.\nsurf_area = 4 * standard_pi_val * gvn_radis * gvn_radis\n# Calculate the volume of the given sphere using the above mathematical formula and\n# store it in another variable.\nsphre_volm = (4 / 3) * standard_pi_val * gvn_radis * gvn_radis * gvn_radis\n# Print the surface area of the given sphere.\nprint(\n    \"The Surface area of the given Sphere with the radius [\", gvn_radis, \"]= %.3f\" % surf_area)\n# Print the volume of the given sphere.\nprint(\n    \"The volume of the given Sphere with the radius [\", gvn_radis, \"]= %.3f\" % sphre_volm)"}
{"nl": "Anna is a strange girl. She likes certain boys, but not others. You have to figure out why she likes some, and not the others.\nExamples\nanna_likes(\"David\") \u279e False\n\nanna_likes(\"Samuel\") \u279e True\n\nanna_likes(\"Gary\") \u279e False\nNotes\nAll names / inputs are valid.\nAnna likes her own name.\nCheck the Tests tab for all 100 examples.\nTry to solve this one using RegEx.", "code": "import re\ndef anna_likes(boy):\n    return len(re.findall(r\"[aeiou]\", boy, re.I))==len(boy)/2"}
{"nl": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n\n \n\nExample 1:\n\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\nExample 2:\n\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n \n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 300].\n-100 <= Node.val <= 100\nThe list is guaranteed to be sorted in ascending order.", "code": "class Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        # sentinel\n        sentinel = ListNode(0, head)\n\n        # predecessor = the last node \n        # before the sublist of duplicates\n        pred = sentinel\n        \n        while head:\n            # if it's a beginning of duplicates sublist \n            # skip all duplicates\n            if head.next and head.val == head.next.val:\n                # move till the end of duplicates sublist\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                # skip all duplicates\n                pred.next = head.next \n            # otherwise, move predecessor\n            else:\n                pred = pred.next \n                \n            # move forward\n            head = head.next\n            \n        return sentinel.next"}
{"nl": "Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n\n \n\nExample 1:\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\nExample 2:\n\nInput: target = 4, nums = [1,4,4]\nOutput: 1\nExample 3:\n\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n \n\nConstraints:\n\n1 <= target <= 109\n1 <= nums.length <= 105\n1 <= nums[i] <= 105", "code": "class Solution:\n\ndef minSubArrayLen(self, s, nums):\n    total = left = 0\n    result = len(nums) + 1\n    for right, n in enumerate(nums):\n        total += n\n        while total >= s:\n            result = min(result, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return result if result <= len(nums) else 0"}
{"nl": "Breadth-First Traversal (or Search) for a graph is similar to Breadth-First Traversal of a tree. The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array. For simplicity, it is assumed that all vertices are reachable from the starting vertex.\u00a0", "code": "# Python3 Program to print BFS traversal\n# from a given source vertex. BFS(int s)\n# traverses vertices reachable from s.\nfrom collections import defaultdict\n\u00a0\n# This class represents a directed graph\n# using adjacency list representation\nclass Graph:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# default dictionary to store graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# function to add an edge to graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u,v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[u].append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to print a BFS of graph\n\u00a0\u00a0\u00a0\u00a0def BFS(self, s):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark all the vertices as not visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited = [False] * (max(self.graph) + 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a queue for BFS\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark the source node as\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited and enqueue it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(s)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[s] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while queue:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Dequeue a vertex from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# queue and print it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s = queue.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (s, end = \" \")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get all adjacent vertices of the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# dequeued vertex s. If a adjacent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# has not been visited, then mark it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited and enqueue it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in self.graph[s]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[i] == False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[i] = True\n\u00a0\n# Driver code\n\u00a0\n# Create a graph given in\n# the above diagram\ng = Graph()\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n\u00a0\nprint (\"Following is Breadth First Traversal\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\" (starting from vertex 2)\")\ng.BFS(2)\n\u00a0\n# This code is contributed by Neelam Yadav\n"}
{"nl": "Our website provided core java programs examples with output aid beginners and expert coders to test their knowledge gap and learn accordingly.\r\n\r\nIn this tutorial, we\u2019ll learn how to construct a Python program to acquire our computer\u2019s IP address.\r\n\r\nBefore we begin the program, let us learn more about the IP Address.\r\n\r\nIP Address:\r\n\r\nAn IP address (internet protocol address) is a numerical representation that identifies a specific network interface.\r\n\r\nIPv4 addresses are 32 bits long. There are a total of 4,294,967,296 (232) unique addresses available. IPv6 addresses are 128 bits long, allowing for a total of 3.4 x 1038 (2128) distinct addresses.\r\n\r\nVarious reserved addresses and other considerations restrict the overall useable address pool in both versions.\r\n\r\nIP addresses are binary numbers, but they\u2019re usually written in decimal (IPv4) or hexadecimal (IPv6) to make them easier to understand and use for people.\r\n\r\nThe Internet Protocol (IP) is a set of standards and specifications for generating and transferring data packets, or datagrams, across networks. The Internet Protocol (IP) is a component of the Internet protocol suite\u2019s Internet layer. IP is considered part of the network layer in the OSI paradigm. IP is usually used in conjunction with a higher-level protocol, the most common of which being TCP. RFC 791 is the standard that governs the IP protocol.\r\n\r\nThere are two ways to define an IP address. There are two types of IP addresses: IPv4 and IPv6. IP Address is defined as a 32-bit number in IPv4. An IP Address is defined as a 128-bit number in IPv6.\r\n\r\n172.15.254.1 is an example of an IPv4 address.\r\n\r\nIPv6 address example: 2000:0db8:85a3:0000:0000:8a2e:0370:7334\r\n\r\nIn this tutorial, we will use the socket library to get our computer\u2019s IP address.\r\n\r\nTo obtain our computer\u2019s IP address, we will utilize the socket library method gethostbyname(). It accepts a hostname as an argument and returns the host\u2019s IPv4 address.", "code": "# To utilize the method gethostbyname() in the socket library,\r\n# first import the socket module using the import statement.\r\nimport socket\r\n# To obtain the IP address of the host,\r\n# we must give hostname as an argument to gethostbyname ().\r\n# So, let's acquire our computer's hostname using the gethostname() method\r\n# and send it as an argument to gethostbyname() to get the IP address.\r\n# Also, assign the variable the value provided by the gethostbyname() method.\r\n\r\ncompIpAdress = socket.gethostbyname(socket.gethostname())\r\n# Print the IP address of the computer.\r\nprint(\"The IP Address of this computer is [\", compIpAdress, ']')"}
{"nl": "The None keyword is used to define a null value, or no value at all.\r\n\r\nNone is not the same as 0, False, or an empty string. None is a data type of its own (NoneType) and only None can be None.\r\n\r\n", "code": "x = None\r\n\r\nprint(x)"}
{"nl": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n\n \n\nExample 1:\n\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\nExample 2:\n\nInput: n = 1\nOutput: [[1]]\n \n\nConstraints:\n\n1 <= n <= 20", "code": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        res = [[0] * n for _ in range(n)]\n        \n        def fill_circle(el, start, n):\n            i, j = start, start            \n            for k in range(j, j + n): \n                res[i][k], el = el, el + 1\n            for k in range(i + 1, i + n): \n                res[k][j + n - 1], el = el, el + 1\n            for k in reversed(range(j, j + n - 1)): \n                res[i + n - 1][k], el = el, el + 1\n            for k in reversed(range(i + 1, i + n - 1)): \n                res[k][j], el = el, el + 1\n        \n        el, start = 1, 0\n        while n > 0:\n            fill_circle(el, start, n)\n            el = el + 4*(n - 1)\n            n, start = n - 2, start + 1\n            \n        return res"}
{"nl": "Transpose of a directed graph G is another directed graph on the same set of vertices with all of the edges reversed compared to the orientation of the corresponding edges in G. That is, if G contains an edge (u, v) then the converse/transpose/reverse of G contains an edge (v, u) and vice versa.\n\nGiven a graph (represented as adjacency list), we need to find another graph which is the transpose of the given graph.", "code": "# Python3 program to find transpose of a graph.\u00a0\n\u00a0\u00a0\n# function to add an edge from vertex\u00a0\n# source to vertex dest\u00a0\ndef addEdge(adj, src, dest):\n\u00a0\u00a0\u00a0\u00a0adj[src].append(dest)\n\u00a0\u00a0\n# function to pradjacency list\u00a0\n# of a graph\u00a0\ndef displayGraph(adj, v):\n\u00a0\u00a0\u00a0\u00a0for i in range(v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(i, \"--> \", end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(adj[i])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(adj[i][j], end = \" \")\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\n# function to get Transpose of a graph\u00a0\n# taking adjacency list of given graph\n# and that of Transpose graph\u00a0\ndef transposeGraph(adj, transpose, v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# traverse the adjacency list of given\u00a0\n\u00a0\u00a0\u00a0\u00a0# graph and for each edge (u, v) add\u00a0\n\u00a0\u00a0\u00a0\u00a0# an edge (v, u) in the transpose graph's\n\u00a0\u00a0\u00a0\u00a0# adjacency list\n\u00a0\u00a0\u00a0\u00a0for i in range(v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(adj[i])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addEdge(transpose, adj[i][j], i)\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0v = 5\n\u00a0\u00a0\u00a0\u00a0adj = [[] for i in range(v)]\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 1)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 4)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 3)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 2, 0)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 3, 2)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 4, 1)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 4, 3)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Finding transpose of graph represented\u00a0\n\u00a0\u00a0\u00a0\u00a0# by adjacency list adj[]\u00a0\n\u00a0\u00a0\u00a0\u00a0transpose = [[]for i in range(v)]\n\u00a0\u00a0\u00a0\u00a0transposeGraph(adj, transpose, v)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# displaying adjacency list of\u00a0\n\u00a0\u00a0\u00a0\u00a0# transpose graph i.e. b\u00a0\n\u00a0\u00a0\u00a0\u00a0displayGraph(transpose, v)\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "The program creates a stack using a single queue and allows the user to perform push and pop operations on it.", "code": "class Stack:\n    def __init__(self):\n        self.q = Queue()\n\u00a0\n    def is_empty(self):\n        return self.q.is_empty()\n\u00a0\n    def push(self, data):\n        self.q.enqueue(data)\n\u00a0\n    def pop(self):\n        for _ in range(self.q.get_size() - 1):\n            dequeued = self.q.dequeue()\n            self.q.enqueue(dequeued)\n        return self.q.dequeue()\n\u00a0\n\u00a0\nclass Queue:\n    def __init__(self):\n        self.items = []\n        self.size = 0\n\u00a0\n    def is_empty(self):\n        return self.items == []\n\u00a0\n    def enqueue(self, data):\n        self.size += 1\n        self.items.append(data)\n\u00a0\n    def dequeue(self):\n        self.size -= 1\n        return self.items.pop(0)\n\u00a0\n    def get_size(self):\n        return self.size\n\u00a0\n\u00a0\ns = Stack()\n\u00a0\nprint('Menu')\nprint('push <value>')\nprint('pop')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'push':\n        s.push(int(do[1]))\n    elif operation == 'pop':\n        if s.is_empty():\n            print('Stack is empty.')\n        else:\n            print('Popped value: ', s.pop())\n    elif operation == 'quit':\n        break"}
{"nl": "You are given two arrays of integers nums1 and nums2, possibly of different lengths. The values in the arrays are between 1 and 6, inclusive.\nIn one operation, you can change any integer's value in any of the arrays to any value between 1 and 6, inclusive.\nReturn the minimum number of operations required to make the sum of values in nums1 equal to the sum of values in nums2. Return -1\u200b\u200b\u200b\u200b\u200b if it is not possible to make the sum of the two arrays equal.\n \nExample 1:\n\nInput: nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]\nOutput: 3\nExplanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.\n- Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2].\n- Change nums1[5] to 1. nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2].\n- Change nums1[2] to 2. nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2].\n\nExample 2:\n\nInput: nums1 = [1,1,1,1,1,1,1], nums2 = [6]\nOutput: -1\nExplanation: There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.\n\nExample 3:\n\nInput: nums1 = [6,6], nums2 = [1]\nOutput: 3\nExplanation: You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. \n- Change nums1[0] to 2. nums1 = [2,6], nums2 = [1].\n- Change nums1[1] to 2. nums1 = [2,2], nums2 = [1].\n- Change nums2[0] to 4. nums1 = [2,2], nums2 = [4].\n\n \nConstraints:\n\n1 <= nums1.length, nums2.length <= 105\n1 <= nums1[i], nums2[i] <= 6", "code": "def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n  if len(nums1) * 6 < len(nums2) or len(nums1) > len(nums2) * 6:\n  return -1\n  sm1, sm2 = map(sum, (nums1, nums2))\n  if sm1 > sm2:\n  return self.minOperations(nums2, nums1)\n  cnt = Counter([6 - n for n in nums1] + [n - 1 for n in nums2])\n  i, operations = 5, 0\n  while sm2 > sm1:\n  while cnt[i] == 0:\n  i -= 1\n  sm1 += i\n  cnt[i] -= 1\n  operations += 1\n  return operations"}
{"nl": "Files in Python:\n\nPython file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python\u2019s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.\n\nGive the N value and file the task is to read the last n lines of the file in Python.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Give the n value static input and store it in a variable.\ngvn_n_val = 2\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent: \n  # Get the lines of the file using the readlines() function\n  lines_lst= givenfilecontent.readlines()\n  print(\"The last\",gvn_n_val,\"lines of a given file are:\")\n  # Iterate in the above lines list using the for loop to get the last\n  # n lines of a file using the negative indexing.\n  for fline in (lines_lst[-gvn_n_val:]):\n  # Print the last n lines of a given file.\n  print(fline, end ='')"}
{"nl": "Given a text file that contains the key-Value pair as data the task is to print the Count of each key-value pair using Python.", "code": "# import the Counter from collections module using the import keyword\nfrom collections import Counter\n# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Take a empty list to store all the words\nl = []\nprint('The Count of frequency of each key-value pair is :')\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  for gvnfileline in givenfilecontent:\n  # Remove the newline character (\\n) using strip() function and store it in a variable.\n  keyval = gvnfileline.strip('\\n')\n  # Inside the For loop append each key-value pair to list using the append() function.\n  l.append(keyval)\n# Get frequency of all the words using the Counter() function and store it in a variable(of type dictionary)\nfreqword = Counter(l)\n# Traverse in the frequency dictionary using the For loop\nfor key in freqword:\n  # print its corresponding key(frequency)\n  print(key, '->', freqword[key])"}
{"nl": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\nGiven n and k, return the kth permutation sequence.\n\n \n\nExample 1:\n\nInput: n = 3, k = 3\nOutput: \"213\"\nExample 2:\n\nInput: n = 4, k = 9\nOutput: \"2314\"\nExample 3:\n\nInput: n = 3, k = 1\nOutput: \"123\"\n \n\nConstraints:\n\n1 <= n <= 9\n1 <= k <= n!", "code": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials, nums = [1], ['1']\n        for i in range(1, n):\n            # generate factorial system bases 0!, 1!, ..., (n - 1)!\n            factorials.append(factorials[i - 1] * i)\n            # generate nums 1, 2, ..., n\n            nums.append(str(i + 1))\n        \n        # fit k in the interval 0 ... (n! - 1)\n        k -= 1\n        \n        # compute factorial representation of k\n        output = []\n        for i in range(n - 1, -1, -1):\n            idx = k // factorials[i]\n            k -= idx * factorials[i]\n            \n            output.append(nums[idx])\n            del nums[idx]\n        \n        return ''.join(output)"}
{"nl": "Given a Sentence, the task is to Reverse each Word in a Given Sentence.", "code": "# Give the string as User input using input() function and store it in a variable.\r\nstrng = input(\" Enter some random String = \")\r\n# Split the words of the given string to a list of words using the built-in split() function and store it in another variable.\r\nsplt_wrds = strng.split()\r\n# Traverse in the above Given List of words using For Loop.\r\n# Inside the Loop, Reverse each word of the list Using Slicing method and\r\n# store it in a variable.\r\nrversd_wrds = [wrd[::-1] for wrd in splt_wrds]\r\n# Join all the reversed words of a given sentence using the built-in join( ) function\r\n# and store it in another variable.\r\nfinl_sentnce = \" \".join(rversd_wrds)\r\n# Print the reversed Sentence of each word of a given String.\r\nprint(\"The Reverse of each word of the above given sentence = \", finl_sentnce)"}
{"nl": "You are given 2 out of 3 angles in a triangle, in degrees.\nWrite a function that classifies the missing angle as either \"acute\", \"right\", or \"obtuse\" based on its degrees.\nAn acute angle is less than 90 degrees.\nA right angle is exactly 90 degrees.\nAn obtuse angle is greater than 90 degrees (but less than 180 degrees).\nFor example: missing_angle(11, 20) should return \"obtuse\", since the missing angle would be 149 degrees, which makes it obtuse.\nExamples\nmissing_angle(27, 59) \u279e \"obtuse\"\n\nmissing_angle(135, 11) \u279e \"acute\"\n\nmissing_angle(45, 45) \u279e \"right\"\nNotes\nThe sum of angles of any triangle is always 180 degrees.", "code": "def missing_angle(angle1, angle2):\n  if (angle1+angle2) < 90: return \"obtuse\"\n  if (angle1+angle2) == 90: return \"right\"\n  if (angle1+angle2) > 90: return \"acute\""}
{"nl": "There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents:\n\npositioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1.\nspeedi is the initial speed of the ith car in meters per second.\n\nFor simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet.\nReturn an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. Answers within 10-5 of the actual answers are accepted.\n \nExample 1:\n\nInput: cars = [[1,2],[2,1],[4,3],[7,2]]\nOutput: [1.00000,-1.00000,3.00000,-1.00000]\nExplanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.\n\nExample 2:\n\nInput: cars = [[3,4],[5,4],[6,3],[9,1]]\nOutput: [2.00000,1.00000,1.50000,-1.00000]\n\n \nConstraints:\n\n1 <= cars.length <= 105\n1 <= positioni, speedi <= 106\npositioni < positioni+1", "code": "def getCollisionTimes(self, A):\n  stack = []\n  n = len(A)\n  res = [-1] * n\n  for i in range(n-1, -1, -1):\n  p, s = A[i]\n  while stack and (s <= A[stack[-1]][1] or (A[stack[-1]][0] - p) / (s - A[stack[-1]][1]) >= res[stack[-1]] > 0):\n  stack.pop()\n  if stack:\n  res[i] = (A[stack[-1]][0] - p) / (s - A[stack[-1]][1])\n  stack.append(i)\n  return res"}
{"nl": "Write a Python Program to Print Square Number Pattern using While Loop and For Loop with an example.", "code": "# Python Program to Print Square Number Pattern\n \nside = int(input(\"Please Enter any Side of a Square  : \"))\n\nprint(\"Square Number Pattern\") \n\nfor i in range(side):\n    for i in range(side):\n        print('1', end = '  ')\n    print()"}
{"nl": "Create a data structure kQueues that represents k queues. Implementation of kQueues should use only one array, i.e., k queues should use the same array for storing elements. Following functions must be supported by kQueues.\n\nenqueue(int x, int qn) \u2013> adds x to queue number \u2018qn\u2019 where qn is from 0 to k-1\u00a0\ndequeue(int qn) \u2013> deletes an element from queue number \u2018qn\u2019 where qn is from 0 to k-1\u00a0\n", "code": "# A Python program to demonstrate implementation of k queues in a single\n# array in time and space efficient way\n\u00a0\nclass KQueues:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, number_of_queues, array_length):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.number_of_queues = number_of_queues\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array_length = array_length\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array = [-1] * array_length\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = [-1] * number_of_queues\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = [-1] * number_of_queues\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array = list(range(1, array_length))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array.append(-1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.free = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To check whether the current queue_number is empty or not\n\u00a0\u00a0\u00a0\u00a0def is_empty(self, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.front[queue_number] == -1 else False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To check whether the current queue_number is full or not\n\u00a0\u00a0\u00a0\u00a0def is_full(self, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.free == -1 else False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To enqueue the given item in the given queue_number where\n\u00a0\u00a0\u00a0\u00a0# queue_number is from 0 to number_of_queues-1\n\u00a0\u00a0\u00a0\u00a0def enqueue(self, item, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.is_full(queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue FULL\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next_free = self.next_array[self.free]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.is_empty(queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front[queue_number] = self.rear[queue_number] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array[self.rear[queue_number]] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear[queue_number] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array[self.free] = -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[self.free] = item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.free = next_free\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To dequeue an item from the given queue_number where\n\u00a0\u00a0\u00a0\u00a0# queue_number is from 0 to number_of_queues-1\n\u00a0\u00a0\u00a0\u00a0def dequeue(self, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.is_empty(queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue EMPTY\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0front_index = self.front[queue_number]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front[queue_number] = self.next_array[front_index]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array[front_index] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.free = front_index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.array[front_index]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0# Let us create 3 queue in an array of size 10\u00a0\n\u00a0\u00a0\u00a0\u00a0ks =\u00a0 KQueues(3, 10)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us put some items in queue number 2\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(15, 2)\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(45, 2)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us put some items in queue number 1\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(17, 1);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(49, 1);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(39, 1);\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us put some items in queue number 0\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(11, 0);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(9, 0);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(7, 0);\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Dequeued element from queue 2 is {}\".format(ks.dequeue(2)))\n\u00a0\u00a0\u00a0\u00a0print(\"Dequeued element from queue 1 is {}\".format(ks.dequeue(1)))\n\u00a0\u00a0\u00a0\u00a0print(\"Dequeued element from queue 0 is {}\".format(ks.dequeue(0)))\n"}
{"nl": "You are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.\nAt each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.\nNotice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).\nReturn the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.\n \nExample 1:\n\nInput: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\nOutput: 4\nExplanation: The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n\nExample 2:\n\nInput: locations = [4,3,1], start = 1, finish = 0, fuel = 6\nOutput: 5\nExplanation: The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n\nExample 3:\n\nInput: locations = [5,2,1], start = 0, finish = 2, fuel = 3\nOutput: 0\nExplanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\n\n \nConstraints:\n\n2 <= locations.length <= 100\n1 <= locations[i] <= 109\nAll integers in locations are distinct.\n0 <= start, finish < locations.length\n1 <= fuel <= 200", "code": "def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n  @lru_cache(None)\n  def dfs(i: int, f: int) -> int:\n  return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n  return dfs(start, fuel) % 1000000007"}
{"nl": "\"Loves me, loves me not\" is a traditional game in which a person plucks off all the petals of a flower one by one, saying the phrase \"Loves me\" and \"Loves me not\" when determining whether the one that they love, loves them back.\nGiven a number of petals, return a string which repeats the phrases \"Loves me\" and \"Loves me not\" for every alternating petal, and return the last phrase in all caps. Remember to put a comma and space between phrases.\nExamples\nloves_me(3) \u279e \"Loves me, Loves me not, LOVES ME\"\n\nloves_me(6) \u279e \"Loves me, Loves me not, Loves me, Loves me not, Loves me, LOVES ME NOT\"\n\nloves_me(1) \u279e \"LOVES ME\"\nNotes\nRemember to return a string.\nThe first phrase is always \"Loves me\".", "code": "def loves_me(n):\n    arr = (['Loves me', 'Loves me not']*n)[:n]\n    arr[-1] = arr[-1].upper()\n    return ', '.join(arr)"}
{"nl": "Arrays\r\nArrays are used to store multiple values in one single variable:", "code": "cars = [\"Ford\", \"Volvo\", \"BMW\"]"}
{"nl": "Given a square matrix, find if it\u2019s a Toeplitz matrix or not. A Toeplitz (or diagonal-constant) matrix is a matrix in which each descending diagonal from left to right is constant, i.e., all elements in a diagonal are same.\n\nIn general, any n\u00d7n matrix mat[][] is a Toeplitz matrix if every cell mat[i][j] is same as mat[i-1][j-1], mat[i+1][j+1], mat[i-2][j-2], mat[i+2][j+2], .. for every cell mat[i][j] and all the valid cells mat[i+k][j+k] or mat[i-k][j-k] \n\nExamples : \n\nInput: mat[N][N] = {{ 6, 7, 8},\n                    { 4, 6, 7},\n                    { 1, 4, 6}},\nOutput : True;\nValues in all diagonals are same.\n\nInput: mat[N][N] = {{ 6, 7, 8, 9 },\n                    { 4, 6, 7, 8 },\n                    { 1, 4, 6, 7 },\n                    { 0, 1, 4, 6 },\n                    { 2, 0, 1, 4 }};\nOutput : True;\n\nInput: mat[N][N] = {{ 6, 3, 8},\n                    { 4, 9, 7},\n                    { 1, 4, 6}},\nOutput : False;", "code": "# Python3 program to check whether given\n# matrix is a Toeplitz matrix or not\nN = 5\nM = 4\n\u00a0\n# Function to check if all elements present in\n# descending diagonal starting from position\n# (i, j) in the matrix are all same or not\n\u00a0\n\u00a0\ndef checkDiagonal(mat, i, j):\n\u00a0\u00a0\u00a0\u00a0res = mat[i][j]\n\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while (i < N and j < M):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mismatch found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] != res):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# we only reach here when all elements\n\u00a0\u00a0\u00a0\u00a0# in given diagonal are same\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n# Function to check whether given\n# matrix is a Toeplitz matrix or not\n\u00a0\n\u00a0\ndef isToeplitz(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# do for each element in first row\n\u00a0\u00a0\u00a0\u00a0for j in range(M):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check descending diagonal starting from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# position (0, j) in the matrix\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not(checkDiagonal(mat, 0, j)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# do for each element in first column\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check descending diagonal starting\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# from position (i, 0) in the matrix\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not(checkDiagonal(mat, i, 0)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[6, 7, 8, 9],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 6, 7, 8],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 4, 6, 7],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 4, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 0, 1, 4]]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call\n\u00a0\u00a0\u00a0\u00a0if(isToeplitz(mat)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Matrix is a Toeplitz\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Matrix is not a Toeplitz\")\n\u00a0\n# This code is contributed by Jasmine K Grewal\n"}
{"nl": "Instructions\r\nGiven a number from 0 to 999,999,999,999, spell out that number in English.\r\n\r\nStep 1\r\nHandle the basic case of 0 through 99.\r\n\r\nIf the input to the program is 22, then the output should be 'twenty-two'.\r\n\r\nYour program should complain loudly if given a number outside the blessed range.\r\n\r\nSome good test cases for this program are:\r\n\r\n0\r\n14\r\n50\r\n98\r\n-1\r\n100\r\nExtension\r\nIf you're on a Mac, shell out to Mac OS X's say program to talk out loud. If you're on Linux or Windows, eSpeakNG may be available with the command espeak.\r\n\r\nStep 2\r\nImplement breaking a number up into chunks of thousands.\r\n\r\nSo 1234567890 should yield a list like 1, 234, 567, and 890, while the far simpler 1000 should yield just 1 and 0.\r\n\r\nThe program must also report any values that are out of range.\r\n\r\nStep 3\r\nNow handle inserting the appropriate scale word between those chunks.\r\n\r\nSo 1234567890 should yield '1 billion 234 million 567 thousand 890'\r\n\r\nThe program must also report any values that are out of range. It's fine to stop at \"trillion\".\r\n\r\nStep 4\r\nPut it all together to get nothing but plain English.\r\n\r\n12345 should give twelve thousand three hundred forty-five.\r\n\r\nThe program must also report any values that are out of range.\r\n\r\nExtensions\r\nUse and (correctly) when spelling out the number in English:\r\n\r\n14 becomes \"fourteen\".\r\n100 becomes \"one hundred\".\r\n120 becomes \"one hundred and twenty\".\r\n1002 becomes \"one thousand and two\".\r\n1323 becomes \"one thousand three hundred and twenty-three\".\r\nException messages\r\nSometimes it is necessary to raise an exception. When you do this, you should always include a meaningful error message to indicate what the source of the error is. This makes your code more readable and helps significantly with debugging. For situations where you know that the error source will be a certain type, you can choose to raise one of the built in error types, but should still include a meaningful message.\r\n\r\nThis particular exercise requires that you use the raise statement to \"throw\" a ValueError if the number input to say() is out of range. The tests will only pass if you both raise the exception and include a message with it.\r\n\r\nTo raise a ValueError with a message, write the message as an argument to the exception type:\r\n\r\n# if the number is negative\r\nraise ValueError(\"input out of range\")\r\n\r\n# if the number is larger than 999,999,999,99\r\nraise ValueError(\"input out of range\")", "code": "_say = lambda x: say(x)\r\nones = lambda x: 'zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen nineteen'.split()[x]\r\ntens = lambda x: 'zero ten twenty thirty forty fifty sixty seventy eighty ninety'.split()[x]\r\ndone = lambda f, q, r, t, h: f(q) + t\r\nnope = lambda f, q, r, t, h: f(q) + t + h + say(r)\r\ndef say(n):\r\n    if not (0 <= n < 1e12): \r\n        raise ValueError(\"input out of range\")    \r\n    condition, d, func, txt, hyphen = list(filter(lambda x: x[0],\r\n        [( n <  20,           1, ones, '',           ''),\r\n         ( n < 1e2,          10, tens, '',          '-'),\r\n         ( n < 1e3,         100, ones, ' hundred',  ' '),\r\n         ( n < 1e6,        1000, _say, ' thousand', ' '),\r\n         ( n < 1e9,     1000000, _say, ' million',  ' '),\r\n         ( n < 1e12, 1000000000, _say, ' billion',  ' ')]))[0]\r\n    q, r = divmod(n, d)                                     \r\n    return {0: done}.get(r, nope)(func, q, r, txt, hyphen)"}
{"nl": "A magic square of order n is an arrangement of n2 numbers, usually distinct integers, in a square, such that the n numbers in all rows, all columns, and both diagonals sum to the same constant. A magic square contains the integers from 1 to n2. \nThe constant sum in every row, column and diagonal are called the magic constant or magic sum, M. The magic constant of a normal magic square depends only on n and has the following value: \nM = n(n2+1)/2\n\nFor normal magic squares of order n = 3, 4, 5, ...,\nthe magic constants are: 15, 34, 65, 111, 175, 260, ... ", "code": "# Python program to generate\n# odd sized magic squares\n# A function to generate odd\n# sized magic squares\n\u00a0\n\u00a0\ndef generateSquare(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2-D array with all\n\u00a0\u00a0\u00a0\u00a0# slots set to 0\n\u00a0\u00a0\u00a0\u00a0magicSquare = [[0 for x in range(n)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for y in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# initialize position of 1\n\u00a0\u00a0\u00a0\u00a0i = n // 2\n\u00a0\u00a0\u00a0\u00a0j = n - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Fill the magic square\n\u00a0\u00a0\u00a0\u00a0# by placing values\n\u00a0\u00a0\u00a0\u00a0num = 1\n\u00a0\u00a0\u00a0\u00a0while num <= (n * n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == -1 and j == n:\u00a0 # 3rd condition\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = n - 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next number goes out of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# right side of square\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == n:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next number goes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# out of upper side\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i < 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = n - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if magicSquare[int(i)][int(j)]:\u00a0 # 2nd condition\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = j - 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0magicSquare[int(i)][int(j)] = num\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0num = num + 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = j + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i - 1\u00a0 # 1st condition\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Printing magic square\n\u00a0\u00a0\u00a0\u00a0print(\"Magic Square for n =\", n)\n\u00a0\u00a0\u00a0\u00a0print(\"Sum of each row or column\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n * (n * n + 1) // 2, \"\\n\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print('%2d ' % (magicSquare[i][j]),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end='')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# To display output\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in matrix form\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == n - 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\n\u00a0\n\u00a0\n# Works only when n is odd\nn = 7\ngenerateSquare(n)\n\u00a0\n# This code is contributed\n# by Harshit Agrawal\n"}
{"nl": "Exercise 1: Reverse the tuple", "code": "tuple1 = (10, 20, 30, 40, 50)\r\ntuple1 = tuple1[::-1]\r\nprint(tuple1)\r"}
{"nl": "Write the regular expression that will match a string if there are no spaces right before the last ending punctuation ?. Use the character class \\S in your expression.\nExample\ntxt1 = \"Can read a spray chart and a balance sheet. 1 part Executive, 1 part entrepreneur, 2 parts geek and 3 parts baseball coach. Too many parts?\"\ntxt2 = \"Can read a spray chart and a balance sheet. 1 part Executive, 1 part entrepreneur, 2 parts geek and 3 parts baseball coach. Too many parts ?\"\npattern = \"yourregularexpressionhere\"\n\nbool(re.search(pattern, txt1)) \u279e True\nbool(re.search(pattern, txt2)) \u279e False\nNotes\nMark Gallion's Twitter bio is used for educational purposes only.\nTo search for the character ? in RegEx, the pattern must include \\?.\nYou don't need to write a function, just the pattern.\nDo not remove import re from the code.\nFind more info on RegEx and character classes in Resources.\nYou can find all the challenges of this series in my Basic RegEx collection.", "code": "import re\npattern = '\\S\\?$'"}
{"nl": "Files in Python:\n\nPython file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python\u2019s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.\n\nFiles are identified locations on a disc where associated data is stored. They are used to retain data in non-volatile memory permanently (e.g. hard disk).\n\n\n\nBecause Random Access Memory (RAM) is volatile (it loses data when the computer is shut off), we employ files to store data for future use by permanently storing it.\n\nWhen we wish to read or write to a file, we must first open it. When we\u2019re finished, it needs to be closed so that the resources associated with the file may be released.\n\nAs a result, in Python, a file operation occurs in the following order:\n\nOpen a file\nReading or writing (performing operation)\nclose the file.\n\n  Mode  Description\n  r  Allows you to read a file. (default)\n  w Allows you to write to a file. If the file does not exist, it is created; otherwise, it is truncated.\n  x Allows you to open a file for exclusive creation. The operation fails if the file already exists.\n  a Opens a file for adding/appending at the end without truncating it. If the file does not exist, it is created.\n  t opens in text mode. (default)\n  b Opens in binary mode.\n  + Opens a file for modification or updating (reading and writing)\n\nFile mode Property in Python:\n\nmode Property is a built-in property of the File object (IO object) in Python that is used to retrieve the file\u2019s mode (write(w), read(r), append(a), etc.) from the file object.\n\nSyntax:\n\nfileobject.mode\nParameters: This method doesn\u2019t accept any parameters.\n\nReturn Value: \n\nThis method\u2019s return type is <class\u2019str\u2019>, and it returns the file mode.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\nsamplefile_1 = open(\"givenFilename\", \"w\")\n# Open the file in read mode. In this case, we're simply reading the contents of the file.\nsamplefile_2 = open(\"givenFilename\", \"r\")\n# Open the file in write-binary mode. In this case, we're simply writing the contents in binary mode into the file.\nsamplefile_3 = open(\"givenFilename\", \"wb\")\n# Print the mode of above file samplefile_1 using the mode property\nprint(\"The mode of samplefile_1:\", samplefile_1.mode)\n# Print the mode of above file samplefile_2 using the mode property\nprint(\"The mode of samplefile_2:\", samplefile_2.mode)\n# Print the mode of above file samplefile_3 using the mode property\nprint(\"The mode of samplefile_3:\", samplefile_3.mode)\n# Close the above file samplefile_1 using the close() function\nsamplefile_1.close()\n# Close the above file samplefile_2 using the close() function\nsamplefile_2.close()\n# Close the above file samplefile_3 using the close() function\nsamplefile_3.close()"}
{"nl": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\nImplement the AuthenticationManager class:\n\nAuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\ngenerate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\nrenew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\ncountUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n\nNote that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.\n \nExample 1:\n\n\nInput\n[\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\nOutput\n[null, null, null, 1, null, null, null, 0]\n\nExplanation\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.\nauthenticationManager.renew(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens.\nauthenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2.\nauthenticationManager.countUnexpiredTokens(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1.\nauthenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7.\nauthenticationManager.renew(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.\nauthenticationManager.renew(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.\nauthenticationManager.countUnexpiredTokens(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0.\n\n \nConstraints:\n\n1 <= timeToLive <= 108\n1 <= currentTime <= 108\n1 <= tokenId.length <= 5\ntokenId consists only of lowercase letters.\nAll calls to generate will contain unique values of tokenId.\nThe values of currentTime across all the function calls will be strictly increasing.\nAt most 2000 calls will be made to all functions combined.", "code": "def __init__(self, timeToLive: int):\n  self.expiry = OrderedDict()\n  self.life = timeToLive\n\n  def generate(self, tokenId: str, currentTime: int) -> None:\n self.evict_expired(currentTime)\n  self.expiry[tokenId] = self.life + currentTime\n\n  def renew(self, tokenId: str, currentTime: int) -> None:\n self.evict_expired(currentTime)\n  if tokenId in self.expiry:\n self.expiry.move_to_end(tokenId) # necessary to move to the end to keep expiry time in ascending order.\n  self.expiry[tokenId] = self.life + currentTime\n\n  def countUnexpiredTokens(self, currentTime: int) -> int:\n self.evict_expired(currentTime)\n  return len(self.expiry)  \n  \n  def evict_expired(self, currentTime: int) -> None:\n  while self.expiry and next(iter(self.expiry.values())) <= currentTime:\n self.expiry.popitem(last=False)"}
{"nl": "Given a binary matrix, print all unique rows of the given matrix. \n\nThis method uses HashSet data structure to solve the above problem. The HashSet class implements the Set interface, backed by a hash table which is actually a HashMap instance. No guarantee is made as to the iteration order of the set which means that the class does not guarantee the constant order of elements over time. This class permits the null element. The class offers constant time performance for the basic operations like add, remove, contains and size assuming the hash function disperses the elements properly among the buckets. ", "code": "# Python3 code to print unique row in a\n# given binary matrix\n \ndef printArray(matrix):\n \n    rowCount = len(matrix)\n    if rowCount == 0:\n        return\n \n    columnCount = len(matrix[0])\n    if columnCount == 0:\n        return\n \n    row_output_format = \" \".join([\"%s\"] * columnCount)\n \n    printed = {}\n \n    for row in matrix:\n        routput = row_output_format % tuple(row)\n        if routput not in printed:\n            printed[routput] = True\n            print(routput)\n \n# Driver Code\nmat = [[0, 1, 0, 0, 1],\n       [1, 0, 1, 1, 0],\n       [0, 1, 0, 0, 1],\n       [1, 1, 1, 0, 0]]\n \nprintArray(mat)\n \n# This code is contributed by myronwalker"}
{"nl": "Given a binary tree with a value associated with each node, we need to choose a subset of these nodes such that the sum of chosen nodes is maximum under a constraint that no two chosen nodes in the subset should be directly connected that is, if we have taken a node in our sum then we can\u2019t take any of its children in consideration and vice versa. ", "code": "# Python3 program to find\n# maximum sum from a subset\n# of nodes of binary tree\n\n# A binary tree node structure\nclass Node:\n\t\n\tdef __init__(self, data):\n\t\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Utility function to create\n# a new Binary Tree node\ndef newNode(data):\n\n\ttemp = Node(data)\n\treturn temp;\n\n# method returns maximum sum\n# possible from subtrees rooted\n# at grandChildrens of node 'node'\ndef sumOfGrandChildren(node, mp):\n\n\tsum = 0;\n\n\t# call for children of left\n\t# child only if it is not NULL\n\tif (node.left):\n\t\tsum += (getMaxSumUtil(node.left.left, mp) +\n\t\t\t\tgetMaxSumUtil(node.left.right, mp));\n\n\t# call for children of right\n\t# child only if it is not NULL\n\tif (node.right):\n\t\tsum += (getMaxSumUtil(node.right.left, mp) +\n\t\t\t\tgetMaxSumUtil(node.right.right, mp));\n\n\treturn sum;\n\n# Utility method to return\n# maximum sum rooted at node\n# 'node'\ndef getMaxSumUtil(node, mp):\n\n\tif (node == None):\n\t\treturn 0;\n\n\t# If node is already processed\n\t# then return calculated\n\t# value from map\n\tif node in mp:\n\t\treturn mp[node];\n\n\t# take current node value\n\t# and call for all grand children\n\tincl = (node.data +\n\t\t\tsumOfGrandChildren(node, mp));\n\n\t# don't take current node\n\t# value and call for all children\n\texcl = (getMaxSumUtil(node.left, mp) +\n\t\t\tgetMaxSumUtil(node.right, mp));\n\n\t# choose maximum from both\n\t# above calls and store that\n\t# in map\n\tmp[node] = max(incl, excl);\n\n\treturn mp[node];\n\n# Returns maximum sum from\n# subset of nodes of binary\n# tree under given constraints\ndef getMaxSum(node):\n\n\tif (node == None):\n\t\treturn 0;\n\t\n\tmp = dict()\n\treturn getMaxSumUtil(node, mp);\n\n# Driver code\nif __name__==\"__main__\":\n\t\n\troot = newNode(1);\n\troot.left = newNode(2);\n\troot.right = newNode(3);\n\troot.right.left = newNode(4);\n\troot.right.right = newNode(5);\n\troot.left.left = newNode(1);\n\t\n\tprint(getMaxSum(root))\n\t\n# This code is contributed by Rutvik_56\n"}
{"nl": "Create a function that takes time1 and time2 and return how many hours have passed between the two times.\nExamples\nhours_passed(\"3:00 AM\", \"9:00 AM\") \u279e \"6 hours\"\n\nhours_passed(\"2:00 PM\", \"4:00 PM\") \u279e \"2 hours\"\n\nhours_passed(\"1:00 AM\", \"3:00 PM\") \u279e \"14 hours\"\nNotes\ntime1 will always be the starting time and time2 the ending time. Return \"no time passed\" if time1 is equal to time2.", "code": "from datetime import datetime as dt\ndef hours_passed(time1, time2):\n    delta = (dt.strptime(time2, \"%I:%M %p\") -\n             dt.strptime(time1, \"%I:%M %p\")).seconds // 3600\n    return '{} hours'.format(delta) if delta else 'no time passed'"}
{"nl": "The not keyword is a logical operator.\r\n\r\nThe return value will be True if the statement(s) are not True, otherwise it will return False.", "code": "x = False\r\n\r\nprint(not x)"}
{"nl": "Variables in Module\r\nThe module can contain functions, as already described, but also variables of all types (arrays, dictionaries, objects etc):", "code": "#Save this code in the file mymodule.py\r\n\r\nperson1 = {\r\n  \"name\": \"John\",\r\n  \"age\": 36,\r\n  \"country\": \"Norway\"\r\n}\r\n#Example\r\n#Import the module named mymodule, and access the person1 dictionary:\r\n\r\nimport mymodule\r\n\r\na = mymodule.person1[\"age\"]\r\nprint(a)"}
{"nl": "Boolean Values\r\nIn programming you often need to know if an expression is True or False.\r\n\r\nYou can evaluate any expression in Python, and get one of two answers, True or False.\r\n\r\nWhen you compare two values, the expression is evaluated and Python returns the Boolean answer:", "code": "print(10 > 9)\r\nprint(10 == 9)\r\nprint(10 < 9)"}
{"nl": "Fibonacci search is a divide and conquer technique that is comparable to both binary search and jump search. It derives its name from the fact that it calculates the block size or search range in each step using Fibonacci numbers.\r\n\r\nIt is applicable to sorted arrays.\r\nAn Algorithm of Divide and Conquer.\r\nHas a Time complexity of Log n.", "code": "# function which implements the fibonacci search\r\ndef fib_search(givenlist, givenelement):\r\n    # ffinding the length of given list\r\n    length = len(givenlist)\r\n\r\n    first = -1\r\n\r\n    x0 = 0\r\n    x1 = 1\r\n    x2 = 1\r\n    while(x2 < length):\r\n        x0 = x1\r\n        x1 = x2\r\n        x2 = x1 + x0\r\n\r\n    while(x2 > 1):\r\n        eleIndex = min(first + x0, length - 1)\r\n        if givenlist[eleIndex] < givenelement:\r\n            x2, x1 = x1, x0\r\n            x0 = x2 - x1\r\n            start = eleIndex\r\n        elif givenlist[eleIndex] > givenelement:\r\n            x2 = x0\r\n            x1 = x1 - x0\r\n            x0 = x2 - x1\r\n        else:\r\n            return eleIndex\r\n    if (x1) and (givenlist[length - 1] == givenelement):\r\n        return length - 1\r\n    return None\r\n\r\n\r\n# given list\r\ngiven_list = [1, 9, 4, 7, 2, 8, 6]\r\n# sorting the given list\r\ngiven_list.sort()\r\n# given element to search\r\ngiven_element = 4\r\n# passing given list and given element to fibonacci search function to check whether\r\n# the given element is present in list or not\r\nprint(fib_search(given_list, given_element))"}
{"nl": "An ultrarelativistic particle is one whose speed v is very close to the speed of light c (or equivalently, one whose \u03b2 = v/c is very close to 1). But a number like 0.9999999999999999999 is inconvenient to work with: calculators round it to 1, and trying to write it in scientific notation does the same (because any 9 you stop at gets rounded up by the following 9). It's better to work with the quantity (1 - \u03b2) instead.\nFortunately, we don't need to deal directly with \u03b2 to calculate an ultrarelativistic particle's (1 - \u03b2). There are some other wieldier quantities that we can use to approximate (1 - \u03b2) with great precision. One of them is the particle's rapidity \u03c6, which is related to \u03b2 by the equation:\ntanh \u03c6 = \u03b2\n(where tanh is the hyperbolic tangent function).\nFor an ultrarelativistic particle, the rapidity lets us approximate (1 - \u03b2) like this:\n1 - \u03b2 \u2248 sech(2\u03c6)\n(where sech is the hyperbolic secant).\nWrite a function that takes an ultrarelativistic particle's rapidity (a number) and uses the approximation formula given above to return the particle's (1 - \u03b2) to three significant figures. The output should be a string in scientific notation, formatted like \"6.63e-34\".\nExamples\nhow_close_to_c(3.14) \u279e \"3.75e-3\"\n\nhow_close_to_c(42) \u279e \"6.61e-37\"\n\nhow_close_to_c(355) \u279e \"8.95e-309\"\nNotes\nN/A", "code": "import math\ndef how_close_to_c(rap):\n  return '{:.2e}'.format(1/math.cosh(2*rap)).replace('-0','-')"}
{"nl": "In this program. you'll learn to check whether a string is palindrome or Not", "code": "# Program to check if a string is palindrome or not\n\nmy_str = 'aIbohPhoBiA'\n\n# make it suitable for caseless comparison\nmy_str = my_str.casefold()\n\n# reverse the string\nrev_str = reversed(my_str)\n\n# check if the string is equal to its reverse\nif list(my_str) == list(rev_str):\n   print(\"The string is a palindrome.\")\nelse:\n   print(\"The string is not a palindrome.\")"}
{"nl": "The program creates a tree and finds the sum of all nodes in the tree.", "code": "class Tree:\n    def __init__(self, data=None):\n        self.key = data\n        self.children = []\n\u00a0\n    def set_root(self, data):\n        self.key = data\n\u00a0\n    def add(self, node):\n        self.children.append(node)\n\u00a0\n    def search(self, key):\n        if self.key == key:\n            return self\n        for child in self.children:\n            temp = child.search(key)\n            if temp is not None:\n                return temp\n        return None\n\u00a0\n    def sum_nodes(self):\n        summation = self.key\n        for child in self.children:\n            summation = summation + child.sum_nodes()\n        return summation\n\u00a0\n\u00a0\ntree = None\n\u00a0\nprint('Menu (this assumes no duplicate keys)')\nprint('add <data> at root')\nprint('add <data> below <data>')\nprint('sum')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'add':\n        data = int(do[1])\n        new_node = Tree(data)\n        suboperation = do[2].strip().lower() \n        if suboperation == 'at':\n            tree = new_node\n        elif suboperation == 'below':\n            position = do[3].strip().lower()\n            key = int(position)\n            ref_node = None\n            if tree is not None:\n                ref_node = tree.search(key)\n            if ref_node is None:\n                print('No such key.')\n                continue\n            ref_node.add(new_node)\n\u00a0\n    elif operation == 'sum':\n        if tree is None:\n            print('Tree is empty.')\n        else:\n            summation = tree.sum_nodes()\n            print('Sum of all nodes: {}'.format(summation))\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Given array representation of min Heap, convert it to max Heap in O(n) time. \nExample : \n \n\nInput: arr[] = [3 5 9 6 8 20 10 12 18 9]\n         3\n      /     \\\n     5       9\n   /   \\    /  \\\n  6     8  20   10\n /  \\   /\n12   18 9 \n\n\nOutput: arr[] = [20 18 10 12 9 9 3 5 6 8] OR \n       [any Max Heap formed from input elements]\n\n         20\n       /    \\\n     18      10\n   /    \\    /  \\\n  12     9  9    3\n /  \\   /\n5    6 8 ", "code": "# A Python3 program to convert min Heap\n# to max Heap\n\n# to heapify a subtree with root\n# at given index\ndef MaxHeapify(arr, i, n):\n\tl = 2 * i + 1\n\tr = 2 * i + 2\n\tlargest = i\n\tif l < n and arr[l] > arr[i]:\n\t\tlargest = l\n\tif r < n and arr[r] > arr[largest]:\n\t\tlargest = r\n\tif largest != i:\n\t\tarr[i], arr[largest] = arr[largest], arr[i]\n\t\tMaxHeapify(arr, largest, n)\n\n# This function basically builds max heap\ndef convertMaxHeap(arr, n):\n\t\n\t# Start from bottommost and rightmost\n\t# internal mode and heapify all\n\t# internal modes in bottom up way\n\tfor i in range(int((n - 2) / 2), -1, -1):\n\t\tMaxHeapify(arr, i, n)\n\n# A utility function to print a\n# given array of given size\ndef printArray(arr, size):\n\tfor i in range(size):\n\t\tprint(arr[i], end = \" \")\n\tprint()\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# array representing Min Heap\n\tarr = [3, 5, 9, 6, 8, 20, 10, 12, 18, 9]\n\tn = len(arr)\n\n\tprint(\"Min Heap array : \")\n\tprintArray(arr, n)\n\n\tconvertMaxHeap(arr, n)\n\n\tprint(\"Max Heap array : \")\n\tprintArray(arr, n)\n\n# This code is contributed by PranchalK"}
{"nl": "WordNet is a large lexical database of English. Nouns, verbs, adjectives and adverbs are grouped into sets of cognitive synonyms (synsets), each expressing a distinct concept. Synsets are interlinked by means of conceptual-semantic and lexical relations.\r\nWordNet\u2019s structure makes it a useful tool for computational linguistics and natural language processing.\r\n\r\nWordNet superficially resembles a thesaurus, in that it groups words together based on their meanings. However, there are some important distinctions.", "code": "\r\n# First, you're going to need to import wordnet:\r\nfrom nltk.corpus import wordnet\r\n  \r\n# Then, we're going to use the term \"program\" to find synsets like so:\r\nsyns = wordnet.synsets(\"program\")\r\n  \r\n# An example of a synset:\r\nprint(syns[0].name())\r\n  \r\n# Just the word:\r\nprint(syns[0].lemmas()[0].name())\r\n  \r\n# Definition of that first synset:\r\nprint(syns[0].definition())\r\n  \r\n# Examples of the word in use in sentences:\r\nprint(syns[0].examples())"}
{"nl": "Here, we will develop a Python program to get the last character of a string. If the string was \u201cKnowprogram\u201d then print the last character \u201cm\u201d. We will discuss how to get the last character from the given string using [] operator, and slice operator. Also, we will develop a Python program to get the last two characters of a string.", "code": "# Python Program get last character of string # take input string = input('Enter any string: ') # get last character last_char = string[-1] # printing last character of string print('Last character:', last_char)"}
{"nl": "The list is a container that stores multiple items, it can also store elements of different data types like it can have strings and numbers and also objects in a single list. The elements in the list that are indexed usually start from 0. There is no function required to create a list just create and variable and enter the elements inside the square brackets \u201c[ ]\u201d, it contains mutable elements.", "code": "list = [1, 2, 3, 4, 5] print(list)"}
{"nl": "Wondering how to find if two numbers given are Amicable or Not? Then, you have come the right way as we will explain what are Amicable Numbers and Python Program to Check if Two Numbers are Amicable Numbers or not. Refer to the Various Methods for Checking if given Numbers are Amicable or Not and use the method you are comfortable with.", "code": "# python program to cheeck whether the given number is Amicable numbers or not\n # function which returns true if the given number is\n # Amicable numbers else it will return False\n def checkAmicableNumb(given_numb1, given_numb2):\n  # Taking a variable totalSum1 and initializing it with 1\n  totalSum1 = 1\n  # Iterating from 2 to n-1\n  for i in range(2, given_numb1):\n  # if the iterator value is divides the number then add the given\n  # number to totalSum1\n  if given_numb1 % i == 0:\n  totalSum1 += i\n  # repeating the same step for number 2\n  # Taking a variable totalSum2 and initializing it with 1\n  totalSum2 = 1\n  # Iterating from 2 to n-1\n  for i in range(2, given_numb2):\n  # if the iterator value is divides the number then add the given\n  # number to totalSum2\n  if given_numb2 % i == 0:\n  totalSum2 += i\n  # if the totalSum1 is equal to the given number2 and\n  # totalSum2 is equal to the given number1 then both the numbers are amicable numbers\n  # else they are not amicable numbers\n  if(totalSum1 == given_numb2 and totalSum2 == given_numb1):\n  # if it is true then they are amicable numbers so return true\n  return True\n  # if nothing is returned then they are not a amicable numbers so return False\n  return False\n # Given two numbers\n # given number1(numb1)\n given_numb1 = 220\n # given number2(numb2)\n given_numb2 = 284\n # passing the given two numbers to checkAmicableNumb to check whether it is\n # Amicable numbers or not\n if(checkAmicableNumb(given_numb1, given_numb2)):\n  print(\"The given numbers\", given_numb1, \"and\",\n  given_numb2, \"are amicable numbers\")\n else:\n  print(\"The given numbers\", given_numb1, \"and\",\n  given_numb2, \"are not amicable numbers\")"}
{"nl": "For this challenge, forget how to add two numbers together. The best explanation on what to do for this function is this meme:\nExamples\nmeme_sum(26, 39) \u279e 515\n# 2+3 = 5, 6+9 = 15\n# 26 + 39 = 515\n\nmeme_sum(122, 81) \u279e 1103\n# 1+0 = 1, 2+8 = 10, 2+1 = 3\n# 122 + 81 = 1103\n\nmeme_sum(1222, 30277) \u279e 31499\nNotes\nN/A", "code": "def meme_sum(a, b):\n  a, b = sorted([str(a), str(b)], key=len)\n    res = ''\n  for i, j in zip(a.zfill(len(b)), b):\n    res += str(int(i) + int(j))\n  return int(res)"}
{"nl": "The program sorts a list by bubble sort.", "code": "def bubble_sort(alist):\n    for i in range(len(alist) - 1, 0, -1):\n        no_swap = True\n        for j in range(0, i):\n            if alist[j + 1] < alist[j]:\n                alist[j], alist[j + 1] = alist[j + 1], alist[j]\n                no_swap = False\n        if no_swap:\n            return\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\nbubble_sort(alist)\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "A fulcrum of a list is an integer such that all elements to the left of it and all elements to the right of it sum to the same value. Write a function that finds the fulcrum of a list.\nTo illustrate:\nfind_fulcrum([3, 1, 5, 2, 4, 6, -1]) \u279e 2\n// Since [3, 1, 5] and [4, 6, -1] both sum to 9\nExamples\nfind_fulcrum([1, 2, 4, 9, 10, -10, -9, 3]) \u279e 4\n\nfind_fulcrum([9, 1, 9]) \u279e 1\n\nfind_fulcrum([7, -1, 0, -1, 1, 1, 2, 3]) \u279e 0\n\nfind_fulcrum([8, 8, 8, 8]) \u279e -1\nNotes\nIf the fulcrum does not exist, return -1 (see example #4).\nExclude the leftmost and rightmost elements when computing the fulcrum (it doesn't make sense to sum zero values).\nIf a list has multiple fulcrums, return the one that occurs first.", "code": "def find_fulcrum(lst):\n  for idx, i in enumerate(lst):\n    if sum(lst[:idx]) == sum(lst[idx+1:]):\n      return i\n  return -1"}
{"nl": "In the previous article, we have discussed Python Program for Sign Change\n Recursion:\n Recursion is the process by which a function calls itself directly or indirectly, and the associated function is known as a recursive function. Certain issues can be addressed fairly easily using a recursive approach. Towers of Hanoi (TOH), Inorder /Preorder/Postorder Tree Traversals, DFS of Graph, and other analogous issues are examples.\n Binary Code:\n As previously stated, Binary Code is a Base-2 representation of a number. In Binary, all numbers are represented by simply two symbols: 0 and 1. Binary (also known as base-2) is a numerical system with only two digits: 0 and 1.\n Given a binary string, the task is to convert the given binary string to a decimal number using recursion in Python.\n Examples:\n Example1:\n Input:\n Given binary number = 1011\n Output:\n The decimal Equivalent of the given binary number { 1011 } is : 11\n Example2:\n Input:\n Given binary number = 10010101\n Output:\n The decimal Equivalent of the given binary number { 10010101 } is : 149", "code": "# Create a recursive function to say binaryToDeci()\n \n # which accepts the binary number as an argument\n \n # and returns the decimal equivalent of the given binary string.\n \n \n \n \n \n def binaryToDeci(binanumb):\n \n  # Inside the binaryToDeci() function,\n \n  # Check if the binary number is equal to 0 using the if conditional statement.\n \n  if(binanumb == 0):\n \n  # If it is true then return 0.\n \n  return 0\n \n  # Else return (n% 10 + 2* binaryToDeci(n // 10))\n \n  # {Recursive logic where n%10 gives rightmostbit and n//10 divides the number by 10}.\n \n  return (binanumb % 10 + 2 * binaryToDeci(binanumb // 10))\n \n \n \n \n \n # Give the binary number as static input and store it in a variable.\n \n gvnbinarynumb = 1011\n \n # Inside the main function pass the given binary number as an argument\n \n # to binaryToDeci() which returns the decimal equivalent of the given binary number.\n \n resdecimalnumbr = binaryToDeci(gvnbinarynumb)\n \n # Print the decimal equivalent of the given binary number.\n \n print(\n \n  'The decimal Equivalent of the given binary number {', gvnbinarynumb, '} is :', resdecimalnumbr)"}
{"nl": "Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL). The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be the same as in Inorder for the given Binary Tree. The first node of Inorder traversal (leftmost node in BT) must be the head node of the DLL.  ", "code": "# A simple inorder traversal based program to convert a\n# Binary Tree to DLL\n\n# A Binary Tree node\nclass Node:\n\t\n\t# Constructor to create a new tree node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Standard Inorder traversal of tree\ndef inorder(root):\n\t\n\tif root is not None:\n\t\tinorder(root.left)\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\tinorder(root.right)\n\n# Changes left pointers to work as previous pointers\n# in converted DLL\n# The function simply does inorder traversal of\n# Binary Tree and updates\n# left pointer using previously visited node\ndef fixPrevPtr(root):\n\tif root is not None:\n\t\tfixPrevPtr(root.left)\n\t\troot.left = fixPrevPtr.pre\n\t\tfixPrevPtr.pre = root\n\t\tfixPrevPtr(root.right)\n\n# Changes right pointers to work as next pointers in\n# converted DLL\ndef fixNextPtr(root):\n\n\tprev = None\n\t# Find the right most node in BT or last node in DLL\n\twhile(root and root.right != None):\n\t\troot = root.right\n\n\t# Start from the rightmost node, traverse back using\n\t# left pointers\n\t# While traversing, change right pointer of nodes\n\twhile(root and root.left != None):\n\t\tprev = root\n\t\troot = root.left\n\t\troot.right = prev\n\n\t# The leftmost node is head of linked list, return it\n\treturn root\n\n# The main function that converts BST to DLL and returns\n# head of DLL\ndef BTToDLL(root):\n\t\n\t# Set the previous pointer\n\tfixPrevPtr(root)\n\n\t# Set the next pointer and return head of DLL\n\treturn fixNextPtr(root)\n\n# Traversses the DLL from left to right\ndef printList(root):\n\twhile(root != None):\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\troot = root.right\n\n# Driver program to test above function\nroot = Node(10)\nroot.left = Node(12)\nroot.right = Node(15)\nroot.left.left = Node(25)\nroot.left.right = Node(30)\nroot.right.left = Node(36)\n\nprint (\"Inorder Tree Traversal\")\ninorder(root)\n\n# Static variable pre for function fixPrevPtr\nfixPrevPtr.pre = None\nhead = BTToDLL(root)\n\nprint (\"\\nDLL Traversal\")\nprintList(head)\n\t\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "In this example, you will learn to iterate over dictionaries using for loop.", "code": "dt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key, value in dt.items():\n    print(key, value)\ndt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key in dt:\n    print(key, dt[key])\ndt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key, value in dt.iteritems():\n    print(key, value)\ndt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key in dt.keys():\n    print(key)\n\nfor value in dt.values():\n    print(value)"}
{"nl": "Alternative Sorting (Static Input)", "code": "# Give the list as static input and store it in a variable.\r\ngvn_lst = [2, 3, 7, 8, 1, 3, 6]\r\n# Calculate the length of the given list using the len() function and\r\n# store it in another variable.\r\nlen_lst = len(gvn_lst)\r\n# Sort the given list using the sort() method and store it in another variable.\r\ngvn_lst.sort()\r\n# Take a variable say 'p' and initialize its value with zero.\r\np = 0\r\n# Take another variable say 'q' and initialize its value with the length of the\r\n# given list -1.\r\nq = len_lst-1\r\nprint(\"The Alternative sorting of the above given list is :\")\r\n# Check if the value of p is less than q using the while loop.\r\nwhile (p < q):\r\n    # If the statement is true, then print the value of the given list of q.\r\n    print(gvn_lst[q], end=\" \")\r\n    # Subtract 1 from q (q-1)and store it in the same variable 'q'.\r\n    q -= 1\r\n    # Print the value of the given list of p.\r\n    print(gvn_lst[p], end=\" \")\r\n    # Increment the value of p by 1 and store it in the same variable 'p'.\r\n    p += 1\r\n   # Check if the length of the given list is odd(len_lst % 2 != 0) by using the\r\n   # if conditional statement.\r\nif (len_lst % 2 != 0):\r\n    # If the statement is true, print the value of the given list of p.\r\n    print(gvn_lst[p])"}
{"nl": "Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u v, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.", "code": "# Python program to print topological sorting of a DAG\r\nfrom collections import defaultdict\r\n \r\n# Class to represent a graph\r\n \r\n \r\nclass Graph:\r\n    def __init__(self, vertices):\r\n        self.graph = defaultdict(list)  # dictionary containing adjacency List\r\n        self.V = vertices  # No. of vertices\r\n \r\n    # function to add an edge to graph\r\n    def addEdge(self, u, v):\r\n        self.graph[u].append(v)\r\n \r\n    # A recursive function used by topologicalSort\r\n    def topologicalSortUtil(self, v, visited, stack):\r\n \r\n        # Mark the current node as visited.\r\n        visited[v] = True\r\n \r\n        # Recur for all the vertices adjacent to this vertex\r\n        for i in self.graph[v]:\r\n            if visited[i] == False:\r\n                self.topologicalSortUtil(i, visited, stack)\r\n \r\n        # Push current vertex to stack which stores result\r\n        stack.append(v)\r\n \r\n    # The function to do Topological Sort. It uses recursive\r\n    # topologicalSortUtil()\r\n    def topologicalSort(self):\r\n        # Mark all the vertices as not visited\r\n        visited = [False]*self.V\r\n        stack = []\r\n \r\n        # Call the recursive helper function to store Topological\r\n        # Sort starting from all vertices one by one\r\n        for i in range(self.V):\r\n            if visited[i] == False:\r\n                self.topologicalSortUtil(i, visited, stack)\r\n \r\n        # Print contents of the stack\r\n        print(stack[::-1])  # return list in reverse order\r\n \r\n \r\n# Driver Code\r\ng = Graph(6)\r\ng.addEdge(5, 2)\r\ng.addEdge(5, 0)\r\ng.addEdge(4, 0)\r\ng.addEdge(4, 1)\r\ng.addEdge(2, 3)\r\ng.addEdge(3, 1)\r\n \r\nprint (\"Following is a Topological Sort of the given graph\")\r\n \r\n# Function Call\r\ng.topologicalSort()\r\n \r\n# This code is contributed by Neelam Yadav"}
{"nl": "Create a function that takes a word and returns True if the word has two consecutive identical letters.\nExamples\ndouble_letters(\"loop\") \u279e True\n\ndouble_letters(\"yummy\") \u279e True\n\ndouble_letters(\"orange\") \u279e False\n\ndouble_letters(\"munchkin\") \u279e False\nNotes\nN/A", "code": "def double_letters(word):\n  return any(i*2 in word for i in word)"}
{"nl": "Here, we will develop a program to remove special characters from a list in python. If the list was [\u2018Know@Program\u2019, \u2018Python*Program\u2019] then the result in the string will be [\u2018KnowProgram\u2019, \u2018PythonProgram\u2019]. We will discuss how to remove all special characters from the given list using Regular Expression, translate(), join(), filter() method, and str.isalnum() function.", "code": "# Python program to remove all special characters from list # importing RegEx module import re # take list my_list = ['@know*', 'pr#ogra!m^', '(py_th@on_3}'] # using regular expression to remove special characters out_list = [re.sub(r'[^a-zA-Z0-9]','',string) for string in my_list] # print list without special characters print('List after removal of special characters:', out_list)"}
{"nl": "Given two sorted linked lists, construct a linked list that contains maximum sum path from start to end. The result list may contain nodes from both input lists. When constructing the result list, we may switch to the other input list only at the point of intersection (which mean the two node with the same value in the lists). You are allowed to use O(1) extra space.\n \n\nInput:\nList1 =  1->3->30->90->120->240->511\nList2 =  0->3->12->32->90->125->240->249\n\nOutput: Following is maximum sum linked list out of two input lists\nlist =  1->3->12->32->90->125->240->511\nwe switch at 3 and 240 to get above maximum sum linked list", "code": "# Python program to construct a Maximum Sum Linked List out of\n# two Sorted Linked Lists having some Common nodes\nclass LinkedList(object):\n\tdef __init__(self):\n\t# head of list\n\t\tself.head = None\n\n\t# Linked list Node\n\tclass Node(object):\n\t\tdef __init__(self, d):\n\t\t\tself.data = d\n\t\t\tself.next = None\n\n\t# Method to adjust pointers and print final list\n\tdef finalMaxSumList(self, a, b):\n\t\tresult = None\n\t\t# assigning pre and cur to head\n\t\t# of the linked list\n\t\tpre1 = a\n\t\tcurr1 = a\n\t\tpre2 = b\n\t\tcurr2 = b\n\t\t# Till either of current pointers is not null\n\t\t# execute the loop\n\t\twhile curr1 != None or curr2 != None:\n\t\t\t# Keeping 2 local variables at the start of every\n\t\t\t# loop run to keep track of the sum between pre\n\t\t\t# and cur reference elements.\n\t\t\tsum1 = 0\n\t\t\tsum2 = 0\n\t\t\t# Calculating sum by traversing the nodes of linked\n\t\t\t# list as the merging of two linked list. The loop\n\t\t\t# stops at a common node\n\t\t\twhile curr1 != None and curr2 != None and curr1.data != curr2.data:\n\t\t\t\tif curr1.data < curr2.data:\n\t\t\t\t\tsum1 += curr1.data\n\t\t\t\t\tcurr1 = curr1.next\n\t\t\t\telse:\n\t\t\t\t\tsum2 += curr2.data\n\t\t\t\t\tcurr2 = curr2.next\n\t\t\t# If either of current pointers becomes null\n\t\t\t# carry on the sum calculation for other one.\n\t\t\tif curr1 == None:\n\t\t\t\twhile curr2 != None:\n\t\t\t\t\tsum2 += curr2.data\n\t\t\t\t\tcurr2 = curr2.next\n\t\t\tif curr2 == None:\n\t\t\t\twhile curr1 != None:\n\t\t\t\t\tsum1 += curr1.data\n\t\t\t\t\tcurr1 = curr1.next\n\t\t\t# First time adjustment of resultant head based on\n\t\t\t# the maximum sum.\n\t\t\tif pre1 == a and pre2 == b:\n\t\t\t\tresult = pre1 if (sum1 > sum2) else pre2\n\t\t\telse:\n\t\t\t\t# If pre1 and pre2 don't contain the head references of\n\t\t\t\t# lists adjust the next pointers of previous pointers.\n\t\t\t\tif sum1 > sum2:\n\t\t\t\t\tpre2.next = pre1.next\n\t\t\t\telse:\n\t\t\t\t\tpre1.next = pre2.next\n\t\t\t# Adjusting previous pointers\n\t\t\tpre1 = curr1\n\t\t\tpre2 = curr2\n\t\t\t# If curr1 is not NULL move to the next.\n\t\t\tif curr1 != None:\n\t\t\t\tcurr1 = curr1.next\n\t\t\t# If curr2 is not NULL move to the next.\n\t\t\tif curr2 != None:\n\t\t\t\tcurr2 = curr2.next\n\n\t\twhile result != None:\n\t\t\tprint (str(result.data),end=\" \")\n\t\t\tresult = result.next\n\t\tprint ()\n\n\t# Utility functions\n\t# Inserts a new Node at front of the list.\n\tdef push(self, new_data):\n\t\t# 1 & 2: Allocate the Node &\n\t\t# Put in the data\n\t\tnew_node = self.Node(new_data)\n\t\t# 3. Make next of new Node as head\n\t\tnew_node.next = self.head\n\t\t# 4. Move the head to point to new Node\n\t\tself.head = new_node\n\n# Driver program\nllist1 = LinkedList()\nllist2 = LinkedList()\n\n# Linked List 1 : 1->3->30->90->110->120->NULL\n# Linked List 2 : 0->3->12->32->90->100->120->130->NULL\n\nllist1.push(120)\nllist1.push(110)\nllist1.push(90)\nllist1.push(30)\nllist1.push(3)\nllist1.push(1)\n\nllist2.push(130)\nllist2.push(120)\nllist2.push(100)\nllist2.push(90)\nllist2.push(32)\nllist2.push(12)\nllist2.push(3)\nllist2.push(0)\n\nllist1.finalMaxSumList(llist1.head, llist2.head)\n\n# This code is contributed by BHAVYA JAIN\n"}
{"nl": "A string r is a subsequence of a string s if r can be obtained from s by dropping zero or more characters from s. A string r is a common subsequence of s and t if r is a subsequence of both s and t. A string r is a longest common subsequence (LCS) of s and t if there is no string that is longer than r and is a common subsequence of s and t. The problem is to find an LCS of two given strings.", "code": "def lcs(u, v):\n    \"\"\"Return c where c[i][j] contains length of LCS of u[i:] and v[j:].\"\"\"\n    c = [[-1]*(len(v) + 1) for _ in range(len(u) + 1)]\n\u00a0\n    for i in range(len(u) + 1):\n        c[i][len(v)] = 0\n    for j in range(len(v)):\n        c[len(u)][j] = 0\n\u00a0\n    for i in range(len(u) - 1, -1, -1):\n        for j in range(len(v) - 1, -1, -1):\n            if u[i] == v[j]:\n                c[i][j] = 1 + c[i + 1][j + 1]\n            else:\n                c[i][j] = max(c[i + 1][j], c[i][j + 1])\n\u00a0\n    return c\n\u00a0\n\u00a0\ndef print_lcs(u, v, c):\n    \"\"\"Print one LCS of u and v using table c.\"\"\"\n    i = j = 0\n    while not (i == len(u) or j == len(v)):\n        if u[i] == v[j]:\n            print(u[i], end='')\n            i += 1\n            j += 1\n        elif c[i][j + 1] > c[i + 1][j]:\n            j += 1\n        else:\n            i += 1\n\u00a0\n\u00a0\nu = input('Enter first string: ')\nv = input('Enter second string: ')\nc = lcs(u, v)\nprint('Longest Common Subsequence: ', end='')\nprint_lcs(u, v, c)"}
{"nl": "You have given an integer matrix with odd dimensions. Find the square of the diagonals elements on both sides.", "code": "# Efficient Python program\n# to print squares of\n# diagonal elements.\n\n# function of diagonal square\ndef diagonalsquare(mat, row,\n                                column) :\n        \n        # This loop is for finding\n        # of square of the first\n        # side of diagonal elements\n        print (\"Diagonal one : \",\n                                        end = \"\")\n        for i in range(0, row) :\n\n                # printing direct square\n                # of diagonal element\n                # there is no need to\n                # check condition\n                print (mat[i][i] *\n                        mat[i][i], end = \" \")\n        \n\n        # This loop is for finding\n        # square of the second side\n        # of diagonal elements\n        print (\"\\n\\nDiagonal two : \",\n                                                end = \"\")\n        \n        for i in range(0, row) :        \n                \n                # printing direct square\n                # of diagonal element in\n                # the second side\n                print (mat[i][row - i - 1] *\n                        mat[i][row - i - 1] ,\n                                                end = \" \")\n\n# Driver code\nmat = [[2, 5, 7 ],\n        [3, 7, 2 ],\n        [5, 6, 9 ]]\ndiagonalsquare(mat, 3, 3)\n        \n# This code is contributed by\n# Manish Shaw(manishshaw1)\n"}
{"nl": "Given a Balanced Binary Search Tree and a target sum, write a function that returns true if there is a pair with sum equals to target sum, otherwise return false. Expected time complexity is O(n) and only O(Logn) extra space can be used. Any modification to Binary Search Tree is not allowed. Note that height of a Balanced BST is always O(Logn).", "code": "# Python3 code to find a pair with given sum\n# in a Balanced BST\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Construct to create a new Node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\n# A utility function to insert a new\n# Node with given key in BST\ndef insert(root: Node, key: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty, return a new Node\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Otherwise, recur down the tree\n\u00a0\u00a0\u00a0\u00a0if root.data > key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0elif root.data < key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return the (unchanged) Node pointer\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# Function that adds values of given BST into\n# ArrayList and hence returns the ArrayList\ndef tree_to_list(root: Node, arr: list):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if not root:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return arr\n\u00a0\n\u00a0\u00a0\u00a0\u00a0tree_to_list(root.left, arr)\n\u00a0\u00a0\u00a0\u00a0arr.append(root.data)\n\u00a0\u00a0\u00a0\u00a0tree_to_list(root.right, arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return arr\n\u00a0\n# Function that checks if there is a pair present\ndef isPairPresent(root: Node, target: int) -> bool:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# This list a1 is passed as an argument\n\u00a0\u00a0\u00a0\u00a0# in treeToList method which is later\n\u00a0\u00a0\u00a0\u00a0# on filled by the values of BST\n\u00a0\u00a0\u00a0\u00a0arr1 = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# a2 list contains all the values of BST\n\u00a0\u00a0\u00a0\u00a0# returned by treeToList method\n\u00a0\u00a0\u00a0\u00a0arr2 = tree_to_list(root, arr1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Starting index of a2\n\u00a0\u00a0\u00a0\u00a0start = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Ending index of a2\n\u00a0\u00a0\u00a0\u00a0end = len(arr2) - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while start < end:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If target found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr2[start] + arr2[end] == target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(f\"Pair Found: {arr2[start]} + {arr2[end]} = {target}\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Decrements end\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr2[start] + arr2[end] > target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Increments start\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr2[start] + arr2[end] < target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0start += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"No such values are found!\")\n\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 8)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 12)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 16)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 25)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0isPairPresent(root, 33)\n\u00a0\n# This code is contributed by shindesharad71\n"}
{"nl": "Raise an exception\r\nAs a Python developer you can choose to throw an exception if a condition occurs.\r\n\r\nTo throw (or raise) an exception, use the raise keyword.", "code": "x = -1\r\n\r\nif x < 0:\r\n  raise Exception(\"Sorry, no numbers below zero\")"}
{"nl": "Python\u2019s if-else statement is logical. Python does not use the ternary operator as other languages do for inline if statements. It instead provides a one-line code to evaluate the first expression if the condition is met. Otherwise, the second expression is evaluated.", "code": "numb = 10\ntemp = 3\nprint(numb if temp else 0)"}
{"nl": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\nReturn the capitalized title.\n\n ", "code": "class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        title = title.title().split()\n        for i in range(len(title)):\n            if len(title[i]) < 3:\n                title[i] = title[i].lower()\n        return ' '.join(title)"}
{"nl": "Instructions\r\nTo try and encourage more sales of different books from a popular 5 book series, a bookshop has decided to offer discounts on multiple book purchases.\r\n\r\nOne copy of any of the five books costs $8.\r\n\r\nIf, however, you buy two different books, you get a 5% discount on those two books.\r\n\r\nIf you buy 3 different books, you get a 10% discount.\r\n\r\nIf you buy 4 different books, you get a 20% discount.\r\n\r\nIf you buy all 5, you get a 25% discount.\r\n\r\nNote: that if you buy four books, of which 3 are different titles, you get a 10% discount on the 3 that form part of a set, but the fourth book still costs $8.\r\n\r\nYour mission is to write a piece of code to calculate the price of any conceivable shopping basket (containing only books of the same series), giving as big a discount as possible.\r\n\r\nFor example, how much does this basket of books cost?\r\n\r\n2 copies of the first book\r\n2 copies of the second book\r\n2 copies of the third book\r\n1 copy of the fourth book\r\n1 copy of the fifth book\r\nOne way of grouping these 8 books is:\r\n\r\n1 group of 5 --> 25% discount (1st,2nd,3rd,4th,5th)\r\n+1 group of 3 --> 10% discount (1st,2nd,3rd)\r\nThis would give a total of:\r\n\r\n5 books at a 25% discount\r\n+3 books at a 10% discount\r\nResulting in:\r\n\r\n5 \u00d7 (8 - 2.00) = 5 \u00d7 6.00 = $30.00\r\n+3 \u00d7 (8 - 0.80) = 3 \u00d7 7.20 = $21.60\r\nFor a total of $51.60\r\n\r\nHowever, a different way to group these 8 books is:\r\n\r\n1 group of 4 books --> 20% discount (1st,2nd,3rd,4th)\r\n+1 group of 4 books --> 20% discount (1st,2nd,3rd,5th)\r\nThis would give a total of:\r\n\r\n4 books at a 20% discount\r\n+4 books at a 20% discount\r\nResulting in:\r\n\r\n4 \u00d7 (8 - 1.60) = 4 \u00d7 6.40 = $25.60\r\n+4 \u00d7 (8 - 1.60) = 4 \u00d7 6.40 = $25.60\r\nFor a total of $51.20\r\n\r\nAnd $51.20 is the price with the biggest discount.", "code": "\"\"\"\nExercism solution for \"book-store\"\n\"\"\"\nimport math\nfrom collections import Counter\nfrom decimal import Decimal\nfrom functools import lru_cache, reduce\nfrom typing import List, Tuple\nPER_BOOK = Decimal(\"800.00\")\nPER_GROUP = {\n    1: 1 * PER_BOOK * Decimal(\"1.00\"),\n    2: 2 * PER_BOOK * Decimal(\"0.95\"),\n    3: 3 * PER_BOOK * Decimal(\"0.90\"),\n    4: 4 * PER_BOOK * Decimal(\"0.80\"),\n    5: 5 * PER_BOOK * Decimal(\"0.75\"),\n}\n# memoize the results; cap memory and degrade performance with HUGE number of books\n@lru_cache(maxsize=1024)\ndef _recursive_total(books: Tuple[int]) -> float:\n    \"\"\"\n    Recurse to find the best discounted price for a non-empty, pre-sorted tuple of books.\n    \"\"\"\n    volumes = Counter(books)\n    num_books, num_volumes = len(books), len(volumes)\n    # optimization 1: we only have N copies of the same volume\n    if num_volumes == 1:\n        return num_books * PER_BOOK\n    # optimization 2: we only have 1 copy of each unique volume\n    if num_books == num_volumes:\n        return PER_GROUP[num_books]\n    # optimization 3: we happen to have gotten counts that share a GCD > 1\n    gcd = reduce(math.gcd, volumes.values())\n    if gcd != 1:\n        minimal = Counter({k: v // gcd for k, v in volumes.items()})\n        minimal_books = tuple(sorted(minimal.elements()))\n        return _recursive_total(minimal_books) * gcd\n    # in all other cases we recurse into the groups to find the minimum discount\n    price = num_books * PER_BOOK\n    for num in range(num_volumes, 1, -1):\n        # remove the first copy of each of the num most common volumes\n        group = volumes - Counter(k for k, _ in volumes.most_common(num))\n        group_books = tuple(sorted(group.elements()))\n        # calculate the minimum price for the group\n        price = min(price, PER_GROUP[num] + _recursive_total(group_books))\n    return price\ndef total(books: List[int]) -> float:\n    \"\"\"\n    Calculate the best discounted price for a list of books.\n    \"\"\"\n    if not books:\n        return 0\n    return _recursive_total(tuple(sorted(books)))"}
{"nl": "In this example you will learn to create a simple calculator that can add, subtract, multiply or divide depending upon the input from the user.", "code": "# Program make a simple calculator\n\n# This function adds two numbers\ndef add(x, y):\n    return x + y\n\n# This function subtracts two numbers\ndef subtract(x, y):\n    return x - y\n\n# This function multiplies two numbers\ndef multiply(x, y):\n    return x * y\n\n# This function divides two numbers\ndef divide(x, y):\n    return x / y\n\n\nprint(\"Select operation.\")\nprint(\"1.Add\")\nprint(\"2.Subtract\")\nprint(\"3.Multiply\")\nprint(\"4.Divide\")\n\nwhile True:\n    # take input from the user\n    choice = input(\"Enter choice(1/2/3/4): \")\n\n    # check if choice is one of the four options\n    if choice in ('1', '2', '3', '4'):\n        num1 = float(input(\"Enter first number: \"))\n        num2 = float(input(\"Enter second number: \"))\n\n        if choice == '1':\n            print(num1, \"+\", num2, \"=\", add(num1, num2))\n\n        elif choice == '2':\n            print(num1, \"-\", num2, \"=\", subtract(num1, num2))\n\n        elif choice == '3':\n            print(num1, \"*\", num2, \"=\", multiply(num1, num2))\n\n        elif choice == '4':\n            print(num1, \"/\", num2, \"=\", divide(num1, num2))\n        \n        # check if user wants another calculation\n        # break the while loop if answer is no\n        next_calculation = input(\"Let's do next calculation? (yes/no): \")\n        if next_calculation == \"no\":\n          break\n    \n    else:\n        print(\"Invalid Input\")"}
{"nl": "How to Find the Length of a List in Python | The length of a list is the number of elements in a list, there are many inbuilt features to find python list size. The list is a container that has many elements of similar data types.", "code": "# Python program to find the length of a list # take list list = [0,8,7,6] # find length of the list len = len(list) # print length of the list print(\"The length of a list is\", len)"}
{"nl": "We will develop a Python program to reverse a string. In this article, we are using the for loop, while loop, reversed() function, slice operator, and recursion methods to reverse a string in python.", "code": "# Python program to reverse a string using for loop # take inputs string = input('Enter the string: ') # calculate reverse of string reverse = '' for i in range(len(string), 0, -1): reverse += string[i-1] # print reverse of string print('The reverse string is', reverse)"}
{"nl": "Write a function that takes a list sorted in non-decreasing order and deletes any duplicate nodes from the list. The list should only be traversed once. \nFor example if the linked list is 11->11->11->21->43->43->60 then removeDuplicates() should convert the list to 11->21->43->60. ", "code": "# Python3 program to remove duplicates\n# from unsorted linked list\n\n\nclass Node():\n\n\tdef __init__(self, data):\n\n\t\tself.data = data\n\t\tself.next = None\n\n\nclass LinkedList():\n\n\tdef __init__(self):\n\n\t\t# Head of list\n\t\tself.head = None\n\n\tdef remove_duplicates(self):\n\n\t\tptr1 = None\n\t\tptr2 = None\n\t\tdup = None\n\t\tptr1 = self.head\n\n\t\t# Pick elements one by one\n\t\twhile (ptr1 != None and ptr1.next != None):\n\n\t\t\tptr2 = ptr1\n\n\t\t\t# Compare the picked element with rest\n\t\t\t# of the elements\n\t\t\twhile (ptr2.next != None):\n\n\t\t\t\t# If duplicate then delete it\n\t\t\t\tif (ptr1.data == ptr2.next.data):\n\n\t\t\t\t\t# Sequence of steps is important here\n\t\t\t\t\tdup = ptr2.next\n\t\t\t\t\tptr2.next = ptr2.next.next\n\t\t\t\telse:\n\t\t\t\t\tptr2 = ptr2.next\n\n\t\t\tptr1 = ptr1.next\n\n\t# Function to print nodes in a\n\t# given linked list\n\tdef printList(self):\n\t\ttemp = self.head\n\n\t\twhile(temp != None):\n\t\t\tprint(temp.data, end=\" \")\n\t\t\ttemp = temp.next\n\n\t\tprint()\n\n\n# Driver code\nlist = LinkedList()\nlist.head = Node(10)\nlist.head.next = Node(12)\nlist.head.next.next = Node(11)\nlist.head.next.next.next = Node(11)\nlist.head.next.next.next.next = Node(12)\nlist.head.next.next.next.next.next = Node(11)\nlist.head.next.next.next.next.next.next = Node(10)\n\nprint(\"Linked List before removing duplicates :\")\nlist.printList()\nlist.remove_duplicates()\nprint()\nprint(\"Linked List after removing duplicates :\")\nlist.printList()\n\n# This code is contributed by maheshwaripiyush9"}
{"nl": "Given two numbers n and a prime number, the task is to find the modular multiplicative inverse from 1 to the given number n", "code": "# Create a function to say modularmultInverse() which takes the iterator value and the\n# given number as the arguments and returns the modular multiplicative inverse from 1\n# to the given number n.\n\n\ndef modularmultInverse(itrvl, gvn_primenum):\n  # Inside the function, calculate the iterator value modulus given prime number and\n  # store it in the same variable iterator value.\n    itrvl = itrvl % gvn_primenum\n    # Loop from 1 to the given prime number using the for loop.\n    for k in range(1, gvn_primenum):\n     # Check if the iterator value multiplied by k (where k is the iterator value of for loop)\n     # modulus given prime number is equal to 1 using the if conditional statement.\n        if ((itrvl*k) % gvn_primenum == 1):\n          # If it is true, return the value of k.\n            return k\n    #Return -1.\n    return -1\n    \n    \n# Give the number as user input using the int(input()) function and store it in a variable.\ngvn_numb = int(input(\"Enter some random number = \"))\n# Give the prime number as user input using the int(input()) function and \n# store it in another variable.\ngvn_primenum = int(input(\"Enter some random number = \"))\n# Loop from 1 to the given number using the for loop.\nprint(\n    \"The modular multiplicative inverse from 1 to the given number{\", gvn_numb, \"} :\")\nfor itr in range(1, gvn_numb+1):\n  # Pass the iterator value and the given prime number to the modularmultInverse() function\n  # and print it.\n    print(modularmultInverse(itr, gvn_primenum), end=\" \")"}
{"nl": "Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts. \nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.\n \nExample 1:\n\n\nInput: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\nExample 2:\n\nInput: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1\n\nExample 3:\n\nInput: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1\n\n \nConstraints:\n\n1 <= rows, cols <= 50\nrows == pizza.length\ncols == pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A' and '.' only.", "code": "class Solution:\n  def ways(self, pizza: List[str], K: int) -> int:\n  m, n, MOD = len(pizza), len(pizza[0]), 10 ** 9 + 7\n  preSum = [[0] * (n + 1) for _ in range(m + 1)]\n  for r in range(m - 1, -1, -1):\n  for c in range(n - 1, -1, -1):\n  preSum[r][c] = preSum[r][c + 1] + preSum[r + 1][c] - preSum[r + 1][c + 1] + (pizza[r][c] == 'A')\n\n  @lru_cache(None)\n  def dp(k, r, c):\n  if preSum[r][c] == 0: return 0\n  if k == 0: return 1\n  ans = 0\n  # cut horizontally\n  for nr in range(r + 1, m):\n  if preSum[r][c] - preSum[nr][c] > 0:\n  ans = (ans + dp(k - 1, nr, c)) % MOD\n  # cut vertically  \n  for nc in range(c + 1, n):\n  if preSum[r][c] - preSum[r][nc] > 0:\n  ans = (ans + dp(k - 1, r, nc)) % MOD\n  return ans\n\n  return dp(K - 1, 0, 0)"}
{"nl": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\n\nAn interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:\n\ns = s1 + s2 + ... + sn\nt = t1 + t2 + ... + tm\n|n - m| <= 1\nThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\nNote: a + b is the concatenation of strings a and b.\n\n \n\nExample 1:\n\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExample 2:\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\nExample 3:\n\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\nOutput: true\n \n\nConstraints:\n\n0 <= s1.length, s2.length <= 100\n0 <= s3.length <= 200\ns1, s2, and s3 consist of lowercase English letters.\n ", "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    \n    if len(s3) != len(s1) + len(s2):\n        return False\n    \n    def helper(i, j, k):\n        if (i, j) in seen:\n            return False\n        seen.add((i, j))\n        if i == len(s1):\n            return s2[j:] == s3[k:]\n        if j == len(s2):\n            return s1[i:] == s3[k:]\n        if ((s1[i] == s3[k] and helper(i + 1, j, k + 1)) or\n                (s2[j] == s3[k] and helper(i, j + 1, k + 1))):\n            return True\n        return False\n\n    seen = set()\n    return helper(0, 0, 0)"}
{"nl": "A new number is a number that is not a permutation of any smaller number. 869 is not a new number because it is just a permutation of smaller numbers, 689 and 698. 509 is a new number because it can't be formed by a permutation of any smaller number (leading zeros not allowed).\nWrite a function that takes a non-negative integer and returns True if the integer is a new number and False if it is not.\nExamples\nis_new(3) \u279e True\n\nis_new(30) \u279e True\n\nis_new(321) \u279e False\n\nis_new(123) \u279e True\nNotes\nA curious fact: out of the first one million integers, only 8002 are new.", "code": "def is_new(n):\n    s = sorted(str(n))\n    zeros = s.count('0')\n    s[:zeros + 1] = reversed(s[:zeros + 1])\n    return n <= int(''.join(s))"}
{"nl": "Given a Binary Tree and a key, write a function that returns level of the key.\nFor example, consider the following tree. If the input key is 3, then your function should return 1. If the input key is 4, then your function should return 3. And for key which is not present in key, then your function should return 0.", "code": "# Python3 program to find closest\n# value in Binary search Tree\n\n_MIN = -2147483648\n_MAX = 2147483648\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pointers.\t\t\t\t\t\t\t\t\t\nclass getnode:\n\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# utility function to return level\n# of given node\ndef getlevel(root, data):\n\n\tq = []\n\tlevel = 1\n\tq.append(root)\n\n\t# extra None is appended to keep track\n\t# of all the nodes to be appended\n\t# before level is incremented by 1\n\tq.append(None)\n\twhile (len(q)):\n\t\ttemp = q[0]\n\t\tq.pop(0)\n\t\tif (temp == None) :\n\t\t\tif len(q) == 0:\n\t\t\t\treturn 0\n\t\t\tif (q[0] != None):\n\t\t\t\tq.append(None)\n\t\t\tlevel += 1\n\t\telse :\n\t\t\tif (temp.data == data) :\n\t\t\t\treturn level\n\t\t\tif (temp.left):\n\t\t\t\tq.append(temp.left)\n\t\t\tif (temp.right) :\n\t\t\t\tq.append(temp.right)\t\n\treturn 0\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# create a binary tree\n\troot = getnode(20)\n\troot.left = getnode(10)\n\troot.right = getnode(30)\n\troot.left.left = getnode(5)\n\troot.left.right = getnode(15)\n\troot.left.right.left = getnode(12)\n\troot.right.left = getnode(25)\n\troot.right.right = getnode(40)\n\n\t# return level of node\n\tlevel = getlevel(root, 30)\n\tif level != 0:\n\t\tprint(\"level of node 30 is\", level)\n\telse:\n\t\tprint(\"node 30 not found\")\n\n\tlevel = getlevel(root, 12)\n\tif level != 0:\n\t\tprint(\"level of node 12 is\", level)\n\telse:\n\t\tprint(\"node 12 not found\")\n\t\t\n\tlevel = getlevel(root, 25)\n\tif level != 0:\n\t\tprint(\"level of node 25 is\", level)\n\telse:\n\t\tprint(\"node 25 not found\")\n\n\tlevel = getlevel(root, 27)\n\tif level != 0:\n\t\tprint(\"level of node 27 is\", level)\n\telse:\n\t\tprint(\"node 27 not found\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Definition and Usage\r\nThe tell() method returns the current file position in a file stream.\r\n\r\nTip: You can change the current file position with the seek() method.", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.tell())"}
{"nl": "Create a function which takes in a word and spells it out, by consecutively adding letters until the full word is completed.\nExamples\nspelling(\"bee\") \u279e [\"b\", \"be\", \"bee\"]\n\nspelling(\"happy\") \u279e [\"h\", \"ha\", \"hap\", \"happ\", \"happy\"]\n\nspelling(\"eagerly\") \u279e [\"e\", \"ea\", \"eag\", \"eage\", \"eager\", \"eagerl\", \"eagerly\"]\nNotes\nN/A", "code": "def spelling(txt):\n  return [txt[:i + 1] for i in range(len(txt))]"}
{"nl": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n \n\nExample 1:\n\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\nExample 2:\n\nInput: root = []\nOutput: []\nExample 3:\n\nInput: root = [1]\nOutput: [1]\n \n\nConstraints:\n\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100\n ", "code": "def inorder(root):\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []"}
{"nl": "Create a function that takes a list of integers lst and sort the elements of the list by decreasing frequency of the elements. If two elements have the same frequency, sort them by increasing value.\nExamples\nsort_freq([2, 3, 5, 3, 7, 9, 5, 3, 7]) \u279e [3, 3, 3, 5, 5, 7, 7, 2, 9]\n\nsort_freq([1, 2, 3, 0, 5, 0, 1, 6, 8, 8, 6, 9, 1]) \u279e [1, 1, 1, 0, 0, 6, 6, 8, 8, 2, 3, 5, 9]\n\nsort_freq([4, 4, 2, 5, 1, 1, 3, 3, 2, 8]) \u279e [1, 1, 2, 2, 3, 3, 4, 4, 5, 8]\nNotes\nAll input numbers will be between 0-9.", "code": "def sort_freq(lst):\n    return sorted(lst, key=lambda k: (-lst.count(k), k))"}
{"nl": "Create a function that takes a string (the string to truncate) and a number (the maximum length of the truncated string) as arguments and returns the truncated string at the given length.\nExamples\ntruncate(\"Lorem ipsum dolor sit amet.\", 11) \u279e \"Lorem ipsum\"\n\ntruncate(\"Lorem ipsum dolor sit amet.\", 16) \u279e \"Lorem ipsum\"\n\ntruncate(\"Lorem ipsum dolor sit amet.\", 17) \u279e \"Lorem ipsum dolor\"\nNotes\nTo \"truncate\" means \"to shorten by cutting off the top or end\".\nIf a word is truncated in the middle, discard it in the output (see 2nd example above).", "code": "def truncate(txt, length):\n  return \" \".join([word for word in txt[:length].split() if word in txt.split()])"}
{"nl": "Given a matrix and the task is to find the normal and trace of the given Matrix in Python.", "code": "# Import the math module using the import keyword.\r\nimport math\r\n# Give the matrix as static input and store it in a variable.\r\nmtrx = [[2, 6, 4], [8, 5, 3], [1, 6, 8]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Take a variable say mtrxtrace which stores the trace of the given matrix\r\n# and initialize its value to 0.\r\nmtrxtrace = 0\r\n# Take a variable say mtrxsum which stores the sum of all elements of the matrix\r\n# and initialize its value to 0.\r\nmtrxsum = 0\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # Check if the parent loop iterator value is equal to the inner loop iterator value\r\n        # using the if conditional statement\r\n        # (This is whether the element is diagonal element or not)\r\n        if(n == m):\r\n            # If it is true then add this value to mtrxtrace.\r\n            mtrxtrace = mtrxtrace+mtrx[n][m]\r\n\r\n        # After the if conditional statement,\r\n        # Add the gvnmatrix[n][m] to the above-initialized mtrxsum\r\n        # and store it in the same variable mtrxsum.\r\n        mtrxsum = mtrxsum+mtrx[n][m]\r\n# After the end of two loops calculate the square root of the mtrxsum value\r\n# using the sqrt() function\r\n# and store this result in mtrxnormal variable.\r\nmtrxnormal = math.sqrt(mtrxsum)\r\n# Print the value of mtrxtrace which gives the value of the trace of the given matrix.\r\nprint('The trace value of the given matrix is :', mtrxtrace)\r\n# Print the value of mtrxnormal which gives the value of the normal of the given matrix.\r\nprint('The normal value of the given matrix is :', mtrxnormal)"}
{"nl": "A pie chart is a circular graphical representation of a dataset, where each category frequency is represented by a slice (or circular sector) with an amplitude in degrees given by the single frequency percentage over the total of frequencies. You can obtain the degrees of sectors following these steps:\nCalculate frequencies total.\nCalculate percentage of every category frequency dividing it by the frequencies total.\nTransform every percentage in degrees multiplying it for 360.\nYou are given a dictionary data with keys being the data categories (represented by letters) and values being the data frequencies. Implement a function that returns a map to design a pie chart, like to say the same dictionary with values transformed in degrees instead of frequencies. Round final values to the nearest tenth.\nExamples\npie_chart({ \"a\": 1, \"b\": 2 }) \u279e { \"a\": 120, \"b\": 240 }\n\npie_chart({ \"a\": 30, \"b\": 15, \"c\": 55 }) \u279e { \"a\": 108, \"b\": 54, \"c\": 198 }\n\npie_chart({ \"a\": 8, \"b\": 21, \"c\": 12, \"d\": 5, \"e\": 4 }) \u279e { \"a\": 57.6, \"b\": 151.2, \"c\": 86.4, \"d\": 36, \"e\": 28.8 }\nNotes\nN/A", "code": "def pie_chart(data):\n  total = sum(data.values())\n  return {i:round(data[i]/total * 360, 1) for i in data}"}
{"nl": "Create a class named User and create a way to check the number of users (number of instances) that were created, so that the value can be accessed as a class attribute.", "code": "class User:\r\n\tuser_count=0\r\n\tdef __init__(self,u):\r\n\t\tself.username = u \r\n\t\tUser.user_count+=1"}
{"nl": "Write a function that finds the sum of a list. Make your function recursive.\nExamples\nsum_recursively([1, 2, 3, 4]) \u279e 10\n\nsum_recursively([1, 2]) \u279e 3\n\nsum_recursively([1]) \u279e 1\n\nsum_recursively([]) \u279e 0\nNotes\nReturn 0 for an empty list.\nCheck the Resources tab for info on recursion.", "code": "def sum_recursively(lst):\n  if not lst: return 0\n  return lst.pop() + sum_recursively(lst)"}
{"nl": "Given the number of rows, the task is to print Exponentially Increasing Star Pattern in C, C++, and Python", "code": "# Give the number of rows of the pattern as static input and store it in a variable.\nrowsnumb = 5\n# Loop till a given number of rows using For loop.\nfor m in range(rowsnumb+1):\n  # Calculate the exponential value of the first loop iterator\n  # value using 2**(iterator value of the first loop).\n    expvalue = 2**m\n    # Loop till the exponential value using another For loop(Nested For loop).\n    for n in range(expvalue):\n      # Print the star character in the inner for loop.\n        print(\"*\", end=\" \")\n    # Print the newline character after the end of the inner for loop.\n    print()"}
{"nl": "In the previous article, we have discussed Python Program to Find Super Factorial of a Number.\n Math Module :\n Python\u2019s math module is a built-in module. By importing this module, we can perform mathematical computations.\n Numerous mathematical operations like ceil( ),floor( ),factorial( ),mod( ),value of pi ,\u2026..etc .can be computed with the help of math module.\n math.sin() function:\n To compute the sine value, we must use the sine function as math. sine() takes only one parameter, the degree value.\n Sin is a trigonometric function that represents the Sine function. Its value can be calculated by dividing the length of the opposite side by the length of the hypotenuse of a right-angled triangle, as we learned in math.\n By importing the math module that contains the definition, we will be able to use the sin() function in Python to obtain the sine value for any given angle.\n Examples:\n Example1:\n Input:\n Given lower limit range =0\n \n Given upper limit range =181\n \n Given step size =30\n Output:\n The Sine values in a given range are : \n \n sin 0 = 0.0\n \n sin 30 = 0.49999999999999994\n \n sin 60 = 0.8660254037844386\n \n sin 90 = 1.0\n \n sin 120 = 0.8660254037844387\n \n sin 150 = 0.49999999999999994\n \n sin 180 = 1.2246467991473532e-16\n Example 2:\n Input:\n Given lower limit range = 50\n \n Given upper limit range = 200 \n \n Given step size = 20\n Output:\n The Sine values in a given range are : \n \n sin 50 = 0.766044443118978\n \n sin 70 = 0.9396926207859083\n \n sin 90 = 1.0\n \n sin 110 = 0.9396926207859084\n \n sin 130 = 0.766044443118978\n \n sin 150 = 0.49999999999999994\n \n sin 170 = 0.17364817766693028\n \n sin 190 = -0.17364817766693047", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the lower limit range as static input and store it in a variable.\n \n lwer_lmt = 0\n \n # Give the upper limit range as static input and store it in another variable.\n \n upp_lmt = 181\n \n # Give the step size as static input and store it in another variable.\n \n stp_sze = 30\n \n # Loop from lower limit range to upper limit range using For loop.\n \n print(\"The Sine values in a given range are : \")\n \n for vale in range(lwer_lmt, upp_lmt, stp_sze):\n \n  # Get the angle value in radians from the given range(converting from degree to radians )\n \n  # and store it in a variable.\n \n  radns = math.radians(vale)\n \n  # Calculate the Sine value in a given range of above obtained radian values using\n \n  # math.Sine()function and store it in another variable.\n \n  sine_vlue = math.sin(radns)\n \n  # print the Sine Values in the above given range.\n \n  print(\"sin\",vale, \"=\", sine_vlue)\n \n </pre>"}
{"nl": "Find Common Divisors of Two Numbers (User Input)", "code": "# Give the first number as the user input using the int(input())\r\n# function and store it in a variable.\r\nfirstnumbe = int(input('Enter some random first number ='))\r\n# Give the second number as the user input using the int(input())\r\n# function and store it in another variable.\r\nsecondnumbe = int(input('Enter some random second number ='))\r\n# Calculate the minimum number among the two numbers using the min()\r\n# function and store it in a variable.\r\nmininumb = min(firstnumbe, secondnumbe)\r\nprint(\r\n    'The common divisors of the two numbers {', firstnumbe, secondnumbe, '} are :')\r\n# Loop from 1 to minimum number using the For loop.\r\nfor itrnumb in range(1, mininumb+1):\r\n    # Inside the For loop.\r\n    # Check if the iterator value divides the given two numbers\r\n    # using the If conditional Statement.\r\n    if(firstnumbe % itrnumb == 0 and secondnumbe % itrnumb == 0):\r\n          # If it is true then print the iterator value.\r\n        print(itrnumb)"}
{"nl": "In mathematics, an Arithmetic Progression (AP) is a sequence of numbers such that the difference between the consecutive terms is constant. Create a function that takes three arguments:\nThe first element of the sequence first\nConstant difference between the elements diff\nTotal numbers in the sequence n\nReturn the first n elements of the sequence with the given common difference diff. Final result should be a string of numbers, separated by comma and space.\nExamples\narithmetic_progression(1, 2, 5) \u279e \"1, 3, 5, 7, 9\"\n\narithmetic_progression(1, 0, 5) \u279e \"1, 1, 1, 1, 1\"\n\narithmetic_progression(1, -3, 10) \u279e \"1, -2, -5, -8, -11, -14, -17, -20, -23, -26\"\nNotes\nN/A", "code": "def arithmetic_progression(start, diff, n):\n    return \", \".join((str(start+diff*i) for i in range(n)))"}
{"nl": "Files In Python:\n\nA file is a piece of data or information stored on a computer\u2019s hard drive. You\u2019re already familiar with a variety of file kinds, including music, video, and text files. Manipulation of these files is trivial with Python. Text files and binary files are the two types of files that are commonly used. Binary files contain binary data that can only be read by a computer, whereas text files include plain text.\n\nFor programmers and automation testers, Python file handling (also known as File I/O) is a crucial topic. Working with files is required in order to write to or read data from them.\n\n\n\nIn addition, if you didn\u2019t know, I/O activities are the most expensive techniques via which software might fail. As a result, when implementing file processing for reporting or any other reason, you should proceed with caution. The construction of a high-performance application or a robust solution for automated software testing can benefit from optimizing a single file activity.\n\nFile writelines() Method in Python:\n\nThe writelines() function in Python is used to write a list of strings (multiple strings or items of a list) to a file.\n\nIn which the texts will be inserted depending on the file mode and stream position.\n\n\n\n\u201ca\u201d: The texts will be added at the current file stream position, which is often at the end of the file by default.\n\n\u201cw\u201d: The file will be emptied before the texts are inserted at the current file stream position, which is 0 by default.\n\nSyntax:\n\nfile.writelines(list)\nParameters\n\nlist: This is the list of texts or byte objects to be inserted.\n\nReturn Value:\n\nThis method doesn\u2019t return anything.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in append mode. In this case, we're simply appending/adding the contents into the file.\ngvn_file = open(givenFilename, 'a') \n# Write some random lines to the file by passing lines in the form of list as an\n# argument to the writelines() function.\ngvn_file.writelines([\"good morning btechgeeks\\n\", \"welcome to python coding platform\\n\"])\n# Close the given file using the close function\ngvn_file.close()\n# Open the file in read mode. In this case, we're simply reading the contents of the file.\ngvn_file = open(givenFilename, 'r') \n# Read the contents of the file using the read() function\nprint(gvn_file.read())"}
{"nl": "The Euler's phi function (from the Greek letter \u03c6, also called Euler's totient function) counts the positive integers that are coprime of a given number n, from 1 to n - 1. Two numbers are coprime when their greater common divisor is equal to 1. Look at the example below.\ndivisors of 6 \u279e [1, 2, 3, 6]\n\ndivisors of 5 \u279e [1, 5] \u279e g.c.d. = 1\ndivisors of 4 \u279e [1, 2, 4] \u279e g.c.d. = 2\ndivisors of 3 \u279e [1, 3] \u279e g.c.d. = 3\ndivisors of 2 \u279e [1, 2] \u279e g.c.d. = 2\ndivisors of 1 \u279e [1] \u279e g.c.d. = 1\n\n1 and 5 are coprime of 6 \u279e phi(6) = 2\nImplement a phi function that returns the count of coprime integers of a given positive integer n.\nExamples\nphi(1) \u279e 1\n\nphi(3) \u279e 2\n\nphi(8) \u279e 4\nNotes\n1 is trivially coprime of every number.\nYou can also proceed to obtain prime factors of an integer instead of all its positive divisors, just remember that 1 is present in any case despite is not prime.", "code": "def get_gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\ndef phi(n):\n    return sum(get_gcd(i, n) == 1 for i in range(1, n+1))"}
{"nl": "The Postfix notation is used to represent algebraic expressions. The expressions written in postfix form are evaluated faster compared to infix notation as parenthesis are not required in postfix. We have discussed infix to postfix conversion. In this post, evaluation of postfix expressions is discussed.", "code": "# Python program to evaluate value of a postfix expression\n\u00a0\n# Class to convert the expression\nclass Evaluate:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to initialize the class variables\n\u00a0\u00a0\u00a0\u00a0def __init__(self, capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.top = -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.capacity = capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# This array is used a stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# check if the stack is empty\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.top == -1 else False\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return the value of the top of the stack\n\u00a0\u00a0\u00a0\u00a0def peek(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.array[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Pop the element from the stack\n\u00a0\u00a0\u00a0\u00a0def pop(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.top -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.array.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return \"$\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Push the element to the stack\n\u00a0\u00a0\u00a0\u00a0def push(self, op):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.top += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array.append(op)\n\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# The main function that converts given infix expression\n\u00a0\u00a0\u00a0\u00a0# to postfix expression\n\u00a0\u00a0\u00a0\u00a0def evaluatePostfix(self, exp):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Iterate over the expression for conversion\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in exp:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the scanned character is an operand\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (number here) push it to the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i.isdigit():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.push(i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the scanned character is an operator,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop two elements from stack and apply it.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val1 = self.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val2 = self.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.push(str(eval(val2 + i + val1)))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return int(self.pop())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver program to test above function\nexp = \"231*+9-\"\nobj = Evaluate(len(exp))\nprint (\"postfix evaluation: %d\"%(obj.evaluatePostfix(exp)))\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "In the previous article, we have discussed Python Program to Find Vertex, Focus and Directrix of Parabola\n max() function :\n max() is a built-in function that returns the maximum value in a list.\n index() function:\n This function searches the lists. It returns the index where the value is found when we pass it as an argument that matches the value in the list. If no value is found, Value Error is returned.\n Given a list, the task is to Get the position of Max Value in a List.\n Examples:\n Example 1 :\n Input :\n Given List = [1, 5, 9, 2, 7, 3, 8]\n Output:\n Maximum Value in the above Given list = 9\n \n Position of Maximum value of the above Given List = 3\n Example 2 :\n Input : \n Given List = [4, 3, 7, 1, 2, 8, 9]\n Output:\n Maximum Value in the above Given list = 9\n \n Position of Maximum value of the above Given List = 7", "code": "# Give the List as static input and store it in a variable.\n Gvn_lst = [1, 5, 9, 2, 7, 3, 8]\n # Get the maximum value of the given list using the built-in max() function and\n # store it in another variable\n maxim_vle = max(Gvn_lst)\n # Print the maximum value of the above given List.\n print(\"Maximum Value in the above Given list = \", maxim_vle)\n # Get the position of the maximum value of the List using the built-in index() function\n # and store it in another variable.\n maxim_positn = Gvn_lst.index(maxim_vle)\n # Print the position of the maximum value of the given List i.e. maximum position+1\n # ( since list index starts from zero).\n print(\"Position of Maximum value of the above Given List = \", maxim_positn+1)"}
{"nl": "We have discussed BST search and insert operations. In this post, the delete operation is discussed. When we delete a node, three possibilities arise.\u00a0\n\n\n1) Node to be deleted is the leaf: Simply remove from the tree.\u00a0", "code": "# Python program to demonstrate delete operation\n# in binary search tree\n\u00a0\n# A Binary Tree Node\n\u00a0\n\u00a0\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n\u00a0\n# A utility function to do inorder traversal of BST\ndef inorder(root):\n\u00a0\u00a0\u00a0\u00a0if root is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (root.key,end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.right)\n\u00a0\n\u00a0\n# A utility function to insert a\n# new node with given key in BST\ndef insert(node, key):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty, return a new node\n\u00a0\u00a0\u00a0\u00a0if node is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Otherwise recur down the tree\n\u00a0\u00a0\u00a0\u00a0if key < node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.left = insert(node.left, key)\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.right = insert(node.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return the (unchanged) node pointer\n\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\n# Given a non-empty binary\n# search tree, return the node\n# with minimum key value\n# found in that tree. Note that the\n# entire tree does not need to be searched\n\u00a0\n\u00a0\ndef minValueNode(node):\n\u00a0\u00a0\u00a0\u00a0current = node\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# loop down to find the leftmost leaf\n\u00a0\u00a0\u00a0\u00a0while(current.left is not None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = current.left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return current\n\u00a0\n# Given a binary search tree and a key, this function\n# delete the key and returns the new root\n\u00a0\n\u00a0\ndef deleteNode(root, key):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the key to be deleted\n\u00a0\u00a0\u00a0\u00a0# is smaller than the root's\n\u00a0\u00a0\u00a0\u00a0# key then it lies in\u00a0 left subtree\n\u00a0\u00a0\u00a0\u00a0if key < root.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = deleteNode(root.left, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the kye to be delete\n\u00a0\u00a0\u00a0\u00a0# is greater than the root's key\n\u00a0\u00a0\u00a0\u00a0# then it lies in right subtree\n\u00a0\u00a0\u00a0\u00a0elif(key > root.key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = deleteNode(root.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If key is same as root's key, then this is the node\n\u00a0\u00a0\u00a0\u00a0# to be deleted\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Node with only one child or no child\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if root.left is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = root.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return temp\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif root.right is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = root.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return temp\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Node with two children:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the inorder successor\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (smallest in the right subtree)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = minValueNode(root.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Copy the inorder successor's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# content to this node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.key = temp.key\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Delete the inorder successor\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = deleteNode(root.right, temp.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\n# Driver code\n\"\"\" Let us create following BST\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a050\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0\u00a0\u00a0\u00a0 \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a030\u00a0\u00a0\u00a0\u00a0\u00a0 70\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0 \\\u00a0\u00a0\u00a0 /\u00a0 \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a020\u00a0\u00a0 40\u00a0 60\u00a0\u00a0 80 \"\"\"\n\u00a0\nroot = None\nroot = insert(root, 50)\nroot = insert(root, 30)\nroot = insert(root, 20)\nroot = insert(root, 40)\nroot = insert(root, 70)\nroot = insert(root, 60)\nroot = insert(root, 80)\n\u00a0\nprint (\"Inorder traversal of the given tree\")\ninorder(root)\n\u00a0\nprint (\"\\nDelete 20\")\nroot = deleteNode(root, 20)\nprint (\"Inorder traversal of the modified tree\")\ninorder(root)\n\u00a0\nprint (\"\\nDelete 30\")\nroot = deleteNode(root, 30)\nprint (\"Inorder traversal of the modified tree\")\ninorder(root)\n\u00a0\nprint (\"\\nDelete 50\")\nroot = deleteNode(root, 50)\nprint (\"Inorder traversal of the modified tree\")\ninorder(root)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "In this example, you will learn to sort a Python dictionary by value.", "code": "dt = {5:4, 1:6, 6:3}\n\nsorted_dt = {key: value for key, value in sorted(dt.items(), key=lambda item: item[1])}\n\nprint(sorted_dt)\ndt = {5:4, 1:6, 6:3}\n\nsorted_dt_value = sorted(dt.values())\nprint(sorted_dt_value)"}
{"nl": "We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.\nWhen two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\nWhen an ant reaches one end of the plank at a time t, it falls out of the plank immediately.\nGiven an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.\n \nExample 1:\n\n\nInput: n = 4, left = [4,3], right = [0,1]\nOutput: 4\nExplanation: In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n\nExample 2:\n\n\nInput: n = 7, left = [], right = [0,1,2,3,4,5,6,7]\nOutput: 7\nExplanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n\nExample 3:\n\n\nInput: n = 7, left = [0,1,2,3,4,5,6,7], right = []\nOutput: 7\nExplanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n\n \nConstraints:\n\n1 <= n <= 104\n0 <= left.length <= n + 1\n0 <= left[i] <= n\n0 <= right.length <= n + 1\n0 <= right[i] <= n\n1 <= left.length + right.length <= n + 1\nAll values of left and right are unique, and each value can appear only in one of the two arrays.", "code": "def getLastMoment(self, n, left, right):\n  return max(max(left or [0]), n - min(right or [n]))"}
{"nl": "Python Pandas Period.freqstr Attribute:\r\n\r\nThe string alias of the Time series frequency applied to the specified Period object is returned by the Period.freqstr attribute of Pandas module.", "code": "# Import pandas module using the import keyword.\r\nimport pandas as pd\r\n# Pass freq ='D'(here D represents Date), some random year, month, day, \r\n# as the arguments to the Period() function of the\r\n# pandas module to get the period object\r\nperiod_obj = pd.Period(freq ='D', year = 2021, month = 8, day = 15)\r\n# Print the above obtained period object\r\nprint(\"The above obtained period object:\", period_obj)\r\n\r\n# Apply freqstr attribute to the above period object to get a \r\n# string alias of the Time series frequency applied to the given Period object\r\nprint(\"String alias of the Time series frequency applied to the given Period object:\")\r\nperiod_obj.freqstr"}
{"nl": "Program for addition of two matrices in C++ Program and Python.", "code": "# given matrix A\nA = [[11, -2, 0],\n     [4, 8, 6]]\n# given matrix B\nB = [[5, 1, -5],\n     [2, 3, 0]]\n# Initialize the sum of matrices elements to 0\nmatrixSum = [[0, 0, 0],\n             [0, 0, 0]]\n\n# Traverse the rows\nfor rows in range(len(A)):\n    # Traverse the  columns\n    for columns in range(len(A[0])):\n        matrixSum[rows][columns] = A[rows][columns] + B[rows][columns]\n# printing the sum of matrices\nprint(\"Printing the sum of matrices : \")\nfor rows in matrixSum:\n    print(*rows)"}
{"nl": "Given a date string in the form Day Month Year, where:\n\nDay is in the set {\"1st\", \"2nd\", \"3rd\", \"4th\", ..., \"30th\", \"31st\"}.\nMonth is in the set {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"}.\nYear is in the range [1900, 2100].\n\nConvert the date string to the format YYYY-MM-DD, where:\n\nYYYY denotes the 4 digit year.\nMM denotes the 2 digit month.\nDD denotes the 2 digit day.\n\n \nExample 1:\n\nInput: date = \"20th Oct 2052\"\nOutput: \"2052-10-20\"\n\nExample 2:\n\nInput: date = \"6th Jun 1933\"\nOutput: \"1933-06-06\"\n\nExample 3:\n\nInput: date = \"26th May 1960\"\nOutput: \"1960-05-26\"\n\n \nConstraints:\n\nThe given dates are guaranteed to be valid, so no error handling is necessary.", "code": "class Solution:\n  def reformatDate(self, date: str) -> str:\n  M = {\"Jan\" : \"01\", \"Feb\" : \"02\", \"Mar\" : \"03\", \"Apr\" : \"04\", \"May\" : \"05\", \"Jun\" : \"06\", \"Jul\" : \"07\", \"Aug\" : \"08\", \"Sep\" : \"09\", \"Oct\" : \"10\", \"Nov\" : \"11\", \"Dec\" : \"12\", }\n  \n  D = \"\"\n  if (len(date) == 13):\n  D += date[-4:] + \"-\" + M[date[-8:-5]] + \"-\" + date[:2]\n  else:\n  D += date[-4:] + \"-\" + M[date[-8:-5]] + \"-0\" + date[0]\n  return D"}
{"nl": "nPr:\n\nnPr indicates n permutation r.\n\nThe process of organizing all the individuals in a given set to form a sequence is referred to as permutation.\n\nThe Given mathematical formula for nPr =n!/(n-r)!\n\nGiven the values of n, r and the task is to find the value of nPr .\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven n value = 5 \nGiven r value = 4\nOutput:\n\nThe value of nPr for above given n, r values =  120\nExample 2:\n\nInput:\n\nGiven n value = 6\nGiven r value = 3\nOutput:\n\nThe value of nPr for above given n, r values = 120", "code": "# Import math module using the import keyword.\n import math\n # Give the number as static input and store it in a variable.\n gvn_n_val = 5\n # Give another number as static input and store it in another variable.\n gvn_r_val = 4\n # Calculate the value of nPr with reference to standard mathematical formula n!/(n-r)!\n # using factorial() function \n # Store it in a variable.\n n_p_r = math.factorial(gvn_n_val)//math.factorial(gvn_n_val-gvn_r_val)\n # Print the value of nPr for the above given n, r values.\n print(\"The value of nPr for above given n, r values = \", n_p_r)"}
{"nl": "Create a function that takes three numbers as arguments and returns True if it's a triangle and False if not.\nExamples\nis_triangle(2, 3, 4) \u279e True\n\nis_triangle(3, 4, 5) \u279e True\n\nis_triangle(4, 3, 8) \u279e False\nNotes\na, b and, c are the side lengths of the triangles.\nTest input will always be three positive numbers.", "code": "def is_triangle(*sides):\n  return all(s < sum(sides) - s for s in sides)"}
{"nl": "Given a directed and two vertices \u2018u\u2019 and \u2018v\u2019 in it, find shortest path from \u2018u\u2019 to \u2018v\u2019 with exactly k edges on the path.\n\nThe graph is given as adjacency matrix representation where value of graph[i][j] indicates the weight of an edge from vertex i to vertex j and a value INF(infinite) indicates no edge from i to j.\n\nFor example, consider the following graph. Let source \u2018u\u2019 be vertex 0, destination \u2018v\u2019 be 3 and k be 2. There are two walks of length 2, the walks are {0, 2, 3} and {0, 1, 3}. The shortest among the two is {0, 2, 3} and weight of path is 3+6 = 9.\n\n\n\u00a0", "code": "# Python3 program to find shortest path\n# with exactly k edges\n\u00a0\n# Define number of vertices in the graph\n# and infinite value\n\u00a0\n# A naive recursive function to count\n# walks from u to v with k edges\ndef shortestPath(graph, u, v, k):\n\u00a0\u00a0\u00a0\u00a0V = 4\n\u00a0\u00a0\u00a0\u00a0INF = 999999999999\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base cases\n\u00a0\u00a0\u00a0\u00a0if k == 0 and u == v:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0if k == 1 and graph[u][v] != INF:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return graph[u][v]\n\u00a0\u00a0\u00a0\u00a0if k <= 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return INF\n\u00a0\n# Initialize result\n\u00a0\u00a0\u00a0\u00a0res = INF\n\u00a0\n# Go to all adjacents of u and recur\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if graph[u][i] != INF and u != i and v != i:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rec_res = shortestPath(graph, i, v, k - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if rec_res != INF:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = min(res, graph[u][i] + rec_res)\n\u00a0\u00a0\u00a0\u00a0return res\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0INF = 999999999999\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us create the graph shown\n\u00a0\u00a0\u00a0\u00a0# in above diagram\n\u00a0\u00a0\u00a0\u00a0graph = [[0, 10, 3, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, 0, INF, 7],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, 0, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, INF, 0]]\n\u00a0\u00a0\u00a0\u00a0u = 0\n\u00a0\u00a0\u00a0\u00a0v = 3\n\u00a0\u00a0\u00a0\u00a0k = 2\n\u00a0\u00a0\u00a0\u00a0print(\"Weight of the shortest path is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0shortestPath(graph, u, v, k))\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn true if you can finish all courses. Otherwise, return false.\n\n \n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\nExample 2:\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.", "code": "class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        from collections import defaultdict\n        courseDict = defaultdict(list)\n\n        for relation in prerequisites:\n            nextCourse, prevCourse = relation[0], relation[1]\n            courseDict[prevCourse].append(nextCourse)\n\n        path = [False] * numCourses\n        for currCourse in range(numCourses):\n            if self.isCyclic(currCourse, courseDict, path):\n                return False\n        return True\n\n\n    def isCyclic(self, currCourse, courseDict, path):\n        \"\"\"\n        backtracking method to check that no cycle would be formed starting from currCourse\n        \"\"\"\n        if path[currCourse]:\n            # come across a previously visited node, i.e. detect the cycle\n            return True\n\n        # before backtracking, mark the node in the path\n        path[currCourse] = True\n\n        # backtracking\n        ret = False\n        for child in courseDict[currCourse]:\n            ret = self.isCyclic(child, courseDict, path)\n            if ret: break\n\n        # after backtracking, remove the node from the path\n        path[currCourse] = False\n        return ret"}
{"nl": "The internet is filled with huge amounts of data in the form of images. People upload millions of pictures every day on social media sites such as Instagram, Facebook and cloud storage platforms such as google drive, etc. With such large amounts of data, image compression techniques become important to compress the images and reduce storage space.\r\n\r\nIn this article, we will look at image compression using K-means clustering algorithm which is an unsupervised learning algorithm.\r\n\r\nAn image is made up of several intensity values known as Pixels. In a colored image, each pixel is of 3 bytes containing RGB (Red-Blue-Green) values having Red intensity value, then Blue and then Green intensity value for each pixel.", "code": "\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.image as img\r\n# from scipy.io import loadmat\r\nfrom scipy import misc\r\n  \r\ndef read_image():\r\n      \r\n    # loading the png image as a 3d matrix \r\n    img = misc.imread('bird_small.png') \r\n  \r\n    # uncomment the below code to view the loaded image\r\n    # plt.imshow(A) # plotting the image\r\n    # plt.show() \r\n      \r\n    # scaling it so that the values are small\r\n    img = img / 255 \r\n  \r\n    return img\r\n  \r\ndef initialize_means(img, clusters):\r\n      \r\n    # reshaping it or flattening it into a 2d matrix\r\n    points = np.reshape(img, (img.shape[0] * img.shape[1],\r\n                                             img.shape[2])) \r\n    m, n = points.shape\r\n  \r\n    # clusters is the number of clusters\r\n    # or the number of colors that we choose.\r\n      \r\n    # means is the array of assumed means or centroids. \r\n    means = np.zeros((clusters, n)) \r\n  \r\n    # random initialization of means. \r\n    for i in range(clusters):\r\n        rand1 = int(np.random.random(1)*10)\r\n        rand2 = int(np.random.random(1)*8)\r\n        means[i, 0] = points[rand1, 0]\r\n        means[i, 1] = points[rand2, 1]\r\n  \r\n    return points, means\r\n  \r\n  \r\n# Function to measure the euclidean\r\n# distance (distance formula)\r\ndef distance(x1, y1, x2, y2):\r\n      \r\n    dist = np.square(x1 - x2) + np.square(y1 - y2)\r\n    dist = np.sqrt(dist)\r\n  \r\n    return dist\r\n  \r\n  \r\ndef k_means(points, means, clusters):\r\n  \r\n    iterations = 10 # the number of iterations \r\n    m, n = points.shape\r\n      \r\n    # these are the index values that\r\n    # correspond to the cluster to\r\n    # which each pixel belongs to.\r\n    index = np.zeros(m) \r\n  \r\n    # k-means algorithm.\r\n    while(iterations > 0):\r\n  \r\n        for j in range(len(points)):\r\n              \r\n            # initialize minimum value to a large value\r\n            minv = 1000\r\n            temp = None\r\n              \r\n            for k in range(clusters):\r\n                  \r\n                x1 = points[j, 0]\r\n                y1 = points[j, 1]\r\n                x2 = means[k, 0]\r\n                y2 = means[k, 1]\r\n                  \r\n                if(distance(x1, y1, x2, y2) < minv):         \r\n                    minv = distance(x1, y1, x2, y2)\r\n                    temp = k\r\n                    index[j] = k \r\n          \r\n        for k in range(clusters):\r\n              \r\n            sumx = 0\r\n            sumy = 0\r\n            count = 0\r\n              \r\n            for j in range(len(points)):\r\n                  \r\n                if(index[j] == k):\r\n                    sumx += points[j, 0]\r\n                    sumy += points[j, 1] \r\n                    count += 1\r\n              \r\n            if(count == 0):\r\n                count = 1    \r\n              \r\n            means[k, 0] = float(sumx / count)\r\n            means[k, 1] = float(sumy / count)     \r\n              \r\n        iterations -= 1\r\n  \r\n    return means, index\r\n  \r\n  \r\ndef compress_image(means, index, img):\r\n  \r\n    # recovering the compressed image by\r\n    # assigning each pixel to its corresponding centroid.\r\n    centroid = np.array(means)\r\n    recovered = centroid[index.astype(int), :]\r\n      \r\n    # getting back the 3d matrix (row, col, rgb(3))\r\n    recovered = np.reshape(recovered, (img.shape[0], img.shape[1],\r\n                                                     img.shape[2]))\r\n  \r\n    # plotting the compressed image.\r\n    plt.imshow(recovered)\r\n    plt.show()\r\n  \r\n    # saving the compressed image.\r\n    misc.imsave('compressed_' + str(clusters) +\r\n                        '_colors.png', recovered)\r\n  \r\n  \r\n# Driver Code\r\nif __name__ == '__main__':\r\n  \r\n    img = read_image()\r\n  \r\n    clusters = 16\r\n    clusters = int(input('Enter the number of colors in the compressed image. default = 16\\n'))\r\n  \r\n    points, means = initialize_means(img, clusters)\r\n    means, index = k_means(points, means, clusters)\r\n    compress_image(means, index, img)"}
{"nl": "Given a string that contains the words the task is to print the last word in the given string in Python.", "code": "# Give the string as user input using the input() function and store it in the variable.\ngvnstrng = input('Enter some random string = ')\n# Split the words of the given string to a list of words\n# using the built-in split() function.\nlsttofwrds = gvnstrng.split()\n# Get the last word from the above list of words using negative indexing\n# and store it in a variable.\nlstwrd = lsttofwrds[-1]\n# Print the last word of the given string by printing the above variable.\nprint('The last word in the given string {', gvnstrng, '} is:', lstwrd)"}
{"nl": "Guys who are serious about learning the concepts of the java programming language should practice this list of programs in java and get a good grip on it for better results in exams or interviews.\n \n Given a number, the task is to check whether the given number is a Narcissistic Number or Not in Python.\n \n Narcissistic Number:\n \n Narcissistic numbers are a type of number that can be generated by adding the sum of its own digits raised to the power of the number of digits.\n \n Example:\n \n 370\n \n Number of digits=3\n \n 3*(Number of digits)+7*(Number of digits)+0*(Number of digits)\n \n 3^(3)+7^(3)+0^3=370\n \n So it is a Narcissistic Number.\n \n Examples:\n \n Example1:\n \n Input:\n \n Given Number =370\n Output:\n \n The given Number { 370 } is a Narcissistic Number\n Example2:\n \n Input:\n \n Given Number =371\n Output:\n \n The given Number { 371 } is a Narcissistic Number", "code": "# Give the number as static input and store it in a variable.\n givennmb = 370\n # Convert this number into list of digits using list(),map(),int(),str() functions.\n # Store it in a variable.\n numbedigis = list(map(int, str(givennmb)))\n # Calculate the length of the list using the len() function\n # and store it in a variable say listleng.\n listleng = len(numbedigis)\n # Take a variable tempo and initialize its value to 0.\n tempo = 0\n # Loop in this digits list using For loop.\n for numbrdigit in numbedigis:\n  # Calculate the iterator value^listleng where ^ represents\n  # the power operator and store it in a variable.\n  powevalu = numbrdigit**listleng\n  # Increment the tempo by the above variable.\n  tempo = tempo+powevalu\n # After the end of For loop check if the tempo value is equal\n # to the given number using the If conditional Statement.\n if(tempo == givennmb):\n  # If it is true then print the given number as a Narcissistic Number.\n  print('The given Number {', givennmb, '} is a Narcissistic Number')\n else:\n  # Else it is not a Narcissistic Number.\n  print('The given Number {', givennmb, '} is not a Narcissistic Number')"}
{"nl": "A binary tree and a number k are given. Print every path in the tree with sum of the nodes in the path as k. \nA path can start from any node and end at any node and must be downward only, i.e. they need not be root node and leaf node; and negative numbers can also be there in the tree.\nExamples: \n \n\nInput : k = 5  \n        Root of below binary tree:\n           1\n        /     \\\n      3        -1\n    /   \\     /   \\\n   2     1   4     5                        \n        /   / \\     \\                    \n       1   1   2     6    \n                       \nOutput :\n3 2 \n3 1 1 \n1 3 1 \n4 1 \n1 -1 4 1 \n-1 4 2 \n5 \n1 -1 5 ", "code": "# Python3 program to print all paths\n# with sum k\n\n# utility function to print contents of\n# a vector from index i to it's end\n\n\ndef printVector(v, i):\n\tfor j in range(i, len(v)):\n\t\tprint(v[j], end=\" \")\n\tprint()\n\n\n# Binary Tree Node\n\"\"\" utility that allocates a newNode\nwith the given key \"\"\"\n\n\nclass newNode:\n\n\t# Construct to create a newNode\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# This function prints all paths\n# that have sum k\n\n\ndef printKPathUtil(root, path, k):\n\n\t# empty node\n\tif (not root):\n\t\treturn\n\n\t# add current node to the path\n\tpath.append(root.data)\n\n\t# check if there's any k sum path\n\t# in the left sub-tree.\n\tprintKPathUtil(root.left, path, k)\n\n\t# check if there's any k sum path\n\t# in the right sub-tree.\n\tprintKPathUtil(root.right, path, k)\n\n\t# check if there's any k sum path that\n\t# terminates at this node\n\t# Traverse the entire path as\n\t# there can be negative elements too\n\tf = 0\n\tfor j in range(len(path) - 1, -1, -1):\n\t\tf += path[j]\n\n\t\t# If path sum is k, print the path\n\t\tif (f == k):\n\t\t\tprintVector(path, j)\n\n\t# Remove the current element\n\t# from the path\n\tpath.pop(-1)\n\n# A wrapper over printKPathUtil()\n\n\ndef printKPath(root, k):\n\n\tpath = []\n\tprintKPathUtil(root, path, k)\n\n\n# Driver Code\nif __name__ == '__main__':\n\n\troot = newNode(1)\n\troot.left = newNode(3)\n\troot.left.left = newNode(2)\n\troot.left.right = newNode(1)\n\troot.left.right.left = newNode(1)\n\troot.right = newNode(-1)\n\troot.right.left = newNode(4)\n\troot.right.left.left = newNode(1)\n\troot.right.left.right = newNode(2)\n\troot.right.right = newNode(5)\n\troot.right.right.right = newNode(2)\n\n\tk = 5\n\tprintKPath(root, k)\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted.\n\nReturn the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7.", "code": "class Solution:\n    def colorTheGrid(self, m: int, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        # Get valid states for a column\n        valid_states = generate_states(m)\n        # Init rolling array dp\n        dp = [[0] * len(valid_states) for _ in range(2)]\n        # Init the first column of dp to all ones\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n\n        # Memorize valid current and previous states pairs\n        # memo: {(current state index, [previous valid state indexes])}\n        memo = {}\n        for i in range(1, n):\n            for j in range(len(valid_states)):\n                # Init the dp value of current column at this state to zero\n                dp[i % 2][j] = 0\n                # Iterate through all the valid states in previous column\n                # First check if the current state index is in memo\n                if j in memo:\n                    for k in memo[j]:\n                        dp[i % 2][j] = (dp[i % 2][j] + dp[(i - 1) % 2][k]) % MOD\n                    continue\n\n                # If not, iterate through all the valid states in previous column\n                valid_prev_states = []\n                for k in range(len(valid_states)):\n                    # Accumulate to the dp value of current column at this state if the two states are valid\n                    if check_valid_states(valid_states[j], valid_states[k]):\n                        dp[i % 2][j] = (dp[i % 2][j] + dp[(i - 1) % 2][k]) % MOD\n                        valid_prev_states.append(k)\n\n                # Save the current state index and previous valid state indexes list to memo\n                memo[j] = valid_prev_states\n        \n        # Add up the dp values of the last column\n        res = 0\n        for i in range(len(dp[0])):\n            res = (res + dp[(n - 1) % 2][i]) % MOD\n        return res\n\ndef generate_states(m):\n    states = []\n    # Iterate over all possible states in 10 digit base\n    for i in range(3 ** m):\n        state_tmp = i\n        state = []\n        # Convert the state to 3 digit base\n        for j in range(m):\n            last_bit = state_tmp % 3\n            if state and last_bit == state[-1]:\n                break\n            state.append(last_bit)\n            state_tmp //= 3\n\n        # Add the state to states if valid\n        if len(state) == m:\n            states.append(state)\n    \n    return states\n\ndef check_valid_states(state1, state2):\n    for i in range(len(state1)):\n        if state1[i] == state2[i]:\n            return False\n    return True"}
{"nl": "You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i].\n\nExecute all the valid transactions. A transaction is valid if:\n\nThe given account number(s) are between 1 and n, and\nThe amount of money withdrawn or transferred from is less than or equal to the balance of the account.\nImplement the Bank class:\n\nBank(long[] balance) Initializes the object with the 0-indexed integer array balance.\nboolean transfer(int account1, int account2, long money) Transfers money dollars from the account numbered account1 to the account numbered account2. Return true if the transaction was successful, false otherwise.\nboolean deposit(int account, long money) Deposit money dollars into the account numbered account. Return true if the transaction was successful, false otherwise.\nboolean withdraw(int account, long money) Withdraw money dollars from the account numbered account. Return true if the transaction was successful, false otherwise.\n ", "code": "class Bank:\n\n    def __init__(self, balance: List[int]):\n        self.bankaccount=balance\n\n    def transfer(self, account1: int, account2: int, money: int) -> bool:\n        account1-=1\n        account2-=1\n        if(account1<len(self.bankaccount) and account2<len(self.bankaccount)):\n            if(self.bankaccount[account1]>=money):\n                self.bankaccount[account1]-=money\n                self.bankaccount[account2]+=money\n                return True\n        return False\n\n    def deposit(self, account: int, money: int) -> bool:\n        account-=1\n        if(account<len(self.bankaccount)):\n            self.bankaccount[account]+=money\n            return True\n        return False\n\n\n    def withdraw(self, account: int, money: int) -> bool:\n        account-=1\n        if(account<len(self.bankaccount) and money<=self.bankaccount[account]):\n            self.bankaccount[account]-=money\n            return True\n        return False"}
{"nl": "A list is special if every even index contains an even number and every odd index contains an odd number. Create a function that returns True if an array is special, and False otherwise.", "code": "def is_special_array(lst):\n        return all(lst[i]%2==i%2 for i in range(len(lst)))"}
{"nl": "In a Red-Black Tree, the maximum height of a node is at most twice the minimum height (The four Red-Black tree properties make sure this is always followed). Given a Binary Search Tree, we need to check for following property. \nFor every node, length of the longest leaf to node path has not more than twice the nodes on shortest path from node to leaf.\n \n\n    12                                        40\n      \\                                     /    \\ \n       14                                 10      100    \n         \\                                        /  \\\n          16                                     60   150    \n Cannot be a Red-Black Tree              It can be Red-Black Tree\n with any color assignment\n Max height of 12 is 1\n Min height of 12 is 3\n\n\n          10\n        /   \\\n      5     100\n           /   \\\n          50   150\n         /\n        40 \n It can also be Red-Black Tree", "code": "\"\"\" Program to check if a given Binary\nTree is balanced like a Red-Black Tree \"\"\"\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pointers.\t\t\t\t\t\t\t\t\nclass newNode:\n\n\t# Construct to create a new node\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# Returns returns tree if the Binary\n# tree is balanced like a Red-Black\n# tree. This function also sets value\n# in maxh and minh (passed by\n# reference). maxh and minh are set\n# as maximum and minimum heights of root.\ndef isBalancedUtil(root, maxh, minh) :\n\n\t# Base case\n\tif (root == None) :\n\t\n\t\tmaxh = minh = 0\n\t\treturn True\n\t\n\n\tlmxh=0\n\t\n\t# To store max and min\n\t# heights of left subtree\n\tlmnh=0\n\t\n\t# To store max and min\n\t# heights of right subtree\n\trmxh, rmnh=0,0\n\n\t# Check if left subtree is balanced,\n\t# also set lmxh and lmnh\n\tif (isBalancedUtil(root.left, lmxh, lmnh) == False) :\n\t\treturn False\n\n\t# Check if right subtree is balanced,\n\t# also set rmxh and rmnh\n\tif (isBalancedUtil(root.right, rmxh, rmnh) == False) :\n\t\treturn False\n\n\t# Set the max and min heights of\n\t# this node for the parent call\n\tmaxh = max(lmxh, rmxh) + 1\n\tminh = min(lmnh, rmnh) + 1\n\n\t# See if this node is balanced\n\tif (maxh <= 2 * minh) :\n\t\treturn True\n\n\treturn False\n\n\n# A wrapper over isBalancedUtil()\ndef isBalanced(root) :\n\n\tmaxh, minh =0,0\n\treturn isBalancedUtil(root, maxh, minh)\n\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(10)\n\troot.left = newNode(5)\n\troot.right = newNode(100)\n\troot.right.left = newNode(50)\n\troot.right.right = newNode(150)\n\troot.right.left.left = newNode(40)\n\tif (isBalanced(root)):\n\t\tprint(\"Balanced\")\n\telse:\n\t\tprint(\"Not Balanced\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Create a function that tweaks letters by one forward (+1) or backwards (-1) according to a list.\nExamples\ntweak_letters(\"apple\", [0, 1, -1, 0, -1]) \u279e \"aqold\"\n# \"p\" + 1 => \"q\"; \"p\" - 1 => \"o\"; \"e\" - 1 => \"d\"\n\ntweak_letters(\"many\", [0, 0, 0, -1]) \u279e \"manx\"\n\ntweak_letters(\"rhino\", [1, 1, 1, 1, 1]) \u279e \"sijop\"\nNotes\nDon't worry about capital letters.", "code": "l = 'abcdefghijklmnopqrstuvwxyz'\ndef tweak_letters(txt, lst):\n  return ''.join([l[(l.find(txt[i]) + lst[i])%26] for i in range(len(lst))])"}
{"nl": "In the previous article, we have discussed Python Program for Given Two Numbers a and b Find all x Such that a % x = b\n Given a string and the task is to remove all the odd occurring characters from the given string.\n Examples:\n Example1:\n Input:\n Given String = \"goodmorning\"\n Output:\n The given string { goodmorning } after removing odd frequency elements is : gnng\n Example2:\n Input:\n Given String = \"thisisbtechgeeks\"\n Output:\n The given string { thisisbtechgeeks } after removing odd frequency elements is : thiith", "code": "# Take a dictionary and initialize it to empty\n \n # using the {} or dict() say freqncyDictionary.\n \n freqncyDictionary = {}\n \n # Give the string as static input and store it in a variable\n \n gvnstrng = \"goodmorning\"\n \n # Loop in the given string using the For loop.\n \n for i in gvnstrng:\n \n  # Inside the For loop,\n \n  # Check if the string character is present in the dictionary\n \n  # or not using the if conditional statement and 'in' keyword.\n \n  if i in freqncyDictionary.keys():\n \n  # If it is true then increment the count of the string character\n \n  # in the dictionary by 1.\n \n  freqncyDictionary[i] = freqncyDictionary[i]+1\n \n  # Else initialize the dictionary with the string character as key and value as 1.\n \n  else:\n \n  freqncyDictionary[i] = 1\n \n # Take a string which stores all the characters which are not occuring odd number\n \n # of times and initialize it to null string using \"\" or str()\n \n modifd_string = \"\"\n \n # loop in the given string using the for loop\n \n for charac in gvnstrng:\n \n \n \n  # check if the character has even frequency by checking value of that character in frequency dictionary\n \n  # we check using the if conditional statement\n \n  if(freqncyDictionary[charac] % 2 == 0):\n \n  # if it is true then concatenate this character to modifd_string using string concatenation\n \n  modifd_string = modifd_string+charac\n \n \n \n \n \n # print the modifd_string string\n \n print('The given string {', gvnstrng,\n \n  '} after removing odd frequency elements is :', modifd_string)"}
{"nl": "Syncopation means an emphasis on a weak beat of a bar of music; most commonly, beats 2 and 4 (and all other even-numbered beats if applicable).\n\nYou will be given a string representing beats, where hashtags # represent emphasized beats. Create a function that returns if the line of music contains any syncopation, and False otherwise.\n\nExamples\n\nhas_syncopation(\".#.#.#.#\") \u279e True\n# There are Hash signs in the second, fourth, sixth and\n# eighth positions of the string.\n\nhas_syncopation(\"#.#...#.\") \u279e False\n# There are no Hash signs in the second, fourth, sixth or\n# eighth positions of the string.\n\nhas_syncopation(\"#.#.###.\") \u279e True\n# There is a Hash sign in the sixth position of the string.\nNotes\n\nAll other unemphasized beats will be represented as a dot.", "code": "def has_syncopation(s):\n  return '#' in s[1::2]"}
{"nl": "A string is an almost-palindrome if, by changing only one character, you can make it a palindrome. Create a function that returns True if a string is an almost-palindrome and False otherwise.\nExamples\nalmost_palindrome(\"abcdcbg\") \u279e True\n# Transformed to \"abcdcba\" by changing \"g\" to \"a\".\n\nalmost_palindrome(\"abccia\") \u279e True\n# Transformed to \"abccba\" by changing \"i\" to \"b\".\n\nalmost_palindrome(\"abcdaaa\") \u279e False\n# Can't be transformed to a palindrome in exactly 1 turn.\n\nalmost_palindrome(\"1234312\") \u279e False\nNotes\nReturn False if the string is already a palindrome.", "code": "def almost_palindrome(txt):\n  return sum(a != b for a, b in zip(txt, txt[::-1])) == 2"}
{"nl": "You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\nThe output order does not matter, returning [9,0] is fine too.\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\n \n\nConstraints:\n\n1 <= s.length <= 104\ns consists of lower-case English letters.\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] consists of lower-case English letters.", "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(s)\n        k = len(words)\n        word_length = len(words[0])\n        substring_size = word_length * k\n        word_count = collections.Counter(words)\n        \n        def sliding_window(left):\n            words_found = collections.defaultdict(int)\n            words_used = 0\n            excess_word = False\n            \n            # Do the same iteration pattern as the previous approach - iterate\n            # word_length at a time, and at each iteration we focus on one word\n            for right in range(left, n, word_length):\n                if right + word_length > n:\n                    break\n\n                sub = s[right : right + word_length]\n                if sub not in word_count:\n                    # Mismatched word - reset the window\n                    words_found = collections.defaultdict(int)\n                    words_used = 0\n                    excess_word = False\n                    left = right + word_length # Retry at the next index\n                else:\n                    # If we reached max window size or have an excess word\n                    while right - left == substring_size or excess_word:\n                        # Move the left bound over continously\n                        leftmost_word = s[left : left + word_length]\n                        left += word_length\n                        words_found[leftmost_word] -= 1\n\n                        if words_found[leftmost_word] == word_count[leftmost_word]:\n                            # This word was the excess word\n                            excess_word = False\n                        else:\n                            # Otherwise we actually needed it\n                            words_used -= 1\n                    \n                    # Keep track of how many times this word occurs in the window\n                    words_found[sub] += 1\n                    if words_found[sub] <= word_count[sub]:\n                        words_used += 1\n                    else:\n                        # Found too many instances already\n                        excess_word = True\n                    \n                    if words_used == k and not excess_word:\n                        # Found a valid substring\n                        answer.append(left)\n        \n        answer = []\n        for i in range(word_length):\n            sliding_window(i)\n\n        return answer"}
{"nl": "Given an array of n elements, where each element is at most k away from its target position, devise an algorithm that sorts in O(n log k) time.\n", "code": "# A Python3 program to sort a\r\n# nearly sorted array.\r\n \r\nfrom heapq import heappop, heappush, heapify\r\n \r\n \r\n# A utility function to print\r\n# array elements\r\ndef print_array(arr: list):\r\n    for elem in arr:\r\n        print(elem, end=' ')\r\n \r\n# Given an array of size n, where every\r\n# element is k away from its target\r\n# position, sorts the array in O(nLogk) time.\r\n \r\n \r\ndef sort_k(arr: list, n: int, k: int):\r\n    \"\"\"\r\n    :param arr: input array\r\n    :param n: length of the array\r\n    :param k: max distance, which every\r\n     element is away from its target position.\r\n    :return: None\r\n    \"\"\"\r\n    # List of first k+1 items\r\n    heap = arr[:k + 1]\r\n \r\n    # using heapify to convert list\r\n    # into heap(or min heap)\r\n    heapify(heap)\r\n \r\n    # \"rem_elmnts_index\" is index for remaining\r\n    # elements in arr and \"target_index\" is\r\n    # target index of for current minimum element\r\n    # in Min Heap \"heap\".\r\n    target_index = 0\r\n    for rem_elmnts_index in range(k + 1, n):\r\n        arr[target_index] = heappop(heap)\r\n        heappush(heap, arr[rem_elmnts_index])\r\n        target_index += 1\r\n \r\n    while heap:\r\n        arr[target_index] = heappop(heap)\r\n        target_index += 1\r\n \r\n \r\n# Driver Code\r\nk = 3\r\narr = [2, 6, 3, 12, 56, 8]\r\nn = len(arr)\r\nsort_k(arr, n, k)\r\n \r\nprint('Following is sorted array')\r\nprint_array(arr)\r\n \r\n# This code is contributed by\r\n# Veerat Beri(viratberi)"}
{"nl": "You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\n\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\nYou choose any number of obstacles between 0 and i inclusive.\nYou must include the ith obstacle in the course.\nYou must put the chosen obstacles in the same order as they appear in obstacles.\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.", "code": "class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        # at every i, we need to find all j <i of height less than i\n        # it also has to be an increasing sequence, which makes it harder\n        n = len(obstacles)\n        ansr = [0]*n\n        ansr[0] = 1\n        \n        # for each obstacle_course_length, keep track of the minimum height\n        lengths = defaultdict(lambda : float('Inf'))\n        lengths[1] = obstacles[0]\n      \n        for i in range(1,n):\n            #binary search lengths from 1 to i: these are possible lengths of the obstacle course for i\n            l,r = 0, i+1\n            while(l<r):\n                mid = (l+r+1)//2 # this is a length\n                #print(l,r,mid)\n                if(lengths[mid] <= obstacles[i]):\n                    l = mid\n                else:\n                    r = mid-1\n                    \n            best = l+1\n            # for j in range(i):\n            #     if(obstacles[j]<=obstacles[i]):\n            #         best = max(best, ansr[j])\n            lengths[best] = min(lengths[best], obstacles[i])\n            ansr[i] = best\n        return ansr"}
{"nl": "PRINCIPAL COMPONENT ANALYSIS: is a tool which is used to reduce the dimension of the data. It allows us to reduce the dimension of the data without much loss of information. PCA reduces the dimension by finding a few orthogonal linear combinations (principal components) of the original variables with the largest variance.", "code": "from sklearn.decomposition import PCA\r\npca = PCA(n_components = 2)\r\nX_pca = pca.fit_transform(X)\r\n   \r\nplt.title(\"PCA\")\r\nplt.scatter(X_pca[:, 0], X_pca[:, 1], c = y)\r\nplt.xlabel(\"Component 1\")\r\nplt.ylabel(\"Component 2\")\r\nplt.show()"}
{"nl": "Given the array houses where houses[i] is the location of the ith house along a street and an integer k, allocate k mailboxes in the street.\nReturn the minimum total distance between each house and its nearest mailbox.\nThe test cases are generated so that the answer fits in a 32-bit integer.\n \nExample 1:\n\n\nInput: houses = [1,4,8,10,20], k = 3\nOutput: 5\nExplanation: Allocate mailboxes in position 3, 9 and 20.\nMinimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n\nExample 2:\n\n\nInput: houses = [2,3,5,12,18], k = 2\nOutput: 9\nExplanation: Allocate mailboxes in position 3 and 14.\nMinimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n\n \nConstraints:\n\n1 <= k <= houses.length <= 100\n1 <= houses[i] <= 104\nAll the integers of houses are unique.", "code": "class Solution:  # 575 ms, faster than 57.25%\n  def minDistance(self, houses: List[int], k: int) -> int:\n  n = len(houses)\n  houses = sorted(houses)\n  costs = [[0] * n for _ in range(n)]\n  for i in range(n):\n  for j in range(n):\n  medianPos = houses[(i + j) // 2]\n  for m in range(i, j + 1):\n  costs[i][j] += abs(medianPos - houses[m])\n\n  @lru_cache(None)\n  def dp(k, i):\n  if k == 0 and i == n: return 0\n  if k == 0 or i == n: return math.inf\n  ans = math.inf\n  for j in range(i, n):\n  cost = costs[i][j]  # Try to put a mailbox among house[i:j]\n  ans = min(ans, cost + dp(k - 1, j + 1))\n  return ans\n\n  return dp(k, 0)"}
{"nl": "Create a function that counts the number of towers.\nExamples\ncount_towers([\n  [\"     ##         \"],\n  [\"##   ##        ##\"],\n  [\"##   ##   ##   ##\"],\n  [\"##   ##   ##   ##\"]\n]) \u279e 4\n\ncount_towers([\n  [\"                         ##\"],\n  [\"##             ##   ##   ##\"],\n  [\"##        ##   ##   ##   ##\"],\n  [\"##   ##   ##   ##   ##   ##\"]\n]) \u279e 6\n\ncount_towers([\n  [\"##\"],\n  [\"##\"]\n]) \u279e 1\nNotes\nYou are given a 2D matrix.\nTowers are two characters in length.\nTowers are made only of the character #.\nSome tests have no towers, return 0.", "code": "def count_towers(towers):\n  return towers[-1][0].count('##')"}
{"nl": "Given a number x and two positions (from the right side) in the binary representation of x, write a function that swaps n bits at given two positions and returns the result. It is also given that the two sets of bits do not overlap.\n", "code": "# Python program to\n# swap bits in a given number\n\ndef swapBits(x, p1, p2, n):\n\n\t# Move all bits of first\n\t# set to rightmost side\n\tset1 = (x >> p1) & ((1<< n) - 1)\n\n\t# Move all bits of second\n\t# set to rightmost side\n\tset2 = (x >> p2) & ((1 << n) - 1)\n\n\t# XOR the two sets\n\txor = (set1 ^ set2)\n\n\t# Put the xor bits back\n\t# to their original positions\n\txor = (xor << p1) | (xor << p2)\n\n\t# XOR the 'xor' with the\n\t# original number so that the\n\t# two sets are swapped\n\tresult = x ^ xor\n\n\treturn result\n\t\n# Driver code\n\nres = swapBits(28, 0, 3, 2)\nprint(\"Result =\", res)\n\n# This code is contributed\n# by Anant Agarwal."}
{"nl": "In the previous article, we have discussed Python Program to Check Strontio Number or Not.\nGiven the Date of Birth and task is to calculate the corresponding age in days.\n\ndatetime module:\n\nThe datetime module contains numerous classes that can be used to manipulate date and time in both simple and complex ways.\n\nIn this, the date is formatted as the year month date (YY, MM, DD).\n\ndatetime.today() :The current date/system date is returned by datetime.today().\n\nTo calculate age from date of birth, subtract the date of birth from the current date.\n\ntimedelta() function in Python:\n\nThe Python timedelta() function is part of the datetime library and is commonly used for calculating date differences. It can also be used for date manipulation in Python. It is one of the simplest methods for manipulating dates.\n\nExamples:\n\nExample1:\n\nInput:\n\nGiven Date of Birth = (2000, 3, 14)\nOutput:\n\nThe age in days and time for the Given DOB =  7823 days, 14:16:13.409557", "code": "# Import datetime(), timedelta() functions from datetime module using import keyword.\nfrom datetime import datetime, timedelta\n# Give the date of birth as static input in the format (YY, MM, DD) using datetime() function\n# and store it in a variable.\ngvn_DOB = datetime(1999, 5, 16)\n# Get the current/today date using datetime.today() function and store it in\n# another variable.\ncurrent_date = datetime.today()\n# Subtract the given date of birth from the current date to get the age in days\n# and store it in another variable.\nage_in_days = current_date - gvn_DOB\n# Print the age in days and time from the given date of birth.\nprint(\"The age in days and time for the Given DOB = \", age_in_days)"}
{"nl": "The power of lambda is better shown when you use them as an anonymous function inside another function.\r\n\r\nSay you have a function definition that takes one argument, and that argument will be multiplied with an unknown number:", "code": "def myfunc(n):\r\n  return lambda a : a * n\r\n\r\nmytripler = myfunc(3)\r\n\r\nprint(mytripler(11))"}
{"nl": "Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.\nReturn the sorted array.\n \nExample 1:\n\nInput: nums = [1,1,2,2,2,3]\nOutput: [3,1,1,2,2,2]\nExplanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.\n\nExample 2:\n\nInput: nums = [2,3,1,3,2]\nOutput: [1,3,3,2,2]\nExplanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.\n\nExample 3:\n\nInput: nums = [-1,1,-6,4,5,-6,1,4,1]\nOutput: [5,-1,4,4,-6,-6,1,1,1]\n \nConstraints:\n\n1 <= nums.length <= 100\n-100 <= nums[i] <= 100", "code": "class Solution:\n  def frequencySort(self, nums: List[int]) -> List[int]:\n  r = Counter(nums)\n  return sorted(nums, key=lambda x: (r[x], -x))"}
{"nl": "Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.\nA grid is said to be valid if all the cells above the main diagonal are zeros.\nReturn the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.\nThe main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).\n \nExample 1:\n\n\nInput: grid = [[0,0,1],[1,1,0],[1,0,0]]\nOutput: 3\n\nExample 2:\n\n\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\nOutput: -1\nExplanation: All rows are similar, swaps have no effect on the grid.\n\nExample 3:\n\n\nInput: grid = [[1,0,0],[1,1,0],[1,1,1]]\nOutput: 0\n\n \nConstraints:\n\nn == grid.length == grid[i].length\n1 <= n <= 200\ngrid[i][j] is either 0 or 1", "code": "class Solution:\n  def minSwaps(self, grid: List[List[int]]) -> int:\n  n = len(grid)\n  \n  def count(arr):\n  ans = 0\n  for i in range(n-1, -1, -1):\n  if arr[i] == 0:\n  ans += 1\n  else:\n  break\n  return ans\n  \n  arr = [count(row) for row in grid]\n  ans = 0\n  for i in range(n):\n  target = n - i - 1\n  if arr[i] >= target:\n  continue\n  flag = False\n  for j in range(i+1, n):\n  if arr[j] >= target:\n  flag = True\n  ans += (j - i)\n  arr[i+1:j+1] = arr[i:j]\n  break\n  if not flag:\n  return -1\n  \n  return ans"}
{"nl": "Print Odd Numbers Within a Given Range Using for loop(Static Input) ", "code": "# Give the lower limit and upper limit as static input\r\n# and store them in two separate variables.\r\n# given lower limit range\r\nlowLimitRange = 23\r\n# given upper limit range\r\nuppLimitRange = 143\r\nprint('Odd numbers from', lowLimitRange, 'to', uppLimitRange, 'are :')\r\n# Loop from lower limit range to upper limit range using For loop.\r\nfor iterval in range(lowLimitRange, uppLimitRange+1):\r\n    # Check if the iterator value is even or odd using if statement and modulus operator.\r\n    if(iterval % 2 != 0):\r\n        # If the iterator value is odd then print it.\r\n        print(iterval, end=\" \")"}
{"nl": "Write a program to use string.format() method to format the following three variables as per the expected output", "code": "quantity = 3\ntotalMoney = 1000\nprice = 450\nstatement1 = \"I have {1} dollars so I can buy {0} football for {2:.2f} dollars.\"\nprint(statement1.format(quantity, totalMoney, price))"}
{"nl": "Given two unsorted arrays that represent two sets (elements in every array are distinct), find the union and intersection of two arrays.", "code": "# Python3 program to find union and intersection\r\n# using similar Hashing Technique\r\n# without using any predefined Java Collections\r\n# Time Complexity best case & avg case = O(m+n)\r\n# Worst case = O(nlogn)\r\n\r\n\r\n# Prints intersection of arr1[0..n1-1] and\r\n# arr2[0..n2-1]\r\ndef findPosition(a, b):\r\n\tv = len(a) + len(b);\r\n\tans = [0]*v;\r\n\tzero1 = zero2 = 0;\r\n\tprint(\"Intersection :\",end=\" \");\r\n\t\r\n\t# Iterate first array\r\n\tfor i in range(len(a)):\r\n\t\tzero1 = iterateArray(a, v, ans, i);\r\n\t\r\n\t# Iterate second array\r\n\tfor j in range(len(b)):\r\n\t\tzero2 = iterateArray(b, v, ans, j);\r\n\t\r\n\tzero = zero1 + zero2;\r\n\tplaceZeros(v, ans, zero);\r\n\tprintUnion(v, ans, zero);\r\n\t\r\n# Prints union of arr1[0..n1-1] and arr2[0..n2-1]\r\ndef printUnion(v, ans,zero):\r\n\tzero1 = 0;\r\n\tprint(\"\\nUnion :\",end=\" \");\r\n\tfor i in range(v):\r\n\t\tif ((zero == 0 and ans[i] == 0) or\r\n\t\t\t(ans[i] == 0 and zero1 > 0)):\r\n\t\t\tcontinue;\r\n\t\tif (ans[i] == 0):\r\n\t\t\tzero1+=1;\r\n\t\tprint(ans[i],end=\",\");\r\n\r\ndef placeZeros(v, ans, zero):\r\n\tif (zero == 2):\r\n\t\tprint(\"0\");\r\n\t\td = [0];\r\n\t\tplaceValue(d, ans, 0, 0, v);\r\n\tif (zero == 1):\r\n\t\td=[0];\r\n\t\tplaceValue(d, ans, 0, 0, v);\r\n\r\n# Function to iterate array\r\ndef iterateArray(a,v,ans,i):\r\n\tif (a[i] != 0):\r\n\t\tp = a[i] % v;\r\n\t\tplaceValue(a, ans, i, p, v);\r\n\telse:\r\n\t\treturn 1;\r\n\t\r\n\treturn 0;\r\n\r\ndef placeValue(a,ans,i,p,v):\r\n\tp = p % v;\r\n\tif (ans[p] == 0):\r\n\t\tans[p] = a[i];\r\n\telse:\r\n\t\tif (ans[p] == a[i]):\r\n\t\t\tprint(a[i],end=\",\");\r\n\t\telse:\r\n\t\t\t# Hashing collision happened increment\r\n\t\t\t# position and do recursive call\r\n\t\t\tp = p + 1;\r\n\t\t\tplaceValue(a, ans, i, p, v);\r\n\r\n# Driver code\r\na = [ 7, 1, 5, 2, 3, 6 ];\r\nb = [ 3, 8, 6, 20, 7 ];\r\nfindPosition(a, b);\r\n\r\n# This code is contributed by mits\r"}
{"nl": "iven an array, the task is to find if the input array contains a majority element or not.", "code": "# Hashing based Python\r\n# program to find if\r\n# there is a majority\r\n# element in input array.\r\n\r\n# Returns true if there\r\n# is a majority element\r\n# in a[]\r\ndef isMajority(a):\r\n\t\r\n\t# Insert all elements\r\n\t# in a hash table\r\n\tmp = {}\r\n\t\r\n\tfor i in a:\r\n\t\tif i in mp: mp[i] += 1\r\n\t\telse: mp[i] = 1\r\n\t\r\n\t# Check if frequency\r\n\t# of any element is\r\n\t# n/2 or more.\r\n\tfor x in mp:\r\n\t\tif mp[x] >= len(a)//2:\r\n\t\t\treturn True\r\n\treturn False\r\n\r\n# Driver code\r\na = [ 2, 3, 9, 2, 2 ]\r\n\r\nprint(\"Yes\" if isMajority(a) else \"No\")\r\n\r\n#This code is contributed by Ansu Kumari\r"}
{"nl": "Given a number \u2018n\u2019 and the task is to find the double factorial of a given number.", "code": "# Give the number as static input and store it in a variable.\nnumbr = 8\n# Take a variable, initialize it with the value '1', and store it in another\n# variable say 'c'.\nc = 1\n# Loop from the given number to 0 in decreasing order with the stepsize of -2\n# using the for loop.\nfor i in range(numbr, 0, -2):\n    # Inside the loop multiply the above initialized variable c with the iterator value\n    # and store it in the same variable 'c'.\n    c *= i\n # Print the double factorial of a given number.\nprint(\"The double factorial of a given number{\", numbr, \"} = \", c)"}
{"nl": "Definition and Usage\r\nThe get() method returns the value of the item with the specified key.\n", "code": "car = {\r\n  \"brand\": \"Ford\",\r\n  \"model\": \"Mustang\",\r\n  \"year\": 1964\r\n}\r\n\r\nx = car.get(\"model\")\r\n\r\nprint(x)"}
{"nl": "Steps to follow for deletion. \r\nTo make sure that the given tree remains AVL after every deletion, we must augment the standard BST delete operation to perform some re-balancing. Following are two basic operations that can be performed to re-balance a BST without violating the BST property (keys(left) < key(root) < keys(right)). ", "code": "# Python code to delete a node in AVL tree\n# Generic tree node class\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n \n# AVL tree class which supports insertion,\n# deletion operations\nclass AVL_Tree(object):\n \n    def insert(self, root, key):\n         \n        # Step 1 - Perform normal BST\n        if not root:\n            return TreeNode(key)\n        elif key < root.val:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n \n        # Step 2 - Update the height of the\n        # ancestor node\n        root.height = 1 + max(self.getHeight(root.left),\n                          self.getHeight(root.right))\n \n        # Step 3 - Get the balance factor\n        balance = self.getBalance(root)\n \n        # Step 4 - If the node is unbalanced,\n        # then try out the 4 cases\n        # Case 1 - Left Left\n        if balance > 1 and key < root.left.val:\n            return self.rightRotate(root)\n \n        # Case 2 - Right Right\n        if balance < -1 and key > root.right.val:\n            return self.leftRotate(root)\n \n        # Case 3 - Left Right\n        if balance > 1 and key > root.left.val:\n            root.left = self.leftRotate(root.left)\n            return self.rightRotate(root)\n \n        # Case 4 - Right Left\n        if balance < -1 and key < root.right.val:\n            root.right = self.rightRotate(root.right)\n            return self.leftRotate(root)\n \n        return root\n \n    # Recursive function to delete a node with\n    # given key from subtree with given root.\n    # It returns root of the modified subtree.\n    def delete(self, root, key):\n \n        # Step 1 - Perform standard BST delete\n        if not root:\n            return root\n \n        elif key < root.val:\n            root.left = self.delete(root.left, key)\n \n        elif key > root.val:\n            root.right = self.delete(root.right, key)\n \n        else:\n            if root.left is None:\n                temp = root.right\n                root = None\n                return temp\n \n            elif root.right is None:\n                temp = root.left\n                root = None\n                return temp\n \n            temp = self.getMinValueNode(root.right)\n            root.val = temp.val\n            root.right = self.delete(root.right,\n                                      temp.val)\n \n        # If the tree has only one node,\n        # simply return it\n        if root is None:\n            return root\n \n        # Step 2 - Update the height of the\n        # ancestor node\n        root.height = 1 + max(self.getHeight(root.left),\n                            self.getHeight(root.right))\n \n        # Step 3 - Get the balance factor\n        balance = self.getBalance(root)\n \n        # Step 4 - If the node is unbalanced,\n        # then try out the 4 cases\n        # Case 1 - Left Left\n        if balance > 1 and self.getBalance(root.left) >= 0:\n            return self.rightRotate(root)\n \n        # Case 2 - Right Right\n        if balance < -1 and self.getBalance(root.right) <= 0:\n            return self.leftRotate(root)\n \n        # Case 3 - Left Right\n        if balance > 1 and self.getBalance(root.left) < 0:\n            root.left = self.leftRotate(root.left)\n            return self.rightRotate(root)\n \n        # Case 4 - Right Left\n        if balance < -1 and self.getBalance(root.right) > 0:\n            root.right = self.rightRotate(root.right)\n            return self.leftRotate(root)\n \n        return root\n \n    def leftRotate(self, z):\n \n        y = z.right\n        T2 = y.left\n \n        # Perform rotation\n        y.left = z\n        z.right = T2\n \n        # Update heights\n        z.height = 1 + max(self.getHeight(z.left),\n                         self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                         self.getHeight(y.right))\n \n        # Return the new root\n        return y\n \n    def rightRotate(self, z):\n \n        y = z.left\n        T3 = y.right\n \n        # Perform rotation\n        y.right = z\n        z.left = T3\n \n        # Update heights\n        z.height = 1 + max(self.getHeight(z.left),\n                          self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                          self.getHeight(y.right))\n \n        # Return the new root\n        return y\n \n    def getHeight(self, root):\n        if not root:\n            return 0\n \n        return root.height\n \n    def getBalance(self, root):\n        if not root:\n            return 0\n \n        return self.getHeight(root.left) - self.getHeight(root.right)\n \n    def getMinValueNode(self, root):\n        if root is None or root.left is None:\n            return root\n \n        return self.getMinValueNode(root.left)\n \n    def preOrder(self, root):\n \n        if not root:\n            return\n \n        print(\"{0} \".format(root.val), end=\"\")\n        self.preOrder(root.left)\n        self.preOrder(root.right)\n \n \nmyTree = AVL_Tree()\nroot = None\nnums = [9, 5, 10, 0, 6, 11, -1, 1, 2]\n \nfor num in nums:\n    root = myTree.insert(root, num)\n \n# Preorder Traversal\nprint(\"Preorder Traversal after insertion -\")\nmyTree.preOrder(root)\nprint()\n \n# Delete\nkey = 10\nroot = myTree.delete(root, key)\n \n# Preorder Traversal\nprint(\"Preorder Traversal after deletion -\")\nmyTree.preOrder(root)\nprint()\n \n# This code is contributed by Ajitesh Pathak"}
{"nl": "User Input: Shuffle Elements of a Tuple", "code": "# Import the random module using import method.\r\nimport random\r\n# Give the tuple as user input using tuple(),map(),input(),and split() functions\r\n#and Store it in a variable.\r\ngvn_tup = tuple(map(int, input(\r\n   'Enter some random tuple Elements separated by spaces = ').split()))\r\n# Convert the given tuple into list using the list() function and\r\n# store it in another variable.\r\nlst = list(gvn_tup)\r\n# Apply random.shuffle() method on the above obtained list .\r\nrandom.shuffle(lst)\r\n# Convert the above shuffled list into tuple again using the tuple() function\r\n# and store it in another variable.\r\nshuffld_tupl = tuple(lst)\r\n# Print the above given tuple after shuffling the elements of a given tuple.\r\nprint(\"The given tuple after Shuffling the elements = \", shuffld_tupl)"}
{"nl": "Given a string, the task is to check if all characters of the string are alphanumeric or not. \nThe isalnum() Method is a String Class pre-defined method that can be used on any String Object. It returns Boolean Values based on the following criteria.\nIf all of the characters in the given string are Alphanumerical, it returns True.\nIf any of the characters in the given string are not Alphanumerical, this function returns False.", "code": "# Give the string as user input using the input()function and store it in a variable.\ngvn_strng = input('Enter some random string = ')\n# Check whether the Given string is alphanumeric using built-in alnum() method\n# and store it in another variable.\nBol_val = gvn_strng.isalnum()\n# Check whether the above result is True or not using the if conditional statement.\nif(Bol_val == True):\n # If it is True, Print the given string is  alphanumeric.\n    print(\"The Given string {\", gvn_strng, \"} is Alpha Numeric\")\nelse:\n  # If it is False, Print the given string is not alphanumeric.\n    print(\"The Given string {\", gvn_strng, \"} is not Alpha Numeric\")"}
{"nl": "Loops Inside Loops\r\nA nested loop is a loop inside a loop.\r\n\r\nThe \"inner loop\" will be executed one time for each iteration of the \"outer loop\":", "code": "adj = [\"red\", \"big\", \"tasty\"]\r\nfruits = [\"apple\", \"banana\", \"cherry\"]\r\n\r\nfor x in adj:\r\n  for y in fruits:\r\n    print(x, y)"}
{"nl": "Sometimes it is necessary to define a custom data structure of some type, like a set. In this exercise you will define your own set. How it works internally doesn't matter, as long as it behaves like a set of unique elements.", "code": "class CustomSet(object):\n    def __init__(self, elements=[]):\n        self.elements = []\n        for element in elements:\n            self.add(element)\n    def isempty(self):\n        return len(self.elements) == 0\n    def __contains__(self, element):\n        return element in self.elements\n    def issubset(self, other):\n        for element in self.elements:\n            if element not in other.elements:\n                return False\n        return True\n    def isdisjoint(self, other):\n        for element in self.elements:\n            if element in other.elements:\n                return False\n        return True\n    def __eq__(self, other):\n        if len(self.elements) != len(other.elements):\n            return False\n        else:\n            for element in self.elements:\n                if element not in other.elements:\n                    return False\n            return True\n    def add(self, element):\n        if element not in self.elements:\n            self.elements.append(element)\n    def intersection(self, other):\n        result_elements = []\n        for element in self.elements:\n            if element in other.elements:\n                result_elements.append(element)\n        return CustomSet(result_elements)\n    def __sub__(self, other):\n        result_elements = []\n        for element in self.elements:\n            if element not in other.elements:\n                result_elements.append(element)\n        return CustomSet(result_elements)\n    def __add__(self, other):\n        result = CustomSet(self.elements)\n        for element in other.elements:\n            result.add(element)\n        return result"}
{"nl": "An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes.\nGiven an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj .\nReturn a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.\n \nExample 1:\n\n\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\nOutput: [false,true]\nExplanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\nFor the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\nFor the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.\n\nExample 2:\n\n\nInput: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\nOutput: [true,false]\nExaplanation: The above figure shows the given graph.\n\n \nConstraints:\n\n2 <= n <= 105\n1 <= edgeList.length, queries.length <= 105\nedgeList[i].length == 3\nqueries[j].length == 3\n0 <= ui, vi, pj, qj <= n - 1\nui != vi\npj != qj\n1 <= disi, limitj <= 109\nThere may be multiple edges between two nodes.", "code": "class UnionFind:\n  def __init__(self, N: int):\n  self.parent = list(range(N))\n  self.rank = [1] * N\n\n  def find(self, p: int) -> int:\n  if p != self.parent[p]:\n  self.parent[p] = self.find(self.parent[p])\n  return self.parent[p]\n\n  def union(self, p: int, q: int) -> bool:\n  prt, qrt = self.find(p), self.find(q)\n  if prt == qrt: return False \n  if self.rank[prt] > self.rank[qrt]: \n  prt, qrt = qrt, prt \n  self.parent[prt] = qrt \n  self.rank[qrt] += self.rank[prt] \n  return True \n\n\nclass Solution:\n  def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n  queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\n  edgeList = sorted((w, u, v) for u, v, w in edgeList)\n  \n  uf = UnionFind(n)\n  \n  ans = [None] * len(queries)\n  ii = 0\n  for w, p, q, i in queries: \n  while ii < len(edgeList) and edgeList[ii][0] < w: \n  _, u, v = edgeList[ii]\n  uf.union(u, v)\n  ii += 1\n  ans[i] = uf.find(p) == uf.find(q)\n  return ans"}
{"nl": "Files in Python:\n\nPython file handling is a way of saving program output to a file or reading data from a file. File handling is a crucial concept in the programming world. File management is used in almost every form of project. Assume you are constructing an inventory management system. You have data in the inventory management system related to sales and purchases, thus you must save that data somewhere. Using Python\u2019s file management, you can save that data to a file. You must be given data in the form of a comma-separated file or a Microsoft Excel file if you wish to conduct data analysis. Using file handling, you can read data from a file and write output back into it.\n\nfileno() Method in Python:\n\nThe fileno() function is a built-in Python method that returns the file number, i.e. the file descriptor, as an integer of the stream. If the operating system does not use a file descriptor when the file is closed, it may return an error.\n\nSyntax:\n\nfile.fileno()\nParameters: This method doesn\u2019t accept any parameters\n\nReturn Value: This method\u2019s return type is class \u2018int\u2019>; it returns an integer value that is the file descriptor of a file.", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\ngvn_file = open(givenFilename, 'r') \n# Get the file descriptor of a file using the fileno() function and store it in a variable\nrslt= gvn_file.fileno()\n# Print the above result\nprint(rslt)"}
{"nl": "This python program multiplies twoo numbers given by user and display output in standard output unit.\r\nIn this example, we first read two number from user using built-in function input(). Since function input() returns string value, we need to convert them to number type. And then given numbers are multiplied simply by * operator to get desired result.", "code": "# Python program to find\r\n# multiply two numbers\r\n\r\n# Reading two numbers\r\nnumber1 = input('Enter first number: ')\r\nnumber2 = input('Enter second number: ')\r\n\r\n# Converting to float\r\n# Conversion is required because\r\n# input() function return string\r\nnumber1 = float(number1)\r\nnumber2 = float(number2)\r\n\r\n# Multiplication\r\nresult = number1 * number2\r\n\r\n# Displaying result\r\nprint('%0.2f * %0.2f = %0.2f' % (number1, number2, result))"}
{"nl": "Check Perfect Number\r", "code": "# Python program to check Perfect Number\r\n\r\n# Function to check perfect number\r\ndef is_perfect(n):\r\n\r\n    perfect_sum = 0\r\n    \r\n    for i in range(1,n):\r\n        if n%i==0:\r\n            perfect_sum += i\r\n\r\n    return perfect_sum == n\r\n\r\n# Reading number\r\nnumber = int(input('Enter number: '))\r\n\r\n# Function call & Decision\r\nif is_perfect(number):\r\n    print('%d is PERFECT' %(number))\r\nelse:\r\n    print('%d is NOT PERFECT' %(number))"}
{"nl": "Return maximum occurring character in an input string", "code": "# Python program to return the maximum occurring character in the input string\nASCII_SIZE = 256\n\ndef getMaxOccurringChar(str):\n\t# Create array to keep the count of individual characters\n\t# Initialize the count array to zero\n\tcount = [0] * ASCII_SIZE\n\n\t# Utility variables\n\tmax = -1\n\tc = ''\n\n\t# Traversing through the string and maintaining the count of\n\t# each character\n\tfor i in str:\n\t\tcount[ord(i)]+=1;\n\n\tfor i in str:\n\t\tif max < count[ord(i)]:\n\t\t\tmax = count[ord(i)]\n\t\t\tc = i\n\n\treturn c\n\n# Driver program to test the above function\nstr = \"sample string\"\nprint(\"Max occurring character is\",getMaxOccuringChar(str))\n\n# Although this program can be written in atmost 3 lines in Python\n# the above program has been written for a better understanding of\n# the reader\n\n# Shorter version of the program\n# import collections\n# str = \"sample string\"\n# print \"Max occurring character is \" +\n#\t collections.Counter(str).most_common(1)[0][0]\n\n# This code has been contributed by Bhavya Jain"}
{"nl": "Growable array based stack", "code": "# Python3 Program to implement growable array based stack\n# using tight strategy\n\u00a0\n# constant amount at which stack is increased\nBOUND = 4\n\u00a0\n# top of the stack\ntop = -1;\na = []\n\u00a0\n# length of stack\nlength = 0;\n\u00a0\n# function to create new stack\ndef create_new():\n\u00a0\u00a0\u00a0\u00a0global length;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# allocate memory for new stack\n\u00a0\u00a0\u00a0\u00a0new_a = [0 for i in range(length + BOUND)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# copying the content of old stack\n\u00a0\u00a0\u00a0\u00a0for i in range(length):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new_a[i] = a[i];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# re-sizing the length\n\u00a0\u00a0\u00a0\u00a0length += BOUND;\n\u00a0\u00a0\u00a0\u00a0return new_a\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# function to push new element\ndef push( element):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0global top, a\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if stack is full, create new one\n\u00a0\u00a0\u00a0\u00a0if (top == length - 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a = create_new();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0top +=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# insert element at top of the stack\n\u00a0\u00a0\u00a0\u00a0a[top] = element;\n\u00a0\u00a0\u00a0\u00a0return a;\n\u00a0\n# function to pop an element\ndef pop():\n\u00a0\u00a0\u00a0\u00a0global top\n\u00a0\u00a0\u00a0\u00a0top -= 1;\n\u00a0\n# function to display\ndef display():\n\u00a0\u00a0\u00a0\u00a0global top\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if top is -1, that means stack is empty\n\u00a0\u00a0\u00a0\u00a0if (top == -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack is Empty\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack: \", end = '')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(top + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[i], end = ' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\nif __name__=='__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# creating initial stack\n\u00a0\u00a0\u00a0\u00a0a = create_new();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# pushing element to top of stack\n\u00a0\u00a0\u00a0\u00a0push(1);\n\u00a0\u00a0\u00a0\u00a0push(2);\n\u00a0\u00a0\u00a0\u00a0push(3);\n\u00a0\u00a0\u00a0\u00a0push(4);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# pushing more element when stack is full\n\u00a0\u00a0\u00a0\u00a0push(5);\n\u00a0\u00a0\u00a0\u00a0push(6);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0push(7);\n\u00a0\u00a0\u00a0\u00a0push(8);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# pushing more element so that stack can grow\n\u00a0\u00a0\u00a0\u00a0push( 9);\n\u00a0\u00a0\u00a0\u00a0display();\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "Check if Tree is Symmetric", "code": "# Python program to check if a\r\n# given Binary Tree is symmetric or not\r\n\r\n# Node structure\r\n\r\n\r\nclass Node:\r\n\r\n\t# Utility function to create new node\r\n\tdef __init__(self, key):\r\n\t\tself.key = key\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# Returns True if trees\r\n#with roots as root1 and root 2 are mirror\r\n\r\n\r\ndef isMirror(root1, root2):\r\n\t# If both trees are empty, then they are mirror images\r\n\tif root1 is None and root2 is None:\r\n\t\treturn True\r\n\r\n\t\"\"\" For two trees to be mirror images,\r\n\t\tthe following three conditions must be true\r\n\t\t1 - Their root node's key must be same\r\n\t\t2 - left subtree of left tree and right subtree\r\n\t\tof the right tree have to be mirror images\r\n\t\t3 - right subtree of left tree and left subtree\r\n\t\tof right tree have to be mirror images\r\n\t\"\"\"\r\n\tif (root1 is not None and root2 is not None):\r\n\t\tif root1.key == root2.key:\r\n\t\t\treturn (isMirror(root1.left, root2.right)and\r\n\t\t\t\t\tisMirror(root1.right, root2.left))\r\n\r\n\t# If none of the above conditions is true then root1\r\n\t# and root2 are not mirror images\r\n\treturn False\r\n\r\n\r\ndef isSymmetric(root):\r\n\r\n\t# Check if tree is mirror of itself\r\n\treturn isMirror(root, root)\r\n\r\n\r\n# Driver Code\r\n# Let's construct the tree show in the above figure\r\nroot = Node(1)\r\nroot.left = Node(2)\r\nroot.right = Node(2)\r\nroot.left.left = Node(3)\r\nroot.left.right = Node(4)\r\nroot.right.left = Node(4)\r\nroot.right.right = Node(3)\r\nprint (\"Symmetric\" if isSymmetric(root) == True else \"Not symmetric\")\r\n\r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\r"}
{"nl": "Python Program to Read and Display a Matrix", "code": "# Give the number of rows of the matrix as user input using the int(input()) function\n # and store it in a variable.\n mtrxrows = int(input('Enter some random number of rows of the matrix = '))\n # Give the number of columns of the matrix as user input using the int(input()) function\n # and store it in another variable.\n mtrxcols = int(input('Enter some random number of columns of the matrix = '))\n # Take a list and initialize it with an empty value using [] or list() to say gvnmatrix.\n mtrx = []\n # Loop till the given number of rows using the For loop\n for n in range(mtrxrows):\n  # Inside the For loop, Give all the row elements of the given Matrix as a list using\n  # the list(),map(),int(),split() functions and store it in a variable.\n  l = list(map(int, input(\n  'Enter {'+str(mtrxcols)+'} elements of row {'+str(n+1)+'} separated by spaces = ').split()))\n  # Add the above row elements list to gvnmatrix using the append() function.\n  mtrx.append(l)\n # To print all the elements of the given matrix.\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of rows using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Print the element of the matrix by printing gvnmatrix[n][m] value\n  # where n is the iterator value of the parent For loop and m is the iterator\n  # value of the inner For loop.\n  print(mtrx[n][m], end=' ')\n  print()"}
{"nl": "Get a dictionary from an object\u2019s fields", "code": "# Create a class say student\nclass student:\n  # Create a constructor function which initializes the default values of all the variables \n  def __init__(self):\n  #Taking some random class/Instance variables and intializing them with some random values \n  self.rollno = 1\n  self.marks = 85\n  # Creating a method/function to print all the variables values of the class object\n  def display(self):\n  print('The values of roll number and marks are :',self.rollno, self.marks)\n# Creating object of the above class\nresult = student()\n# Calling the display() method of the student class using the above created object\nresult.display()\n# Calling the __dict__ attribute on the above created object and printing it\nprint(result.__dict__)"}
{"nl": "Print BST keys in given Range | O(1) Space", "code": "# Python3 code to print BST keys in given Range\n# in constant space using Morris traversal.\n\u00a0\n# Helper function to create a new node\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Function to print the keys in range\ndef RangeTraversal(root, n1, n2):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0curr = root\n\u00a0\u00a0\u00a0\u00a0while curr:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if curr.left == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check if current node lies\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# between n1 and n2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if curr.data <= n2 and curr.data >= n1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(curr.data, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr = curr.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre = curr.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# finding the inorder predecessor-\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# inorder predecessor is the right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# most in left subtree or the left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# child, i.e in BST it is the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# maximum(right most) in left subtree.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (pre.right != None and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre.right != curr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre = pre.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if pre.right == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre.right = curr;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr = curr.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pre.right = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check if current node lies\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# between n1 and n2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if curr.data <= n2 and curr.data >= n1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(curr.data, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr = curr.right\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructed binary tree is\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 4\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0 / \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 2\u00a0\u00a0\u00a0\u00a0\u00a0 7\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0 / \\ / \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0 1\u00a0 3 6 10\n\u00a0\u00a0\u00a0\u00a0root = newNode(4)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(7)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(1)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(3)\n\u00a0\u00a0\u00a0\u00a0root.right.left = newNode(6)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(10)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0RangeTraversal(root, 4, 12)\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Dice Score", "code": "def dice_score(throw):\n  threes = [0,1000,200,300,400,500,600]\n    tot = 0\n  for i in set(throw):\n    if throw.count(i) >=3: tot += threes[i]\n    if i ==1:\n      tot += throw.count(i)%3*100\n    if i ==5:\n      tot += throw.count(i)%3*50\n    return tot"}
{"nl": "Get the Date", "code": "import datetime\ndef get_day(day):\n  m,d,y = [int(i) for i in day.split('/')]\n  days = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']\n  return days[datetime.date(y,m,d).weekday()]"}
{"nl": "the minimum number of candies to distribute to the children", "code": "class Solution:\n    def candy(self, R):\n        n, ans = len(R), [1]*len(R)\n        \n        for i in range(n-1):\n            if R[i] < R[i+1]:\n                ans[i+1] = max(1 + ans[i], ans[i+1])\n                \n        for i in range(n-2, -1, -1):\n            if R[i+1] < R[i]:\n                ans[i] = max(1 + ans[i+1], ans[i])\n        \n        return sum(ans)"}
{"nl": "Python Set difference() Method", "code": "x = {\"apple\", \"banana\", \"cherry\"}\r\ny = {\"google\", \"microsoft\", \"apple\"}\r\n\r\nz = x.difference(y)\r\n\r\nprint(z)"}
{"nl": "Print Common Nodes in Two Binary Search Trees", "code": "# Python3 program of iterative traversal based\n# method to find common elements in two BSTs.\n\n# A utility function to create a new node\nclass newNode:\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = self.right = None\n\n# Function two print common elements\n# in given two trees\ndef printCommon(root1, root2):\n\t\n\t# Create two stacks for two inorder\n\t# traversals\n\ts1 = []\n\ts2 = []\n\n\twhile 1:\n\t\t\n\t\t# append the Nodes of first\n\t\t# tree in stack s1\n\t\tif root1:\n\t\t\ts1.append(root1)\n\t\t\troot1 = root1.left\n\n\t\t# append the Nodes of second tree\n\t\t# in stack s2\n\t\telif root2:\n\t\t\ts2.append(root2)\n\t\t\troot2 = root2.left\n\n\t\t# Both root1 and root2 are NULL here\n\t\telif len(s1) != 0 and len(s2) != 0:\n\t\t\troot1 = s1[-1]\n\t\t\troot2 = s2[-1]\n\n\t\t\t# If current keys in two trees are same\n\t\t\tif root1.key == root2.key:\n\t\t\t\tprint(root1.key, end = \" \")\n\t\t\t\ts1.pop(-1)\n\t\t\t\ts2.pop(-1)\n\n\t\t\t\t# move to the inorder successor\n\t\t\t\troot1 = root1.right\n\t\t\t\troot2 = root2.right\n\n\t\t\telif root1.key < root2.key:\n\t\t\t\t\n\t\t\t\t# If Node of first tree is smaller, than\n\t\t\t\t# that of second tree, then its obvious\n\t\t\t\t# that the inorder successors of current\n\t\t\t\t# Node can have same value as that of the\n\t\t\t\t# second tree Node. Thus, we pop from s2\n\t\t\t\ts1.pop(-1)\n\t\t\t\troot1 = root1.right\n\n\t\t\t\t# root2 is set to NULL, because we need\n\t\t\t\t# new Nodes of tree 1\n\t\t\t\troot2 = None\n\t\t\telif root1.key > root2.key:\n\t\t\t\ts2.pop(-1)\n\t\t\t\troot2 = root2.right\n\t\t\t\troot1 = None\n\n\t\t# Both roots and both stacks are empty\n\t\telse:\n\t\t\tbreak\n\n# A utility function to do inorder traversal\ndef inorder(root):\n\tif root:\n\t\tinorder(root.left)\n\t\tprint(root.key, end = \" \")\n\t\tinorder(root.right)\n\n# A utility function to insert a new Node\n# with given key in BST\ndef insert(node, key):\n\t\n\t# If the tree is empty, return a new Node\n\tif node == None:\n\t\treturn newNode(key)\n\n\t# Otherwise, recur down the tree\n\tif key < node.key:\n\t\tnode.left = insert(node.left, key)\n\telif key > node.key:\n\t\tnode.right = insert(node.right, key)\n\t\t\n\t# return the (unchanged) Node pointer\n\treturn node\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# Create first tree as shown in example\n\troot1 = None\n\troot1 = insert(root1, 5)\n\troot1 = insert(root1, 1)\n\troot1 = insert(root1, 10)\n\troot1 = insert(root1, 0)\n\troot1 = insert(root1, 4)\n\troot1 = insert(root1, 7)\n\troot1 = insert(root1, 9)\n\n\t# Create second tree as shown in example\n\troot2 = None\n\troot2 = insert(root2, 10)\n\troot2 = insert(root2, 7)\n\troot2 = insert(root2, 20)\n\troot2 = insert(root2, 4)\n\troot2 = insert(root2, 9)\n\n\tprint(\"Tree 1 : \")\n\tinorder(root1)\n\tprint()\n\t\n\tprint(\"Tree 2 : \")\n\tinorder(root2)\n\tprint()\n\n\tprint(\"Common Nodes: \")\n\tprintCommon(root1, root2)\n\t\n# This code is contributed by PranchalK"}
{"nl": "Minimal V: Membership Operator", "code": "def not_share(lst1, lst2):\n  return not set(lst1) & set(lst2)"}
{"nl": "Find n character word in the given text file", "code": "# Give the value of n as static input and store it in a variable.\nn = 6\n# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  print('The words of length', n, 'are :')\n  for gvnfileline in givenfilecontent:\n  # Split the words of the line using the split() function and store them in a variable(it is of type list).\n  gvnfilewords = gvnfileline.split()\n  # Loop in the above list using another Nested For loop\n  for word in gvnfilewords:\n  # Check the length of the word is equal to the given value n using the If conditional statement.\n  if(len(word) == n):\n  # If it is true then print it using the print() function.\n  print(word)"}
{"nl": "Python Program to Find Armstrong Number in an Interval", "code": "# Program to check Armstrong numbers in a certain interval\n\nlower = 100\nupper = 2000\n\nfor num in range(lower, upper + 1):\n\n   # order of number\n   order = len(str(num))\n    \n   # initialize sum\n   sum = 0\n\n   temp = num\n   while temp > 0:\n       digit = temp % 10\n       sum += digit ** order\n       temp //= 10\n\n   if num == sum:\n       print(num)"}
{"nl": "Good Match?", "code": "def is_good_match(lst):\n  return 'bad match' if len(lst) % 2 else [sum(lst[i:i+2]) for i in range(0, len(), 2)]"}
{"nl": "A Simple Timer", "code": "def simple_timer(seconds):\n  h,r=divmod(seconds,3600)\n  m,s=divmod(r,60)\n  return '{:02d}:{:02d}:{:02d}'.format(h,m,s)"}
{"nl": "Python Program to Print Pyramid Numbers Pattern", "code": "rows = int(input(\"Enter Numbers Pyramid Pattern Rows = \"))\n\nprint(\"====The Pyramid of Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(rows, i, -1):\n        print(end = ' ')\n    for k in range(1, i + 1):\n        print(i, end = ' ')\n    print()"}
{"nl": "Bubble Sort Ascending order", "code": "# function which implements the bubble_sort algorithm for givenlist\r\ndef bubbleSort(givenlist):\r\n  # finding the length of given list\r\n    length = len(givenlist)\r\n    # using nested for loops\r\n    for i in range(length-1):\r\n        for j in range(length-i-1):\r\n          # checking if the jth element is greater than j+1 th element\r\n            if(givenlist[j] > givenlist[j+1]):\r\n              # if it is greater then swap the elements\r\n                givenlist[j], givenlist[j+1] = givenlist[j+1], givenlist[j]\r\n\r\n\r\n# given list\r\ngivenlist = [8, 132, 22, 34, 57, 2, 1, 9, 45, 87, 63, 80, 26, 65, 132]\r\n# printing the list before sorting\r\nprint(\"printing the list before sorting :\")\r\nfor i in givenlist:\r\n    print(i, end=\" \")\r\nprint()\r\n# passing this given list to bubbleSort function which sorts the given list\r\nbubbleSort(givenlist)\r\n# printing the list after sorting\r\nprint(\"printing the list after sorting :\")\r\nfor i in givenlist:\r\n    print(i, end=\" \")"}
{"nl": "Integer in Range?", "code": "def int_within_bounds(n, lower, upper):\n  return n in range(lower, upper)"}
{"nl": "Kth smallest element in a row-wise and column-wise sorted 2D array", "code": "# Program for kth largest element in a 2d array\n# sorted row-wise and column-wise\nfrom sys import maxsize\n\n# A structure to store an entry of heap.\n# The entry contains a value from 2D array,\n# row and column numbers of the value\nclass HeapNode:\n\tdef __init__(self, val, r, c):\n\t\tself.val = val # value to be stored\n\t\tself.r = r # Row number of value in 2D array\n\t\tself.c = c # Column number of value in 2D array\n\n# A utility function to minheapify the node harr[i]\n# of a heap stored in harr[]\ndef minHeapify(harr, i, heap_size):\n\tl = i * 2 + 1\n\tr = i * 2 + 2\n\tif(l < heap_size and r<heap_size and harr[l].val < harr[i].val and harr[r].val < harr[i].val):\n\ttemp= HeapNode(0,0,0)\n\ttemp=harr[r]\n\tharr[r]=harr[i]\n\tharr[i]=harr[l]\n\tharr[l]=temp\n\tminHeapify(harr ,l,heap_size)\n\tminHeapify(harr ,r,heap_size)\n\tif (l < heap_size and harr[l].val < harr[i].val):\n\ttemp= HeapNode(0,0,0)\n\ttemp=harr[i]\n\tharr[i]=harr[l]\n\tharr[l]=temp\n\tminHeapify(harr ,l,heap_size)\n\t\t\t\n# This function returns kth smallest element\n# in a 2D array mat[][]\ndef kthSmallest(mat, n, k):\n\n\t# k must be greater than 0 and smaller than n*n\n\tif k < 0 or k > n * n:\n\t\treturn maxsize\n\n\t# Create a min heap of elements from\n\t# first row of 2D array\n\tharr = [0] * n\n\tfor i in range(n):\n\t\tharr[i] = HeapNode(mat[0][i], 0, i)\n\n\thr = HeapNode(0, 0, 0)\n\tfor i in range(k):\n\n\t\t# Get current heap root\n\t\thr = harr[0]\n\n\t\t# Get next value from column of root's value.\n\t\t# If the value stored at root was last value\n\t\t# in its column, then assign INFINITE as next value\n\t\tnextval = mat[hr.r + 1][hr.c] if (hr.r < n - 1) else maxsize\n\n\t\t# Update heap root with next value\n\t\tharr[0] = HeapNode(nextval, hr.r + 1, hr.c)\n\n\t\t# Heapify root\n\t\tminHeapify(harr, 0, n)\n\n\t# Return the value at last extracted root\n\treturn hr.val\n\n# Driver Code\nif __name__ == \"__main__\":\n\tmat = [[10, 20, 30, 40],\n\t\t[15, 25, 35, 45],\n\t\t[25, 29, 37, 48],\n\t\t[32, 33, 39, 50]]\n\tprint(\"7th smallest element is\",\n\t\t\tkthSmallest(mat, 4, 7))\n\n# This code is contributed by Rishabh Chauhan"}
{"nl": "Python Program to Find HCF or GCD", "code": "# Python program to find H.C.F of two numbers\n\n# define a function\ndef compute_hcf(x, y):\n\n# choose the smaller number\n    if x > y:\n        smaller = y\n    else:\n        smaller = x\n    for i in range(1, smaller+1):\n        if((x % i == 0) and (y % i == 0)):\n            hcf = i \n    return hcf\n\nnum1 = 54 \nnum2 = 24\n\nprint(\"The H.C.F. is\", compute_hcf(num1, num2))\n\n# Function to find HCF the Using Euclidian algorithm\ndef compute_hcf(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\nhcf = compute_hcf(300, 400)\nprint(\"The HCF is\", hcf)"}
{"nl": "Generate first N numbers of Pell Series", "code": "# Give the number N as user input using int(input()) and store it in a variable.\r\nnumb = int(input('Enter some random number = '))\r\n# Take a variable temp1 and initialize it to 1.\r\ntemp1 = 1\r\n# Take another variable temp2 and initialize it to 2.\r\ntemp2 = 2\r\n# Take the third variable temp3 and initialize it to 0.\r\ntemp3 = 0\r\n# Now, print the first two numbers in the series,\r\n# and we'll print the other generated numbers in the order they were generated.\r\nprint('The first', numb, 'numbers of the pell series are :')\r\nprint(temp1, temp2, end=' ')\r\n# Loop till number -2 using For loop.\r\nfor i in range(numb-2):\r\n    # Add the value of temp1 and twice the temp2 value\r\n    # and initialize the temp3 with this value.\r\n    temp3 = temp1+2*temp2\r\n    # Swap the previous number for the previous number's predecessor (temp1 =temp2).\r\n    temp1 = temp2\r\n    # Swap the generated and previously generated numbers (temp2 = temp3)\r\n    temp2 = temp3\r\n    # Print the value of temp3.\r\n    print(temp3, end=' ')"}
{"nl": "find the middle index in array", "code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            if sum(nums[:i]) == sum(nums[i+1:]):\n                return i\n        return -1"}
{"nl": "find largest odd number in a string", "code": "class Solution:\n    def largestOddNumber(self, num: str) -> str:\n        num_r = num[::-1]\n        \n        for index, n in enumerate(num_r):\n            if int(n) %2 != 0:\n                return num_r[index:][::-1]\n            \n        return \"\""}
{"nl": "Generating and Swapping Key-Value-Pairs in Dictionary", "code": "def swap_d(k, v, swapped):\n    return dict(zip(v, k)) if swapped else dict(zip(k, v))"}
{"nl": "Subtree with given sum in a Binary Tree", "code": "# Python3 program to find if there is a\n# subtree with given sum\n\n# Binary Tree Node\n\"\"\" utility that allocates a newNode\nwith the given key \"\"\"\nclass newnode:\n\n\t# Construct to create a newNode\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# function to check if there exist any\n# subtree with given sum\n# cur_sum -. sum of current subtree\n#\t\t from ptr as root\n# sum_left -. sum of left subtree from\n#\t\t\t ptr as root\n# sum_right -. sum of right subtree\n#\t\t\t from ptr as root\ndef sumSubtreeUtil(ptr,cur_sum,sum):\n\n\t# base condition\n\tif (ptr == None):\n\t\tcur_sum[0] = 0\n\t\treturn False\n\n\t# Here first we go to left sub-tree,\n\t# then right subtree then first we\n\t# calculate sum of all nodes of subtree\n\t# having ptr as root and assign it as cur_sum\n\t# cur_sum = sum_left + sum_right + ptr.data\n\t# after that we check if cur_sum == sum\n\tsum_left, sum_right = [0], [0]\n\tx=sumSubtreeUtil(ptr.left, sum_left, sum)\n\ty=sumSubtreeUtil(ptr.right, sum_right, sum)\n\tcur_sum[0] = (sum_left[0] +\n\t\t\t\tsum_right[0] + ptr.data)\n\treturn ((x or y)or (cur_sum[0] == sum))\n\n# Wrapper over sumSubtreeUtil()\ndef sumSubtree(root, sum):\n\n\t# Initialize sum of subtree with root\n\tcur_sum = [0]\n\n\treturn sumSubtreeUtil(root, cur_sum, sum)\n\n# Driver Code\nif __name__ == '__main__':\n\n\troot = newnode(8)\n\troot.left = newnode(5)\n\troot.right = newnode(4)\n\troot.left.left = newnode(9)\n\troot.left.right = newnode(7)\n\troot.left.right.left = newnode(1)\n\troot.left.right.right = newnode(12)\n\troot.left.right.right.right = newnode(2)\n\troot.right.right = newnode(11)\n\troot.right.right.left = newnode(3)\n\tsum = 22\n\n\tif (sumSubtree(root, sum)) :\n\t\tprint(\"Yes\" )\n\telse:\n\t\tprint(\"No\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Calculate the squares of the diagonal elements in a matrix.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[1, 5, 4], [2, 3, 6], [4, 2, 1]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\nprint(\"The squares of diagonal elements of first diagonal:\")\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n is equal to m using the if conditional statement where n\r\n      # is the iterator value of the parent For loop and m is the iterator value of the\r\n      # inner For loop.\r\n        if (n == m):\r\n          # If the statement is true, then print the square of the gvnmatrix[n][m]\r\n            print(mtrx[n][m]**2)\r\n\r\n# Loop till the given number of rows using the For loop.\r\nprint(\"The squares of diagonal elements of second diagonal:\")\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n+m is equal to the mtrxrows-1 using the if conditional\r\n      # statement where n is the iterator value of the parent For loop and\r\n      # m is the iterator value of the inner For loop.\r\n\r\n        if (n+m == mtrxrows-1):\r\n           # If the statement is true, then print the square of the gvnmatrix[n][m]\r\n            print(mtrx[n][m]**2)"}
{"nl": "Given a fraction as a string, return whether or not it is greater than 1 when evaluated.", "code": "def greaterThanOne(frac):\r\n\treturn eval(frac) > 1"}
{"nl": "Python List reverse() Method\r\n\r\n", "code": "fruits = ['apple', 'banana', 'cherry']\r\n\r\nfruits.reverse()"}
{"nl": "Largest BST in a Binary Tree", "code": "# Python program to find largest\n# BST in a Binary Tree.\n\u00a0\nINT_MIN = -2147483648\nINT_MAX = 2147483647\n\u00a0\n# Helper function that allocates a new\n# node with the given data and None left\n# and right pointers.\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Returns Information about subtree. The\n# Information also includes size of largest\n# subtree which is a BST\ndef largestBSTBT(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Base cases : When tree is empty or it has\n\u00a0\u00a0\u00a0\u00a0# one child.\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0, INT_MIN, INT_MAX, 0, True\n\u00a0\u00a0\u00a0\u00a0if (root.left == None and root.right == None) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1, root.data, root.data, 1, True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for left subtree and right subtrees\n\u00a0\u00a0\u00a0\u00a0l = largestBSTBT(root.left)\n\u00a0\u00a0\u00a0\u00a0r = largestBSTBT(root.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a return variable and initialize its\n\u00a0\u00a0\u00a0\u00a0# size.\n\u00a0\u00a0\u00a0\u00a0ret = [0, 0, 0, 0, 0]\n\u00a0\u00a0\u00a0\u00a0ret[0] = (1 + l[0] + r[0])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If whole tree rooted under current root is\n\u00a0\u00a0\u00a0\u00a0# BST.\n\u00a0\u00a0\u00a0\u00a0if (l[4] and r[4] and l[1] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.data and r[2] > root.data) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[2] = min(l[2], min(r[2], root.data))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[1] = max(r[1], max(l[1], root.data))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update answer for tree rooted under\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current 'root'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[3] = ret[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret[4] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ret\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If whole tree is not BST, return maximum\n\u00a0\u00a0\u00a0\u00a0# of left and right subtrees\n\u00a0\u00a0\u00a0\u00a0ret[3] = max(l[3], r[3])\n\u00a0\u00a0\u00a0\u00a0ret[4] = False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return ret\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\"\"\"Let us construct the following Tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a060\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/ \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a065 70\n\u00a0\u00a0\u00a0\u00a0/\n\u00a0\u00a0\u00a0\u00a050 \"\"\"\n\u00a0\u00a0\u00a0\u00a0root = newNode(60)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(65)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(70)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(50)\n\u00a0\u00a0\u00a0\u00a0print(\"Size of the largest BST is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0largestBSTBT(root)[3])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "design a stack that supports push, pop, top, and retrieving the minimum element in constant time", "code": "class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []        \n        \n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.min_stack or x <= self.min_stack[-1]:\n            self.min_stack.append(x)\n    \n    def pop(self) -> None:\n        if self.min_stack[-1] == self.stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]"}
{"nl": "Sum of dependencies in a graph", "code": "# Python3 program to find the sum\u00a0\n# of dependencies\n\u00a0\u00a0\n# To add an edge\ndef addEdge(adj, u, v):\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0adj[u].append(v)\n\u00a0\u00a0\n# Find the sum of all dependencies\ndef findSum(adj, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0sum = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Just find the size at each\u00a0\n\u00a0\u00a0\u00a0\u00a0# vector's index\n\u00a0\u00a0\u00a0\u00a0for u in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += len(adj[u])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return sum\n\u00a0\u00a0\n# Driver code\nif __name__=='__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0V = 4\n\u00a0\u00a0\u00a0\u00a0adj = [[] for i in range(V)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 2)\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 3)\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 1, 3)\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 2, 3)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Sum of dependencies is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0findSum(adj, V))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by rutvik_56\n"}
{"nl": "Program to find parity", "code": "# Python3 code to get parity.\n\n# Function to get parity of number n.\n# It returns 1 if n has odd parity,\n# and returns 0 if n has even parity\ndef getParity( n ):\n\tparity = 0\n\twhile n:\n\t\tparity = ~parity\n\t\tn = n & (n - 1)\n\treturn parity\n\n# Driver program to test getParity()\nn = 7\nprint (\"Parity of no \", n,\" = \",\n\t( \"odd\" if getParity(n) else \"even\"))\n\n# This code is contributed by \"Sharad_Bhardwaj\".\n"}
{"nl": "Python Program to Make a Simple Calculator", "code": "givenChoice = input('''\nPlease select which type of operation which we want to apply\\n\nenter + for addition operation\\n\nenter - for subtraction  operation\\n\nenter * for multiplication  operation\\n\nenter / for division  operation\\n''')\n# given two numbers\nnumber1 = int(\n    input(\"Enter the first number of which we wan to do perform calculation: \"))\nnumber2 = int(\n    input(\"Enter the first number of which we wan to do perform calculation: \"))\nif givenChoice == \"+\":\n    # adding the given two numbers\n    print('{} + {} = '.format(number1, number2))\n    print(number1 + number2)\nelif givenChoice == \"-\":\n    # subtracting the given two numbers\n    print('{} - {} = '.format(number1, number2))\n    print(number1 - number2)\nelif givenChoice == \"*\":\n    # multiplying the given two numbers\n    print('{} * {} = '.format(number1, number2))\n    print(number1 * number2)\nelif givenChoice == \"/\":\n    # dividing the given two numbers\n    print('{} / {} = '.format(number1, number2))\n    print(number1 / number2)\nelse:\n    print(\"You have entered the invalid operation\")"}
{"nl": "Recursion: Left Shift By Powers of Two", "code": "def shift_to_left(x, y):\n  return 2 * shift_to_left(x, y-1) if y else x"}
{"nl": "Tarjan\u2019s Algorithm to find Strongly Connected Components\n", "code": "# Python program to find strongly connected components in a given\n# directed graph using Tarjan's algorithm (single DFS)\n#Complexity : O(V+E)\n\nfrom collections import defaultdict\n\n#This class represents an directed graph\n# using adjacency list representation\nclass Graph:\n\n        def __init__(self,vertices):\n                #No. of vertices\n                self.V= vertices\n                \n                # default dictionary to store graph\n                self.graph = defaultdict(list)\n                \n                self.Time = 0\n\n        # function to add an edge to graph\n        def addEdge(self,u,v):\n                self.graph[u].append(v)\n                \n\n        '''A recursive function that find finds and prints strongly connected\n        components using DFS traversal\n        u --> The vertex to be visited next\n        disc[] --> Stores discovery times of visited vertices\n        low[] -- >> earliest visited vertex (the vertex with minimum\n                                discovery time) that can be reached from subtree\n                                rooted with current vertex\n        st -- >> To store all the connected ancestors (could be part\n                of SCC)\n        stackMember[] --> bit/index array for faster check whether\n                                a node is in stack\n        '''\n        def SCCUtil(self,u, low, disc, stackMember, st):\n\n                # Initialize discovery time and low value\n                disc[u] = self.Time\n                low[u] = self.Time\n                self.Time += 1\n                stackMember[u] = True\n                st.append(u)\n\n                # Go through all vertices adjacent to this\n                for v in self.graph[u]:\n                        \n                        # If v is not visited yet, then recur for it\n                        if disc[v] == -1 :\n                        \n                                self.SCCUtil(v, low, disc, stackMember, st)\n\n                                # Check if the subtree rooted with v has a connection to\n                                # one of the ancestors of u\n                                # Case 1 (per above discussion on Disc and Low value)\n                                low[u] = min(low[u], low[v])\n                                                \n                        elif stackMember[v] == True:\n\n                                '''Update low value of 'u' only if 'v' is still in stack\n                                (i.e. it's a back edge, not cross edge).\n                                Case 2 (per above discussion on Disc and Low value) '''\n                                low[u] = min(low[u], disc[v])\n\n                # head node found, pop the stack and print an SCC\n                w = -1 #To store stack extracted vertices\n                if low[u] == disc[u]:\n                        while w != u:\n                                w = st.pop()\n                                print (w, end=\" \")\n                                stackMember[w] = False\n                                \n                        print()\n                        \n        \n\n        #The function to do DFS traversal.\n        # It uses recursive SCCUtil()\n        def SCC(self):\n\n                # Mark all the vertices as not visited\n                # and Initialize parent and visited,\n                # and ap(articulation point) arrays\n                disc = [-1] * (self.V)\n                low = [-1] * (self.V)\n                stackMember = [False] * (self.V)\n                st =[]\n                \n\n                # Call the recursive helper function\n                # to find articulation points\n                # in DFS tree rooted with vertex 'i'\n                for i in range(self.V):\n                        if disc[i] == -1:\n                                self.SCCUtil(i, low, disc, stackMember, st)\n\n\n\n\n\n# Create a graph given in the above diagram\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\nprint (\"SSC in first graph \")\ng1.SCC()\n\ng2 = Graph(4)\ng2.addEdge(0, 1)\ng2.addEdge(1, 2)\ng2.addEdge(2, 3)\nprint (\"nSSC in second graph \")\ng2.SCC()\n\n\ng3 = Graph(7)\ng3.addEdge(0, 1)\ng3.addEdge(1, 2)\ng3.addEdge(2, 0)\ng3.addEdge(1, 3)\ng3.addEdge(1, 4)\ng3.addEdge(1, 6)\ng3.addEdge(3, 5)\ng3.addEdge(4, 5)\nprint (\"nSSC in third graph \")\ng3.SCC()\n\ng4 = Graph(11)\ng4.addEdge(0, 1)\ng4.addEdge(0, 3)\ng4.addEdge(1, 2)\ng4.addEdge(1, 4)\ng4.addEdge(2, 0)\ng4.addEdge(2, 6)\ng4.addEdge(3, 2)\ng4.addEdge(4, 5)\ng4.addEdge(4, 6)\ng4.addEdge(5, 6)\ng4.addEdge(5, 7)\ng4.addEdge(5, 8)\ng4.addEdge(5, 9)\ng4.addEdge(6, 4)\ng4.addEdge(7, 9)\ng4.addEdge(8, 9)\ng4.addEdge(9, 8)\nprint (\"nSSC in fourth graph \")\ng4.SCC();\n\n\ng5 = Graph (5)\ng5.addEdge(0, 1)\ng5.addEdge(1, 2)\ng5.addEdge(2, 3)\ng5.addEdge(2, 4)\ng5.addEdge(3, 0)\ng5.addEdge(4, 2)\nprint (\"nSSC in fifth graph \")\ng5.SCC();\n\n#This code is contributed by Neelam Yadav\n"}
{"nl": "Cup Swapping", "code": "def cup_swapping(swaps):\n    ball = \"B\"\n    for move in swaps:\n        if ball in move:\n            ball = move[1] if move[0] == ball else move[0]\n    return ball"}
{"nl": "Python File fileno() Method", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.fileno())"}
{"nl": "Python Program to Find Volume and Surface Area of a Cuboid", "code": "# Give the length of a cuboid as user input using the float(input()) function and\n# store it in a variable.\ngvn_len = float(input(\"Enter some random number = \"))\n# Give the width of a cuboid as user input using the float(input()) function and\n# store it in another variable.\ngvn_widt = float(input(\"Enter some random number = \"))\n# Give the height of a cuboid as user input using the float(input()) function\n# and store it in another variable.\ngvn_heigt = float(input(\"Enter some random number = \"))\n# Calculate the surface area of a given cuboid using the above given mathematical formula\n# and store it in another variable.\nsurf_area = 2 * (gvn_len * gvn_widt + gvn_len *\n                 gvn_heigt + gvn_widt * gvn_heigt)\n# Calculate the volume of a given cuboid using the above given mathematical formula\n# and store it in another variable.\nVol = gvn_len * gvn_widt * gvn_heigt\n# Calculate the lateral surface area of a given cuboid using the above given mathematical\n# formula and store it in another variable.\nLaterl_surfcarea = 2 * gvn_heigt * (gvn_len + gvn_widt)\n# Print the surface area of a given cuboid.\nprint(\n    \"The given surface Area of a Cuboid with given length,width,height[\", gvn_len, gvn_widt, gvn_heigt, \"]= %.3f\" % surf_area)\n# Print the volume of a given cuboid.\nprint(\n    \"The given volume of a Cuboid with given length,width,height[\", gvn_len, gvn_widt, gvn_heigt, \"]= %.3f\" % Vol)\n# Print the lateral surface area of a given cuboid.\nprint(\n    \"The given lateral surface Area of a Cuboid with given length,width,height[\", gvn_len, gvn_widt, gvn_heigt, \"]= %.3f\" % Laterl_surfcarea)"}
{"nl": "Maximum product of 4 adjacent elements in matrix", "code": "# Python3 program to find out the maximum\n# product in the matrix which four elements\n# are adjacent to each other in one direction\nn = 5\n\u00a0\n# function to find max product\ndef FindMaxProduct(arr, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0max = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# iterate the rows.\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# iterate the columns.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range( n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in horizontal row.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((j - 3) >= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i][j - 1] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j - 2] * arr[i][j - 3])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in vertical row.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i - 3) >= 0) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i - 1][j] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i - 2][j] * arr[i - 3][j])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# diagonal going through down - right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i - 3) >= 0 and (j - 3) >= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i - 1][j - 1] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i - 2][j - 2] * arr[i - 3][j - 3])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check the maximum product in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# diagonal going through up - right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i - 3) >= 0 and (j - 1) <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = (arr[i][j] * arr[i - 1][j + 1] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i - 2][j + 2] * arr[i - 3][j + 3])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (max < result):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return max\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# int arr[][4] = {{6, 2, 3, 4},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {5, 4, 3, 1},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {7, 4, 5, 6},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {8, 3, 1, 0}};\n\u00a0\u00a0\u00a0\u00a0# int arr[][5] = {{1, 2, 1, 3, 4},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {5, 6, 3, 9, 2},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {7, 8, 8, 1, 2},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {1, 0, 7, 9, 3},\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 {3, 0, 8, 4, 9}};\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0arr = [[1, 2, 3, 4, 5],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[6, 7, 8, 9, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 3, 4, 5, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[7, 8, 9, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[9, 6, 4, 2, 3]]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(FindMaxProduct(arr, n))\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": "Sort a Matrix in all way increasing order", "code": "# Python program to sort matrix in all-way\nN = 3;\n\u00a0\n# Sorts a matrix in increasing order\ndef sortAllWay(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Consider matrix elements (in row major\n\u00a0\u00a0\u00a0\u00a0# order) and sort the sequence.\n\u00a0\u00a0\u00a0\u00a0ar = [0 for i in range(len(arr) * len(arr))];\n\u00a0\u00a0\u00a0\u00a0k = 0;\n\u00a0\u00a0\u00a0\u00a0for i in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ar[k] = arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k += 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0ar.sort();\n\u00a0\u00a0\u00a0\u00a0k = 0;\n\u00a0\u00a0\u00a0\u00a0for i in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(arr)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = ar[k];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k += 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return arr;\n\u00a0\n# Driver program\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0arr = [[ 1, 0, 3 ],[ 2, 5, 6 ],[ 9, 4, 8 ]] ;\n\u00a0\u00a0\u00a0\u00a0arr = sortAllWay(arr);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# print resultant matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(arr[i][j], end=\" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print();\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code IS contributed by umadevi9616\n"}
{"nl": "Python Program to Rearrange the Letters of a String in Alphabetical Order", "code": "# Give the string as static input and store it in variable.\n \n gvnstrng = 'btechgeeks'\n \n # Reorder the letters of a string alphabetically using\n \n # the sorted function(This method returns a list of letters in alphabetical order).\n \n sortdstrng = sorted(gvnstrng)\n \n # Join this using the join() function.\n \n finalstrng = ''.join(sortdstrng)\n \n # Print the modified string after reordering the letters of a string alphabetically.\n \n print('The original string is [', gvnstrng, ']')\n \n print(\n \n  'The modified string after reordering the letters of a string alphabetically is [', finalstrng, ']')\n \n </pre>"}
{"nl": "Return the maximum number of removable characters", "code": "class Solution:\n    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\n        left = 0\n        right = len(removable)\n        while left < right:\n            mid = (left + right + 1) // 2\n            res = self.helper(s, set(removable[:mid]), p)\n            if res == True:\n                left = mid\n            else:\n                right = mid - 1\n            \n        return left\n        \n    def helper(self, s, removed, p):\n        # return a true or false\n        slist = list(s)\n        slist = [slist[i] for i in range(len(slist)) if i not in removed]\n        \n        idx = 0\n        for char in slist:\n            if char == p[idx]:\n                idx += 1\n            if idx == len(p):\n                return True\n        \n        return False"}
{"nl": "find peak element", "code": "def findPeakElement(self, nums):\n    left = 0\n    right = len(nums)-1\n\n    # handle condition 3\n    while left < right-1:\n        mid = (left+right)/2\n        if nums[mid] > nums[mid+1] and nums[mid] > nums[mid-1]:\n            return mid\n            \n        if nums[mid] < nums[mid+1]:\n            left = mid+1\n        else:\n            right = mid-1\n            \n    #handle condition 1 and 2\n    return left if nums[left] >= nums[right] else right"}
{"nl": "Convert Polar to Cartesian Coordinate", "code": "# Converting Polar Coordinate to Cartesian Coordinates\r\n# Importing math library\r\nimport math\r\n\r\n# Reading radius and angle of polar coordinate\r\nradius = float(input('Enter radius: '))\r\ntheta = float(input('Enter theta in degree: '))\r\n\r\n# Converting theta from degree to radian\r\ntheta = theta * math.pi/180.0;\r\n\r\n# Converting polar to cartesian coordinates\r\nx = radius * math.cos(theta)\r\ny = radius * math.sin(theta)\r\n\r\n# Displaying cartesian coordinates\r\nprint('Cartesian coordinate is: (x = %0.2f, y = %0.2f)' %(x,y))"}
{"nl": "Remove minimum number of elements such that no common element exist in both array", "code": "# Python3 program to find minimum\n# element to remove so no common\n# element exist in both array\n\n# To find no elements to remove\n# so no common element exist\ndef minRemove(a, b, n, m):\n\n\t# To store count of array element\n\tcountA = dict()\n\tcountB = dict()\n\n\t# Count elements of a\n\tfor i in range(n):\n\t\tcountA[a[i]] = countA.get(a[i], 0) + 1\n\n\t# Count elements of b\n\tfor i in range(n):\n\t\tcountB[b[i]] = countB.get(b[i], 0) + 1\n\n\t# Traverse through all common\n\t# element, and pick minimum\n\t# occurrence from two arrays\n\tres = 0\n\tfor x in countA:\n\t\tif x in countB.keys():\n\t\t\tres += min(countA[x],countB[x])\n\n\t# To return count of\n\t# minimum elements\n\treturn res\n\n# Driver Code\na = [ 1, 2, 3, 4 ]\nb = [2, 3, 4, 5, 8 ]\nn = len(a)\nm = len(b)\nprint(minRemove(a, b, n, m))\n\n# This code is contributed\n# by mohit kumar"}
{"nl": "Print consonants in a String in Python", "code": "# print only consonants in given string def printConsonants(string): # printing consonants for c in string: if c not in \"AEIOUaeiou \": print(c, end=', ') return c # input from the user string = input('String: ') # call the function printConsonants(string)"}
{"nl": "First Player Win", "code": "def canIWin(self, maxInt: int, total: int) -> bool:\n        @functools.lru_cache(None)\n        def dp(nums, left):\n            return any(left - n <= 0 or not dp(frozenset(nums - {n}), left - n) for n in nums)\n        \n        return  (1 + maxInt) * maxInt // 2 >= total and dp(frozenset(range(1, maxInt + 1)), total)"}
{"nl": "Print hollow box pattern of numbers", "code": "# Give the number of rows and number of columns of the box as static or user input\n# and store them in two separate variables.\nboxrows = 11\nboxcolumns = 19\n# Loop from 1 to the number of rows of the box +1 using a For loop.\nfor m in range(1, boxrows+1):\n  # Loop from 1 to the number of columns of the box +1 using another Nested For loop.\n  for n in range(1, boxcolumns+1):\n  '''Check if the parent iterator value is equal to 1 or the number of rows of the box using the If statement.\n  Check if the inner loop iterator value is equal to 1 or the number of columns of the box using the If statement.\n  Merge these two conditions in a single If statement using or operator.  \n  '''\n  if(m == 1 or m == boxrows or n == 1 or n == boxcolumns):\n  # If the condition is true then print 1 with a space character.\n  print(\"1\", end=\" \")\n  else:\n  # Else print space character.\n  print(\" \", end=\" \")\n  # Print the newline character after the end of the inner For loop.\n  print()"}
{"nl": "Snail Goes Up the Stairs", "code": "def total_distance(height, length, tower):\n  return round(((tower/height)*(height+length)),1)"}
{"nl": "Sort Palindrome Words in a Sentence", "code": "# Give the sentence/string as static input and store it in a variable.\r\ngvnstrng = 'sos how are you madam pip instal'\r\n# Convert the given sentence to a list of words using list()\r\n# and split() functions and store it another variable.\r\nstrngwrdslst = list(gvnstrng.split())\r\n# Take an empty list to say palindromicwordslist\r\n# that stores all the palindromic words in the given string\r\n# and initialize it to null/empty using the list() function or [].\r\npalindromicwordslist = []\r\n# Traverse the given list of words using a for loop.\r\nfor wrd in strngwrdslst:\r\n        # Check if the word is palindrome or not using the slicing\r\n    # and if conditional statement.\r\n    if(wrd == wrd[::-1]):\r\n        # If it is true then append this word to the palindromicwordslist\r\n        # using the append() function.\r\n        palindromicwordslist.append(wrd)\r\n\r\n# Sort the palindromicwordslist using the sort() function.\r\npalindromicwordslist.sort()\r\n# Take a variable say tempo and initialize its value to 0\r\n# (Here it acts as a pointer to palindromicwordslist ).\r\ntempo = 0\r\n# Traverse the list of words of the given sentence using the For loop.\r\nfor wrditr in range(len(strngwrdslst)):\r\n  # Check if the word is palindrome or not using the slicing\r\n    # and if conditional statement.\r\n    if(strngwrdslst[wrditr] == strngwrdslst[wrditr][::-1]):\r\n        # If it is true then modify the word with the palindromicwordslist[tempo] word.\r\n        strngwrdslst[wrditr] = palindromicwordslist[tempo]\r\n        tempo = tempo+1\r\n        # Increment the tempo value by 1.\r\n\r\n\r\n# Convert this list of words of the given sentence\r\n# to the string using the join() function.\r\nfinalstrng = ' '.join(strngwrdslst)\r\nprint('The given string before sorting all the palindromic words is = ', gvnstrng)\r\n# Print the final string after sorting the palindromic words.\r\nprint('The final string after sorting all the palindromic words is = ', finalstrng)"}
{"nl": "Count number of bits to be flipped to convert A to B", "code": "# Count number of bits to be flipped\n# to convert A into B\n\n# Function that count set bits\ndef countSetBits( n ):\n\tcount = 0\n\twhile n:\n\t\tcount += 1\n\t\tn &= (n-1)\n\treturn count\n\t\n# Function that return count of\n# flipped number\ndef FlippedCount(a , b):\n\n\t# Return count of set bits in\n\t# a XOR b\n\treturn countSetBits(a^b)\n\n# Driver code\na = 10\nb = 20\nprint(FlippedCount(a, b))\n\n# This code is contributed by \"Sharad_Bhardwaj\"."}
{"nl": "Recursion: Palindrome Word", "code": "def is_palindrome(wrd):\n  return wrd == \"\" or (wrd[0] == wrd[-1] and is_palindrome(wrd[1:-1]))"}
{"nl": "Unmix My Strings", "code": "def unmix(txt):\n  return ''.join(txt[i:i+2][::-1] for i in range(0,len(txt),2))"}
{"nl": "Find the Second Occurrence of \"zip\" in a String\n", "code": "def find_zip(txt):\n        return txt.find(\"zip\", txt.find(\"zip\")+1)"}
{"nl": "Domino Chain", "code": "def domino_chain(dominos):\n  dominos = list(dominos)\n  for i, d in enumerate(dominos):\n    if d in [' ', '/']:\n      break\n    dominos[i] = '/'\n  return ''.join(dominos)"}
{"nl": "Print Hollow Right Angle Triangle Star Pattern", "code": "# Hollow Right Angle Triangle Pattern Using Stars\r\n\r\nrow = int(input('Enter number of rows required: '))\r\n\r\nfor i in range(row):\r\n    for j in range(i+1):\r\n        if j==0 or j==i or i==row-1:\r\n            print('*',end=\" \")\r\n        else:\r\n            print(\" \", end=\" \")\r\n    print()"}
{"nl": "K\u2019th Smallest/Largest Element in Unsorted Array |", "code": "# Python3 program to find k'th smallest\n# element\n\n# Function to return k'th smallest\n# element in a given array\ndef kthSmallest(arr, n, k):\n\n\t# Sort the given array\n\tarr.sort()\n\n\t# Return k'th element in the\n\t# sorted array\n\treturn arr[k-1]\n\n# Driver code\nif __name__=='__main__':\n\tarr = [12, 3, 5, 7, 19]\n\tn = len(arr)\n\tk = 2\n\tprint(\"K'th smallest element is\",\n\t\tkthSmallest(arr, n, k))\n\n# This code is contributed by\n# Shrikant13"}
{"nl": "Ice Cream Stand", "code": "def profit(A, B):\n  return [(A+B+1)//2,100-(A+B)//2]"}
{"nl": "East or West", "code": "def direction(lst):\n  return [i.translate(str.maketrans('eEaA','wWeE')) for i in lst]"}
{"nl": "Print a Binary Tree in Vertical Order ", "code": "# Python program for printing vertical order of a given\n# binary tree\n\n# A binary tree node\nclass Node:\n\t# Constructor to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\n# Utility function to store vertical order in map 'm'\n# 'hd' is horizontal distance of current node from root\n# 'hd' is initially passed as 0\ndef getVerticalOrder(root, hd, m):\n\n\t# Base Case\n\tif root is None:\n\t\treturn\n\t\n\t# Store current node in map 'm'\n\ttry:\n\t\tm[hd].append(root.key)\n\texcept:\n\t\tm[hd] = [root.key]\n\t\n\t# Store nodes in left subtree\n\tgetVerticalOrder(root.left, hd-1, m)\n\t\n\t# Store nodes in right subtree\n\tgetVerticalOrder(root.right, hd+1, m)\n\n# The main function to print vertical order of a binary\n#tree ith given root\ndef printVerticalOrder(root):\n\t\n\t# Create a map and store vertical order in map using\n\t# function getVerticalORder()\n\tm = dict()\n\thd = 0\n\tgetVerticalOrder(root, hd, m)\n\t\n\t# Traverse the map and print nodes at every horizontal\n\t# distance (hd)\n\tfor index, value in enumerate(sorted(m)):\n\t\tfor i in m[value]:\n\t\t\tprint (i,end=\" \")\n\t\tprint()\n\n\n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nroot.right.left.right = Node(8)\nroot.right.right.right = Node(9)\nprint (\"Vertical order traversal is\")\nprintVerticalOrder(root)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)"}
{"nl": "Convert Key, Values in a Dictionary to List", "code": "def dict_to_list(d):\n  return sorted(d.items())"}
{"nl": "Sort an array in wave form", "code": "# Python function to sort the array arr[0..n-1] in wave form,\n# i.e., arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= arr[5]\ndef sortInWave(arr, n):\n\t\n\t# Traverse all even elements\n\tfor i in range(0, n, 2):\n\t\t\n\t\t# If current even element is smaller than previous\n\t\tif (i> 0 and arr[i] < arr[i-1]):\n\t\t\tarr[i],arr[i-1] = arr[i-1],arr[i]\n\t\t\n\t\t# If current even element is smaller than next\n\t\tif (i < n-1 and arr[i] < arr[i+1]):\n\t\t\tarr[i],arr[i+1] = arr[i+1],arr[i]\n\n# Driver program\narr = [10, 90, 49, 2, 1, 5, 23]\nsortInWave(arr, len(arr))\nfor i in range(0,len(arr)):\n\tprint (arr[i],end=\" \")\n\t\n# This code is contributed by __Devesh Agrawal__"}
{"nl": "Python or Keyword", "code": "x = (5 > 3 or 5 > 10)\r\n\r\nprint(x)"}
{"nl": "The lexicographically largest sequence", "code": "class Solution:\n  def constructDistancedSequence(self, n: int) -> List[int]:\n  \n  arr = [0]*(2*n-1)  # the array we want to put numbers. 0 means no number has been put here\n  i = 0  # current index to put a number  \n  vi = [False] * (n+1)  # check if we have used that number\n  \n# backtracking\n  def dfs(arr, i, vi):\n  # if we already fill the array successfully, return True\n  if i >= (2*n-1):\n  return True\n\n# try each number from n to 1\n  for x in range(n, 0, -1):\n  # two cases:\n  # x > 1, we check two places. Mind index out of bound here.\n  # x = 1, we only check one place\n# arr[i] == 0 means index i is not occupied\n  if (x > 1 and ((not (arr[i] == 0 and (i+x < 2*n-1) and arr[i+x] == 0)) or vi[x]))  \\\nor (x == 1 and (arr[i] != 0 or vi[x])):\n  continue\n\n# if it can be placed, then place it\n  if x > 1:\n  arr[i] = x\n  arr[i+x] = x\n  else:\n  arr[i] = x\n  vi[x] = True\n\n# find the next available place\n  nexti = i+1\n  while nexti < 2*n-1 and arr[nexti]:\n  nexti += 1\n\n# place the next one\n  if dfs(arr, nexti, vi):\n# if it success, it is already the lexicographically largest one, we don't search anymore\n  return True\n\n# backtracking... restore the state\n  if x > 1:\n  arr[i] = 0\n  arr[i+x] = 0\n  else:\n  arr[i] = 0\n  vi[x] = False\n\n# we could not find a solution, return False\n  return False\n\n  dfs(arr, i, vi)\n  return arr"}
{"nl": "Coloured Triangles", "code": "def coloured_triangle(row):\n  if len(row) == 1:\n    return row\n  elif len(row) > 2:\n    return ''.join(sorted(set(row), key=row.index))[-1]\n  else:\n    return 'R'"}
{"nl": "The minimum degree of a connected trio in the graph", "code": "def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n  graph = defaultdict(set)\n  for u, v in edges:\n  graph[u].add(v)\n  graph[v].add(u)\n  \n  min_degree = float('inf')\n  for u in sorted(range(1, n + 1), key=lambda x: len(graph[x])):\n  if len(graph[u]) >= min_degree / 3:\n  break\n  for v in graph[u]:  \n  for w in graph[v]:\n  if w in graph[u]:\n  min_degree = min(min_degree, len(graph[u]) + len(graph[v]) + len(graph[w]))\n  return min_degree - 6 if min_degree != float('inf') else -1"}
{"nl": "Find a pair with given sum in BST", "code": "# Python3 program to find a pair with\n# given sum using hashing\nimport sys\nimport math\n\u00a0\n\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n\u00a0\ndef insert(root, data):\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(data)\n\u00a0\u00a0\u00a0\u00a0if(data < root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, data)\n\u00a0\u00a0\u00a0\u00a0if(data > root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, data)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\ndef findPairUtil(root, summ, unsorted_set):\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0if findPairUtil(root.left, summ, unsorted_set):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0if unsorted_set and (summ-root.data) in unsorted_set:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Pair is Found ({},{})\".format(summ-root.data, root.data))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsorted_set.add(root.data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return findPairUtil(root.right, summ, unsorted_set)\n\u00a0\n\u00a0\ndef findPair(root, summ):\n\u00a0\u00a0\u00a0\u00a0unsorted_set = set()\n\u00a0\u00a0\u00a0\u00a0if(not findPairUtil(root, summ, unsorted_set)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Pair do not exist!\")\n\u00a0\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 8)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 12)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 16)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 25)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0summ = 33\n\u00a0\u00a0\u00a0\u00a0findPair(root, summ)\n\u00a0\n# This code is contributed by Vikash Kumar 37\n"}
{"nl": "Bird Names to Four Letter Bird Codes", "code": "def bird_code(lst):\n  def f(name):\n    w=name.replace('-',' ').upper().split()\n    s={1:[4],2:[2,2],3:[1,1,2],4:[1,1,1,1]}[len(w)]\n    return ''.join(x[:l] for x, l in zip(w, s))\n  return list(map(f,lst))"}
{"nl": "Complete the Binary Number", "code": "def complete_binary(s):\n  return (-len(s)%8 * '0') + s"}
{"nl": "Maximum sum of i*arr[i] among all rotations of a given array", "code": "# A Naive Python3 program to find\n# maximum sum rotation\nimport sys\n\n# Returns maximum value of i * arr[i]\ndef maxSum(arr, n):\n\n\t# Initialize result\n\tres = -sys.maxsize\n\n\t# Consider rotation beginning with i\n\t# for all possible values of i.\n\tfor i in range(0, n):\n\n\n\t\t# Initialize sum of current rotation\n\t\tcurr_sum = 0\n\t\n\t\t# Compute sum of all values. We don't\n\t\t# actually rotation the array, but\n\t\t# compute sum by finding ndexes when\n\t\t# arr[i] is first element\n\t\tfor j in range(0, n):\n\t\t\n\t\t\tindex = int((i + j)% n)\n\t\t\tcurr_sum += j * arr[index]\n\t\n\n\t\t# Update result if required\n\t\tres = max(res, curr_sum)\n\treturn res\n\n# Driver code\narr = [8, 3, 1, 2]\nn = len(arr)\n\nprint(maxSum(arr, n))\n\n# This code is contributed by\n# Smitha Dinesh Semwal"}
{"nl": "The longest nice substring", "code": "class Solution:\n  def longestNiceSubstring(self, s: str) -> str:\n  if not s: return \"\" # boundary condition \n  ss = set(s)\n  for i, c in enumerate(s):\n  if c.swapcase() not in ss: \n  s0 = self.longestNiceSubstring(s[:i])\n  s1 = self.longestNiceSubstring(s[i+1:])\n  return max(s0, s1, key=len)\n  return s"}
{"nl": "Function that takes phrases/words as clues and forms a sentence formatted to have the murder's name, verb, \"Tom as\", Reason.", "code": "def sherlock(person,weapon):\r\n\tclass Weapon:\r\n\t\r\n\t\tdef __init__(self, verb, reason):\r\n\t\t\tself.v = verb\r\n\t\t\tself.r = reason\r\n\tclass Person:\r\n\t\tdef gender(name):\r\n\t\t\tif 'Mr.' in name:\r\n\t\t\t\treturn 'M'\r\n\t\t\treturn 'F'\r\n\t\tdef __init__(self, name):\r\n\t\t\tself.name = name\r\n\t\t\tself.gender = Person.gender(name)\r\n\t\t\tself.pronoun = 'he' if self.gender == 'M' else 'she'\r\n\t\r\n\tpoison = Weapon('poisoned', 'only {X} could have such high-grade poison.')\r\n\tknife = Weapon('butchered', 'only {X} was in the kitchen.')\r\n\tbat = Weapon('swatted', 'only {X} is a baseball player.')\r\n\tgun = Weapon('shot', 'only {X} had a gun.')\r\n\tbriefcase = Weapon('smacked', 'only {X} was after Tom\\'s money.')\r\n\t\r\n\tweapon = eval(weapon.lower())\r\n\tperson = Person(person)\r\n\t\r\n\ttry:\r\n\t\treturn person.name +  ' {v} Tom as {r}'.format(v = weapon.v, r = weapon.r).format(X = person.pronoun)\r\n\texcept KeyError:\r\n\t\tprint('{X} {v} Tom as {r}'.format(v = weapon.v, r = weapon.r))"}
{"nl": "Check if a String Contains only Identical Characters", "code": "def is_identical(s):\n  return len(set(s)) == 1"}
{"nl": "The kth lexicographically smallest instruction", "code": "def kthSmallestPath(self, destination: List[int], k: int) -> str:\n  from math import comb\n  r, c = destination\n  \n  ret = []\n  remDown = r\n  for i in range(r + c):\n  remSteps = r + c - (i + 1)\n  com = comb(remSteps, remDown)\n  if com >= k:\n  ret.append(\"H\")\n  else:\n  remDown -= 1\n  k -= com\n  ret.append(\"V\")\n  \n  return ''.join(ret)"}
{"nl": "The self Parameter\r\n", "code": "class Person:\r\n  def __init__(mysillyobject, name, age):\r\n    mysillyobject.name = name\r\n    mysillyobject.age = age\r\n\r\n  def myfunc(abc):\r\n    print(\"Hello my name is \" + abc.name)\r\n\r\np1 = Person(\"John\", 36)\r\np1.myfunc()"}
{"nl": "Find lowest common ancestor in a binary search tree", "code": "# A recursive python program to find LCA of two nodes\r\n# n1 and n2\r\n \r\n# A Binary tree node\r\nclass Node:\r\n \r\n    # Constructor to create a new node\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\n \r\n# Function to find LCA of n1 and n2. The function assumes\r\n# that both n1 and n2 are present in BST\r\ndef lca(root, n1, n2):\r\n     \r\n    # Base Case\r\n    if root is None:\r\n        return None\r\n \r\n    # If both n1 and n2 are smaller than root, then LCA\r\n    # lies in left\r\n    if(root.data > n1 and root.data > n2):\r\n        return lca(root.left, n1, n2)\r\n \r\n    # If both n1 and n2 are greater than root, then LCA\r\n    # lies in right\r\n    if(root.data < n1 and root.data < n2):\r\n        return lca(root.right, n1, n2)\r\n \r\n    return root\r\n \r\n# Driver program to test above function\r\n \r\n# Let us construct the BST shown in the figure\r\nroot = Node(20)\r\nroot.left = Node(8)\r\nroot.right = Node(22)\r\nroot.left.left = Node(4)\r\nroot.left.right = Node(12)\r\nroot.left.right.left = Node(10)\r\nroot.left.right.right = Node(14)\r\n \r\nn1 = 10 ; n2 = 14\r\nt = lca(root, n1, n2)\r\nprint (\"LCA of %d and %d is %d\" %(n1, n2, t.data))\r\n \r\nn1 = 14 ; n2 = 8\r\nt = lca(root, n1, n2)\r\nprint (\"LCA of %d and %d is %d\" %(n1, n2 , t.data))\r\n \r\nn1 = 10 ; n2 = 22\r\nt = lca(root, n1, n2)\r\nprint (\"LCA of %d and %d is %d\" %(n1, n2, t.data))\r\n \r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)"}
{"nl": "Block the Square in Tic Tac Toe", "code": "def block_player(a, b):\n    wins = ({0, 1, 2}, {3, 4, 5}, {6, 7, 8}, {0, 4, 8}, \n            {0, 3, 6}, {1, 4, 7}, {2, 5, 8}, {2, 4, 6})\n    for i in wins:\n        if {a, b}.issubset(i):\n            return (i - {a, b}).pop()"}
{"nl": "Eulerian Path in undirected graph", "code": "# Efficient Python3 program to\n# find out Eulerian path\n\u00a0\u00a0\n# Function to find out the path\n# It takes the adjacency matrix\n# representation of the graph as input\ndef findpath(graph, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0numofadj = []\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find out number of edges each\n\u00a0\u00a0\u00a0\u00a0# vertex has\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0numofadj.append(sum(graph[i]))\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find out how many vertex has\u00a0\n\u00a0\u00a0\u00a0\u00a0# odd number edges\n\u00a0\u00a0\u00a0\u00a0startpoint, numofodd = 0, 0\n\u00a0\u00a0\u00a0\u00a0for i in range(n - 1, -1, -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (numofadj[i] % 2 == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0numofodd += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0startpoint = i\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If number of vertex with odd number of edges\n\u00a0\u00a0\u00a0\u00a0# is greater than two return \"No Solution\".\n\u00a0\u00a0\u00a0\u00a0if (numofodd > 2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No Solution\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If there is a path find the path\n\u00a0\u00a0\u00a0\u00a0# Initialize empty stack and path\n\u00a0\u00a0\u00a0\u00a0# take the starting current as discussed\n\u00a0\u00a0\u00a0\u00a0stack = []\n\u00a0\u00a0\u00a0\u00a0path = []\n\u00a0\u00a0\u00a0\u00a0cur = startpoint\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Loop will run until there is element in the\n\u00a0\u00a0\u00a0\u00a0# stack or current edge has some neighbour.\n\u00a0\u00a0\u00a0\u00a0while (len(stack) > 0 or sum(graph[cur])!= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current node has not any neighbour\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# add it to path and pop stack set new\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current to the popped element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sum(graph[cur]) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append(cur)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = stack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0del stack[-1]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the current vertex has at least one\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# neighbour add the current vertex to stack,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# remove the edge between them and set the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current to its neighbour.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (graph[cur][i] == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(cur)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0graph[cur][i] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0graph[i][cur] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the path\n\u00a0\u00a0\u00a0\u00a0for ele in path:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(ele, end = \" -> \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(cur)\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Test case 1\n\u00a0\u00a0\u00a0\u00a0graph1 = [ [ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 1, 0, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 0, 0, 0 ] ]\n\u00a0\u00a0\u00a0\u00a0n = len(graph1)\n\u00a0\u00a0\u00a0\u00a0findpath(graph1, n)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Test case 2\n\u00a0\u00a0\u00a0\u00a0graph2 = [ [ 0, 1, 0, 1, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 1, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 1, 1, 0, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 0, 0 ] ]\n\u00a0\u00a0\u00a0\u00a0n = len(graph2)\n\u00a0\u00a0\u00a0\u00a0findpath(graph2, n)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Test case 3\n\u00a0\u00a0\u00a0\u00a0graph3 = [ [ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 1, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 1, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 1, 0, 1, 0 ] ]\n\u00a0\u00a0\u00a0\u00a0n = len(graph3)\n\u00a0\u00a0\u00a0\u00a0findpath(graph3, n)\n\u00a0\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Ternary Search function", "code": "# A recursive ternary search function. It returns location of x in\n# given array arr[l..r] is present, otherwise -1\ndef ternarySearch(arr, l, r, x):\n\tif (r >= l):\n\t\tmid1 = l + (r - l)//3\n\t\tmid2 = mid1 + (r - l)//3\n\n\t\t# If x is present at the mid1\n\t\tif arr[mid1] == x:\n\t\t\treturn mid1\n\n\t\t# If x is present at the mid2\n\t\tif arr[mid2] == x:\n\t\t\treturn mid2\n\n\t\t# If x is present in left one-third\n\t\tif arr[mid1] > x:\n\t\t\treturn ternarySearch(arr, l, mid1-1, x)\n\n\t\t# If x is present in right one-third\n\t\tif arr[mid2] < x:\n\t\t\treturn ternarySearch(arr, mid2+1, r, x)\n\n\t\t# If x is present in middle one-third\n\t\treturn ternarySearch(arr, mid1+1, mid2-1, x)\n\t\n\t# We reach here when element is not present in array\n\treturn -1\n\t\n# This code is contributed by ankush_953\n"}
{"nl": "AVL with duplicate keys", "code": "# Python code to delete a node in AVL tree\r\n# Generic tree node class\r\n\r\n\r\nclass TreeNode():\r\n\tdef __init__(self, val):\r\n\t\tself.count = 1 # assigning count variable so that during insertion in will be incremented for duplicate values\r\n\t\t# and during deletion, it will be decremented if has multiple copies.\r\n\t\tself.height = 1\r\n\t\tself.val = val\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n# only insertion and deletion will be affected. if multiple copies are there, entry(count) will be printed during traversal.\r\n\r\n# AVL tree class which supports insertion,\r\n# deletion operations\r\n\r\n\r\nclass AVL_Tree(object):\r\n\r\n\tdef insert(self, root, key):\r\n\r\n\t\t# Step 1 - Perform normal BST\r\n\t\tif not root:\r\n\t\t\treturn TreeNode(key)\r\n\t\telse if key < root.val:\r\n\t\t\troot.left = self.insert(root.left, key)\r\n\t\telse if key > root.val:\r\n\t\t\troot.right = self.insert(root.right, key)\r\n\t\telse:\r\n\t\t\troot.count += 1 # incrementing count if same entry is inserted.\r\n\r\n\t\t# Step 2 - Update the height of the\r\n\t\t# ancestor node\r\n\t\troot.height = 1 + max(self.getHeight(root.left),\r\n\t\t\t\t\t\t\tself.getHeight(root.right))\r\n\r\n\t\t# Step 3 - Get the balance factor\r\n\t\tbalance = self.getBalance(root)\r\n\r\n\t\t# Step 4 - If the node is unbalanced,\r\n\t\t# then try out the 4 cases\r\n\t\t# Case 1 - Left Left\r\n\t\tif balance > 1 and key < root.left.val:\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 2 - Right Right\r\n\t\tif balance < -1 and key > root.right.val:\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\t# Case 3 - Left Right\r\n\t\tif balance > 1 and key > root.left.val:\r\n\t\t\troot.left = self.leftRotate(root.left)\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 4 - Right Left\r\n\t\tif balance < -1 and key < root.right.val:\r\n\t\t\troot.right = self.rightRotate(root.right)\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\treturn root\r\n\r\n\t# Recursive function to delete a node with\r\n\t# given key from subtree with given root.\r\n\t# It returns root of the modified subtree.\r\n\tdef delete(self, root, key):\r\n\r\n\t\t# Step 1 - Perform standard BST delete\r\n\t\tif not root:\r\n\t\t\treturn root\r\n\r\n\t\telse if key < root.val:\r\n\t\t\troot.left = self.delete(root.left, key)\r\n\r\n\t\telse if key > root.val:\r\n\t\t\troot.right = self.delete(root.right, key)\r\n\r\n\t\telse:\r\n\t\t\tif root.count > 1: # if count is more than one i.e multiple copies are there\r\n\t\t\t\troot.count -= 1 # just decrement count\r\n\t\t\t\treturn root # so that one copy will be deleted and return\r\n\r\n\t\t\tif root.left is None:\r\n\t\t\t\ttemp = root.right\r\n\t\t\t\troot = None\r\n\t\t\t\treturn temp\r\n\r\n\t\t\telse if root.right is None:\r\n\t\t\t\ttemp = root.left\r\n\t\t\t\troot = None\r\n\t\t\t\treturn temp\r\n\r\n\t\t\ttemp = self.getMinValueNode(root.right)\r\n\t\t\troot.val = temp.val\r\n\t\t\troot.right = self.delete(root.right,\r\n\t\t\t\t\t\t\t\t\ttemp.val)\r\n\r\n\t\t# If the tree has only one node,\r\n\t\t# simply return it\r\n\t\tif root is None:\r\n\t\t\treturn root\r\n\r\n\t\t# Step 2 - Update the height of the\r\n\t\t# ancestor node\r\n\t\troot.height = 1 + max(self.getHeight(root.left),\r\n\t\t\t\t\t\t\tself.getHeight(root.right))\r\n\r\n\t\t# Step 3 - Get the balance factor\r\n\t\tbalance = self.getBalance(root)\r\n\r\n\t\t# Step 4 - If the node is unbalanced,\r\n\t\t# then try out the 4 cases\r\n\t\t# Case 1 - Left Left\r\n\t\tif balance > 1 and self.getBalance(root.left) >= 0:\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 2 - Right Right\r\n\t\tif balance < -1 and self.getBalance(root.right) <= 0:\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\t# Case 3 - Left Right\r\n\t\tif balance > 1 and self.getBalance(root.left) < 0:\r\n\t\t\troot.left = self.leftRotate(root.left)\r\n\t\t\treturn self.rightRotate(root)\r\n\r\n\t\t# Case 4 - Right Left\r\n\t\tif balance < -1 and self.getBalance(root.right) > 0:\r\n\t\t\troot.right = self.rightRotate(root.right)\r\n\t\t\treturn self.leftRotate(root)\r\n\r\n\t\treturn root\r\n\r\n\tdef leftRotate(self, z):\r\n\r\n\t\ty = z.right\r\n\t\tT2 = y.left\r\n\r\n\t\t# Perform rotation\r\n\t\ty.left = z\r\n\t\tz.right = T2\r\n\r\n\t\t# Update heights\r\n\t\tz.height = 1 + max(self.getHeight(z.left),\r\n\t\t\t\t\t\tself.getHeight(z.right))\r\n\t\ty.height = 1 + max(self.getHeight(y.left),\r\n\t\t\t\t\t\tself.getHeight(y.right))\r\n\r\n\t\t# Return the new root\r\n\t\treturn y\r\n\r\n\tdef rightRotate(self, z):\r\n\r\n\t\ty = z.left\r\n\t\tT3 = y.right\r\n\r\n\t\t# Perform rotation\r\n\t\ty.right = z\r\n\t\tz.left = T3\r\n\r\n\t\t# Update heights\r\n\t\tz.height = 1 + max(self.getHeight(z.left),\r\n\t\t\t\t\t\tself.getHeight(z.right))\r\n\t\ty.height = 1 + max(self.getHeight(y.left),\r\n\t\t\t\t\t\tself.getHeight(y.right))\r\n\r\n\t\t# Return the new root\r\n\t\treturn y\r\n\r\n\tdef getHeight(self, root):\r\n\t\tif not root:\r\n\t\t\treturn 0\r\n\r\n\t\treturn root.height\r\n\r\n\tdef getBalance(self, root):\r\n\t\tif not root:\r\n\t\t\treturn 0\r\n\r\n\t\treturn self.getHeight(root.left) - self.getHeight(root.right)\r\n\r\n\tdef getMinValueNode(self, root):\r\n\t\tif root is None or root.left is None:\r\n\t\t\treturn root\r\n\r\n\t\treturn self.getMinValueNode(root.left)\r\n\r\n\tdef preOrder(self, root):\r\n\r\n\t\tif not root:\r\n\t\t\treturn\r\n\r\n\t\tprint(\"{}({}) \".format(root.val, root.count), end=\"\")\r\n\t\tself.preOrder(root.left)\r\n\t\tself.preOrder(root.right)\r\n\r\n\r\nmyTree = AVL_Tree()\r\nroot = None\r\nnums = [9, 5, 10, 5, 9, 7, 17]\r\n\r\nfor num in nums:\r\n\troot = myTree.insert(root, num)\r\n\r\n# Preorder Traversal\r\nprint(\"Preorder Traversal after insertion -\")\r\nmyTree.preOrder(root)\r\nprint()\r\n\r\n# Delete\r\nkey = 10\r\nroot = myTree.delete(root, key)\r\nkey = 10\r\nroot = myTree.delete(root, key)\r\nkey = -1\r\nroot = myTree.delete(root, key)\r\nkey = 0\r\nroot = myTree.delete(root, key)\r\n\r\n# Preorder Traversal\r\nprint(\"Preorder Traversal after deletion -\")\r\nmyTree.preOrder(root)\r\nprint()\r\n\r\n# This code is contributed by Ajitesh Pathak\r"}
{"nl": "Calculate Sum of Series 1\u00b3+2\u00b3+3\u00b3+\u2026.+n\u00b3", "code": "# Import math module using the import keyword.\r\nimport math\r\n# Give the nth term of a series as user input using the int(input()) function and store it in a variable.\r\nnum = int(input(\"Enter some random variable = \"))\r\n# Calculate the sum of cubes of a series with a given nth term using the above\r\n# mathematical formula and math.pow() function. \r\n# Store it in another variable.\r\ncube_sum = math.pow((num * (num + 1)) / 2, 2)\r\n# Print the sum of cubes of a given series with the given n value.\r\nprint(\r\n    \"The sum of cubes of a series with the given n value[\", num, \"] =\", cube_sum)"}
{"nl": "Factor Chain", "code": "def factor_chain(lst):\n  for x in lst:\n    if (lst[-1]%x != 0):\n      return False\n  return True"}
{"nl": "Count good nodes in binary tree", "code": "def goodNodes(self, r, ma=-10000):\n  return self.goodNodes(r.left, max(ma, r.val)) + self.goodNodes(r.right, max(ma, r.val)) + (r.val >= ma) if r else 0"}
{"nl": "Python Set clear() Method", "code": "fruits = {\"apple\", \"banana\", \"cherry\"}\r\n\r\nfruits.clear()\r\n\r\nprint(fruits)"}
{"nl": "File name property", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're simply writing the contents into the file.\ngvn_file = open(givenFilename, 'w') \n# Get the given file name using the name property and store it in a variable\nf_name= gvn_file.name\n# Print the given file name.\nprint(\"The given file name is:\", f_name)\n# Close the given file using the close() function\ngvn_file.close()"}
{"nl": "Give Me the Even Numbers", "code": "def sum_even_nums_in_range(start, stop):\n    return sum(i for i in range(start, stop+1) if not i%2)"}
{"nl": "the number of words in the shortest transformation sequence from beginWord to endWord", "code": "from collections import defaultdict\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\n            return 0\n\n        # Since all words are of same length.\n        L = len(beginWord)\n\n        # Dictionary to hold combination of words that can be formed,\n        # from any given word. By changing one letter at a time.\n        all_combo_dict = defaultdict(list)\n        for word in wordList:\n            for i in range(L):\n                # Key is the generic word\n                # Value is a list of words which have the same intermediate generic word.\n                all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\n\n\n        # Queue for BFS\n        queue = collections.deque([(beginWord, 1)])\n        # Visited to make sure we don't repeat processing same word.\n        visited = {beginWord: True}\n        while queue:\n            current_word, level = queue.popleft()\n            for i in range(L):\n                # Intermediate words for current word\n                intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\n\n                # Next states are all the words which share the same intermediate state.\n                for word in all_combo_dict[intermediate_word]:\n                    # If at any point if we find what we are looking for\n                    # i.e. the end word - we can return with the answer.\n                    if word == endWord:\n                        return level + 1\n                    # Otherwise, add it to the BFS Queue. Also mark it visited\n                    if word not in visited:\n                        visited[word] = True\n                        queue.append((word, level + 1))\n                all_combo_dict[intermediate_word] = []\n        return 0"}
{"nl": "Minimum Cost Polygon Triangulation", "code": "# Recursive implementation for minimum\r\n# cost convex polygon triangulation\r\nfrom math import sqrt\r\nMAX = 1000000.0\r\n \r\n# A utility function to find distance\r\n# between two points in a plane\r\ndef dist(p1, p2):\r\n    return sqrt((p1[0] - p2[0])*(p1[0] - p2[0]) + \\\r\n                (p1[1] - p2[1])*(p1[1] - p2[1]))\r\n \r\n# A utility function to find cost of\r\n# a triangle. The cost is considered\r\n# as perimeter (sum of lengths of all edges)\r\n# of the triangle\r\ndef cost(points, i, j, k):\r\n    p1 = points[i]\r\n    p2 = points[j]\r\n    p3 = points[k]\r\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1)\r\n \r\n \r\n# A recursive function to find minimum\r\n# cost of polygon triangulation\r\n# The polygon is represented by points[i..j].\r\ndef mTC(points, i, j):\r\n     \r\n    # There must be at least three points between i and j\r\n    # (including i and j)\r\n    if (j < i + 2):\r\n        return 0\r\n         \r\n    # Initialize result as infinite\r\n    res = MAX\r\n     \r\n    # Find minimum triangulation by considering all\r\n    for k in range(i + 1, j):\r\n        res = min(res, (mTC(points, i, k) + \\\r\n                        mTC(points, k, j) + \\\r\n                        cost(points, i, k, j)))\r\n     \r\n    return round(res, 4)\r\n \r\n \r\n# Driver code\r\npoints = [[0, 0], [1, 0], [2, 1], [1, 2], [0, 2]]\r\nn = len(points)\r\nprint(mTC(points, 0, n-1))\r\n \r\n# This code is contributed by SHUBHAMSINGH10"}
{"nl": "Sum of all nodes in a binary tree", "code": "# Python3 Program to print sum of all\n# the elements of a binary tree\n\n# Binary Tree Node\n\n\"\"\" utility that allocates a new Node\nwith the given key \"\"\"\nclass newNode:\n\n\t# Construct to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\t\t\n# Function to find sum of all the element\ndef addBT(root):\n\tif (root == None):\n\t\treturn 0\n\treturn (root.key + addBT(root.left) +\n\t\t\t\t\taddBT(root.right))\n\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(6)\n\troot.right.right = newNode(7)\n\troot.right.left.right = newNode(8)\n\n\tsum = addBT(root)\n\n\tprint(\"Sum of all the nodes is:\", sum)\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Find the max distance between two occurences of elements in a list.", "code": "# Give the list as static input and store it in a variable.\r\ngvn_lst = [1, 2, 3, 7, 8, 9, 2, 1, 4, 3]\r\n# Calculate the length of the given list using the len() function and store it in\r\n# another variable.\r\nlst_len = len(gvn_lst)\r\n# Create an empty dictionary and store it in another variable.\r\nnew_dict = {}\r\n# Take a variable say \"max_val\" and initialize its value with 0.\r\nmax_val = 0\r\n# Loop till the number of elements of the list using the for loop.\r\nfor itr in range(lst_len):\r\n    # Check if the list element is present in the dictionary keys or not using the\r\n    # if conditional statement.\r\n    if gvn_lst[itr] not in new_dict.keys():\r\n        # If the statement is true, then update the dictionary with the key as a list element\r\n        # and value as an iterator.\r\n        new_dict[gvn_lst[itr]] = itr\r\n # If it is not true, calculate the maximum value of \"max_val\" and iterator -dictionary\r\n# of list of iterator and store it in \"max_val\".\r\n    else:\r\n        max_val = max(max_val, itr-new_dict[gvn_lst[itr]])\r\n # Print \"max_val\" to get the greatest distance between two occurrences of an element\r\n# in a given list of repeated elements.\r\nprint(\"The greatest distance between two occurrences of an element in a given list of repeated elements = \", max_val)"}
{"nl": "camelCase \u21c4 snake_case", "code": "import re\ndef to_snake_case(txt):\n  pattern = re.compile(r\"([a-z])([A-Z])\")\n  match = pattern.sub(r'\\1_\\2', txt).lower()\n  return match\n  def to_camel_case(txt):\n  pattern = re.compile(r\"(_)([a-z])\")\n  match = pattern.sub(lambda x: x.group(2).upper(), txt)\n  a = re.sub(r\"_\", \"\", match)\n  return a"}
{"nl": "Find the Maximum width of a binary tree", "code": "# Python program to find the maximum width of\n# binary tree using Level Order Traversal.\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to get the maximum width of a binary tree\n \n \ndef getMaxWidth(root):\n    maxWidth = 0\n    h = height(root)\n    # Get width of each level and compare the\n    # width with maximum width so far\n    for i in range(1, h+1):\n        width = getWidth(root, i)\n        if (width > maxWidth):\n            maxWidth = width\n    return maxWidth\n \n# Get width of a given level\n \n \ndef getWidth(root, level):\n    if root is None:\n        return 0\n    if level == 1:\n        return 1\n    elif level > 1:\n        return (getWidth(root.left, level-1) +\n                getWidth(root.right, level-1))\n \n# UTILITY FUNCTIONS\n# Compute the \"height\" of a tree -- the number of\n# nodes along the longest path from the root node\n# down to the farthest leaf node.\n \n \ndef height(node):\n    if node is None:\n        return 0\n    else:\n \n        # compute the height of each subtree\n        lHeight = height(node.left)\n        rHeight = height(node.right)\n \n        # use the larger one\n        return (lHeight+1) if (lHeight > rHeight) else (rHeight+1)\n \n \n# Driver code\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(8)\nroot.right.right.left = Node(6)\nroot.right.right.right = Node(7)\n \n\"\"\"\nConstructed binary tree is:\n    1\n    / \\\n    2 3\n    / \\     \\\n4 5 8\n        / \\\n        6 7\n\"\"\"\n# Function call\nprint (\"Maximum width is %d\" % (getMaxWidth(root)))\n \n# This code is contributed by Naveen Aili"}
{"nl": "Python Program to Find the Sum of the Digits of the Number Recursively", "code": "# take a empty list\nnumbList = []\n# function which returns count of all the digits of\n# the given number using recursive approach.\n\n\ndef sumDigitsRecursion(numb):\n    # Put the base condition in the function that says\n    # if the number is zero, return the created list.\n    if(numb == 0):\n        return numbList\n    # getting the last digit of the given number using modulus operator\n    numdigit = numb % 10\n    # appending this digit to numberslist using digit function\n    numbList.append(numdigit)\n    # passing numb/10 recursively\n    sumDigitsRecursion(numb//10)\n\n\n# give the number as static input\nnumb = 18627677851\n# passing the number to sumDigitsRecursion function to\n# calculate the sum of digits recursively\nsumDigitsRecursion(numb)\n# calculating the sum of list using sum() function.\nprint('The total sum of digits off the given number', numb, '=', sum(numbList))"}
{"nl": "Python Program to Print Right Triangle of 1 and 0", "code": "rows = int(input(\"Enter Right Triangle of 1 & 0 Num Pattern Rows = \"))\n\nprint(\"====Right Angled Triangle of 1 and 0 Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(1, i + 1):\n        if j % 2 == 0:\n           print(0, end = ' ') \n        else:\n            print(1, end = ' ') \n    print()"}
{"nl": "Concatenate two strings if given.", "code": "def stupid_addition(a, b):\r\n    if type(a) == type(b):\r\n        if type(a) == int:\r\n            return str(a) + str(b)\r\n        return int(a)+int(b)"}
{"nl": "Graph Coloring | Set 2 (Greedy Algorithm)", "code": "# Python3 program to implement greedy\n# algorithm for graph coloring\n\u00a0\ndef addEdge(adj, v, w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0adj[v].append(w)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Note: the graph is undirected\n\u00a0\u00a0\u00a0\u00a0adj[w].append(v)\u00a0\n\u00a0\u00a0\u00a0\u00a0return adj\n\u00a0\n# Assigns colors (starting from 0) to all\n# vertices and prints the assignment of colors\ndef greedyColoring(adj, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0result = [-1] * V\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Assign the first color to first vertex\n\u00a0\u00a0\u00a0\u00a0result[0] = 0;\n\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A temporary array to store the available colors.\n\u00a0\u00a0\u00a0\u00a0# True value of available[cr] would mean that the\n\u00a0\u00a0\u00a0\u00a0# color cr is assigned to one of its adjacent vertices\n\u00a0\u00a0\u00a0\u00a0available = [False] * V\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Assign colors to remaining V-1 vertices\n\u00a0\u00a0\u00a0\u00a0for u in range(1, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Process all adjacent vertices and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# flag their colors as unavailable\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in adj[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (result[i] != -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0available[result[i]] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Find the first available color\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while cr < V:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (available[cr] == False):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cr += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Assign the found color\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[u] = cr\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Reset the values back to false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for the next iteration\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in adj[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (result[i] != -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0available[result[i]] = False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the result\n\u00a0\u00a0\u00a0\u00a0for u in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Vertex\", u, \" --->\u00a0 Color\", result[u])\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0g1 = [[] for i in range(5)]\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 0, 1)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 0, 2)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 1, 2)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 1, 3)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 2, 3)\n\u00a0\u00a0\u00a0\u00a0g1 = addEdge(g1, 3, 4)\n\u00a0\u00a0\u00a0\u00a0print(\"Coloring of graph 1 \")\n\u00a0\u00a0\u00a0\u00a0greedyColoring(g1, 5)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0g2 = [[] for i in range(5)]\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 0, 1)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 0, 2)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 1, 2)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 1, 4)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 2, 4)\n\u00a0\u00a0\u00a0\u00a0g2 = addEdge(g2, 4, 3)\n\u00a0\u00a0\u00a0\u00a0print(\"\\nColoring of graph 2\")\n\u00a0\u00a0\u00a0\u00a0greedyColoring(g2, 5)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Calculate depth of a full Binary tree from Preorder", "code": "#Python program to find height of full binary tree\r\n# using preorder\r\n\t\r\n# function to return max of left subtree height\r\n# or right subtree height\r\ndef findDepthRec(tree, n, index) :\r\n\r\n\tif (index[0] >= n or tree[index[0]] == 'l'):\r\n\t\treturn 0\r\n\r\n\t# calc height of left subtree (In preorder\r\n\t# left subtree is processed before right)\r\n\tindex[0] += 1\r\n\tleft = findDepthRec(tree, n, index)\r\n\r\n\t# calc height of right subtree\r\n\tindex[0] += 1\r\n\tright = findDepthRec(tree, n, index)\r\n\treturn (max(left, right) + 1)\r\n\r\n# Wrapper over findDepthRec()\r\ndef findDepth(tree, n) :\r\n\r\n\tindex = [0]\r\n\treturn findDepthRec(tree, n, index)\r\n\r\n\t\t\r\n# Driver program to test above functions\r\nif __name__ == '__main__':\r\n\ttree= \"nlnnlll\"\r\n\tn = len(tree)\r\n\r\n\tprint(findDepth(tree, n))\r\n\r\n# This code is contributed by SHUBHAMSINGH10\r"}
{"nl": "Make two arrays equal by reversing sub-arrays", "code": "def canBeEqual(self, target, A):\n  return collections.Counter(target) == collections.Counter(A)"}
{"nl": "Python Program to Find Whether a Number is a Power of Two", "code": "# importing log from math\n \n from math import log\n \n # given number\n \n numb = 2048\n \n # given base (here it is 2 as we have to check whether it is power of 2 or not)\n \n bas = 2\n \n # calculating log2 of the given numb using log function\n \n logvalue = log(numb, bas)\n \n # if the value is integer then it is power of 2\n \n if (int(logvalue) == logvalue):\n \n  print(\"The given numb\", numb, \"is power of 2\")\n \n # else it is not power of 2\n \n else:\n \n  print(\"The given numb\", numb, \"is not power of 2\")"}
{"nl": "Given a square matrix, check whether it is diagonally dominant.", "code": "# Create a function to say checkdiagnolydominant_matx() which takes the given matrix\r\n# and the number of rows of the given matrix as the arguments and returns true or false\r\n\r\n\r\ndef checkdiagnolydominant_matx(mtrx, mtrxrows):\r\n    # Inside the function, Loop till the given number of rows using the For loop.\r\n    for n in range(0, mtrxrows):\r\n       # Take a variable to say rslt_summ and initialize its value to 0.\r\n        rslt_summ = 0\r\n        # Inside the For loop, Iterate till the given number of rows using another\r\n        # Nested For loop(Inner For loop).\r\n\r\n        for m in range(0, mtrxrows):\r\n          # Add the absolute of mtrx[n][m] to the above-initialized rslt_summ and store\r\n          # it in  the same variable.\r\n\r\n            rslt_summ = rslt_summ + abs(mtrx[n][m])\r\n       # Remove the diagonal element by subtracting the abs(mtrx[n][n]) from the rslt_summ and\r\n       # store it in the same variable.\r\n        rslt_summ = rslt_summ - abs(mtrx[n][n])\r\n        # Check if the abs(mtrx[n][n]) (diagonal element) is less than the rslt_summ\r\n        # (Which is the #sum of non diagonal elements) using the if conditional statement.\r\n        if (abs(mtrx[n][n]) < rslt_summ):\r\n          # If it is true, then return False.\r\n            return False\r\n    # Return True.\r\n    return True\r\n\r\n\r\n# Give the matrix as static input and store it in a variable.\r\nmtrx = [[5, 1, 3], [2, 7, 1], [4, 0, 9]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Pass the given matrix and the number of rows of the given matrix as the arguments\r\n# to the checkdiagnolydominant_matx() function and check if returns true or false\r\n# using the if conditional statement.\r\nif((checkdiagnolydominant_matx(mtrx, mtrxrows))):\r\n  # If it is true, print \"Yes, the given matrix is a diagonally dominant matrix\".\r\n    print(\"Yes, the given matrix is a diagonally dominant matrix\")\r\nelse:\r\n  # Else print \"No, the given matrix is not a diagonally dominant matrix\".\r\n    print(\"No, the given matrix is not a diagonally dominant matrix\")"}
{"nl": "Priority Queue using Doubly Linked List", "code": "# Python3 code to implement priority\n# queue using doubly linked list\n\n# Linked List Node\nclass Node:\n\t\n\tdef __init__(self):\n\t\t\n\t\tself.info = 0\n\t\tself.priority = 0\n\t\tself.next = None\n\t\tself.prev = None\n\nfront = None\nrear = None\n\n# Function to insert a new Node\ndef push(fr, rr, n, p):\n\t\n\tglobal front, rear\n\t\n\tnews = Node()\n\tnews.info = n\n\tnews.priority = p\n\t\n\t# If linked list is empty\n\tif (fr == None):\n\t\tfr = news\n\t\trr = news\n\t\tnews.next = None\n\t\n\telse:\n\t\t\n\t\t# If p is less than or equal fr\n\t\t# node's priority, then insert at\n\t\t# the fr.\n\t\tif (p <= (fr).priority):\n\t\t\tnews.next = fr\n\t\t\t(fr).prev = news.next\n\t\t\tfr = news\n\n\t\t# If p is more rr node's priority,\n\t\t# then insert after the rr.\n\t\telif (p > (rr).priority):\n\t\t\tnews.next = None\n\t\t\t(rr).next = news\n\t\t\tnews.prev = (rr).next\n\t\t\trr = news\n\t\t\n\t\t# Handle other cases\n\t\telse:\n\n\t\t\t# Find position where we need to\n\t\t\t# insert.\n\t\t\tstart = (fr).next\n\t\t\t\n\t\t\twhile (start.priority > p):\n\t\t\t\tstart = start.next\n\t\t\t\t\n\t\t\t(start.prev).next = news\n\t\t\tnews.next = start.prev\n\t\t\tnews.prev = (start.prev).next\n\t\t\tstart.prev = news.next\n\t\t\t\n\tfront = fr\n\trear = rr\n\t\n# Return the value at rr\ndef peek(fr):\n\t\n\treturn fr.info\n\t\t\t\ndef isEmpty(fr):\n\t\n\treturn fr == None\n\n# Removes the element with the\n# least priority value form the list\ndef pop(fr, rr):\n\t\n\tglobal front , rear\n\ttemp = fr\n\tres = temp.info\n\t(fr) = (fr).next\n\t\n\tif (fr == None):\n\t\trr = None\n\t\t\n\tfront = fr\n\trear = rr\n\treturn res\n\n# Driver code\nif __name__=='__main__':\n\t\n\tpush( front, rear, 2, 3)\n\tpush( front, rear, 3, 4)\n\tpush( front, rear, 4, 5)\n\tpush( front, rear, 5, 6)\n\tpush( front, rear, 6, 7)\n\tpush( front, rear, 1, 2)\n\t\n\tprint(pop(front, rear))\n\tprint(peek(front))\n\n# This code is contributed by rutvik_56"}
{"nl": "find minimum in rotated sorted array", "code": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # If the list has just one element then return that element.\n        if len(nums) == 1:\n            return nums[0]\n\n        # left pointer\n        left = 0\n        # right pointer\n        right = len(nums) - 1\n\n        # if the last element is greater than the first element then there is no rotation.\n        # e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.\n        # Hence the smallest element is first element. A[0]\n        if nums[right] > nums[0]:\n            return nums[0]\n\n        # Binary search way\n        while right >= left:\n            # Find the mid element\n            mid = left + (right - left) / 2\n            # if the mid element is greater than its next element then mid+1 element is the smallest\n            # This point would be the point of change. From higher to lower value.\n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            # if the mid element is lesser than its previous element then mid element is the smallest\n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n\n            # if the mid elements value is greater than the 0th element this means\n            # the least value is still somewhere to the right as we are still dealing with elements greater than nums[0]\n            if nums[mid] > nums[0]:\n                left = mid + 1\n            # if nums[0] is greater than the mid value then this means the smallest value is somewhere to the left\n            else:\n                right = mid - 1"}
{"nl": "YouTube Upload Count", "code": "def upload_count(dates, month):\n  return str(dates).count(month)"}
{"nl": "Binary Indexed Tree : Range Update and Range Queries", "code": "# Python program to demonstrate Range Update\r\n# and Range Queries using BIT\r\n \r\n# Returns sum of arr[0..index]. This function assumes\r\n# that the array is preprocessed and partial sums of\r\n# array elements are stored in BITree[]\r\ndef getSum(BITree: list, index: int) -> int:\r\n    summ = 0 # Initialize result\r\n \r\n    # index in BITree[] is 1 more than the index in arr[]\r\n    index = index + 1\r\n \r\n    # Traverse ancestors of BITree[index]\r\n    while index > 0:\r\n \r\n        # Add current element of BITree to sum\r\n        summ += BITree[index]\r\n \r\n        # Move index to parent node in getSum View\r\n        index -= index & (-index)\r\n    return summ\r\n \r\n# Updates a node in Binary Index Tree (BITree) at given\r\n# index in BITree. The given value 'val' is added to\r\n# BITree[i] and all of its ancestors in tree.\r\ndef updateBit(BITTree: list, n: int, index: int, val: int) -> None:\r\n \r\n    # index in BITree[] is 1 more than the index in arr[]\r\n    index = index + 1\r\n \r\n    # Traverse all ancestors and add 'val'\r\n    while index <= n:\r\n \r\n        # Add 'val' to current node of BI Tree\r\n        BITTree[index] += val\r\n \r\n        # Update index to that of parent in update View\r\n        index += index & (-index)\r\n \r\n \r\n# Returns the sum of array from [0, x]\r\ndef summation(x: int, BITTree1: list, BITTree2: list) -> int:\r\n    return (getSum(BITTree1, x) * x) - getSum(BITTree2, x)\r\n \r\n \r\ndef updateRange(BITTree1: list, BITTree2: list, n: int, val: int, l: int,\r\n                r: int) -> None:\r\n \r\n    # Update Both the Binary Index Trees\r\n    # As discussed in the article\r\n \r\n    # Update BIT1\r\n    updateBit(BITTree1, n, l, val)\r\n    updateBit(BITTree1, n, r + 1, -val)\r\n \r\n    # Update BIT2\r\n    updateBit(BITTree2, n, l, val * (l - 1))\r\n    updateBit(BITTree2, n, r + 1, -val * r)\r\n \r\ndef rangeSum(l: int, r: int, BITTree1: list, BITTree2: list) -> int:\r\n \r\n    # Find sum from [0,r] then subtract sum\r\n    # from [0,l-1] in order to find sum from\r\n    # [l,r]\r\n    return summation(r, BITTree1, BITTree2) - summation(\r\n        l - 1, BITTree1, BITTree2)\r\n \r\n# Driver Code\r\nif __name__ == \"__main__\":\r\n    n = 5\r\n \r\n    # BIT1 to get element at any index\r\n    # in the array\r\n    BITTree1 = [0] * (n + 1)\r\n \r\n    # BIT 2 maintains the extra term\r\n    # which needs to be subtracted\r\n    BITTree2 = [0] * (n + 1)\r\n \r\n    # Add 5 to all the elements from [0,4]\r\n    l = 0\r\n    r = 4\r\n    val = 5\r\n    updateRange(BITTree1, BITTree2, n, val, l, r)\r\n \r\n    # Add 2 to all the elements from [2,4]\r\n    l = 2\r\n    r = 4\r\n    val = 10\r\n    updateRange(BITTree1, BITTree2, n, val, l, r)\r\n \r\n    # Find sum of all the elements from\r\n    # [1,4]\r\n    l = 1\r\n    r = 4\r\n    print(\"Sum of elements from [%d,%d] is %d\" %\r\n        (l, r, rangeSum(l, r, BITTree1, BITTree2)))\r\n \r\n# This code is contributed by\r\n# sanjeev2552"}
{"nl": "Back to Home?", "code": "def back_to_home(d):\n  return d.count('N') == d.count('S') and d.count('E') == d.count('W')"}
{"nl": "Establish if a given positive integer num is a Happy number, i.e. if the number reduces to 1", "code": "def happy_algorithm(n):\n    if n == 1:\n        return 'HAPPY 1'\n    found = [1]\n    while n not in found:\n        found.append(n)\n        n = sum(int(i)**2 for i in str(n))\n    return '{} {}'.format('HAPPY' if n == 1 else 'SAD', len(found) - 1)"}
{"nl": "Evaluating Factorials", "code": "def eval_factorial(lst):\n\treturn sum(fac(int(k[:-1])) for k in lst)\n\ndef fac(n):\n\treturn n*fac(n-1) if n else 1"}
{"nl": "Python Program to Print all Disarium Numbers within Given range", "code": "# Give the lower limit range as static input and store it in a variable.\n \n lowlim_range = 7\n \n # Give the upper limit range as static input and store it in another variable.\n \n upplim_range = 180\n \n print('The disarium numbers in the given range',\n \n  lowlim_range, 'and', upplim_range, 'are:')\n \n # Loop from lower limit range to upper limit range using For loop.\n \n for m in range(lowlim_range, upplim_range+1):\n \n \n \n  # given number\n \n  num = m\n \n  # intialize result to zero(ans)\n \n  ans = 0\n \n \n \n  # calculating the digits\n \n  digit_s = len(str(num))\n \n  # copy the number in another variable(duplicate)\n \n  dup_numbr = num\n \n  while (dup_numbr != 0):\n \n  # getting the last digit\n \n  remaindr = dup_numbr % 10\n \n  # multiply the result by a digit raised to the power of the iterator value.\n \n  ans = ans + remaindr**digit_s\n \n  digit_s = digit_s - 1\n \n  dup_numbr = dup_numbr//10\n \n  # It is disarium number if it is equal to original number\n \n  if(num == ans):\n \n  print(num, end=' ')\n \n </pre>"}
{"nl": "Print right triangle number pattern", "code": "# Give the number of rows of the right-angled triangle Number pattern\n# as static input and store it in a variable.\ntriangleNum = 11\n# Loop from 1 to the number of rows using For loop.\nfor m in range(1, triangleNum+1):\n  # Loop from 1 to first loop iterator value using another Nested For loop.\n  for n in range(1, m+1):\n  # Print the iterator value of the nested loop with space in the inner For loop.\n  # (This prints the same number parent loop number of times)\n  print(m, end=' ')\n  # Print the newline character after ending of inner For loop.\n  print()"}
{"nl": "Construct Ancestor Matrix from a Given Binary Tree", "code": "# Python3 program to construct ancestor\n# matrix for given tree.\n\u00a0\nclass newnode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# anc[] stores all ancestors of current node.\n# This function fills ancestors for all nodes.\n# It also returns size of tree. Size of tree\u00a0\n# is used to print ancestor matrix.\ndef ancestorMatrixRec(root, anc):\n\u00a0\u00a0\u00a0\u00a0global mat, MAX\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# base case\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Update all ancestors of current node\n\u00a0\u00a0\u00a0\u00a0data = root.data\n\u00a0\u00a0\u00a0\u00a0for i in range(len(anc)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[anc[i]][data] = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Push data to list of ancestors\n\u00a0\u00a0\u00a0\u00a0anc.append(data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse left and right subtrees\n\u00a0\u00a0\u00a0\u00a0l = ancestorMatrixRec(root.left, anc)\n\u00a0\u00a0\u00a0\u00a0r = ancestorMatrixRec(root.right, anc)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Remove data from list the list of ancestors\n\u00a0\u00a0\u00a0\u00a0# as all descendants of it are processed now.\n\u00a0\u00a0\u00a0\u00a0anc.pop(-1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return l + r + 1\n\u00a0\n# This function mainly calls ancestorMatrixRec()\ndef ancestorMatrix(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an empty ancestor array\n\u00a0\u00a0\u00a0\u00a0anc = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Fill ancestor matrix and find\n\u00a0\u00a0\u00a0\u00a0# size of tree.\n\u00a0\u00a0\u00a0\u00a0n = ancestorMatrixRec(root, anc)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the filled values\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\nMAX = 100\nmat = [[0] * MAX for i in range(MAX)]\n\u00a0\n# Construct the following binary tree\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 5\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 / \\\n#\u00a0\u00a0\u00a0\u00a0 1\u00a0\u00a0\u00a0\u00a0 2\n#\u00a0\u00a0\u00a0\u00a0 / \\ /\n#\u00a0\u00a0\u00a0\u00a0 0 4 3\nroot = newnode(5)\nroot.left = newnode(1)\nroot.right = newnode(2)\nroot.left.left = newnode(0)\nroot.left.right = newnode(4)\nroot.right.left = newnode(3)\n\u00a0\nancestorMatrix(root)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Establish if the digits of a given number form a sequence (ascending or descending).", "code": "def digitaldrome(n):\r\n    s = str(n)\r\n    ordered = ''.join(sorted(s))\r\n    \r\n    if len(set(s)) == 1:\r\n        return 'Repdrome'\r\n    if s == ordered:\r\n        return 'Metadrome' if len(s) == len(set(s)) else 'Plaindrome'\r\n    if s == ordered[::-1]:\r\n        return 'Katadrome' if len(s) == len(set(s)) else 'Nialpdrome'\r\n    return 'Nondrome'"}
{"nl": "Python Program to Print each Word of a Sentence along with Number of Vowels in each Word", "code": "# Give the sentence as static input and store it in a variable.\n \n givnstrng = 'Hello this is BTechgeeks'\n \n # Convert the given string/sentence to lowercase using the lower() function.\n \n givnstrng = givnstrng.lower()\n \n # To break words from a sentence, use the string.split() method.\n \n # The words will be separated and kept in a list named \u2018wordslst'\n \n wordslst = givnstrng.split()\n \n # Create a list called vowelchars, which will hold all of the vowels in the English alphabet.\n \n vowelchars = ['a', 'e', 'i', 'o', 'u']\n \n # Iterate through the list of words and set up a counter to count\n \n # the number of vowels in each one.\n \n for gvnword in wordslst:\n \n  cntvowel = 0\n \n  # Start a nested loop that iterates throughout the word in question,\n \n  # checking whether any of the characters are vowels.\n \n  for m in gvnword:\n \n  # Increase the counter if a character is a vowel.\n \n  if m in vowelchars:\n \n  cntvowel = cntvowel+1\n \n  # Print the current iteration's word and the value\n \n  # of the counter corresponding with it\n \n  # (which contains the sentence's number of vowels).\n \n  print(\n \n  'The total number of vowels in the given word {', gvnword, '} is', cntvowel)\n \n </pre>"}
{"nl": "Delete Edge to minimize subtree sum difference", "code": "# Python3 program to minimize subtree\u00a0\n# Sum difference by one edge deletion\u00a0\n\u00a0\u00a0\n# DFS method to traverse through edges,\u00a0\n# calculating subtree Sum at each node and\u00a0\n# updating the difference between subtrees\u00a0\ndef dfs(u, parent, totalSum, edge,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subtree, res):\u00a0\n\u00a0\u00a0\u00a0\u00a0Sum = subtree[u]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# loop for all neighbors except parent\u00a0\n\u00a0\u00a0\u00a0\u00a0# and aggregate Sum over all subtrees\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(len(edge[u])):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = edge[u][i]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (v != parent):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dfs(v, u, totalSum, edge,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subtree, res)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Sum += subtree[v]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# store Sum in current node's\u00a0\n\u00a0\u00a0\u00a0\u00a0# subtree index\u00a0\n\u00a0\u00a0\u00a0\u00a0subtree[u] = Sum\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# at one side subtree Sum is 'Sum' and\u00a0\n\u00a0\u00a0\u00a0\u00a0# other side subtree Sum is 'totalSum - Sum'\u00a0\n\u00a0\u00a0\u00a0\u00a0# so their difference will be totalSum - 2*Sum,\u00a0\n\u00a0\u00a0\u00a0\u00a0# by which we'll update res\u00a0\n\u00a0\u00a0\u00a0\u00a0if (u != 0 and abs(totalSum - 2 * Sum) < res[0]):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[0] = abs(totalSum - 2 * Sum)\u00a0\n\u00a0\u00a0\n# Method returns minimum subtree\u00a0\n# Sum difference\u00a0\ndef getMinSubtreeSumDifference(vertex, edges, N):\u00a0\n\u00a0\u00a0\u00a0\u00a0totalSum = 0\n\u00a0\u00a0\u00a0\u00a0subtree = [None] * N\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Calculating total Sum of tree\u00a0\n\u00a0\u00a0\u00a0\u00a0# and initializing subtree Sum's\u00a0\n\u00a0\u00a0\u00a0\u00a0# by vertex values\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subtree[i] = vertex[i]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalSum += vertex[i]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# filling edge data structure\u00a0\n\u00a0\u00a0\u00a0\u00a0edge = [[] for i in range(N)]\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N - 1):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge[edges[i][0]].append(edges[i][1])\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edge[edges[i][1]].append(edges[i][0])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0res = [999999999999]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# calling DFS method at node 0,\u00a0\n\u00a0\u00a0\u00a0\u00a0# with parent as -1\u00a0\n\u00a0\u00a0\u00a0\u00a0dfs(0, -1, totalSum, edge, subtree, res)\u00a0\n\u00a0\u00a0\u00a0\u00a0return res[0]\u00a0\n\u00a0\u00a0\n# Driver Code\u00a0\nif __name__ == '__main__':\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0vertex = [4, 2, 1, 6, 3, 5, 2]\u00a0\n\u00a0\u00a0\u00a0\u00a0edges = [[0, 1], [0, 2], [0, 3],\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 4], [2, 5], [3, 6]]\u00a0\n\u00a0\u00a0\u00a0\u00a0N = len(vertex)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(getMinSubtreeSumDifference(vertex,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges, N))\u00a0\n\u00a0\u00a0\n# This code is contributed by PranchalK\u00a0\n"}
{"nl": "Dijkstra\u2019s Algorithm for Adjacency List Representation | Greedy Algo-8", "code": "# A Python program for Dijkstra's shortest\n# path algorithm for adjacency\n# list representation of graph\n\u00a0\nfrom collections import defaultdict\nimport sys\n\u00a0\n\u00a0\nclass Heap():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def newMinHeapNode(self, v, dist):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeapNode = [v, dist]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return minHeapNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A utility function to swap two nodes\n\u00a0\u00a0\u00a0\u00a0# of min heap. Needed for min heapify\n\u00a0\u00a0\u00a0\u00a0def swapMinHeapNode(self, a, b):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = self.array[a]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[a] = self.array[b]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[b] = t\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A standard function to heapify at given idx\n\u00a0\u00a0\u00a0\u00a0# This function also updates position of nodes\n\u00a0\u00a0\u00a0\u00a0# when they are swapped.Position is needed\n\u00a0\u00a0\u00a0\u00a0# for decreaseKey()\n\u00a0\u00a0\u00a0\u00a0def minHeapify(self, idx):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest = idx\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = 2*idx + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = 2*idx + 2\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (left < self.size and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[left][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0< self.array[smallest][1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest = left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (right < self.size and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[right][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0< self.array[smallest][1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0smallest = right\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# The nodes to be swapped in min\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# heap if idx is not smallest\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if smallest != idx:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Swap positions\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[self.array[smallest][0]] = idx\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[self.array[idx][0]] = smallest\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Swap nodes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.swapMinHeapNode(smallest, idx)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.minHeapify(smallest)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Standard function to extract minimum\n\u00a0\u00a0\u00a0\u00a0# node from heap\n\u00a0\u00a0\u00a0\u00a0def extractMin(self):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Return NULL wif heap is empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty() == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Store the root node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = self.array[0]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Replace root node with last node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastNode = self.array[self.size - 1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[0] = lastNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update position of last node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[lastNode[0]] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[root[0]] = self.size - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Reduce heap size and heapify root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.minHeapify(0)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.size == 0 else False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def decreaseKey(self, v, dist):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the index of v in\u00a0 heap array\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = self.pos[v]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the node and update its dist value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[i][1] = dist\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Travel up while the complete tree is\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# not hepified. This is a O(Logn) loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (i > 0 and self.array[i][1] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[(i - 1) // 2][1]):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Swap this node with its parent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[ self.array[i][0] ] = (i-1)//2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.pos[ self.array[(i-1)//2][0] ] = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.swapMinHeapNode(i, (i - 1)//2 )\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# move to parent index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = (i - 1) // 2;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# A utility function to check if a given\n\u00a0\u00a0\u00a0\u00a0# vertex 'v' is in min heap or not\n\u00a0\u00a0\u00a0\u00a0def isInMinHeap(self, v):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.pos[v] < self.size:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\ndef printArr(dist, n):\n\u00a0\u00a0\u00a0\u00a0print (\"Vertex\\tDistance from source\")\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"%d\\t\\t%d\" % (i,dist[i]))\n\u00a0\n\u00a0\nclass Graph():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Adds an edge to an undirected graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self, src, dest, weight):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add an edge from src to dest.\u00a0 A new node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is added to the adjacency list of src. The\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# node is added at the beginning. The first\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element of the node has the destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and the second elements has the weight\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode = [dest, weight]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[src].insert(0, newNode)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Since graph is undirected, add an edge\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# from dest to src also\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode = [src, weight]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[dest].insert(0, newNode)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# The main function that calculates distances\n\u00a0\u00a0\u00a0\u00a0# of shortest paths from src to all vertices.\n\u00a0\u00a0\u00a0\u00a0# It is a O(ELogV) function\n\u00a0\u00a0\u00a0\u00a0def dijkstra(self, src):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = self.V\u00a0 # Get the number of vertices in graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist = []\u00a0\u00a0 # dist values used to pick minimum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# weight edge in cut\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# minHeap represents set E\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap = Heap()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#\u00a0 Initialize min heap with all vertices.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# dist value of all vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for v in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist.append(1e7)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.array.append( minHeap.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newMinHeapNode(v, dist[v]))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.pos.append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Make dist value of src vertex as 0 so\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# that it is extracted first\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.pos[src] = src\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[src] = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.decreaseKey(src, dist[src])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Initially size of min heap is equal to V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.size = V;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# In the following loop,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# min heap contains all nodes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# whose shortest distance is not yet finalized.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while minHeap.isEmpty() == False:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Extract the vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# with minimum distance value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newHeapNode = minHeap.extractMin()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = newHeapNode[0]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Traverse through all adjacent vertices of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# u (the extracted vertex) and update their\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# distance values\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for pCrawl in self.graph[u]:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = pCrawl[0]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If shortest distance to v is not finalized\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# yet, and distance to v through u is less\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than its previously calculated distance\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (minHeap.isInMinHeap(v) and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[u] != 1e7 and \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pCrawl[1] + dist[u] < dist[v]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[v] = pCrawl[1] + dist[u]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# update distance value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in min heap also\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minHeap.decreaseKey(v, dist[v])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printArr(dist,V)\n\u00a0\n\u00a0\n# Driver program to test the above functions\ngraph = Graph(9)\ngraph.addEdge(0, 1, 4)\ngraph.addEdge(0, 7, 8)\ngraph.addEdge(1, 2, 8)\ngraph.addEdge(1, 7, 11)\ngraph.addEdge(2, 3, 7)\ngraph.addEdge(2, 8, 2)\ngraph.addEdge(2, 5, 4)\ngraph.addEdge(3, 4, 9)\ngraph.addEdge(3, 5, 14)\ngraph.addEdge(4, 5, 10)\ngraph.addEdge(5, 6, 2)\ngraph.addEdge(6, 7, 1)\ngraph.addEdge(6, 8, 6)\ngraph.addEdge(7, 8, 7)\ngraph.dijkstra(0)\n\u00a0\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "Print all triplets in sorted array that form AP\n", "code": "# python 3 program to print all triplets in given\n# array that form Arithmetic Progression\n\n# Function to print all triplets in\n# given sorted array that forms AP\ndef printAllAPTriplets(arr, n):\n\n        for i in range(1, n - 1):\n\n                # Search other two elements of\n                # AP with arr[i] as middle.\n                j = i - 1\n                k = i + 1\n                while(j >= 0 and k < n ):\n\n                        # if a triplet is found\n                        if (arr[j] + arr[k] == 2 * arr[i]):\n                                print(arr[j], \"\", arr[i], \"\", arr[k])\n\n                                # Since elements are distinct,\n                                # arr[k] and arr[j] cannot form\n                                # any more triplets with arr[i]\n                                k += 1\n                                j -= 1\n                        \n\n                        # If middle element is more move to\n                        # higher side, else move lower side.\n                        elif (arr[j] + arr[k] < 2 * arr[i]):\n                                k += 1        \n                        else:\n                                j -= 1        \n                \n# Driver code\narr = [ 2, 6, 9, 12, 17,\n                22, 31, 32, 35, 42 ]\nn = len(arr)\nprintAllAPTriplets(arr, n)\n\n# This article is contributed\n# by Smitha Dinesh Semwal\n"}
{"nl": "Linear Search", "code": "# Python3 code to linearly search x in arr[].\n# If x is present then return its location,\n# otherwise return -1\n\n\ndef search(arr, n, x):\n\n\tfor i in range(0, n):\n\t\tif (arr[i] == x):\n\t\t\treturn i\n\treturn -1\n\n\n# Driver Code\narr = [2, 3, 4, 10, 40]\nx = 10\nn = len(arr)\n\n# Function call\nresult = search(arr, n, x)\nif(result == -1):\n\tprint(\"Element is not present in array\")\nelse:\n\tprint(\"Element is present at index\", result)"}
{"nl": "Split a list into two lists of even and odd numbers", "code": "# given list\r\ngiven_list = [7, 24, 72, 39, 65, 87, 93,\r\n              27, 64, 96, 82, 36, 47, 75, 12, 58, 97]\r\n# Create two empty lists. one for storing even numbers and the other\r\n# for storing odd numbers, referred to as evenList and oddList.\r\nevenList = []\r\noddList = []\r\n# Using a for loop, traverse the given list.\r\nfor element in given_list:\r\n    # If the given list element is even then append this element to evenList\r\n    if(element % 2 == 0):\r\n        evenList.append(element)\r\n    # If the given list element is odd then append this element to oddList\r\n    else:\r\n        oddList.append(element)\r\n# printing both evenList and oddList\r\nprint(\"The even elements present in given list are :\")\r\nprint(evenList)\r\nprint(\"The odd elements present in given list are :\")\r\nprint(oddList)"}
{"nl": "Python Program to Illustrate Different Set Operations", "code": "# Program to perform different set operations like in mathematics\n\n# define three sets\nE = {0, 2, 4, 6, 8};\nN = {1, 2, 3, 4, 5};\n\n# set union\nprint(\"Union of E and N is\",E | N)\n\n# set intersection\nprint(\"Intersection of E and N is\",E & N)\n\n# set difference\nprint(\"Difference of E and N is\",E - N)\n\n# set symmetric difference\nprint(\"Symmetric difference of E and N is\",E ^ N)"}
{"nl": "Functioninator 8000", "code": "def inator_inator(s):\n  return '{}{}inator {}000'.format(s, '-' if s[-1].lower() in 'aeiou' else '', len(s))"}
{"nl": "Python Program to Find all Numbers in a Range which are Perfect Squares and Sum of all Digits in the Number is Less than 10", "code": "# given lower limit range as static input\n \n lowerlimit = 5\n \n # given upper limit range as static input\n \n upperlimit = 525\n \n # When the element is a perfect square within the range and the total of the digits of the number\n \n # is less than 10, a list must be generated using list comprehension.\n \n prftSquaresList = [k for k in range(\n \n  lowerlimit, upperlimit+1) if (int(k**0.5))**2 == k and sum(list(map(int, str(k)))) &lt; 10]\n \n # printing the list\n \n print(\"Printing the perfect squares numbers list which are less than 10: \", prftSquaresList)\n \n </pre>"}
{"nl": "Print mirrored right triangle star pattern given number of rows in the triangle.", "code": "# Give the number of rows of the right triangle pattern as static input and store it in a variable.\r\ntriNumRows = 6\r\n# Iterate from 1 to given rows using the First for loop.\r\nfor m in range(1, triNumRows+1):\r\n    # Iterate from 1 to given rows using another for loop(Nested For loop)\r\n    for n in range(1, triNumRows+1):\r\n        # Check if the iterator value of the inner for loop is less than or equal to given rows - first iterator value using If statement.\r\n        if(n <= triNumRows - m):\r\n            # If the statement is true then print space.\r\n            print(' ', end=' ')\r\n        else:\r\n            # Else print star character with space.\r\n            print('*', end=' ')\r\n    #Print the newline character after the exit of the inner for loop.\r\n    print()"}
{"nl": "Find Vowels and Consonants in Python", "code": "# Python code to find character is vowels or consonants # inputs from the user c = input('Enter a Characters: ') # find vowel or constant and display result if(c=='A' or c=='a' or c=='E' or c =='e' or c=='I' or c=='i' or c=='O' or c=='o' or c=='U' or c=='u'): print(c, \"is a Vowels.\") else: print(c, \"is a Consonants.\")"}
{"nl": "Write a Program to Reverse a Number in Python | Reverse Digits or Integers", "code": "# given number\n \n given_num = 12345\n \n \n \n # Take a variable reverse_number and initialize it to null\n \n reverse_number = 0\n \n \n \n # using while loop to reverse the given number\n \n \n \n while (given_num > 0):\n \n  # implementing the algorithm\n \n  # getting the last digit\n \n  remainder = given_num % 10\n \n  reverse_number = (reverse_number * 10) + remainder\n \n  given_num = given_num // 10\n \n \n \n # Display the result\n \n print(\"The reversed number =\", reverse_number)"}
{"nl": "Tilt of Binary Tree", "code": "# Python3 Program to find Tilt of\n# Binary Tree\n\u00a0\n# class that allocates a new node\n# with the given data and\n# None left and right pointers.\nclass newNode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.val = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\n# Recursive function to calculate\n# Tilt of whole tree\ndef traverse(root, tilt):\n\u00a0\u00a0\u00a0\u00a0if (not root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Compute tilts of left and right subtrees\n\u00a0\u00a0\u00a0\u00a0# and find sums of left and right subtrees\n\u00a0\u00a0\u00a0\u00a0left = traverse(root.left, tilt)\n\u00a0\u00a0\u00a0\u00a0right = traverse(root.right, tilt)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Add current tilt to overall\n\u00a0\u00a0\u00a0\u00a0tilt[0] += abs(left - right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns sum of nodes under\n\u00a0\u00a0\u00a0\u00a0# current tree\n\u00a0\u00a0\u00a0\u00a0return left + right + root.val\n\u00a0\n# Driver function to print Tilt\n# of whole tree\ndef Tilt(root):\n\u00a0\u00a0\u00a0\u00a0tilt = [0]\n\u00a0\u00a0\u00a0\u00a0traverse(root, tilt)\n\u00a0\u00a0\u00a0\u00a0return tilt[0]\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us construct a Binary Tree\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 4\n\u00a0\u00a0\u00a0\u00a0# / \\\n\u00a0\u00a0\u00a0\u00a0# 2 9\n\u00a0\u00a0\u00a0\u00a0# / \\ \\\n\u00a0\u00a0\u00a0\u00a0# 3 5 7\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = newNode(4)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(9)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(3)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(8)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(7)\n\u00a0\u00a0\u00a0\u00a0print(\"The Tilt of whole tree is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tilt(root))\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Given a matrix with just 0s and 1s , find the row with the largest number of 1s.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[1, 0, 0], [1, 1, 1], [1, 0, 1]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# take a variable which stores the number of 1's in the row and initialize it with 0\r\nmaxOnes = 0\r\n\r\n# Loop till the given number of rows using the For loop.\r\nfor p in range(mtrxrows):\r\n        # calculate the number of ones in that row using the count() function\r\n    numbOfOnes = mtrx[p].count(1)\r\n    # check if the number of ones in that row is greater or equal to\r\n    # than maxOnes using the if conditional statement\r\n    if(numbOfOnes >= maxOnes):\r\n        # if it is true then initializee maxOnes with numbOfOnes\r\n        maxOnes = numbOfOnes\r\n        # take a variable and store this row number in this row\r\n        maxOnesRow = p+1\r\n# print the row that is containing maximum number of 1's by printing  maxOnesRow\r\nprint('The row which is containing maximum number of 1 is :', maxOnesRow)"}
{"nl": "Rotate the List by One \ud83d\udd04", "code": "def rotate_by_one(lst):\n    return [lst[-1]]+lst[0:-1]"}
{"nl": "Print (Generate) Pascal Triangle", "code": "row = int(input(\"Enter number of rows: \"))\r\n\r\nspace = 36\r\n\r\n# empty list containg all 0s\r\na = [0] * 20 \r\n\r\n\r\nprint(\"\\n\\t\\t\\t\\t*** PASCAL TRIANGLE ***\\n\")\r\nfor i in range(row):\r\n    \r\n    for spi in range(1,space+1):\r\n        print(\" \", end=\"\")\r\n    \r\n    a[i] = 1\r\n    \r\n    for j in range(i+1):\r\n        print('%6d' %(a[j]), end = \"\")\r\n    \r\n    for j in range(i,0,-1):\r\n        a[j] = a[j] + a[j-1]\r\n    \r\n    space = space - 3\r\n    \r\n    print()"}
{"nl": "Python Program to Find Unique Elements in a Matrix", "code": "# import the Counter Function from collections using the import keyword\n from collections import Counter\n # Give the matrix as static input and store it in a variable.\n mtrx = [[1, 2, 2], [3, 4, 2], [5, 1, 5]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n # take a list and initialize it to empty using [] or list() function\n mtrxlist = []\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # add the gvnmatrix[n][m] value to the list using the append() function\n  # where n is the iterator value of the parent For loop and m is the iterator\n  # value of the inner For loop.\n  mtrxlist.append(mtrx[n][m])\n # Apply the Counter function to the matrix elements list which stores the matrix element\n # as key and its frequency as value\n mtrxfreq = Counter(mtrxlist)\n # Print all the keys of the mtrxfreq(using keys() function)\n # which are the uniques values in the given matrix\n print('The unique matrix elements in the given matrix are :')\n print(*mtrxfreq.keys())"}
{"nl": "Python del Keyword", "code": "class MyClass:\r\n  name = \"John\"\r\n\r\ndel MyClass\r\n\r\nprint(MyClass)"}
{"nl": "all possible subsets", "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        # Sorting will help us to skip a number that have been\n        # already used at i-th position at specific permutation.\n        nums.sort()\n        ans = []\n        def backtrack(i=0, solution=[]):\n            ans.append(solution[:])\n            \n            for j in range(i, len(nums)):\n                # We can re-use numbers, but not at this position\n                # and same previous premutation\n                if j > i and nums[j] == nums[j-1]:\n                    continue\n                solution.append(nums[j])\n                backtrack(j+1, solution)\n                solution.pop()\n        backtrack()\n        return ans"}
{"nl": "Bus Class Inheritance from Vehicle Class", "code": "class Vehicle:\r\n    def __init__(self, name, max_speed, mileage):\r\n        self.name = name\r\n        self.max_speed = max_speed\r\n        self.mileage = mileage\r\n\r\n    def seating_capacity(self, capacity):\r\n        return f\"The seating capacity of a {self.name} is {capacity} passengers\"\r\n\r\nclass Bus(Vehicle):\r\n    # assign default value to capacity\r\n    def seating_capacity(self, capacity=50):\r\n        return super().seating_capacity(capacity=50)\r\n\r\nSchool_bus = Bus(\"School Volvo\", 180, 12)\r\nprint(School_bus.seating_capacity())"}
{"nl": "Exercise working with Armstrong numbers, basic arithmetic calculations", "code": "# Armstrong numbers are equal to the sum of the powers of their digits\n# Exponent is the length of the number, base 10\ndef is_armstrong_number(number: int) -> bool:\n    \"\"\"Is number the equal to sum of powers of digits?\"\"\"\n    s = str(number)\n    exp = len(s)\n    return number == sum([int(ch)**exp for ch in s])"}
{"nl": "Succinct Encoding of Binary Tree", "code": "# Python program to demonstrate Succinct Tree Encoding and Decoding\n\u00a0\n# Node structure\nclass Node:\n\u00a0\u00a0\u00a0\u00a0# Utility function to create new Node\n\u00a0\u00a0\u00a0\u00a0def __init__(self , key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\ndef EncodeSuccinct(root , struc , data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If root is None , put 0 in structure array and return\n\u00a0\u00a0\u00a0\u00a0if root is None :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struc.append(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Else place 1 in structure array, key in 'data' array\n\u00a0\u00a0\u00a0\u00a0# and recur for left and right children\n\u00a0\u00a0\u00a0\u00a0struc.append(1)\n\u00a0\u00a0\u00a0\u00a0data.append(root.key)\n\u00a0\u00a0\u00a0\u00a0EncodeSuccinct(root.left , struc , data)\n\u00a0\u00a0\u00a0\u00a0EncodeSuccinct(root.right , struc ,data)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n# Constructs tree from 'struc' and 'data'\ndef DecodeSuccinct(struc , data):\n\u00a0\u00a0\u00a0\u00a0if(len(struc) <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Remove one item from structure list\n\u00a0\u00a0\u00a0\u00a0b = struc[0]\n\u00a0\u00a0\u00a0\u00a0struc.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If removed bit is 1\n\u00a0\u00a0\u00a0\u00a0if b == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0key = data[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#Create a tree node with removed data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#And recur to create left and right subtrees\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = DecodeSuccinct(struc , data);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = DecodeSuccinct(struc , data);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\ndef preorder(root):\n\u00a0\u00a0\u00a0\u00a0if root is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"key: %d\" %(root.key),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if root.left is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"| left child: %d\" %(root.left.key),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if root.right is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"| right child %d\" %(root.right.key),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print ()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0preorder(root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0preorder(root.right)\n\u00a0\n# Driver Program\nroot = Node(10)\nroot.left = Node(20)\nroot.right = Node(30)\nroot.left.left = Node(40)\nroot.left.right = Node(50)\nroot.right.right = Node(70)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\nprint (\"Given Tree\")\npreorder(root)\nstruc = []\ndata = []\nEncodeSuccinct(root , struc , data)\n\u00a0\nprint (\"\\nEncoded Tree\")\nprint (\"Structure List\")\n\u00a0\nfor i in struc:\n\u00a0\u00a0\u00a0\u00a0print (i ,end=\" \")\n\u00a0\nprint (\"\\nDataList\")\nfor value in data:\n\u00a0\u00a0\u00a0\u00a0print (value,end=\" \")\n\u00a0\nnewroot = DecodeSuccinct(struc , data)\n\u00a0\nprint (\"\\n\\nPreorder Traversal of decoded tree\")\npreorder(newroot)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "check if the second reversing on a number leads to the original number", "code": "class Solution:\n    def isSameAfterReversals(self, num: int) -> bool:\n        return (num == 0 or (num > 0 and num%10 != 0))"}
{"nl": "Smooth Sentences\n", "code": "def is_smooth(sentence):\n    sentence = sentence.lower().split()\n    first = [first_letter[0] for first_letter in sentence]\n    last = [last_letter[-1] for last_letter in sentence]\n    return first[1:] == last [:-1]"}
{"nl": "Combined Consecutive Sequence", "code": "def consecutive_combo(lst1, lst2):\n  lst3 = lst1 + lst2\n  return max(lst3) - min(lst3) == len(lst3) - 1"}
{"nl": "Servers that handled most number of requests", "code": "def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\nbusy_jobs = []  # heap (job_end_time, node) to free up the nodes quickly\nafter = [] # heap (nodes) free after current server\nbefore = list(range(k))  # heap (nodes) to use for loopback\nrequests_handled = [0] * k\n\nfor i, (arrvl, ld) in enumerate(zip(arrival, load)):\nserver_id = i % k\nif server_id == 0:  # loopback\nafter = before\nbefore = []\n\nwhile busy_jobs and busy_jobs[0][0] <= arrvl:\nfreed_node = heapq.heappop(busy_jobs)[1]\nif freed_node < server_id: heapq.heappush(before, freed_node)\nelse: heapq.heappush(after, freed_node)\n\nuse_queue = after if after else before\nif not use_queue: continue  # request dropped\nusing_node = heapq.heappop(use_queue)\nrequests_handled[using_node] += 1\nheapq.heappush(busy_jobs, (arrvl + ld, using_node))\n\nmaxreqs = max(requests_handled)\nreturn [i for i, handled in enumerate(requests_handled) if handled == maxreqs]"}
{"nl": "List Comprehension\r\n", "code": "fruits = [\"apple\", \"banana\", \"cherry\", \"kiwi\", \"mango\"]\r\nnewlist = []\r\n\r\nfor x in fruits:\r\n  if \"a\" in x:\r\n    newlist.append(x)\r\n\r\nprint(newlist)"}
{"nl": "Diagonal traverse", "code": "def findDiagonalOrder(self, A):\n  res = []\n  for i, r in enumerate(A):\n  for j, a in enumerate(r):\n  if len(res) <= i + j:\n  res.append([])\n  res[i + j].append(a)\n  return [a for r in res for a in reversed(r)]"}
{"nl": "Length of the largest subarray with contiguous elements (Non-distinct and Distinct)", "code": "# python program to find length of the largest\r\n# subarray which has all contiguous elements */\r\n \r\n# This function prints all distinct elements\r\ndef findLenght(arr, n):\r\n    max_len = 1\r\n    for i in range(0,n - 1):\r\n \r\n        # Create an empty hash set and\r\n        # add i'th element to it\r\n        myset = set()\r\n        myset.add(arr[i])\r\n \r\n        # Initialize max and min in\r\n        # current subarray\r\n        mn = arr[i]\r\n        mx = arr[i]\r\n        for j in range(i + 1,n):\r\n \r\n            # If current element is already\r\n            # in hash set, then this subarray\r\n            # cannot contain contiguous elements\r\n            if arr[j] in myset:\r\n                break\r\n \r\n \r\n            # Else add current element to hash\r\n            # set and update min, max if required.\r\n            myset.add(arr[j])\r\n            mn = min(mn, arr[j])\r\n            mx = max(mx, arr[j])\r\n \r\n            # We have already checked for\r\n            # duplicates, now check for other\r\n            #property and update max_len\r\n            # if needed\r\n            if mx - mn == j - i:\r\n                max_len = max(max_len, mx - mn + 1)\r\n \r\n    return max_len # Return result\r\n \r\n \r\n# Driver code\r\n \r\narr = [10, 12, 12, 10, 10, 11, 10]\r\nn = len(arr)\r\nprint(\"Length of the longest contiguous subarray is\",\r\n                                findLenght(arr,n))\r\n \r\n# This code is contributed by Shrikant13"}
{"nl": "Number Groups", "code": "def number_groups(*g):\n  a, b, c = [set(i) for i in g]\n  return sorted(set.union(a.intersection(b),a.intersection(c),b.intersection(c)))"}
{"nl": "a deep copy (clone) of the connected undirected graph", "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, neighbors):\n        self.val = val\n        self.neighbors = neighbors\n\"\"\"\nfrom collections import deque\nclass Solution(object):\n\n    def cloneGraph(self, node):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n\n        if not node:\n            return node\n\n        # Dictionary to save the visited node and it's respective clone\n        # as key and value respectively. This helps to avoid cycles.\n        visited = {}\n\n        # Put the first node in the queue\n        queue = deque([node])\n        # Clone the node and put it in the visited dictionary.\n        visited[node] = Node(node.val, [])\n\n        # Start BFS traversal\n        while queue:\n            # Pop a node say \"n\" from the from the front of the queue.\n            n = queue.popleft()\n            # Iterate through all the neighbors of the node\n            for neighbor in n.neighbors:\n                if neighbor not in visited:\n                    # Clone the neighbor and put in the visited, if not present already\n                    visited[neighbor] = Node(neighbor.val, [])\n                    # Add the newly encountered node to the queue.\n                    queue.append(neighbor)\n                # Add the clone of the neighbor to the neighbors of the clone node \"n\".\n                visited[n].neighbors.append(visited[neighbor])\n\n        # Return the clone of the node from visited.\n        return visited[node]"}
{"nl": "Total numbers with no repeated digits in a range", "code": "# Python implementation of\r\n# above idea\r\n\r\n# Prefix Array\r\nPrefix = [0]\r\n\r\n# Function to check if\r\n# the given number has\r\n# repeated digit or not\r\ndef repeated_digit(n):\r\n        a = []\r\n        \r\n        # Traversing through each digit\r\n        while n != 0:\r\n                d = n%10\r\n                \r\n                # if the digit is present\r\n                # more than once in the\r\n                # number\r\n                if d in a:\r\n                        \r\n                        # return 0 if the number\r\n                        # has repeated digit\r\n                        return 0\r\n                a.append(d)\r\n                n = n//10\r\n        \r\n        # return 1 if the number has no\r\n        # repeated digit\r\n        return 1\r\n\r\n# Function to pre calculate\r\n# the Prefix array\r\ndef pre_calculation(MAX):\r\n        \r\n        # To use to global Prefix array\r\n        global Prefix\r\n        Prefix.append(repeated_digit(1))\r\n        \r\n        # Traversing through the numbers\r\n        # from 2 to MAX\r\n        for i in range(2,MAX+1):\r\n                \r\n                # Generating the Prefix array\r\n                Prefix.append( repeated_digit(i) +\r\n                                        Prefix[i-1] )\r\n\r\n# Calclute Function\r\ndef calculate(L,R):\r\n        \r\n        # Answer\r\n        return Prefix[R]-Prefix[L-1]\r\n\r\n\r\n# Driver Code\r\n\r\n# Maximum\r\nMAX = 1000\r\n\r\n# Pre-calculating the Prefix array.\r\npre_calculation(MAX)\r\n\r\n# Range\r\nL=1\r\nR=100\r\n\r\n# Calling the calculate function\r\n# to find the total number of number\r\n# which has no repeated digit\r\nprint(calculate(L, R))\r"}
{"nl": "Convert one number to another by flipping its binary representation a minimum number of times", "code": "def minBitFlips(self, start: int, goal: int) -> int:\n        val=start^goal\n        count=0\n        while(val):\n            n=val&1\n            val=val>>1\n            if(n==1):\n                count+=1\n        return count"}
{"nl": "Sort a stack using recursion", "code": "# Python program to sort a stack using recursion\n\u00a0\n# Recursive method to insert element in sorted way\n\u00a0\n\u00a0\ndef sortedInsert(s, element):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case: Either stack is empty or newly inserted\n\u00a0\u00a0\u00a0\u00a0# item is greater than top (more than all existing)\n\u00a0\u00a0\u00a0\u00a0if len(s) == 0 or element > s[-1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(element)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove the top item and recur\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = s.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sortedInsert(s, element)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Put back the top item removed earlier\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(temp)\n\u00a0\n# Method to sort stack\n\u00a0\n\u00a0\ndef sortStack(s):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If stack is not empty\n\u00a0\u00a0\u00a0\u00a0if len(s) != 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove the top item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = s.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Sort remaining stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sortStack(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push the top item back in sorted stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sortedInsert(s, temp)\n\u00a0\n# Printing contents of stack\n\u00a0\n\u00a0\ndef printStack(s):\n\u00a0\u00a0\u00a0\u00a0for i in s[::-1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(i, end=\" \")\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\u00a0\u00a0\u00a0s.append(30)\n\u00a0\u00a0\u00a0\u00a0s.append(-5)\n\u00a0\u00a0\u00a0\u00a0s.append(18)\n\u00a0\u00a0\u00a0\u00a0s.append(14)\n\u00a0\u00a0\u00a0\u00a0s.append(-3)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Stack elements before sorting: \")\n\u00a0\u00a0\u00a0\u00a0printStack(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0sortStack(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"\\nStack elements after sorting: \")\n\u00a0\u00a0\u00a0\u00a0printStack(s)\n\u00a0\n# This code is contributed by Muskan Kalra.\n"}
{"nl": "Digits Battle!", "code": "from itertools import zip_longest\ndef battle_outcome(num):\n  s = str(num)\n  return int(''.join(max(a, b) for a, b in zip_longest(s[::2], s[1::2], fillvalue) if a != b))"}
{"nl": "Count Distinct Non-Negative Integer Pairs (x, y) that Satisfy the Inequality x*x + y*y < n", "code": "# Python3 implementation of above approach\n\n# This function counts number of pairs\n# (x, y) that satisfy\n# the inequality x*x + y*y < n.\ndef countSolutions(n):\n\n\tres = 0\n\tx = 0\n\twhile(x * x < n):\n\t\ty = 0\n\t\twhile(x * x + y * y < n):\n\t\t\tres = res + 1\n\t\t\ty = y + 1\n\t\tx = x + 1\n\n\treturn res\n\n# Driver program to test above function\nif __name__=='__main__':\n\tprint(\"Total Number of distinct Non-Negative pairs is \",\n\t\tcountSolutions(6))\n\n# This code is contributed by\n# Sanjit_Prasad"}
{"nl": "Bitwise Right Shift Implementation", "code": "# Give the number as static input and store it in a variable\r\ngvn_numb = 3\r\n# Right Shift 1 bit of the given number and print the result\r\nprint(\"The number after Right shifting given number by 1 bit:\")\r\nprint(gvn_numb>>1)\r\n# Right Shift 2 bits of the given number and print the result\r\nprint(\"The number after Right shifting given number by 2 bits:\")\r\nprint(gvn_numb>>2)"}
{"nl": "Reverse a number using stack", "code": "# Python3 program to reverse the\n# number using a stack\n\u00a0\n# Stack to maintain order of digits\nst = [];\n\u00a0\n# Function to push digits into stack\ndef push_digits(number):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while (number != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.append(number % 10);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0number = int(number / 10);\n\u00a0\n# Function to reverse the number\ndef reverse_number(number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call to push number's\n\u00a0\u00a0\u00a0\u00a0# digits to stack\n\u00a0\u00a0\u00a0\u00a0push_digits(number);\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0reverse = 0;\n\u00a0\u00a0\u00a0\u00a0i = 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Popping the digits and forming\n\u00a0\u00a0\u00a0\u00a0# the reversed number\n\u00a0\u00a0\u00a0\u00a0while (len(st) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reverse = reverse + (st[len(st) - 1] * i);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i * 10;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return the reversed number formed\n\u00a0\u00a0\u00a0\u00a0return reverse;\n\u00a0\n# Driver Code\nnumber = 39997;\n\u00a0\n# Function call to reverse number\nprint(reverse_number(number));\n\u00a0\n# This code is contributed by mits\n"}
{"nl": "The minimum number of increments on subarrays to form a target array", "code": "def minNumberOperations(self, A):\n  return sum(max(b - a, 0) for b, a in zip(A, [0] + A))"}
{"nl": "Python program to insert a new node at the beginning of the Doubly Linked list", "code": "#Represent a node of doubly linked list    \nclass Node:    \n    def __init__(self,data):    \n        self.data = data;    \n        self.previous = None;    \n        self.next = None;    \n            \nclass InsertStart:    \n    #Represent the head and tail of the doubly linked list    \n    def __init__(self):    \n        self.head = None;    \n        self.tail = None;    \n            \n    #addAtStart() will add a node to the starting of the list    \n    def addAtStart(self, data):    \n        #Create a new node    \n        newNode = Node(data);    \n            \n        #If list is empty    \n        if(self.head == None):    \n            #Both head and tail will point to newNode    \n            self.head = self.tail = newNode;    \n            #head's previous will point to None    \n            self.head.previous = None;    \n            #tail's next will point to None, as it is the last node of the list    \n            self.tail.next = None;    \n        #Add newNode as new head of the list    \n        else:    \n            #head's previous node will be newNode    \n            self.head.previous = newNode;    \n            #newNode's next node will be head    \n            newNode.next = self.head;    \n            #newNode's previous will point to None    \n            newNode.previous = None;    \n            #newNode will become new head    \n            self.head = newNode;    \n                \n    #display() will print out the nodes of the list    \n    def display(self):    \n        #Node current will point to head    \n        current = self.head;    \n        if(self.head == None):    \n            print(\"List is empty\");    \n            return;    \n        print(\"Adding a node to the start of the list: \");    \n        while(current != None):    \n            #Prints each node by incrementing pointer.    \n            print(current.data),    \n            current = current.next;    \n                \n        print();    \n            \ndList = InsertStart();    \n     \n#Adding 1 to the list    \ndList.addAtStart(1);    \ndList.display();    \n#Adding 2 to the list    \ndList.addAtStart(2);    \ndList.display();    \n#Adding 3 to the list    \ndList.addAtStart(3);    \ndList.display();    \n#Adding 4 to the list    \ndList.addAtStart(4);    \ndList.display();    \n#Adding 5 to the list    \ndList.addAtStart(5);    \ndList.display();    "}
{"nl": "Python Program to Print Consecutive Rows Numbers in Right Triangle", "code": "rows = int(input(\"Enter Consecutive Numbers in Right Triangle Pattern Rows = \"))\n\nprint(\"====Consecutive Row Numbers Right Triangle Pattern====\")\n\nfor i in range(1, rows + 1):\n    val = i\n    for j in range(1, i + 1):\n        print(val, end = ' ')\n        val = val + rows - j\n    print()"}
{"nl": "Find Longest Word from User Input Sentence", "code": "# Give the string as user input using the input() function and store it in a variable.\r\nGvn_str = input(\"Enter some random sentence = \")\r\n# Split the given string into a list of words using the split() function and\r\n# store it in another variable say \"wrd_lst\".\r\nwrd_lst = Gvn_str.split()\r\n# Get the longest word from a given sentence using max(), key functions, and\r\n# store it in another variable.\r\nlongst_wrd = max(wrd_lst, key=len)\r\n# Calculate the length of the above-obtained longest word using the len() function\r\n# and store it in another variable.\r\nlen_longst_wrd = len(longst_wrd)\r\n# Print the longest word in the above-given sentence.\r\nprint(\"The Longest Word in the above given sentence = \", longst_wrd)\r\n# Print the above-obtained length of the longest word.\r\nprint(\"The length of the longest word = \", len_longst_wrd)"}
{"nl": "find the maximum sum of the bitwise AND of every number in an array", "code": "import json\nclass Solution:\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        \n        filled = [0 for _ in range(numSlots)]\n        n = len(nums)\n        nums.sort()\n        taken = [False for _ in range(n)]\n        filled = [0 for _ in range(numSlots)]\n        \n        @cache\n        def dp(i=0, filled=tuple(filled)):\n            if i >= n:\n                return 0\n            res = 0\n            filled = list(filled)\n            \n            for j in range(numSlots):\n                if filled[j] < 2:\n                    filled[j] += 1\n                    res  = max(res,(nums[i]&(j+1))+ dp(i+1, tuple(filled)))\n                    filled[j] -= 1\n            return res\n        \n        return dp()"}
{"nl": "Moran Numbers", "code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if not n%i:\n            return False\n    return True\ndef moran(n):\n    d = sum(int(i) for i in str(n))\n    if n%d:\n        return 'Neither'\n    return 'M' if is_prime(n//d) else 'H'"}
{"nl": "Print mirrored half diamond star pattern", "code": "# Give the number of rows of the diamond pattern as static input and store it in a variable.\ndiamondrows = 9\n# Loop from 0 to the number of rows using For Loop.\nfor m in range(0, diamondrows):\n    # Loop from 0 to the number of rows -iterator value of the parent\n    # For loop using another For loop(Nested For loop).\n    for n in range(0, diamondrows - m):\n        # Print the space character in the inner For loop.\n        print(' ', end='')\n    # Loop from 0 to the iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(0, m):\n        # Print the star character\n        print('*', end='')\n    # After the end of the inner for Loops print the Newline Character.\n    print()\n# Loop from number of rows to 0 in decreasing order using For loop.\nfor m in range(diamondrows, 0, -1):\n    # Loop from 0 to the number of rows -iterator value of the parent\n    # For loop using another For loop(Nested For loop).\n    for n in range(0, diamondrows - m):\n        # Print the space character in the inner For loop.\n        print(' ', end='')\n    # Loop from 0 to the iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(0, m):\n        # Print the star character\n        print('*', end='')\n\n    # After the end of the inner for Loops print the Newline Character.\n    print()"}
{"nl": "Return the largest number in a matrix", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[2, 9, 1], [11, 4, 5], [9, 2, 3], [1, 2, 3]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Take a variable mtrxmax which stores the maximum element of the given matrix\r\n# and initialize its value to the first element of the given matrix.\r\nmtrxmax = mtrx[0][0]\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n    # Inside the For loop, Iterate till the given number of rows using another\r\n    # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # Check if the gvnmatrix[n][m] value (where n is the iterator value of the\r\n        # parent For loop and m is the iterator value of the inner For loop)\r\n        # is greater than mtrxmax using the if conditional statement.\r\n        if(mtrx[n][m] > mtrxmax):\r\n            # If it is true then modify the mtrxmax value with gvnmatrix[n][m] value.\r\n            mtrxmax = mtrx[n][m]\r\n# Print the mtrxmax value which is the maximum element of the given Matrix\r\nprint('The maximum element of the given matrix', mtrx, 'is :')\r\nprint(mtrxmax)"}
{"nl": "Print right triangle pattern using numbers", "code": "# Give the number of rows of the right-angled triangle Number pattern as user input using int(input())\n# and store it in a variable.\ntriangleNum = int(\n    input('Enter some random number of rows of the triangle Number pattern ='))\n# Loop from 1 to the number of rows using For loop.\nfor m in range(1, triangleNum+1):\n    # Loop from 1 to first loop iterator value using another Nested For loop.\n    for n in range(1, m+1):\n        # Print the iterator value of the nested loop with space in the inner For loop.\n        # (This prints the same number parent loop number of times)\n        print(m, end=' ')\n    # Print the newline character after ending of inner For loop.\n    print()"}
{"nl": "the bitwise AND of all numbers in the range", "code": "class Solution:\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\n        shift = 0   \n        # find the common 1-bits\n        while m < n:\n            m = m >> 1\n            n = n >> 1\n            shift += 1\n        return m << shift"}
{"nl": "Floyd Warshall Algorithm | DP-16", "code": "# Python Program for Floyd Warshall Algorithm\n\u00a0\n# Number of vertices in the graph\nV = 4\n\u00a0\n# Define infinity as the large\n# enough value. This value will be\n# used for vertices not connected to each other\nINF = 99999\n\u00a0\n# Solves all pair shortest path\n# via Floyd Warshall Algorithm\n\u00a0\ndef floydWarshall(graph):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\"\"\" dist[][] will be the output\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0matrix that will finally\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0have the shortest distances\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0between every pair of vertices \"\"\"\n\u00a0\u00a0\u00a0\u00a0\"\"\" initializing the solution matrix\n\u00a0\u00a0\u00a0\u00a0same as input graph matrix\n\u00a0\u00a0\u00a0\u00a0OR we can say that the initial\n\u00a0\u00a0\u00a0\u00a0values of shortest distances\n\u00a0\u00a0\u00a0\u00a0are based on shortest paths considering no\n\u00a0\u00a0\u00a0\u00a0intermediate vertices \"\"\"\n\u00a0\n\u00a0\u00a0\u00a0\u00a0dist = list(map(lambda i: list(map(lambda j: j, i)), graph))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\"\"\" Add all vertices one by one\n\u00a0\u00a0\u00a0\u00a0to the set of intermediate\n\u00a0\u00a0\u00a0\u00a0\u00a0vertices.\n\u00a0\u00a0\u00a0\u00a0\u00a0---> Before start of an iteration,\n\u00a0\u00a0\u00a0\u00a0\u00a0we have shortest distances\n\u00a0\u00a0\u00a0\u00a0\u00a0between all pairs of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0such that the shortest\n\u00a0\u00a0\u00a0\u00a0\u00a0distances consider only the\n\u00a0\u00a0\u00a0\u00a0\u00a0vertices in the set\n\u00a0\u00a0\u00a0\u00a0{0, 1, 2, .. k-1} as intermediate vertices.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0----> After the end of a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0iteration, vertex no. k is\n\u00a0\u00a0\u00a0\u00a0\u00a0added to the set of intermediate\n\u00a0\u00a0\u00a0\u00a0\u00a0vertices and the\n\u00a0\u00a0\u00a0\u00a0set becomes {0, 1, 2, .. k}\n\u00a0\u00a0\u00a0\u00a0\"\"\"\n\u00a0\u00a0\u00a0\u00a0for k in range(V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pick all vertices as source one by one\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pick all vertices as destination for the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# above picked source\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If vertex k is on the shortest path from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# i to j, then update the value of dist[i][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i][j] = min(dist[i][j],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i][k] + dist[k][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\n\u00a0\u00a0\u00a0\u00a0printSolution(dist)\n\u00a0\n\u00a0\n# A utility function to print the solution\ndef printSolution(dist):\n\u00a0\u00a0\u00a0\u00a0print (\"Following matrix shows the shortest distances\\\n\u00a0between every pair of vertices\")\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(dist[i][j] == INF):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"%7s\" % (\"INF\"),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"%7d\\t\" % (dist[i][j]),end=' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == V-1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print ()\n\u00a0\n\u00a0\n# Driver program to test the above program\n# Let us create the following weighted graph\n\"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(0)------->(3)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 /|\\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05 |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 | 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\|/\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1)------->(2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \"\"\"\ngraph = [[0, 5, INF, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, 0, 3, INF],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, 0,\u00a0\u00a0 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, INF, 0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\n# Print the solution\nfloydWarshall(graph)\n# This code is contributed by Mythri J L\n"}
{"nl": "Find pair with greatest product in array", "code": "# Python 3 program to find a pair\n# with product in given array.\n\n# Function to find greatest number\ndef findGreatest( arr , n):\n\n\tresult = -1\n\tfor i in range(n):\n\t\tfor j in range(n - 1):\n\t\t\tfor k in range(j + 1, n):\n\t\t\t\tif (arr[j] * arr[k] == arr[i]):\n\t\t\t\t\tresult = max(result, arr[i])\n\treturn result\n\n# Driver code\nif __name__ == \"__main__\":\n\t\n\tarr = [ 30, 10, 9, 3, 35]\n\tn = len(arr)\n\n\tprint(findGreatest(arr, n))\n\n# This code is contributed by ita_c"}
{"nl": "Binary List to Decimal", "code": "def binary_to_decimal(lst):\n  return int(''.join(map(str,lst)),2)"}
{"nl": "Alternative Sorting", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n#Store it in a variable.\r\ngvn_lst = list(map(int, input(\r\n   'Enter some random List Elements separated by spaces = ').split()))\r\n# Calculate the length of the given list using the len() function and\r\n# store it in another variable.\r\nlen_lst = len(gvn_lst)\r\n# Sort the given list using the sort() method and store it in another variable.\r\ngvn_lst.sort()\r\n# Take a variable say 'p' and initialize its value with zero.\r\np = 0\r\n# Take another variable say 'q' and initialize its value with the length of the\r\n# given list -1.\r\nq = len_lst-1\r\nprint(\"The Alternative sorting of the above given list is :\")\r\n# Check if the value of p is less than q using the while loop.\r\nwhile (p < q):\r\n    # If the statement is true, then print the value of the given list of q.\r\n    print(gvn_lst[q], end=\" \")\r\n    # Subtract 1 from q (q-1)and store it in the same variable 'q'.\r\n    q -= 1\r\n    # Print the value of the given list of p.\r\n    print(gvn_lst[p], end=\" \")\r\n    # Increment the value of p by 1 and store it in the same variable 'p'.\r\n    p += 1\r\n   # Check if the length of the given list is odd(len_lst % 2 != 0) by using the\r\n   # if conditional statement.\r\nif (len_lst % 2 != 0):\r\n    # If the statement is true, print the value of the given list of p.\r\n    print(gvn_lst[p])"}
{"nl": "Format float number to specific decimal places", "code": "num = 458.541315\nprint('%.2f' % num)"}
{"nl": "return the number of combinations of elements such that the sum of three distinct elements is equal to target", "code": "class Solution(object):\n    def threeSumMulti(self, A, target):\n        MOD = 10**9 + 7\n        count = collections.Counter(A)\n        keys = sorted(count)\n\n        ans = 0\n\n        # Now, let's do a 3sum on \"keys\", for i <= j <= k.\n        # We will use count to add the correct contribution to ans.\n        for i, x in enumerate(keys):\n            T = target - x\n            j, k = i, len(keys) - 1\n            while j <= k:\n                y, z = keys[j], keys[k]\n                if y + z < T:\n                    j += 1\n                elif y + z > T:\n                    k -= 1\n                else: # x+y+z == T, now calculate the size of the contribution\n                    if i < j < k:\n                        ans += count[x] * count[y] * count[z]\n                    elif i == j < k:\n                        ans += count[x] * (count[x] - 1) / 2 * count[z]\n                    elif i < j == k:\n                        ans += count[x] * count[y] * (count[y] - 1) / 2\n                    else:  # i == j == k\n                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6\n\n                    j += 1\n                    k -= 1\n\n        return ans % MOD"}
{"nl": "in a two dimensional n by n array, start at element n,1 and simulate a dice throw to incrementally move through the array, after reaching an array element, move to the cell number specified in the array if it's different than -1. return the lowest number of dice throws required to reach the n^2 element", "code": "def snakesAndLadders(self, board: List[List[int]]) -> int:\n        n = len(board)\n        def label_to_position(label):\n            r, c = divmod(label-1, n)\n            if r % 2 == 0:\n                return n-1-r, c\n            else:\n                return n-1-r, n-1-c\n            \n        seen = set()\n        queue = collections.deque()\n        queue.append((1, 0))\n        while queue:\n            label, step = queue.popleft()\n            r, c = label_to_position(label)\n            if board[r][c] != -1:\n                label = board[r][c]\n            if label == n*n:\n                return step\n            for x in range(1, 7):\n                new_label = label + x\n                if new_label <= n*n and new_label not in seen:\n                    seen.add(new_label)\n                    queue.append((new_label, step+1))\n        return -1"}
{"nl": "Python Program to Check If Two Strings are Anagram", "code": "# given two strings\nstring1 = \"skyis\"\nstring2 = \"ssyki\"\n# converting the both strings to lowercase using lower() function.\nstring1 = string1.lower()\nstring2 = string2.lower()\n# checking if both the strings are equal using sorted() function\nif(sorted(string1) == sorted(string2)):\n    print(\"Both the strings are anagrams\")\nelse:\n    print(\"Both the strings are not anagrams\")"}
{"nl": "minimum operations to halve numerical elements of an array to reduce their sum by at least half", "code": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        total=sum(nums)\n        h=[-el for el in nums]\n        heapq.heapify(h)\n        res=cur=0\n        while cur<total/2:\n            val=-heapq.heappop(h)\n            cur+=val/2\n            heapq.heappush(h,-val/2)\n            res+=1\n        return res"}
{"nl": "Python Program to Add Two Matrices", "code": "# Program to add two matrices using nested loop\n\nX = [[12,7,3],\n    [4 ,5,6],\n    [7 ,8,9]]\n\nY = [[5,8,1],\n    [6,7,3],\n    [4,5,9]]\n\nresult = [[0,0,0],\n         [0,0,0],\n         [0,0,0]]\n\n# iterate through rows\nfor i in range(len(X)):\n   # iterate through columns\n   for j in range(len(X[0])):\n       result[i][j] = X[i][j] + Y[i][j]\n\nfor r in result:\n   print(r)\n\n# Program to add two matrices using list comprehension\n\nX = [[12,7,3],\n    [4 ,5,6],\n    [7 ,8,9]]\n\nY = [[5,8,1],\n    [6,7,3],\n    [4,5,9]]\n\nresult = [[X[i][j] + Y[i][j]  for j in range(len(X[0]))] for i in range(len(X))]\n\nfor r in result:\n   print(r)"}
{"nl": "Convert a given tree to its Sum Tree", "code": "# Python3 program to convert a tree\n# into its sum tree\n\n# Node definition\nclass node:\n\t\n\tdef __init__(self, data):\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.data = data\n\n# Convert a given tree to a tree where\n# every node contains sum of values of\n# nodes in left and right subtrees\n# in the original tree\ndef toSumTree(Node) :\n\t\n\t# Base case\n\tif(Node == None) :\n\t\treturn 0\n\n\t# Store the old value\n\told_val = Node.data\n\n\t# Recursively call for left and\n\t# right subtrees and store the sum as\n\t# new value of this node\n\tNode.data = toSumTree(Node.left) + \\\n\t\t\t\ttoSumTree(Node.right)\n\n\t# Return the sum of values of nodes\n\t# in left and right subtrees and\n\t# old_value of this node\n\treturn Node.data + old_val\n\n# A utility function to print\n# inorder traversal of a Binary Tree\ndef printInorder(Node) :\n\tif (Node == None) :\n\t\treturn\n\tprintInorder(Node.left)\n\tprint(Node.data, end = \" \")\n\tprintInorder(Node.right)\n\t\n# Utility function to create a new Binary Tree node\ndef newNode(data) :\n\ttemp = node(0)\n\ttemp.data = data\n\ttemp.left = None\n\ttemp.right = None\n\t\n\treturn temp\n\n# Driver Code\nif __name__ == \"__main__\":\n\troot = None\n\tx = 0\n\t\n\t# Constructing tree given in the above figure\n\troot = newNode(10)\n\troot.left = newNode(-2)\n\troot.right = newNode(6)\n\troot.left.left = newNode(8)\n\troot.left.right = newNode(-4)\n\troot.right.left = newNode(7)\n\troot.right.right = newNode(5)\n\t\n\ttoSumTree(root)\n\t\n\t# Print inorder traversal of the converted\n\t# tree to test result of toSumTree()\n\tprint(\"Inorder Traversal of the resultant tree is: \")\n\tprintInorder(root)\n\n# This code is contributed by Arnab Kundu\n"}
{"nl": "Valid Rondo Form?", "code": "def valid_rondo(s):\n  n = s.replace(\"A\",\"\")\n  return len(n) and s[::len(s)-1]==\"AA\" and \"AA\" not in n and n in \"BCDEFGHIJKLMNOPQRSTUVWXYZ\""}
{"nl": "Number of Squares in an N * N Grid", "code": "def number_squares(n):\n  return (2 * n**3 + 3 * n**2 + n) / 6"}
{"nl": "rearrange an array such that its integer elements are alternating by sign", "code": "def rearrangeArray(self, nums: List[int]) -> List[int]:\n    pos, neg = [], []\n    for i in nums:\n        if i > 0: pos.append(i)\n        else: neg.append(i)\n    i, j = 0, 0\n    \n    while j < len(nums):\n        nums[j] = pos[i]\n        nums[j+1] = neg[i]\n        j += 2\n        i += 1\n    \n    return nums"}
{"nl": "No Hidden Fees", "code": "def has_hidden_fee(prices, t):\n  return sum([int(i[1:]) for i in prices]) < int(t[1:])"}
{"nl": "Find minimum number of coins that make a given value", "code": "# A Dynamic Programming based Python3 program to\r\n# find minimum of coins to make a given change V\r\nimport sys\r\n \r\n# m is size of coins array (number of\r\n# different coins)\r\ndef minCoins(coins, m, V):\r\n     \r\n    # table[i] will be storing the minimum\r\n    # number of coins required for i value.\r\n    # So table[V] will have result\r\n    table = [0 for i in range(V + 1)]\r\n \r\n    # Base case (If given value V is 0)\r\n    table[0] = 0\r\n \r\n    # Initialize all table values as Infinite\r\n    for i in range(1, V + 1):\r\n        table[i] = sys.maxsize\r\n \r\n    # Compute minimum coins required\r\n    # for all values from 1 to V\r\n    for i in range(1, V + 1):\r\n         \r\n        # Go through all coins smaller than i\r\n        for j in range(m):\r\n            if (coins[j] <= i):\r\n                sub_res = table[i - coins[j]]\r\n                if (sub_res != sys.maxsize and\r\n                    sub_res + 1 < table[i]):\r\n                    table[i] = sub_res + 1\r\n     \r\n    if table[V] == sys.maxsize:\r\n        return -1\r\n       \r\n    return table[V]\r\n \r\n# Driver Code\r\nif __name__ == \"__main__\":\r\n \r\n    coins = [9, 6, 5, 1]\r\n    m = len(coins)\r\n    V = 11\r\n    print(\"Minimum coins required is \",\r\n                 minCoins(coins, m, V))\r\n \r\n# This code is contributed by ita_c"}
{"nl": "Python File readline() Method", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.readline())"}
{"nl": "valid soduku", "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        N = 9\n        # Use binary number to check previous occurrence\n        rows = [0] * N\n        cols = [0] * N\n        boxes = [0] * N\n\n        for r in range(N):\n            for c in range(N):\n                # Check if the position is filled with number\n                if board[r][c] == \".\":\n                    continue\n\n                pos = int(board[r][c]) - 1\n\n                # Check the row\n                if rows[r] & (1 << pos):\n                    return False\n                rows[r] |= (1 << pos)\n\n                # Check the column\n                if cols[c] & (1 << pos):\n                    return False\n                cols[c] |= (1 << pos)\n\n                # Check the box\n                idx = (r // 3) * 3 + c // 3\n                if boxes[idx] & (1 << pos):\n                    return False\n                boxes[idx] |= (1 << pos)\n\n        return True"}
{"nl": "Print hollow diamond star pattern", "code": "# Give the number of rows  as static input and store it in a variable.\ndiamondrows = 6\n\n# Loop from 1 to the number of rows using For Loop.\nfor m in range(1, diamondrows+1):\n    # Loop from 1 to the number of rows -iterator value of the parent\n    # For loop using another For loop(Nested For loop).\n    for n in range(1, diamondrows - m + 1):\n        # Print the space character in the inner For loop.\n        print(end=' ')\n    # Loop from 1 to the 2* iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(1, (2 * m)):\n        # If the value of the iterator is equal to 1 or 2* iterator value\n        # of the parent loop -1 then print star character.\n        if l == 1 or l == m * 2 - 1:\n            print('*', end='')\n        # Else print space character.\n        else:\n            print(' ', end='')\n    # After the end of the inner for Loops print the Newline Character.\n    print()\n\n# loop from number of rows -1 to 0 in decreasing order using For loop.\nfor m in range(diamondrows - 1, 0, -1):\n    # Loop from 1 to number of rows- iterator value\n    # of the parent loop using another For loop(Nested For loop)\n    for n in range(1, diamondrows - m + 1):\n        # Print the space character in the inner For loop.\n        print(end=' ')\n    # Loop from 1 to the 2* iterator value of the parent For loop\n    # using another For loop(Nested For loop).\n    for l in range(1, (2 * m)):\n        # If the value of the iterator is equal to 1 or 2* iterator value\n        # of the parent loop -1 then print star character.\n        if l == 1 or l == m * 2 - 1:\n            print('*', end='')\n        # Else print space character.\n        else:\n            print(' ', end='')\n\n    # After the end of the inner for Loops print the Newline Character.\n    print("}
{"nl": "Finish the Sentence You're On!", "code": "def time_to_finish(full, part):\n    return len(full[len(part):].replace(' ', ''))/2"}
{"nl": "Find the Overlapping Range", "code": "def overlapping(lst):\n    low = max(i[0] for i in lst)\n    high = min(i[1] for i in lst)\n    return (low,high) if high >= low else 'No overlapping'"}
{"nl": "The number of students doing homework at a given time", "code": "def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n  return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))"}
{"nl": "Python Program for Modulo of Tuple Elements", "code": "# Give the first tuple as static input and store it in a variable.\n \n fst_tupl = (1, 10, 12, 3, 9)\n \n # Give the second tuple as static input and store it in another variable.\n \n secnd_tupl = (10, 9, 8, 7, 6)\n \n # Loop in the first and second tuples using the zip() function, apply modulus function to\n \n # the first tuple iterator value with the second tuple iterator value and convert this\n \n # statement to a tuple using the tuple() function.\n \n rslt_tupl = tuple(ele1 % ele2 for ele1, ele2 in zip(fst_tupl, secnd_tupl))\n \n # Print the modulo of the given tuple elements.\n \n print(\"The modulus of the given tuple elements\",\n \n  fst_tupl, \"and\", secnd_tupl, \"is:\")\n \n print(rslt_tupl)\n \n </pre>"}
{"nl": "Return the Index of the First Vowel", "code": "def first_vowel(txt):\n  return [txt.index(x) for x in txt if x.lower() in 'aeiou'][0]"}
{"nl": "The highest altitude of a point", "code": "def largestAltitude(self, A):\n  return max(0, max(accumulate(A)))"}
{"nl": "Return the maximum sum of all keys of any BST sub-tree", "code": "class Solution:\n  def maxSumBST(self, root: TreeNode) -> int:\n  res = 0\n  def traverse(root):\n  '''return status_of_bst, size_of_bst, left_bound, right_bound'''\n  nonlocal res\n  if not root: return 1, 0, None, None # this subtree is empty\n  \n  ls, l, ll, lr = traverse(root.left)\n  rs, r, rl, rr = traverse(root.right)\n  \n  if ((ls == 2 and lr < root.val) or ls == 1) and ((rs == 2 and rl > root.val) or rs == 1):\n  # this subtree is a BST\n  size = root.val + l + r\n  res = max(res, size)\n  return 2, size, (ll if ll is not None else root.val), (rr if rr is not None else root.val)\n  return 0, None, None, None # this subtree is not a BST\n  \n  traverse(root)\n  return res"}
{"nl": "Muddled Middles", "code": "import re\ndef mix_middle(txt):\n  return re.sub(r'(?<=\\b\\w)([\\w-]{2,})(?=\\w\\b)', lambda m: m.group(1)[::-1], txt)"}
{"nl": "Maximum mirrors which can transfer light from bottom to right", "code": "# Python3 program to find how many mirror can transfer\n# light from bottom to right\n\u00a0\n# method returns number of mirror which can transfer\n# light from bottom to right\ndef maximumMirrorInMatrix(mat, N):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To store first obstacles horizontally (from right)\n\u00a0\u00a0\u00a0\u00a0# and vertically (from bottom)\n\u00a0\u00a0\u00a0\u00a0horizontal = [-1 for i in range(N)]\n\u00a0\u00a0\u00a0\u00a0vertical = [-1 for i in range(N)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# looping matrix to mark column for obstacles\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N - 1, -1, -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] == 'B'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark rightmost column with obstacle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0horizontal[i] = j;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# looping matrix to mark rows for obstacles\n\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(N - 1, -1, -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] == 'B'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark leftmost row with obstacle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vertical[j] = i;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0res = 0; # Initialize result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if there is not obstacle on right or below,\n\u00a0\u00a0\u00a0\u00a0# then mirror can be placed to transfer light\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0''' if i > vertical[j] then light can from bottom\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j > horizontal[i] then light can go to right '''\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i > vertical[j] and j > horizontal[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0''' uncomment this code to print actual mirror\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0position also'''\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res+=1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\n\u00a0\n#\u00a0 Driver code to test above method\nN = 5;\n\u00a0\n#\u00a0 B - Blank\u00a0\u00a0\u00a0\u00a0 O - Obstacle\nmat = [\"BBOBB\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BBBBO\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BBBBB\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BOOBO\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"BBBOB\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0];\n\u00a0\nprint(maximumMirrorInMatrix(mat, N));\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "Implement Quicksort", "code": "def quicksort(alist, start, end):\n    '''Sorts the list from indexes start to end - 1 inclusive.'''\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quicksort(alist, start, p)\n        quicksort(alist, p + 1, end)\n\u00a0\n\u00a0\ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n\u00a0\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n\u00a0\n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\nquicksort(alist, 0, len(alist))\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "Python Keyword Arguments\r\n", "code": "def my_function(child3, child2, child1):\r\n  print(\"The youngest child is \" + child3)\r\n\r\nmy_function(child1 = \"Emil\", child2 = \"Tobias\", child3 = \"Linus\")"}
{"nl": "Horner\u2019s Method for Polynomial Evaluation", "code": "# Python program for\n# implementation of Horner Method\n# for Polynomial Evaluation\n\n# returns value of poly[0]x(n-1)\n# + poly[1]x(n-2) + .. + poly[n-1]\ndef horner(poly, n, x):\n\n\t# Initialize result\n\tresult = poly[0]\n\n\t# Evaluate value of polynomial\n\t# using Horner's method\n\tfor i in range(1, n):\n\n\t\tresult = result*x + poly[i]\n\n\treturn result\n\n# Driver program to\n# test above function.\n\n# Let us evaluate value of\n# 2x3 - 6x2 + 2x - 1 for x = 3\npoly = [2, -6, 2, -1]\nx = 3\nn = len(poly)\n\nprint(\"Value of polynomial is \" , horner(poly, n, x))\n\n# This code is contributed\n# by Anant Agarwal."}
{"nl": "Python math.fabs() Method", "code": "#Import math Library\r\nimport math\r\n\r\n#Print absolute values from numbers\r\nprint(math.fabs(-66.43))\r\nprint(math.fabs(-7))"}
{"nl": "Python Program to Print Same Numbers on all Sides of a Square", "code": "rows = int(input(\"Enter Square of same Numbers Pattern Rows = \"))\n\nprint(\"====Print Same Numbers on all Sides of a Square Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(1, rows + 1):\n        if i < j:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - j + 1, end = ' ')\n    for k in range(rows - 1, 0, - 1):\n        if i < k:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - k + 1, end = ' ')\n    print()\n\nfor i in range(rows - 1, 0, -1):\n    for j in range(1, rows + 1):\n        if i < j:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - j + 1, end = ' ')\n    for k in range(rows - 1, 0, - 1):\n        if i < k:\n            print(rows - i + 1, end = ' ')\n        else:\n            print(rows - k + 1, end = ' ')\n    print()"}
{"nl": "Intersecting two dictionaries via keys", "code": "# Give the two dictionaries as static input and store them in two variables.\ndictionary1 = {'Hello': 'one', 'this': 'two',\n               'is': 'three', 'btechgeeks': 'four'}\ndictionary2 = {'good': 'five', 'morning': 'six',\n               'btechgeeks': 'four', 'is': 'three'}\n\n# printing the original given two dictionaries\nprint(\"The given first dictionary = \", dictionary1)\nprint(\"The given second dictionary = \", dictionary2)\n# Then, using the items() function,\n# convert the dictionaries dictionary1 and dictionary2 into list format.\n# Then, using the & operator, perform their AND operation.\n# The common key-value pairs are then\n# converted into a dictionary and stored in intersectdicts using dict().\nintersectdicts = dict(dictionary1.items() & dictionary2.items())\n\n# Print the new dictionary intersectdicts with the common keys and their values.\nprint(\"printing the intersection of the given two dictionaries = \", (intersectdicts))"}
{"nl": "Count Non Palindrome words in static Sentence", "code": "# Give the string as static input and store it in a variable.\r\ngvn_str = \"dad and mom both ordered to bring sos in malayalam\"\r\n# Take an empty list and store it in another variable.\r\nlst = []\r\n# Split the given string using the split() function and store it in another variable.\r\nsplt_str = gvn_str.split()\r\n# Loop in the above-obtained split list of words using the for loop.\r\nfor wrd in splt_str:\r\n    # Check if the iterator value is not equal to the reverse of the iterator value using\r\n    # the if conditional statement.\r\n    if wrd != wrd[::-1]:\r\n     # If the statement is true, then append the respective iterator value to the\r\n        # above initialized empty list using the append() method.\r\n        lst.append(wrd)\r\n# Calculate the length above initialized list \"lst\" using the len() function\r\n# and store it in a variable.\r\n# Print the count of all the Non-palindromic words in a given sentence.\r\ncount = len(lst)\r\n# Print the count of all the Non-palindromic words in a given sentence.\r\nprint(\"The count of all the Non-palindromic words in a given sentence =\", count)"}
{"nl": "Check if an array is stack permutation of other", "code": "# Given two arrays, check if one array is\r\n# stack permutation of other.\r\nfrom queue import Queue\r\n\r\n# function to check if Input queue\r\n# is permutable to output queue\r\ndef checkStackPermutation(ip, op, n):\r\n\t\r\n\t# Input queue\r\n\tInput = Queue()\r\n\tfor i in range(n):\r\n\t\tInput.put(ip[i])\r\n\r\n\t# output queue\r\n\toutput = Queue()\r\n\tfor i in range(n):\r\n\t\toutput.put(op[i])\r\n\r\n\t# stack to be used for permutation\r\n\ttempStack = []\r\n\twhile (not Input.empty()):\r\n\t\tele = Input.queue[0]\r\n\t\tInput.get()\r\n\t\tif (ele == output.queue[0]):\r\n\t\t\toutput.get()\r\n\t\t\twhile (len(tempStack) != 0):\r\n\t\t\t\tif (tempStack[-1] == output.queue[0]):\r\n\t\t\t\t\ttempStack.pop()\r\n\t\t\t\t\toutput.get()\r\n\t\t\t\telse:\r\n\t\t\t\t\tbreak\r\n\t\telse:\r\n\t\t\ttempStack.append(ele)\r\n\r\n\t# If after processing, both Input\r\n\t# queue and stack are empty then\r\n\t# the Input queue is permutable\r\n\t# otherwise not.\r\n\treturn (Input.empty() and\r\n\t\tlen(tempStack) == 0)\r\n\r\n# Driver Code\r\nif __name__ == '__main__':\r\n\r\n\t# Input Queue\r\n\tInput = [1, 2, 3]\r\n\r\n\t# Output Queue\r\n\toutput = [2, 1, 3]\r\n\r\n\tn = 3\r\n\r\n\tif (checkStackPermutation(Input,\r\n\t\t\t\t\t\t\toutput, n)):\r\n\t\tprint(\"Yes\")\r\n\telse:\r\n\t\tprint(\"Not Possible\")\r\n\r\n# This code is contributed by PranchalK\r"}
{"nl": "Spin Around, Touch the Ground", "code": "def spin_around(lst):\n  return abs(lst.count('left') - lst.count('right')) // 4"}
{"nl": "print the series (2, 4, 7, 12, 21, \u2026 N) till the given number N in Python.", "code": "# Give the number N(limit) as static input and store it in a variable.\r\ngvn_numb = 8\r\n# Take a variable to say itr and initialize its value to 0.\r\nitr = 0\r\n# Take another variable say previous_val and initialize its value to 2.\r\nprevious_val = 2\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\n# print the value 2 separated by spaces.\r\nprint(\"2 \",end=\"\")\r\n# Loop until the above-declared variable itr value is less than the\r\n# given number-1 using the while loop.\r\nwhile itr<gvn_numb-1:\r\n    #Inside the loop, Multiply the variable previous_val with 2 and subtract the above\r\n    #itr value from it.\r\n    #Store it in the same variable previous_val.\r\n    previous_val = (previous_val * 2) -itr\r\n    # Print the value of the above previous_val separated by spaces.\r\n    print(previous_val,end=\" \")\r\n    # Increment the above itr value by 1.\r\n    itr+=1"}
{"nl": "multiple of numbers in string format", "code": "def multiply(self, num1: str, num2: str) -> str:\n    n = len(num1)\n    m = len(num2)\n    sum_arr = [0]*(n+m)\n    for i in range(n-1,-1,-1):\n        for j in range(m-1,-1,-1):\n            print(i,j)\n            pos1 = i+j\n            pos2 = pos1+1\n            n1 = int(num1[i])\n            n2 = int(num2[j])\n            \n            mul = (n1 * n2) + sum_arr[pos2]\n            print(n1*n2,sum_arr[pos2])\n            sum_arr[pos1] += mul // 10\n            sum_arr[pos2] = mul % 10\n    print(sum_arr)\n    ans = \"\"\n    for i in range(0,m+n):\n        ans += str(sum_arr[i])\n    \n    return \"0\" if ans.lstrip('0') == \"\" else ans.lstrip('0')"}
{"nl": "Shared Digits", "code": "def shared_digits(lst):\n  return all(set(str(lst[i-1]))&set(str(lst[i])) for i in range(1, len(lst)))"}
{"nl": "Write a regular expression that will match the files with the extension .py or .pyw", "code": "import re\r\n\u200b\r\npattern = '\\.pyw?$'"}
{"nl": "Exercise that calculates the difference between the square of the sum and the sum of the squares of the first N natural numbers.", "code": "def square_of_sum(number):\n        return int((number*(number+1)/2)**2)\ndef sum_of_squares(number):\n    return int(number*(number+1)*(2*number +1)/6)\ndef difference_of_squares(number):\n    return square_of_sum(number)-sum_of_squares(number)"}
{"nl": "Sum of f(a[i], a[j]) over all pairs in an array of n integers", "code": "# Python3 program to calculate the\n# sum of f(a[i], aj])\n\n# Function to calculate the sum\ndef sum(a, n):\n\n        # map to keep a count of occurrences\n        cnt = dict()\n\n        # Traverse in the list from start to end\n        # number of times a[i] can be in a pair and\n        # to get the difference we subtract pre_sum.\n        ans = 0\n        pre_sum = 0\n        for i in range(n):\n                ans += (i * a[i]) - pre_sum\n                pre_sum += a[i]\n\n                # if the (a[i]-1) is present then\n                # subtract that value as f(a[i], a[i]-1)=0\n                if (a[i] - 1) in cnt:\n                        ans -= cnt[a[i] - 1]\n\n                # if the (a[i]+1) is present then add that\n                # value as f(a[i], a[i]-1)=0 here we add\n                # as a[i]-(a[i]-1)<0 which would have been\n                # added as negative sum, so we add to remove\n                # this pair from the sum value\n                if (a[i] + 1) in cnt:\n                        ans += cnt[a[i] + 1]\n\n                # keeping a counter for every element\n                if a[i] not in cnt:\n                        cnt[a[i]] = 0\n                cnt[a[i]] += 1\n        \n        return ans\n\n# Driver Code\nif __name__ == '__main__':\n        a = [1, 2, 3, 1, 3]\n        n = len(a)\n        print(sum(a, n))\n                \n# This code is contributed by\n# SHUBHAMSINGH10\n"}
{"nl": "Enter \u2018*\u2019 between two identical characters in a string", "code": "# Give the string as static input and store it in a variable.\ngvn_str = \"good morning btechgeekss\"\n# Take a new empty string say 'new_str'and store it in another variable.\nnew_str = \"\"\n# Take a variable and initialize its value with '0' and store it in another variable.\nitr = 0\n# Loop from '0' to the length of the given string -1 using for loop and len() function.\nfor itr in range(0, len(gvn_str)-1):\n  # Concat the new_str with the iterator value of the given string and\n  # store it in the same variable 'new_str'\n  new_str = new_str + gvn_str[itr]\n# Check if the iterator value of the given input string is equal to the iterator+1 value\n# of the given input string using the if conditional statement.\n  if(gvn_str[itr] == gvn_str[itr+1]):\n  # If the statement is true, concat the 'new_str' with the '*' symbol and\n  # store it in the same variable 'new_str'.\n  new_str += '*'\n# Print the variable 'new_str' to enter '*' between two identical characters in a\n# given String.\nprint(\"The given string after entering '*' between two identical characters=\", new_str)"}
{"nl": "Interchange elements of first and last rows in matrix", "code": "# Python code to swap the element\n# of first and last row and display\n# the result\n\u00a0\ndef interchangeFirstLast(mat, n, m):\n\u00a0\u00a0\u00a0\u00a0rows = n\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# swapping of element between\n\u00a0\u00a0\u00a0\u00a0# first and last rows\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = mat[0][i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[0][i] = mat[rows-1][i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[rows-1][i] = t\n\u00a0\n# Driver Program\nmat = [[8, 9, 7, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 7, 6, 5],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[3, 2, 1, 8],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[9, 9, 7, 7]]\n\u00a0\nn = 4\nm = 4\ninterchangeFirstLast(mat, n, m)\n\u00a0\n# printing the interchanged matrix\nfor i in range(n):\n\u00a0\u00a0\u00a0\u00a0for j in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0print(\"\\n\")\n\u00a0\n# This code is contributed by Shrikant13.\n"}
{"nl": "The minimum operations to make a subsequence", "code": "def minOperations(self, target, A):\n  ha = {a: i for i, a in enumerate(target)}\n  stack = []\n  for a in A:\n  if a not in ha: continue\n  i = bisect.bisect_left(stack, h[a])\n  if i == len(stack):\n  stack.append(0)\n  stack[i] = h[a]\n  return len(target) - len(stack)"}
{"nl": "Function that takes a string as an argument and converts the first character of each word to uppercase", "code": "def make_title(txt):\r\n    lst = [word[0].upper() + word[1:] for word in txt.split(' ')]\r\n    ans = ' '.join(lst)\r\n    return ans"}
{"nl": "Queue \u2013 Linked List Implementation", "code": "# Python3 program to demonstrate linked list\n# based implementation of queue\n\u00a0\n# A linked list (LL) node\n# to store a queue entry\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next = None\n\u00a0\n# A class to represent a queue\n\u00a0\n# The queue, front stores the front node\n# of LL and rear stores the last node of LL\nclass Queue:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = self.rear = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.front == None\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Method to add an item to the queue\n\u00a0\u00a0\u00a0\u00a0def EnQueue(self, item):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = Node(item)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.rear == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = self.rear = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear.next = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = temp\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Method to remove an item from queue\n\u00a0\u00a0\u00a0\u00a0def DeQueue(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = self.front\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = temp.next\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(self.front == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = None\n\u00a0\n# Driver Code\nif __name__== '__main__':\n\u00a0\u00a0\u00a0\u00a0q = Queue()\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(10)\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(20)\n\u00a0\u00a0\u00a0\u00a0q.DeQueue()\n\u00a0\u00a0\u00a0\u00a0q.DeQueue()\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(30)\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(40)\n\u00a0\u00a0\u00a0\u00a0q.EnQueue(50)\n\u00a0\u00a0\u00a0\u00a0q.DeQueue()\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Queue Front \" + str(q.front.data))\n\u00a0\u00a0\u00a0\u00a0print(\"Queue Rear \" + str(q.rear.data))\n\u00a0\u00a0\u00a0\u00a0\n"}
{"nl": "ZigZag Tree Traversal", "code": "# Python Program to print zigzag traversal\n# of binary tree\n\n# Binary tree node\nclass Node:\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\n\n# function to print zigzag traversal of\n# binary tree\ndef zizagtraversal(root):\n\n\t# Base Case\n\tif root is None:\n\t\treturn\n\n\t# Create two stacks to store current\n\t# and next level\n\tcurrentLevel = []\n\tnextLevel = []\n\n\t# if ltr is true push nodes from\n\t# left to right otherwise from\n\t# right to left\n\tltr = True\n\n\t# append root to currentlevel stack\n\tcurrentLevel.append(root)\n\n\t# Check if stack is empty\n\twhile len(currentLevel) > 0:\n\t\t# pop from stack\n\t\ttemp = currentLevel.pop(-1)\n\t\t# print the data\n\t\tprint(temp.data, \" \", end=\"\")\n\n\t\tif ltr:\n\t\t\t# if ltr is true push left\n\t\t\t# before right\n\t\t\tif temp.left:\n\t\t\t\tnextLevel.append(temp.left)\n\t\t\tif temp.right:\n\t\t\t\tnextLevel.append(temp.right)\n\t\telse:\n\t\t\t# else push right before left\n\t\t\tif temp.right:\n\t\t\t\tnextLevel.append(temp.right)\n\t\t\tif temp.left:\n\t\t\t\tnextLevel.append(temp.left)\n\n\t\tif len(currentLevel) == 0:\n\t\t\t# reverse ltr to push node in\n\t\t\t# opposite order\n\t\t\tltr = not ltr\n\t\t\t# swapping of stacks\n\t\t\tcurrentLevel, nextLevel = nextLevel, currentLevel\n\n\n# Driver program to check above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(7)\nroot.left.right = Node(6)\nroot.right.left = Node(5)\nroot.right.right = Node(4)\nprint(\"Zigzag Order traversal of binary tree is\")\nzizagtraversal(root)\n\n# This code is contributed by Shweta Singh"}
{"nl": "Selective List Reversal", "code": "def sel_reverse(lst, n):\n  if n > 0:\n    new = []\n    for i in range(0, len(lst), n):\n      new += lst[i:i+n][::-1]\n    return new\n  return lst"}
{"nl": "Find if there is a path of more than k length from a source", "code": "# Program to find if there is a simple path with\n# weight more than k\n\u00a0\u00a0\u00a0\n# This class represents a dipathted graph using\n# adjacency list representation\nclass Graph:\n\u00a0\u00a0\u00a0\u00a0# Allocates memory for adjacency list\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj = [[] for i in range(V)]\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if graph has path more than k length\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanK(self,src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a path array with nothing included\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path = [False]*self.V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add source vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[src] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.pathMoreThanKUtil(src, k, path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Prints shortest paths from src to all other vertices\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanKUtil(self,src, k, path):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If k is 0 or negative, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get all adjacent vertices of source vertex src and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursively explore all paths from src.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while i != len(self.adj[src]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get adjacent vertex and weight of edge\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = self.adj[src][i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w = self.adj[src][i][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If vertex v is already there in path, then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# there is a cycle (we ignore this edge)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (path[v] == True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If weight of is more than k, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (w >= k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Else add this vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this adjacent can provide a path longer\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than k, return true.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (self.pathMoreThanKUtil(v, k-w, path)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Backtrack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If no adjacent could produce longer path, return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Utility function to an edge (u, v) of weight w\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u, v, w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[u].append([v, w])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[v].append([u, w])\n\u00a0\u00a0\u00a0\n# Driver program to test methods of graph class\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# create the graph given in above figure\n\u00a0\u00a0\u00a0\u00a0V = 9\n\u00a0\u00a0\u00a0\u00a0g = Graph(V)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0#\u00a0 making above shown graph\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 1, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 7, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 2, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 7, 11)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 3, 7)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 8, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 5, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 4, 9)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 5, 14)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(4, 5, 10)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(5, 6, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 7, 1)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 8, 6)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(7, 8, 7)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0src = 0\n\u00a0\u00a0\u00a0\u00a0k = 62\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0k = 60\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n"}
{"nl": "Program to Print Collatz Conjecture for a Given Number in C++ and Python", "code": "# function which prints collatz sequence of the given number\n \n def printCollatz(numb):\n \n  # Iterate till the given number is not equal to 1 using while loop.\n \n  while numb > 1:\n \n  # Print the number numb\n \n  print(numb, end=' ')\n \n  # If the number is even then set n to n/2.\n \n  if (numb % 2 == 0):\n \n  numb = numb//2\n \n  # If the number is odd then set n to 3*n+1.\n \n  else:\n \n  numb = 3*numb + 1\n \n  # Print 1 after end of while loop.\n \n  print(1, end='')\n \n \n \n \n \n # given number\n \n numb = 179\n \n print('The Collatz Conjecture of the number :')\n \n # passing the given numb to printCollatz function to\n \n # print collatzConjecture sequence of the given number\n \n printCollatz(numb)"}
{"nl": "Words that Start with a Vowel", "code": "def retrieve(txt):\n  return [i for i in txt[:-1].lower().split() if i[0] in 'aeiou']"}
{"nl": "given a string, return the minimum number of seconds to type out the characters in the string", "code": "class Solution:\n    def minTimeToType(self, word: str) -> int:\n        \n        def get_index(c):\n            return ord(c) - 96\n        \n        move = 0\n        \n        # initial start is block 'a'\n        prev = 'a'\n        \n        for c in word:\n            \n            pi, ci = map(get_index, (prev, c))\n            \n            # basic move\n            min_move = abs(ci - pi)\n            \n            if ci > pi:\n                # e.g. current=\"z\", prev=\"a\", borrow 26 to prev \n                min_move = min(min_move, (pi + 26 - ci))\n            else:\n                # e.g. current=\"a\", prev=\"z\", borrow 26 to current\n                min_move = min(min_move, (ci + 26 - pi))\n                        \n            # add print time\n            move = move + min_move + 1\n            \n            # update prev pointer\n            prev = c    \n        \n        return move"}
{"nl": "Find same contacts in a list of contacts", "code": "# A Python3 program to find same contacts\n# in a list of contacts\n\u00a0\n# Structure for storing contact details.\nclass contact:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, field1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0field2, field3):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.field1 = field1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.field2 = field2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.field3 = field3\n\u00a0\n# A utility function to fill entries in\n# adjacency matrix representation of graph\ndef buildGraph(arr, n, mat):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize the adjacency matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse through all contacts\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add mat from i to j and vice versa,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if possible. Since length of each\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# contact field is at max some constant.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (say 30) so body execution of this for\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# loop takes constant time.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(i + 1, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i].field1 == arr[j].field1 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field1 == arr[j].field2 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field1 == arr[j].field3 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field2 == arr[j].field1 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field2 == arr[j].field2 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field2 == arr[j].field3 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field3 == arr[j].field1 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field3 == arr[j].field2 or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i].field3 == arr[j].field3):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[j][i] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n# A recursive function to perform DFS\n# with vertex i as source\ndef DFSvisit(i, mat, visited, sol, n):\n\u00a0\u00a0\u00a0\u00a0visited[i] = True\n\u00a0\u00a0\u00a0\u00a0sol.append(i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] and not visited[j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DFSvisit(j, mat, visited, sol, n)\n\u00a0\n# Finds similar contacts in an\n# array of contacts\ndef findSameContacts(arr, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# vector for storing the solution\n\u00a0\u00a0\u00a0\u00a0sol = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Declare 2D adjacency matrix for mats\n\u00a0\u00a0\u00a0\u00a0mat = [[None] * n for i in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# visited array to keep track\n\u00a0\u00a0\u00a0\u00a0# of visited nodes\n\u00a0\u00a0\u00a0\u00a0visited = [0] * n\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Fill adjacency matrix\n\u00a0\u00a0\u00a0\u00a0buildGraph(arr, n, mat)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Since, we made a graph with contacts\u00a0\n\u00a0\u00a0\u00a0\u00a0# as nodes with fields as links. Two\n\u00a0\u00a0\u00a0\u00a0# nodes are linked if they represent\n\u00a0\u00a0\u00a0\u00a0# the same person. So, total number of\n\u00a0\u00a0\u00a0\u00a0# connected components and nodes in each\n\u00a0\u00a0\u00a0\u00a0# component will be our answer.\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not visited[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DFSvisit(i, mat, visited, sol, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add delimiter to separate nodes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# of one component from other.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sol.append(-1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the solution\n\u00a0\u00a0\u00a0\u00a0for i in range(len(sol)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sol[i] == -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(sol[i], end = \" \")\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0arr = [contact(\"Gaurav\", \"gaurav@gmail.com\", \"gaurav@gfgQA.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"Lucky\", \"lucky@gmail.com\", \"+1234567\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"gaurav123\", \"+5412312\", \"gaurav123@skype.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"gaurav1993\", \"+5412312\", \"gaurav@gfgQA.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"raja\", \"+2231210\", \"raja@gfg.com\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contact(\"bahubali\", \"+878312\", \"raja\")]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0n = len(arr)\n\u00a0\u00a0\u00a0\u00a0findSameContacts(arr, n)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Implement D-ary-Heap", "code": "class D_aryHeap:\n    def __init__(self, d):\n        self.items = []\n        self.d = d\n\u00a0\n    def size(self):\n        return len(self.items)\n\u00a0\n    def parent(self, i):\n        return (i - 1)//self.d\n\u00a0\n    def child(self, index, position):\n        return index*self.d + (position + 1)\n\u00a0\n    def get(self, i):\n        return self.items[i]\n\u00a0\n    def get_max(self):\n        if self.size() == 0:\n            return None\n        return self.items[0]\n\u00a0\n    def extract_max(self):\n        if self.size() == 0:\n            return None\n        largest = self.get_max()\n        self.items[0] = self.items[-1]\n        del self.items[-1]\n        self.max_heapify(0)\n        return largest\n\u00a0\n    def max_heapify(self, i):\n        largest = i\n        for j in range(self.d):\n            c = self.child(i, j)\n            if (c < self.size() and self.get(c) > self.get(largest)):\n                largest = c\n        if (largest != i):\n            self.swap(largest, i)\n            self.max_heapify(largest)\n\u00a0\n    def swap(self, i, j):\n        self.items[i], self.items[j] = self.items[j], self.items[i]\n\u00a0\n    def insert(self, key):\n        index = self.size()\n        self.items.append(key)\n        while (index != 0):\n            p = self.parent(index)\n            if self.get(p) < self.get(index):\n                self.swap(p, index)\n            index = p\n\u00a0\n\u00a0\nd = int(input('Enter the value of D: '));\ndheap = D_aryHeap(d)\n\u00a0\nprint('Menu (this assumes no duplicate keys)')\nprint('insert <data>')\nprint('max get')\nprint('max extract')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'insert':\n        data = int(do[1])\n        dheap.insert(data)\n    elif operation == 'max':\n        suboperation = do[1].strip().lower()\n        if suboperation == 'get':\n            print('Maximum value: {}'.format(dheap.get_max()))\n        elif suboperation == 'extract':\n            print('Maximum value removed: {}'.format(dheap.extract_max()))\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Digital Vowel Ban", "code": "def digital_vowel_ban(n, ban):\n    d = {'e': '0135789', 'i': '5689', 'o': '0124', 'u': '4'}\n    new = ''.join(i for i in str(n) if i not in d.get(ban, ''))\n    return 'Banned Number' if not new else int(new)"}
{"nl": "Last seen array element (last appearance is earliest)\r\n", "code": "\r\n# Python3 program to find last seen\r\n# element in an array.\r\nimport sys;\r\n \r\n# Returns last seen element in arr[]\r\ndef lastSeenElement(a, n):\r\n     \r\n    # Store last occurrence index of\r\n    # every element\r\n    hash = {}\r\n     \r\n    for i in range(n):\r\n        hash[a[i]] = i\r\n         \r\n    # Find an element in hash with minimum\r\n    # index value\r\n    res_ind = sys.maxsize\r\n    res = 0\r\n     \r\n    for x, y in hash.items():\r\n        if y < res_ind:\r\n            res_ind = y\r\n            res = x\r\n             \r\n    return res\r\n \r\n# Driver code   \r\nif __name__==\"__main__\":\r\n     \r\n    a = [ 2, 1, 2, 2, 4, 1 ]\r\n    n = len(a)\r\n     \r\n    print(lastSeenElement(a,n))\r\n \r\n# This code is contributed by rutvik_56"}
{"nl": "Optics clustering sklearn", "code": "\r\nimport numpy as np\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib import gridspec\r\nfrom sklearn.cluster import OPTICS, cluster_optics_dbscan\r\nfrom sklearn.preprocessing import normalize, StandardScaler\r\n\r\n# Changing the working location to the location of the data\r\ncd C:\\Users\\Dev\\Desktop\\Kaggle\\Customer Segmentation\r\n  \r\nX = pd.read_csv('Mall_Customers.csv')\r\n  \r\n# Dropping irrelevant columns\r\ndrop_features = ['CustomerID', 'Gender']\r\nX = X.drop(drop_features, axis = 1)\r\n  \r\n# Handling the missing values if any\r\nX.fillna(method ='ffill', inplace = True)\r\n  \r\nX.head()\r\n\r\n\r\n# Scaling the data to bring all the attributes to a comparable level\r\nscaler = StandardScaler()\r\nX_scaled = scaler.fit_transform(X)\r\n  \r\n# Normalizing the data so that the data\r\n# approximately follows a Gaussian distribution\r\nX_normalized = normalize(X_scaled)\r\n  \r\n# Converting the numpy array into a pandas DataFrame\r\nX_normalized = pd.DataFrame(X_normalized)\r\n  \r\n# Renaming the columns\r\nX_normalized.columns = X.columns\r\n  \r\nX_normalized.head()\r\n\r\n\r\n# Building the OPTICS Clustering model\r\noptics_model = OPTICS(min_samples = 10, xi = 0.05, min_cluster_size = 0.05)\r\n  \r\n# Training the model\r\noptics_model.fit(X_normalized)\r\n\r\n# Producing the labels according to the DBSCAN technique with eps = 0.5\r\nlabels1 = cluster_optics_dbscan(reachability = optics_model.reachability_,\r\n                                   core_distances = optics_model.core_distances_,\r\n                                   ordering = optics_model.ordering_, eps = 0.5)\r\n  \r\n# Producing the labels according to the DBSCAN technique with eps = 2.0\r\nlabels2 = cluster_optics_dbscan(reachability = optics_model.reachability_,\r\n                                   core_distances = optics_model.core_distances_,\r\n                                   ordering = optics_model.ordering_, eps = 2)\r\n  \r\n# Creating a numpy array with numbers at equal spaces till\r\n# the specified range\r\nspace = np.arange(len(X_normalized))\r\n  \r\n# Storing the reachability distance of each point\r\nreachability = optics_model.reachability_[optics_model.ordering_]\r\n  \r\n# Storing the cluster labels of each point\r\nlabels = optics_model.labels_[optics_model.ordering_]\r\n  \r\nprint(labels)\r\n\r\n# Defining the framework of the visualization\r\nplt.figure(figsize =(10, 7))\r\nG = gridspec.GridSpec(2, 3)\r\nax1 = plt.subplot(G[0, :])\r\nax2 = plt.subplot(G[1, 0])\r\nax3 = plt.subplot(G[1, 1])\r\nax4 = plt.subplot(G[1, 2])\r\n  \r\n# Plotting the Reachability-Distance Plot\r\ncolors = ['c.', 'b.', 'r.', 'y.', 'g.']\r\nfor Class, colour in zip(range(0, 5), colors):\r\n    Xk = space[labels == Class]\r\n    Rk = reachability[labels == Class]\r\n    ax1.plot(Xk, Rk, colour, alpha = 0.3)\r\nax1.plot(space[labels == -1], reachability[labels == -1], 'k.', alpha = 0.3)\r\nax1.plot(space, np.full_like(space, 2., dtype = float), 'k-', alpha = 0.5)\r\nax1.plot(space, np.full_like(space, 0.5, dtype = float), 'k-.', alpha = 0.5)\r\nax1.set_ylabel('Reachability Distance')\r\nax1.set_title('Reachability Plot')\r\n  \r\n# Plotting the OPTICS Clustering\r\ncolors = ['c.', 'b.', 'r.', 'y.', 'g.']\r\nfor Class, colour in zip(range(0, 5), colors):\r\n    Xk = X_normalized[optics_model.labels_ == Class]\r\n    ax2.plot(Xk.iloc[:, 0], Xk.iloc[:, 1], colour, alpha = 0.3)\r\n      \r\nax2.plot(X_normalized.iloc[optics_model.labels_ == -1, 0],\r\n        X_normalized.iloc[optics_model.labels_ == -1, 1],\r\n       'k+', alpha = 0.1)\r\nax2.set_title('OPTICS Clustering')\r\n  \r\n# Plotting the DBSCAN Clustering with eps = 0.5\r\ncolors = ['c', 'b', 'r', 'y', 'g', 'greenyellow']\r\nfor Class, colour in zip(range(0, 6), colors):\r\n    Xk = X_normalized[labels1 == Class]\r\n    ax3.plot(Xk.iloc[:, 0], Xk.iloc[:, 1], colour, alpha = 0.3, marker ='.')\r\n        \r\nax3.plot(X_normalized.iloc[labels1 == -1, 0],\r\n        X_normalized.iloc[labels1 == -1, 1],\r\n       'k+', alpha = 0.1)\r\nax3.set_title('DBSCAN clustering with eps = 0.5')\r\n  \r\n# Plotting the DBSCAN Clustering with eps = 2.0\r\ncolors = ['c.', 'y.', 'm.', 'g.']\r\nfor Class, colour in zip(range(0, 4), colors):\r\n    Xk = X_normalized.iloc[labels2 == Class]\r\n    ax4.plot(Xk.iloc[:, 0], Xk.iloc[:, 1], colour, alpha = 0.3)\r\n          \r\nax4.plot(X_normalized.iloc[labels2 == -1, 0],\r\n        X_normalized.iloc[labels2 == -1, 1],\r\n       'k+', alpha = 0.1)\r\nax4.set_title('DBSCAN Clustering with eps = 2.0')\r\n  \r\n  \r\nplt.tight_layout()\r\nplt.show()"}
{"nl": "RegEx III: Boundary Assertions", "code": "import re\npattern = '\\Bend\\B'"}
{"nl": "The minimum number of removals to make mountain array", "code": "class Solution:\n  def minimumMountainRemovals(self, nums):\n  def LIS(nums):\n  dp = [10**10] * (len(nums) + 1)\n  lens = [0]*len(nums)\n  for i, elem in enumerate(nums): \n  lens[i] = bisect_left(dp, elem) + 1\n  dp[lens[i] - 1] = elem \n  return lens\n  \n  l1, l2 = LIS(nums), LIS(nums[::-1])[::-1]\n  ans, n = 0, len(nums)\n  for i in range(n):\n  if l1[i] >= 2 and l2[i] >= 2:\n  ans = max(ans, l1[i] + l2[i] - 1)\n  \n  return n - ans"}
{"nl": "Smallest Transform", "code": "def smallest_transform(num):\n  nums = [int(digit) for digit in str(num)]\n  return min(sum(abs(a - b) for a in nums) for b in nums)"}
{"nl": "Find sum of values of dictionary", "code": "# Take a dictionary and initialize it with some random key and value pairs.\ngivendiction = {'heello': 27, 'this': 282, 'is': 98, 'BTechGeeks': 98,\n                'online': 123, 'platform': 32, 'for': 38, 'coding': 10, 'students': 81}\n# values() function returns the tuple of all the values present in the given dictionary.\n# Store this tuple in some variable.\nvalLst = givendiction.values()\n# Calculate the sum of the values list using the sum() function.\nsumvalu = sum(valLst)\n# Print the sum of all the values in the given dictionary.\nprint('The sum of all the values in the given dictionary\\n', givendiction, ':')\nprint(sumvalu)"}
{"nl": "return the sum of the number of vowels in all substrings", "code": "class Solution:\n    def countVowels(self, word: str) -> int:\n        vows = set(\"aeiou\")\n        l = len(word)\n        s = 0\n        for i in range(l):\n            if word[i] in vows:\n                s += (i + 1) * (l - i)\n        return s"}
{"nl": "Reorder the string according to the algorithm", "code": "def sortString(self, s: str) -> str:\n  cnt, ans, asc = collections.Counter(s), [], True\n  while cnt:  # if Counter not empty.\n  for c in sorted(cnt) if asc else reversed(sorted(cnt)):  # traverse keys in ascending/descending order.\n  ans.append(c) # append the key.\n  cnt[c] -= 1  # decrease the count.\n  if cnt[c] == 0:  # if the count reaches to 0.\n  del cnt[c]  # remove the key from the Counter.\n  asc = not asc  # change the direction, same as asc ^= True.\n  return ''.join(ans)"}
{"nl": "reduction operations to make array elements equal", "code": "class Solution:\n    def reductionOperations(self, nums: List[int]) -> int:\n        ans = 0\n        nums.sort(reverse = True)\n        val = 1\n        for i in range(1 , len(nums)):\n            if(nums[i-1] != nums[i]):\n                ans += val\n            val += 1\n        return ans"}
{"nl": "Check whether a given graph is Bipartite or not", "code": "# Python program to find out whether a\n# given graph is Bipartite or not\n\u00a0\nclass Graph():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = [[0 for column in range(V)] \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for row in range(V)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This function returns true if graph G[V][V]\n\u00a0\u00a0\u00a0\u00a0# is Bipartite, else false\n\u00a0\u00a0\u00a0\u00a0def isBipartite(self, src):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a color array to store colors\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# assigned to all vertices. Vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# number is used as index in this array.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# The value '-1' of\u00a0 colorArr[i] is used to\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# indicate that no color is assigned to\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# vertex 'i'. The value 1 is used to indicate\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# first color is assigned and value 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# indicates second color is assigned.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0colorArr = [-1] * self.V\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Assign first color to source\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0colorArr[src] = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a queue (FIFO) of vertex numbers and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# enqueue source vertex for BFS traversal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(src)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Run while there are vertices in queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (Similar to BFS)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while queue:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = queue.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Return false if there is a self-loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.graph[u][u] == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for v in range(self.V):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# An edge from u to v exists and destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# v is not colored\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.graph[u][v] == 1 and colorArr[v] == -1:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Assign alternate color to this\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# adjacent v of u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0colorArr[v] = 1 - colorArr[u]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# An edge from u to v exists and destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# v is colored with same color as u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif self.graph[u][v] == 1 and colorArr[v] == colorArr[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we reach here, then all adjacent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# vertices can be colored with alternate\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# color\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n# Driver program to test above function\ng = Graph(4)\ng.graph = [[0, 1, 0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 1, 0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nprint (\"Yes\" if g.isBipartite(0) else \"No\")\n\u00a0\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "Common Divisor of List", "code": "def GCD(lst):\n  for i in range(min(lst), 1, -1):\n      if all(not j%i for j in lst):\n          return i\n  return 1"}
{"nl": "Print right angled triangle star pattern given number of rows in the triangle.", "code": "# Give the number of rows of the right-angled triangle star pattern\r\n# as static input and store it in a variable.\r\ntrianglerows = 19\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, trianglerows+1):\r\n    # Loop from 1 to first loop iterator value using another Nested For loop.\r\n    for n in range(1, m+1):\r\n        # Print the star character with space in the inner For loop.\r\n        print('*', end=' ')\r\n    #Print the newline character after ending of inner For loop.\r\n    print()"}
{"nl": "Get the Century\n", "code": "def century(year):\n        century_no = str((year + 99 ) // 100)\n        return '21st century' if century_no == '21' else century_no + 'th century'"}
{"nl": "Check if the number is odd or even in Python", "code": "# Python program to check given number is an even or odd # take inputs num = 5 # check number is even or odd if(num % 2 == 0): print('{0} is an even number'.format(num)) else: print('{0} is an odd number'.format(num))"}
{"nl": "Euler Circuit in a Directed Graph\n", "code": "# A Python3 program to check if a given\n# directed graph is Eulerian or not\n\nfrom collections import defaultdict\n\nclass Graph():\n\n        def __init__(self, vertices):\n                self.V = vertices\n                self.graph = defaultdict(list)\n                self.IN = [0] * vertices\n\n        def addEdge(self, v, u):\n\n                self.graph[v].append(u)\n                self.IN[u] += 1\n\n        def DFSUtil(self, v, visited):\n                visited[v] = True\n                for node in self.graph[v]:\n                        if visited[node] == False:\n                                self.DFSUtil(node, visited)\n\n        def getTranspose(self):\n                gr = Graph(self.V)\n\n                for node in range(self.V):\n                        for child in self.graph[node]:\n                                gr.addEdge(child, node)\n\n                return gr\n\n        def isSC(self):\n                visited = [False] * self.V\n\n                v = 0\n                for v in range(self.V):\n                        if len(self.graph[v]) > 0:\n                                break\n\n                self.DFSUtil(v, visited)\n\n                # If DFS traversal doesn't visit all\n                # vertices, then return false.\n                for i in range(self.V):\n                        if visited[i] == False:\n                                return False\n\n                gr = self.getTranspose()\n\n                visited = [False] * self.V\n                gr.DFSUtil(v, visited)\n\n                for i in range(self.V):\n                        if visited[i] == False:\n                                return False\n\n                return True\n\n        def isEulerianCycle(self):\n\n                # Check if all non-zero degree vertices\n                # are connected\n                if self.isSC() == False:\n                        return False\n\n                # Check if in degree and out degree of\n                # every vertex is same\n                for v in range(self.V):\n                        if len(self.graph[v]) != self.IN[v]:\n                                return False\n\n                return True\n\n\ng = Graph(5);\ng.addEdge(1, 0);\ng.addEdge(0, 2);\ng.addEdge(2, 1);\ng.addEdge(0, 3);\ng.addEdge(3, 4);\ng.addEdge(4, 0);\nif g.isEulerianCycle():\nprint( \"Given directed graph is eulerian\");\nelse:\nprint( \"Given directed graph is NOT eulerian\");\n\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "Given a list of words, remove the ith occurrence of a word from the list", "code": "# Taking a empty list\r\nlistWords = []\r\n# Taking an empty list which gives the result say anslist\r\nanslist = []\r\n# taking a word count and initalize it to 0\r\nwordCount = 0\r\n# scanning the number of strings\r\nnumb = int(input(\"enter the total number of strings :\"))\r\n# Using for loop\r\nfor i in range(numb):\r\n    elem = input(\"enter some random string or word :\\n\")\r\n    listWords.append(elem)\r\n# given word\r\ngiven_word = input(\"Enter the word which you want to remove the ith occurrence\")\r\n# given occurrence number\r\noccur = int(\r\n    input(\"Enter which occurrence you wish to delete of the provided term\"))\r\n\r\n# printing the list before removing the ith occurrence of word\r\nprint(\"printing the list before removing the ith occurrence of word :\")\r\nprint(listWords)\r\n# Traversing the given listWords\r\nfor word in listWords:\r\n    # checking if the given word mathches with the word\r\n    if(word == given_word):\r\n        # increasing the count\r\n        wordCount = wordCount+1\r\n        # If the count doesn't matches with the occurrence value then append it to anslist.\r\n        if(wordCount != occur):\r\n            anslist.append(word)\r\n    else:\r\n        anslist.append(word)\r\n# printing the list before after the ith occurrence of word\r\nprint(\"printing the list after removing the ith occurrence of word :\")\r\nprint(anslist)"}
{"nl": "Find right sibling of a binary tree with parent pointers", "code": "# Python3 program to print right sibling\n# of a node\n\u00a0\n# A class to create a new Binary\n# Tree Node\nclass newNode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, item, parent):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.parent = parent\n\u00a0\n# Method to find right sibling\ndef findRightSibling(node, level):\n\u00a0\u00a0\u00a0\u00a0if (node == None or node.parent == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# GET Parent pointer whose right child is not\n\u00a0\u00a0\u00a0\u00a0# a parent or itself of this node. There might\n\u00a0\u00a0\u00a0\u00a0# be case when parent has no right child, but,\n\u00a0\u00a0\u00a0\u00a0# current node is left child of the parent\n\u00a0\u00a0\u00a0\u00a0# (second condition is for that).\n\u00a0\u00a0\u00a0\u00a0while (node.parent.right == node or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(node.parent.right == None and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.parent.left == node)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.parent == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.parent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0level -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Move to the required child, where\n\u00a0\u00a0\u00a0\u00a0# right sibling can be present\n\u00a0\u00a0\u00a0\u00a0node = node.parent.right\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# find right sibling in the given subtree\n\u00a0\u00a0\u00a0\u00a0# (from current node), when level will be 0\n\u00a0\u00a0\u00a0\u00a0while (level < 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Iterate through subtree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.left != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (node.right != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if no child are there, we cannot\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# have right sibling in this path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0level += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (level == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This is the case when we reach 9 node\n\u00a0\u00a0\u00a0\u00a0# in the tree, where we need to again\n\u00a0\u00a0\u00a0\u00a0# recursively find the right sibling\n\u00a0\u00a0\u00a0\u00a0return findRightSibling(node, level)\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = newNode(1, None)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2, root)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(3, root)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(4, root.left)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(6, root.left)\n\u00a0\u00a0\u00a0\u00a0root.left.left.left = newNode(7, root.left.left)\n\u00a0\u00a0\u00a0\u00a0root.left.left.left.left = newNode(10, root.left.left.left)\n\u00a0\u00a0\u00a0\u00a0root.left.right.right = newNode(9, root.left.right)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(5, root.right)\n\u00a0\u00a0\u00a0\u00a0root.right.right.right = newNode(8, root.right.right)\n\u00a0\u00a0\u00a0\u00a0root.right.right.right.right = newNode(12, root.right.right.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# passing 10\n\u00a0\u00a0\u00a0\u00a0res = findRightSibling(root.left.left.left.left, 0)\n\u00a0\u00a0\u00a0\u00a0if (res == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No right sibling\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(res.data)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Area of a Circular Segment", "code": "# Import math module using the import keyword.\r\nimport math\r\n\r\n# Create a function to say BothSegments_area() which takes the given radius and angle\r\n# as the arguments, and returns the major and minor segments area.\r\n\r\n\r\ndef BothSegments_area(gven_radius, gven_angl):\r\n        # Inside the function, calculate the value area of the sector using the above\r\n        # given mathematical formula and store it in a variable.\r\n    rsltareaof_sectr = pi * (gven_radius * gven_radius) * (gven_angl / 360)\r\n\r\n    # Calculate the area of the triangle using the above given mathematical formula and\r\n    #  math.sin() function.\r\n    # store it in another variable.\r\n    rsltareaof_triangl = 1 / 2 * \\\r\n        (gven_radius * gven_radius) * math.sin((gven_angl * pi) / 180)\r\n\r\n    # Subtract the area of a triangle from the area of a sector and return it.\r\n    return rsltareaof_sectr - rsltareaof_triangl\r\n\r\n\r\n# Give the radius as static input and store it in a variable.\r\ngven_radius = 20\r\n# Give the angle as static input and store it in another variable.\r\ngven_angl = 60\r\n# Take a variable and initialize the pi value as 3.14159.\r\npi = 3.14159\r\n# Pass the given radius and angle as the arguments to the BothSegments_area()\r\n# function and print the area of the minor segment.\r\nprint(\"The minor segment area =\",\r\n      BothSegments_area(gven_radius, gven_angl))\r\n# Pass the given radius and 360-angle as the arguments to the BothSegments_area()\r\n# function and print the area of the major segment.\r\nprint(\"The major segment area =\",\r\n      BothSegments_area(gven_radius, (360 - gven_angl)))"}
{"nl": "Compare two strings", "code": "def match(s1, s2):\r\n  return s1.lower() == s2.lower()"}
{"nl": "Print ASCII Table", "code": "digit = 0\r\n\r\nwhile digit<=255:\r\n    print(\"%d = %c\" %(digit, chr(digit)))\r\n    digit += 1"}
{"nl": "Determine if the elements in the linked list correspond to some downward path in the binary tree", "code": "class Solution(object):\n\n  def isSubPath(self, head, root):\n  A, dp = [head.val], [0]\n  i = 0\n  node = head.next\n  while node:\n  while i and node.val != A[i]:\n  i = dp[i - 1]\n  i += node.val == A[i]\n  A.append(node.val)\n  dp.append(i)\n  node = node.next\n\n  def dfs(root, i):\n  if not root: return False\n  while i and root.val != A[i]:\n  i = dp[i - 1]\n  i += root.val == A[i]\n  return i == len(dp) or dfs(root.left, i) or dfs(root.right, i)\n  return dfs(root, 0)"}
{"nl": "Feature scaling", "code": "\r\nimport pandas as pd\r\nfrom sklearn.preprocessing import StandardScaler\r\n \r\n# Read Data from CSV\r\ndata = read_csv('Geeksforgeeks.csv')\r\ndata.head()\r\n \r\n# Initialise the Scaler\r\nscaler = StandardScaler()\r\n \r\n# To scale data\r\nscaler.fit(data)"}
{"nl": "palindrome number", "code": "def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\n                return False\n        \n        result = 0\n        while x > result:\n                result = result * 10 + x % 10\n                x = x // 10\n                \n        return True if (x == result or x == result // 10) else False"}
{"nl": "Narcissistic Number", "code": "def is_narcissistic(n):\n  return sum([int(i)**len(str(n)) for i in str(n)])==n"}
{"nl": "Exercise working with exceptions: error-handling through the example of DNA bases, if bases are not of the same length, raise an exception", "code": "def distance(strand_a, strand_b):\r\n    if len(strand_a) != len(strand_b):\r\n        raise ValueError('not of equal length')\r\n    errors = [a!=b for a,b in zip(strand_a, strand_b)]\r\n    return sum(errors)"}
{"nl": "Time Conversion", "code": "def digital_clock(s):\n  return \"{:02d}:{:02d}:{:02d}\".format(s//60//60%24, s//60%60, s%60)"}
{"nl": "Hexadecimal to Decimal in Python", "code": "# Python program to convert hexadecimal to decimal def HexDecimal(num): #user-defined function ch = dec = i = 0 length = len(num) - 1 while length >= 0: if num[length]>='0' and num[length]<='9': temp = int(num[length]) elif num[length]>='A' and num[length]<='F': temp = ord(num[length]) - 55 elif num[length]>='a' and num[length]<='f': temp = ord(num[length]) - 87 else: ch = 1 break dec = dec + (temp * (16 ** i)) length = length - 1 i = i+1 return dec # take inputs num = input('Enter hexadecimal number: ') # calling function and display result print('The decimal value is =', HexDecimal(num))"}
{"nl": "Triangle Star Pattern in Python", "code": "# Python star pattern to print left half pyramid  def pattern(n): for i in range(1, n+1): # print star print(\"* \" * i) # take input n = int(input('Enter number of row: ')) # function call pattern(n)"}
{"nl": "Creating Date Objects\r\n", "code": "import datetime\r\n\r\nx = datetime.datetime(2020, 5, 17)\r\n\r\nprint(x)"}
{"nl": "Rearrange the given Number to form the Smallest Number", "code": "# Give the number as user input using int(input()) and store it in a variable.\r\nnumb = int(input('Enter some random number = '))\r\n# Convert the given number to a string and sort it.\r\nstrnumb = str(numb)\r\nstrnumb = sorted(strnumb)\r\n# After sorting join it using the join() function.\r\nsortednumb = ''.join(strnumb)\r\n# Count the number of 0's present in this number\r\n# using the count() function and store it in a variable say m.\r\nm = sortednumb.count('0')\r\n# Convert the given number to a list of digits using the list() function.\r\nnumbdigi = list(sortednumb)\r\n# Swap the first index digit and mth index digit in the list using ',' operator.\r\nnumbdigi[0], numbdigi[m] = numbdigi[m], numbdigi[0]\r\n# Join the list into the string using the join() function.\r\nfinalres = ''.join(numbdigi)\r\n# Print the result\r\nprint('The smallest number that can be formed from',\r\n      numb, 'is [', finalres, ']')"}
{"nl": "Find Armstrong Number in an Interval", "code": "# Give the lower limit range as user input and store it in a variable.\r\ngvn_lower_lmt = int(input(\"Enter some Random number = \"))\r\n# Give the upper limit range as user input and store it in another variable.\r\ngvn_upper_lmt = int(input(\"Enter some Random number = \"))\r\n# Loop from lower limit range to upper limit range using For loop.\r\nprint(\"The Armstrong numbers in the given range: \")\r\nfor numbr in range(gvn_lower_lmt, gvn_upper_lmt + 1):\r\n\r\n    # Inside the for loop take a variable say 'num' and initialize it's value to\r\n    # iterator value .\r\n    # Count how many digits there are in the number.\r\n    no_digits = len(str(numbr))\r\n\r\n # intialize result to zero(tot_sum)\r\n    tot_sum = 0\r\n  # copy the number in another variable(duplicate)\r\n    tempry = numbr\r\n    while tempry > 0:\r\n      # getting the last digit\r\n        rem = tempry % 10\r\n       # multiply the result by a digit raised to the power of the number of digits\r\n        tot_sum += rem ** no_digits\r\n        tempry //= 10\r\n   # It is Armstrong number if it is equal to original number\r\n    if numbr == tot_sum:\r\n        print(numbr)"}
{"nl": "Python Program to Find Sum of Series 1/2!+2/3!+3/5!+\u2026..N/(N+1)!", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the number N(limit) as static input and store it in a variable.\n \n gvn_numb = 6\n \n # Take a variable to say itr and initialize its value to 1.\n \n itr = 1\n \n # Take a variable to say rsltseries_summ and initialize its value to 0.0\n \n # (Floating point number)\n \n rsltseries_summ = 0.0\n \n # Loop until the above-declared variable itr value is less than or equal to the\n \n # given number using the while loop.\n \n while(itr &lt;= gvn_numb):\n \n  # Calculate the factorial of itr+1 using the math.factorial() method and\n \n  # store it in another variable.\n \n  factrl = math.factorial(itr+1)\n \n  # Calculate the value of itr divided by the above result factorial and convert it\n \n  # into float using the float() function.\n \n  # Store it in another variable.\n \n  p = float(itr/factrl)\n \n  # Add the above result to the rsltseries_summ and store it in the same variable.\n \n  rsltseries_summ += p\n \n  # Increment the above itr value by 1.\n \n  itr += 1\n \n # Print the sum of series till the given number N.\n \n print(\n \n  \"The above series sum till the given number N{\", gvn_numb, \"} = \", rsltseries_summ)\n \n </pre>"}
{"nl": "convert 1D array into 2d array", "code": "class Solution:\n    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        if len(original) != m*n:\n            return []\n\n        result = []\n        for i in range(m):\n            result.append([float('inf')]*n)\n            for j in range(n):\n                result[i][j] = original[i*n+j]\n        return result"}
{"nl": "Circumference of a Parallelogram", "code": "# Create a function to say parallelogram_circumference() which takes the given two\r\n# sides as the argument and returns the circumference of the given parallelogram.\r\n\r\n\r\ndef parallelogram_circumference(fst_side, scnd_side):\r\n    # Inside the function, calculate the circumference of the parallelogram using the\r\n        # above given mathematical formula and store it in another variable.\r\n    paralgrm_circum = (2 * fst_side) + (2 * scnd_side)\r\n    # Return the above result.\r\n    return paralgrm_circum\r\n\r\n\r\n# Give the first side as static input and store it in a variable.\r\nfst_side = 5\r\n# Give the second side as static input and store it in another variable.\r\nscnd_side = 6\r\n# Pass the given two sides as the arguments to the parallelogram_circumference() function\r\n# and round it off to up to 3 places after the decimal point using the round() function.\r\n# Store it in another variable.\r\ncircumfrnce = round(parallelogram_circumference(fst_side, scnd_side), 3)\r\n# Print the above result which gives the circumference of the parallelogram for\r\n# the given sides.\r\nprint(\r\n    \"The Circumference of a parallelogram for the given two sides{\", fst_side, \",\", scnd_side, \"} = \", circumfrnce)"}
{"nl": "Python in Keyword", "code": "fruits = [\"apple\", \"banana\", \"cherry\"]\r\n\r\nif \"banana\" in fruits:\r\n  print(\"yes\")"}
{"nl": "X and Y Coordinates", "code": "def convert_cartesian(x, y): \n  return list(map(list, zip(x, y)))"}
{"nl": "Python Error Handling\r\n", "code": "try:\r\n  print(x)\r\nexcept:\r\n  print(\"An exception occurred\")"}
{"nl": "Add 1 to a given number wihout using arithmetic operator", "code": "# Python3 code to add 1\n# one to a given number\ndef addOne(x) :\n\t\n\tm = 1;\n\t# Flip all the set bits\n\t# until we find a 0\n\twhile(x & m):\n\t\tx = x ^ m\n\t\tm <<= 1\n\t\n\t# flip the rightmost\n\t# 0 bit\n\tx = x ^ m\n\treturn x\n\n# Driver program\nn = 13\nprint addOne(n)\n\n# This code is contributed by Prerna Saini.\n"}
{"nl": "Python if Keyword", "code": "x = 5\r\nif x > 3:\r\n  print(\"YES\")"}
{"nl": "Write 1 to 100 in a text file", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\nwith open(givenFilename, 'w') as givenfilecontent:\n  # Iterate from 1 to 100 using the for loop\n  for itr in range(1,101):\n  # Convert the iterator value into a string using the str() function and write it into\n  # the file using the write() function\n  givenfilecontent.write(str(itr) + \"\\t\")"}
{"nl": "Stock Picker", "code": "def stock_picker(lst):\n  return max([max(lst[i+1::])-lst[i] for i in range(len(lst)-1)]+[-1])"}
{"nl": "Print Numbers, that contain 1, 2 and 3, in Ascending Order", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\ngven_lst = list(map(int, input(\r\n   'Enter some random List Elements separated by spaces = ').split()))\r\n# Take a new empty list say \"numb\" and store it in another variable.\r\nnumb = []\r\n# Loop in the given list using the for loop.\r\nfor itr in gven_lst:\r\n # Inside the loop, convert the iterator value to the string using the str() function\r\n    # and store it in another variable.\r\n    strng_number = str(itr)\r\n# Check if 1 and 2 and 3 are present in the string number using the if conditional\r\n# statement and 'and' keyword.\r\n    if '1' in strng_number and '2' in strng_number and '3' in strng_number:\r\n        # If the statement is true, then append the iterator value to the above initialized\r\n        # new empty list \"numb\".\r\n        numb.append(itr)\r\n # Sort the above list \"numb\" using the sort() function.\r\nnumb.sort()\r\n# print the list \"numb\" to print the numbers with the digits 1, 2, and 3 in ascending order,\r\n# which is separated by commas.\r\nprint(\"The numbers with the digits 1, 2, and 3 in ascending order, which is separated by commas= \", numb)"}
{"nl": "Python program to find the frequency of each element in the array", "code": "#Initialize array     \narr = [1, 2, 8, 3, 2, 2, 2, 5, 1];     \n#Array fr will store frequencies of element    \nfr = [None] * len(arr);    \nvisited = -1;    \n     \nfor i in range(0, len(arr)):    \n    count = 1;    \n    for j in range(i+1, len(arr)):    \n        if(arr[i] == arr[j]):    \n            count = count + 1;    \n            #To avoid counting same element again    \n            fr[j] = visited;    \n                \n    if(fr[i] != visited):    \n        fr[i] = count;    \n     \n#Displays the frequency of each element present in array    \nprint(\"---------------------\");    \nprint(\" Element | Frequency\");    \nprint(\"---------------------\");    \nfor i in range(0, len(fr)):    \n    if(fr[i] != visited):    \n        print(\"    \" + str(arr[i]) + \"    |    \" + str(fr[i]));    \nprint(\"---------------------\");    "}
{"nl": "Period.strftime() Function", "code": "# Import pandas module using the import keyword.\r\nimport pandas as pd\r\n# Pass some random frequency(here S= secondly frequency), year, month, day,\r\n# hour, minute, second as the arguments to the Period() function\r\n# of the pandas module to get the Period object\r\nperiod_obj = pd.Period(freq ='S', year = 2015, month = 5, day = 16,\r\n                         hour = 12, minute = 28, second = 10)\r\n  \r\n# Print the given period object\r\nprint(\"The given period object:\")\r\nprint(period_obj)\r\nprint()\r\n# Pass some random format as an argument to the strftime() function\r\n# to get a string representation of the given Period object in the given format.\r\n# Here, %b - month name, %d - day of the month, %Y - year, %A - weekday\r\nprint(\"The Period object in the given format:\")\r\nperiod_obj.strftime('%b. %d, %Y was a %A')"}
{"nl": "Phone Number Word Decoder", "code": "def text_to_num(phone):\n  alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  num = \"22233344455566677778889999\"\n  dic = dict(zip(alpha,num))\n  return \"\".join([dic[i] if i.isalpha() else i for i in phone])"}
{"nl": "Convert a given Binary Tree to Doubly Linked List", "code": "# A simple inorder traversal based program to convert a\n# Binary Tree to DLL\n\n# A Binary Tree node\nclass Node:\n\t\n\t# Constructor to create a new tree node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Standard Inorder traversal of tree\ndef inorder(root):\n\t\n\tif root is not None:\n\t\tinorder(root.left)\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\tinorder(root.right)\n\n# Changes left pointers to work as previous pointers\n# in converted DLL\n# The function simply does inorder traversal of\n# Binary Tree and updates\n# left pointer using previously visited node\ndef fixPrevPtr(root):\n\tif root is not None:\n\t\tfixPrevPtr(root.left)\n\t\troot.left = fixPrevPtr.pre\n\t\tfixPrevPtr.pre = root\n\t\tfixPrevPtr(root.right)\n\n# Changes right pointers to work as next pointers in\n# converted DLL\ndef fixNextPtr(root):\n\n\tprev = None\n\t# Find the right most node in BT or last node in DLL\n\twhile(root and root.right != None):\n\t\troot = root.right\n\n\t# Start from the rightmost node, traverse back using\n\t# left pointers\n\t# While traversing, change right pointer of nodes\n\twhile(root and root.left != None):\n\t\tprev = root\n\t\troot = root.left\n\t\troot.right = prev\n\n\t# The leftmost node is head of linked list, return it\n\treturn root\n\n# The main function that converts BST to DLL and returns\n# head of DLL\ndef BTToDLL(root):\n\t\n\t# Set the previous pointer\n\tfixPrevPtr(root)\n\n\t# Set the next pointer and return head of DLL\n\treturn fixNextPtr(root)\n\n# Traversses the DLL from left to right\ndef printList(root):\n\twhile(root != None):\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\troot = root.right\n\n# Driver program to test above function\nroot = Node(10)\nroot.left = Node(12)\nroot.right = Node(15)\nroot.left.left = Node(25)\nroot.left.right = Node(30)\nroot.right.left = Node(36)\n\nprint (\"Inorder Tree Traversal\")\ninorder(root)\n\n# Static variable pre for function fixPrevPtr\nfixPrevPtr.pre = None\nhead = BTToDLL(root)\n\nprint (\"\\nDLL Traversal\")\nprintList(head)\n\t\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Comma-separated string to tuple", "code": "# Give the string as static input and store it in a variable.\ngvn_str = 'good, morning, btechgeeks'\n# Print the above-given input string.\nprint(\"Given input String = \", gvn_str)\n# Split the given input string separated by commas using the split() function\n# and convert it into a tuple.\n# Store it in another variable.\ntupl = tuple(gvn_str.split(\",\"))\n# Print the tuple with a comma-separated string.\nprint(\"A tuple with comma-separated string is : \", tupl)"}
{"nl": "Simon Says", "code": "def simon_says(lst1, lst2):\n  return lst1[:-1] == lst2[1:]"}
{"nl": "Find three element from different three arrays such that a + b + c = sum", "code": "# Python3 program to find three element\n# from different three arrays such\n# that a + b + c is equal to\n# given sum\n\n# Function to check if there is\n# an element from each array such\n# that sum of the three elements is\n# equal to given sum.\ndef findTriplet(a1, a2, a3,\n                                n1, n2, n3, sum):\n\n        # Store elements of first\n        # array in hash\n        s = set()\n\n        # sum last two arrays element\n        # one by one\n        for i in range(n1):\n                s.add(a1[i])\n\n        for i in range(n2):\n                for j in range(n3):\n\n                        # Consider current pair and\n                        # find if there is an element\n                        # in a1[] such that these three\n                        # form a required triplet\n                        if sum - a2[i] - a3[j] in s:\n                                return True\n        return False\n\n# Driver code\na1 = [1, 2, 3, 4, 5]\na2 = [2, 3, 6, 1, 2]\na3 = [3, 24, 5, 6]\nn1 = len(a1)\nn2 = len(a2)\nn3 = len(a3)\nsum = 9\nif findTriplet(a1, a2, a3,\n                        n1, n2, n3, sum) == True:\n        print(\"Yes\")\nelse:\n        print(\"No\")\n\n# This code is contributed by Shrikant13\n"}
{"nl": "Python Program to Find Common Characters between Two Strings", "code": "# Give the first string as User input  using the input() function , convert the given string into lower case\n# using built-in lower() method and store it in a variable.\nfst_strng = input(\"Enter some Random String = \").lower()\n# Give the  second string as User input  using the input() function, convert the given string into lower case\n# using built-in lower() method and store it in another variable.\nsecnd_strng = input(\"Enter some Random String = \").lower()\n# Get the Common characters between both the above given strings using built-in\n# intersection() method which is a set method.\n# Sort the above given string using  built-in sorted() method.\n# Join the the above given string using built-in join()method .\n# Print all the Common Characters between the above given two Strings.\nprint(\"The Common Characters between the above given two Strings = \",\n      ''.join(sorted(set.intersection(set(fst_strng), set(secnd_strng)))))"}
{"nl": "Shortest distance between two nodes in BST", "code": "# Python3 program to find distance between\n# two nodes in BST\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Standard BST insert function\ndef insert(root, key):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = newNode(key)\n\u00a0\u00a0\u00a0\u00a0else if root.key > key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, key)\n\u00a0\u00a0\u00a0\u00a0else if root.key < key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, key)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# This function returns distance of x from\n# root. This function assumes that x exists\n# in BST and BST is not NULL.\ndef distanceFromRoot(root, x):\n\u00a0\u00a0\u00a0\u00a0if root.key == x:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0else if root.key > x:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1 + distanceFromRoot(root.left, x)\n\u00a0\u00a0\u00a0\u00a0return 1 + distanceFromRoot(root.right, x)\n\u00a0\n# Returns minimum distance between a and b.\n# This function assumes that a and b exist\n# in BST.\ndef distanceBetween2(root, a, b):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Both keys lie in left\n\u00a0\u00a0\u00a0\u00a0if root.key > a and root.key > b:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return distanceBetween2(root.left, a, b)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Both keys lie in right\n\u00a0\u00a0\u00a0\u00a0if root.key < a and root.key < b: # same path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return distanceBetween2(root.right, a, b)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Lie in opposite directions\n\u00a0\u00a0\u00a0\u00a0# (Root is LCA of two nodes)\n\u00a0\u00a0\u00a0\u00a0if root.key >= a and root.key <= b:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (distanceFromRoot(root, a) +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0distanceFromRoot(root, b))\n\u00a0\n# This function make sure that a is smaller\n# than b before making a call to findDistWrapper()\ndef findDistWrapper(root, a, b):\n\u00a0\u00a0\u00a0\u00a0if a > b:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a, b = b, a\n\u00a0\u00a0\u00a0\u00a0return distanceBetween2(root, a, b)\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0insert(root, 5)\n\u00a0\u00a0\u00a0\u00a0insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0insert(root, 30)\n\u00a0\u00a0\u00a0\u00a0insert(root, 25)\n\u00a0\u00a0\u00a0\u00a0insert(root, 35)\n\u00a0\u00a0\u00a0\u00a0a, b = 5, 55\n\u00a0\u00a0\u00a0\u00a0print(findDistWrapper(root, 5, 35))\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Check for Balanced Brackets in an expression (well-formedness) using Stack", "code": "# Python3 program to check for\n# balanced brackets.\n\u00a0\n# function to check if\n# brackets are balanced\n\u00a0\n\u00a0\ndef areBracketsBalanced(expr):\n\u00a0\u00a0\u00a0\u00a0stack = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing the Expression\n\u00a0\u00a0\u00a0\u00a0for char in expr:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char in [\"(\", \"{\", \"[\"]:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push the element in the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(char)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# IF current character is not opening\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# bracket, then it must be closing.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# So stack cannot be empty at this point.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current_char = stack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current_char == '(':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char != \")\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current_char == '{':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char != \"}\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current_char == '[':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if char != \"]\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Check Empty Stack\n\u00a0\u00a0\u00a0\u00a0if stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0expr = \"{()}[]\"\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call\n\u00a0\u00a0\u00a0\u00a0if areBracketsBalanced(expr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Balanced\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Not Balanced\")\n\u00a0\n# This code is contributed by AnkitRai01 and improved\n# by Raju Pitta\n"}
{"nl": "find the intervals between identical elements", "code": "class Solution:\n    def getDistances(self, arr: List[int]) -> List[int]:\n        \n        def helper(nums):\n            n = len(nums)\n            res = [0]*n\n            d = {}\n            for i, num in enumerate(nums):\n                if num not in d:\n                    d[num] = [i, 1]\n                else:\n                    prev_index, cnt = d[num]\n                    res[i] = res[prev_index] + (i - prev_index)*cnt\n                    d[num] = [i, cnt+1]\n            return res\n        \n        left = helper(arr)\n        right = helper(arr[::-1])[::-1]\n        return [x+y for x,y in zip(left, right)]"}
{"nl": "Product of Array except itself", "code": "# Python3 program for the above approach\r\ndef productExceptSelf(a, n):\r\n\t\r\n\tprod = 1\r\n\tflag = 0\r\n\t\r\n\tfor i in range(n):\r\n\t\t\r\n\t\t# Counting number of elements\r\n\t\t# which have value\r\n\t\t# 0\r\n\t\tif (a[i] == 0):\r\n\t\t\tflag += 1\r\n\t\telse:\r\n\t\t\tprod *= a[i]\r\n\t\r\n\t# Creating a new array of size n\r\n\tarr = [0 for i in range(n)]\r\n\t\r\n\tfor i in range(n):\r\n\t\t\r\n\t\t# If number of elements in\r\n\t\t# array with value 0\r\n\t\t# is more than 1 than each\r\n\t\t# value in new array\r\n\t\t# will be equal to 0\r\n\t\tif (flag > 1):\r\n\t\t\tarr[i] = 0\r\n\t\t\r\n\t\t# If no element having value\r\n\t\t# 0 than we will\r\n\t\t# insert product/a[i] in new array\r\n\t\telif (flag == 0):\r\n\t\t\tarr[i] = (prod // a[i])\r\n\t\t\r\n\t\t# If 1 element of array having\r\n\t\t# value 0 than all\r\n\t\t# the elements except that index\r\n\t\t# value , will be\r\n\t\t# equal to 0\r\n\t\telif (flag == 1 and a[i] != 0):\r\n\t\t\tarr[i] = 0\r\n\t\t\r\n\t\t# If(flag == 1 && a[i] == 0)\r\n\t\telse:\r\n\t\t\tarr[i] = prod\r\n\t\t\t\r\n\treturn arr\r\n\r\n# Driver Code\r\nn = 5\r\narray = [ 10, 3, 5, 6, 2 ]\r\nans = productExceptSelf(array, n)\r\n\r\nprint(*ans)\r\n\r\n# This code is contributed by rag2127\r"}
{"nl": "Python Program to Find Area of Circle", "code": "# python program to find area of circle # take inputs r = 10 # calculate area of circle area = 3.14 * r * r # display result print('Area of circle = ',area)"}
{"nl": "Number of sink nodes in a graph", "code": "# Python3 program to count number if sink nodes\n\u00a0\u00a0\n# Return the number of Sink NOdes.\u00a0\ndef countSink(n, m, edgeFrom, edgeTo):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Array for marking the non-sink node.\u00a0\n\u00a0\u00a0\u00a0\u00a0mark = [0] * (n + 1)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Marking the non-sink node.\n\u00a0\u00a0\u00a0\u00a0for i in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mark[edgeFrom[i]] = 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Counting the sink nodes.\u00a0\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(1, n + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not mark[i]):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count += 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0n = 4\n\u00a0\u00a0\u00a0\u00a0m = 2\n\u00a0\u00a0\u00a0\u00a0edgeFrom = [2, 4]\u00a0\n\u00a0\u00a0\u00a0\u00a0edgeTo = [3, 3]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(countSink(n, m, edgeFrom, edgeTo))\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Final value of variable after performing operations", "code": "class Solution:\n    def finalValueAfterOperations(self, operations: List[str]) -> int:\n        ans = 0\n        for operation in operations:\n            ans = ans + 1 if operation in [\"++X\",\"X++\"] else ans-1\n        return ans"}
{"nl": "number of valid move combinations on chessboard", "code": "def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\n        n = len(pieces)\n        rook_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n        bishop_dirs = [(1, 1), (-1, 1), (-1, -1), (1, -1)]\n        \n        dir_map = {\n            'rook': rook_dirs + [(0, 0)],\n            'bishop': bishop_dirs + [(0, 0)],\n            'queen': rook_dirs + bishop_dirs + [(0, 0)]\n        }\n        \n        # count num of moves can be made given positions and directions\n        def count_moves(positions, directions):\n            # if all pieces reached destination, there's no more moves\n            if all(direction == (0, 0) for direction in directions):\n                return 0\n            \n            # do the move\n            new_positions = [(i + di, j + dj) \n                             for (i, j), (di, dj) in zip(positions, directions)\n                             if 1 <= i + di <= 8 and 1 <= j + dj <= 8]\n            \n            # if any pieces hit the wall, or they are in the same position\n            if len(set(new_positions)) != n:\n                return 0\n            \n            # found 1 valid move\n            n_moves = 1\n            \n            # get all the possible directions, recursively call to count moves\n            for new_direction in get_directions(directions, 0, []):\n                n_moves += count_moves(new_positions, new_direction)\n            return n_moves\n        \n        # backtrack to get all possible directions combination given last directions\n        def get_directions(dirs, curr_idx, stack):\n            if len(stack) == n:\n                yield stack\n                return\n            for i in range(curr_idx, n):\n                stack.append(dirs[i])\n                for d in get_directions(dirs, i + 1, stack):\n                    yield d\n                stack.pop()\n                if any(dirs[i]):\n                    stack.append((0, 0))\n                    for d in get_directions(dirs, i + 1, stack):\n                        yield d\n                    stack.pop()\n        \n        # backtrack to get all initial directions, call count_moves() when the stack is full \n        def init_directions_and_count(stack):\n            n_moves = 0\n            if len(stack) == n:\n                n_moves += count_moves(positions, stack)\n            else:            \n                piece_to_add = pieces[len(stack)]            \n                for direction in dir_map[piece_to_add]:\n                    stack.append(direction)\n                    n_moves += init_directions_and_count(stack)\n                    stack.pop()\n            return n_moves\n        \n        # plus one for all pieces stays at initial locations\n        return init_directions_and_count([]) + 1"}
{"nl": "Count divisible pairs in an array", "code": "# Python3 program to count\n# divisible pairs.\n\ndef countDivisibles(arr, n) :\n\n        res = 0\n\n        # Iterate through all pairs\n        for i in range(0, n) :\n                for j in range(i+1, n) :\n                        \n                        # Increment count if one divides\n                        # other\n                        if (arr[i] % arr[j] == 0 or\n                        arr[j] % arr[i] == 0) :\n                                res+=1\n\n        return res\n\n# Driver code\nif __name__=='__main__':\n        a = [1, 2, 3, 9]\n        n = len(a)\n        print(countDivisibles(a, n) )\n\n# this code is contributed by\n# Smitha Dinesh Semwal\n"}
{"nl": "Using List Comprehension to Create List of Tuples", "code": "# given lower limit range as static input\r\nlowerlimit = 5\r\n# given upper limit range as static input\r\nupperlimit = 13\r\n# Using list comprehension, generate a list of tuples with the first element being the number within\r\n# the range and the second element being the square of the number.\r\nlistOfTuples = [(k, k**2) for k in range(lowerlimit, upperlimit+1)]\r\n# printing the list of tuples\r\nprint('The list of Tuples are : ', listOfTuples)"}
{"nl": "Coin Change Dynamic Programming", "code": "# Python program for the above approach\ndef coinchange(a, v, n, dp):\n\tif (v == 0):\n\t\tdp[n][v] = 1;\n\t\treturn dp[n][v];\n\tif (n == 0):\n\t\treturn 0;\n\tif (dp[n][v] != -1):\n\t\treturn dp[n][v];\n\tif (a[n - 1] <= v):\n\n\t\t# Either Pick this coin or not\n\t\tdp[n][v] = coinchange(a, v - a[n - 1], n, dp) + coinchange(a, v, n - 1, dp);\n\t\treturn dp[n][v];\n\telse: # We have no option but to leave this coin\n\t\tdp[n][v] = coinchange(a, v, n - 1, dp);\n\t\treturn dp[n][v];\n\n# Driver code\nif __name__ == '__main__':\n\ttc = 1;\n\twhile (tc != 0):\n\t\tn = 3;\n\t\tv = 4;\n\t\ta = [ 1, 2, 3 ];\n\t\tdp = [[-1 for i in range(v+1)] for j in range(n+1)]\n\t\tres = coinchange(a, v, n, dp);\n\t\tprint(res);\n\t\ttc -= 1;\n\t\n# This code is contributed by Rajput-Ji"}
{"nl": "Python Program to Find the Sum of all Odd Frequency Elements in an Array/List", "code": "# Take a dictionary and initialize it to empty\n# using the {} or dict() say freqncyDictionary.\nfreqncyDictionary = {}\n# Give the list as static input and store it in a variable.\ngvnlst = [10, 4, 2, 10, 1, 2, 3, 4, 5, 6, 6]\n# Loop in the given list using the For loop.\nfor i in gvnlst:\n        # Inside the For loop,\n    # Check if the list element is present in the dictionary\n    # or not using the if conditional statement and 'in' keyword.\n    if i in freqncyDictionary.keys():\n                # If it is true then increment the count of the list element\n        # in the dictionary by 1.\n        freqncyDictionary[i] = freqncyDictionary[i]+1\n    # Else initialize the dictionary with the list element as key and value as 1.\n    else:\n        freqncyDictionary[i] = 1\n\n# Take a variable say oddfreqncycnt and initialize its value to 0.\noddfreqncycnt = 0\n# Loop in the freqncyDictionary using the For loop.\nfor elemnt in freqncyDictionary:\n    # Check if the key in the freqncyDictionary having value odd\n    # using the if conditional statement.\n    if(freqncyDictionary[elemnt] % 2 != 0):\n                # If it is true then increment the oddfreqncycnt by the key\n        # and store it in the same variable.\n        oddfreqncycnt += elemnt\n# After the end of For loop then print the oddfreqncycnt value.\nprint('The sum of all odd frequency elements in the given list', gvnlst, 'is:')\nprint(oddfreqncycnt)"}
{"nl": "Print (Generate) Right Angle Triangle Star Pattern", "code": "# Generating Right Angle Triangle Pattern Using Stars\r\n\r\nrow = int(input('Enter number of rows required: '))\r\n\r\nfor i in range(row):\r\n    for j in range(i+1):\r\n        print('*',end=' ')\r\n    print()"}
{"nl": "Program to find largest element in an array", "code": "# Python3 program to find maximum\n# in arr[] of size n\n\n# Function to find maximum\n# in arr[] of size n\ndef largest(arr,n):\n# Initialize maximum element\nmax = arr[0]\t\t\n\n# Traverse array elements from second\t\t\n# and compare every element with\t\t\n# current max\t\t\nfor i in range(1, n):\t\t\n\tif arr[i] > max:\t\t\n\t\tmax = arr[i]\t\t\nreturn max\n\n# Driver Code\narr = [10, 324, 45, 90, 9808]\nn = len(arr)\n\n#calculating length of an array\nAns = largest(arr,n)\n\n# display max\nprint (\"Largest in given array is\",Ans)\n\n# This code is contributed by Jai Parkash Bhardwaj\n# and improved by ssaha3475"}
{"nl": "Python Check for Duplicates in List", "code": "# Python program to check for duplicates in list # take list my_list = [1, 3, 5, 1] # printing original list print('List:', my_list) # check duplicates using set() seen = set() duplicate_item = {x for x in my_list if x in seen or (seen.add(x) or False)} if duplicate_item: print('Yes, the list contains duplicates.') else: print('No, the list does not contains duplicates.')"}
{"nl": "Solve Matrix-Chain Multiplication using Dynamic Programming with Memoization", "code": "def matrix_product(p):\n    \"\"\"Return m and s.\n\u00a0\n    m[i][j] is the minimum number of scalar multiplications needed to compute the\n    product of matrices A(i), A(i + 1), ..., A(j).\n\u00a0\n    s[i][j] is the index of the matrix after which the product is split in an\n    optimal parenthesization of the matrix product.\n\u00a0\n    p[0... n] is a list such that matrix A(i) has dimensions p[i - 1] x p[i].\n    \"\"\"\n    length = len(p) # len(p) = number of matrices + 1\n\u00a0\n    # m[i][j] is the minimum number of multiplications needed to compute the\n    # product of matrices A(i), A(i+1), ..., A(j)\n    # s[i][j] is the matrix after which the product is split in the minimum\n    # number of multiplications needed\n    m = [[-1]*length for _ in range(length)]\n    s = [[-1]*length for _ in range(length)]\n\u00a0\n    matrix_product_helper(p, 1, length - 1, m, s)\n\u00a0\n    return m, s\n\u00a0\n\u00a0\ndef matrix_product_helper(p, start, end, m, s):\n    \"\"\"Return minimum number of scalar multiplications needed to compute the\n    product of matrices A(start), A(start + 1), ..., A(end).\n\u00a0\n    The minimum number of scalar multiplications needed to compute the\n    product of matrices A(i), A(i + 1), ..., A(j) is stored in m[i][j].\n\u00a0\n    The index of the matrix after which the above product is split in an optimal\n    parenthesization is stored in s[i][j].\n\u00a0\n    p[0... n] is a list such that matrix A(i) has dimensions p[i - 1] x p[i].\n    \"\"\"\n    if m[start][end] >= 0:\n        return m[start][end]\n\u00a0\n    if start == end:\n        q = 0\n    else:\n        q = float('inf')\n        for k in range(start, end):\n            temp = matrix_product_helper(p, start, k, m, s) \\\n                   + matrix_product_helper(p, k + 1, end, m, s) \\\n                   + p[start - 1]*p[k]*p[end]\n            if q > temp:\n                q = temp\n                s[start][end] = k\n\u00a0\n    m[start][end] = q\n    return q\n\u00a0\n\u00a0\ndef print_parenthesization(s, start, end):\n    \"\"\"Print the optimal parenthesization of the matrix product A(start) x\n    A(start + 1) x ... x A(end).\n\u00a0\n    s[i][j] is the index of the matrix after which the product is split in an\n    optimal parenthesization of the matrix product.\n    \"\"\"\n    if start == end:\n        print('A[{}]'.format(start), end='')\n        return\n\u00a0\n    k = s[start][end]\n\u00a0\n    print('(', end='')\n    print_parenthesization(s, start, k)\n    print_parenthesization(s, k + 1, end)\n    print(')', end='')\n\u00a0\n\u00a0\nn = int(input('Enter number of matrices: '))\np = []\nfor i in range(n):\n    temp = int(input('Enter number of rows in matrix {}: '.format(i + 1)))\n    p.append(temp)\ntemp = int(input('Enter number of columns in matrix {}: '.format(n)))\np.append(temp)\n\u00a0\nm, s = matrix_product(p)\nprint('The number of scalar multiplications needed:', m[1][n])\nprint('Optimal parenthesization: ', end='')\nprint_parenthesization(s, 1, n)"}
{"nl": "Sort a nearly sorted (or K sorted) array", "code": "# A Python3 program to sort a\n# nearly sorted array.\n\nfrom heapq import heappop, heappush, heapify\n\n\n# A utility function to print\n# array elements\ndef print_array(arr: list):\n\tfor elem in arr:\n\t\tprint(elem, end=' ')\n\n# Given an array of size n, where every\n# element is k away from its target\n# position, sorts the array in O(nLogk) time.\n\n\ndef sort_k(arr: list, n: int, k: int):\n\t\"\"\"\n\t:param arr: input array\n\t:param n: length of the array\n\t:param k: max distance, which every\n\telement is away from its target position.\n\t:return: None\n\t\"\"\"\n\t# List of first k+1 items\n\theap = arr[:k + 1]\n\n\t# using heapify to convert list\n\t# into heap(or min heap)\n\theapify(heap)\n\n\t# \"rem_elmnts_index\" is index for remaining\n\t# elements in arr and \"target_index\" is\n\t# target index of for current minimum element\n\t# in Min Heap \"heap\".\n\ttarget_index = 0\n\tfor rem_elmnts_index in range(k + 1, n):\n\t\tarr[target_index] = heappop(heap)\n\t\theappush(heap, arr[rem_elmnts_index])\n\t\ttarget_index += 1\n\n\twhile heap:\n\t\tarr[target_index] = heappop(heap)\n\t\ttarget_index += 1\n\n\n# Driver Code\nk = 3\narr = [2, 6, 3, 12, 56, 8]\nn = len(arr)\nsort_k(arr, n, k)\n\nprint('Following is sorted array')\nprint_array(arr)\n\n# This code is contributed by\n# Veerat Beri(viratberi)"}
{"nl": "Sum of nodes at k-th level in a tree represented as string", "code": "# Python3 implementation to find sum of\n# digits of elements at k-th level\n\n# Function to find sum of digits\n# of elements at k-th level\ndef sumAtKthLevel(tree, k) :\n\n\tlevel = -1\n\tsum = 0 # Initialize result\n\tn = len(tree)\n\n\tfor i in range(n):\n\t\t\n\t\t# increasing level number\n\t\tif (tree[i] == '(') :\n\t\t\tlevel += 1\n\n\t\t# decreasing level number\n\t\telse if (tree[i] == ')'):\n\t\t\tlevel -= 1\n\n\t\telse:\n\t\t\n\t\t\t# check if current level is\n\t\t\t# the desired level or not\n\t\t\tif (level == k) :\n\t\t\t\tsum += (ord(tree[i]) - ord('0'))\n\t\t\n\t# required sum\n\treturn sum\n\n# Driver Code\nif __name__ == '__main__':\n\ttree = \"(0(5(6()())(4()(9()())))(7(1()())(3()())))\"\n\tk = 2\n\tprint(sumAtKthLevel(tree, k))\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Print pyramid pattern using stars", "code": "# Give the number of rows of the pyramid as static input and store it in a variable.\npyRows = 10\n# Loop from the number of rows to 0 in decreasing order using For Loop.\n# Loop from 0 to the number of rows using For Loop.\nfor m in range(0, pyRows):\n    # Loop from 0 to the number of rows - iterator value-1 of the parent For loop\\\n    # using another Nested For loop(Inner For loop).\n    for n in range(0, pyRows-m-1):\n        # Print the space character in the inner For loop.\n        print(end=' ')\n    # Loop from 0 to the iterator value+1 of the parent For loop\n    # using another Nested For loop(Inner For loop).\n\n    for l in range(0, m+1):\n        # Print the star character with a star character in the inner For loop.\n        print('*', end=' ')\n    print()"}
{"nl": "The maximum number of non-overlapping subarrays with the sum equal to target", "code": "class Solution:\n  def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n  seen = set([0])\n  ans = curr = 0\n\n  for i, num in enumerate(nums):\n  curr += num\n  prev = curr - target\n  if prev in seen:\n  ans += 1\n  seen = set()\n  seen.add(curr)\n  \n  return ans"}
{"nl": "Encode Morse", "code": "def encode_morse(txt):\n  d = {'A':'.-', 'B':'-...',\n     'C':'-.-.', 'D':'-..', 'E':'.',\n     'F':'..-.', 'G':'--.', 'H':'....',\n     'I':'..', 'J':'.---', 'K':'-.-',\n     'L':'.-..', 'M':'--', 'N':'-.',\n     'O':'---', 'P':'.--.', 'Q':'--.-',\n     'R':'.-.', 'S':'...', 'T':'-',\n     'U':'..-', 'V':'...-', 'W':'.--',\n     'X':'-..-', 'Y':'-.--', 'Z':'--..',\n     '1':'.----', '2':'..---', '3':'...--',\n     '4':'....-', '5':'.....', '6':'-....',\n     '7':'--...', '8':'---..', '9':'----.',\n     '0':'-----', ',':'--..--', '.':'.-.-.-',\n     '?':'..--..', '/':'-..-.', '-':'-....-',\n     '(':'-.--.', ')':'-.--.-', '!': '-.-.--', \n     ' ': ' ', \"'\": '.----.', ':': '---...'}\n       return ' '.join(d[i] for i in txt.upper())"}
{"nl": "The maximum product of two elements in an array", "code": "def maxProduct(self, nums: List[int]) -> int:\n  mx1 = mx2 = -math.inf\n  for n in nums:\n  if n > mx1:\n  mx2 = mx1\n  mx1 = n\n  elif n > mx2:\n  mx2 = n\n  return (mx1 - 1) * (mx2 - 1)"}
{"nl": "Generate random secure token of 64 bytes and random URL", "code": "import secrets\r\n\r\nprint(\"Random secure Hexadecimal token is \", secrets.token_hex(64))\r\nprint(\"Random secure URL is \", secrets.token_urlsafe(64))"}
{"nl": "Print a pyramid in which you double each number horizontally, starting with 1, given the number of rows", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumbrrows = 7\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numbrrows):\r\n    # Loop from iterator value of the parent For loop -1 to 0\r\n    # in decreasing order using another for loop(Nested For loop).\r\n    for n in range(m - 1, -1, -1):\r\n        # Print the 2 power n value with space where n is the value of the inner for loop.\r\n        print(2**n, end=' ')\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "Return the position(s) of an element in a matrix, given the element and the matrix. ", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[2, 9, 1], [11, 4, 5], [9, 2, 3], [1, 2, 3]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Give the number/element as static input and store it in a variable to say gvnele.\r\ngvnele = 9\r\n# Take a variable to say tempo and initialize its value to 0\r\n# (Here tempo as temp variable which says whether the element is present\r\n# or not in matrix at the end).\r\ntempo = 0\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n    # Inside the For loop, Iterate till the given number of rows using another\r\n    # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # Check if the gvnmatrix[n][m] value\r\n        # (where n is the iterator value of the parent For loop and\r\n        # m is the iterator value of the inner For loop)\r\n        # is equal to gvnele using the if conditional statement.\r\n        if(mtrx[n][m] == gvnele):\r\n            # If it is true then print the iterator value of parent for loop+1\r\n            # (Here it acts as row number)\r\n            # and also print the inner loop iterator value+1\r\n            # (Here it acts as column number).\r\n            print('The given element {', gvnele, '} is present at row {' +\r\n                  str(n+1)+'} and column {'+str(m+1)+'}')\r\n            # Set the value of tempo to 1.\r\n            tempo = 1\r\n# After the end of loops check if the value of tempo is 0\r\n# or not using the if conditional statement.\r\nif(tempo == 0):\r\n        # If it is true then print the given element doesn't exist in the given matrix.\r\n    print('the given element doesnot exist in the given matrix.')"}
{"nl": "Python Remove item from List [remove(), pop(), clear(), del]", "code": "# Python program to remove item from list # take list my_list = ['C', 'Java', 'Python', 'HTML', 'Javascript'] # printing original list print('List:', my_list) # removed HTML from the list my_list.remove('HTML') # print list after item deletion print('New list:', my_list)"}
{"nl": "return the smallest k-length subsequence with occurences of a letter", "code": "class Solution:\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n        counts,total = 0, 0\n        n = len(s)\n        for ch in s:\n            if ch==letter:\n                total +=1\n        stack = []\n        occ = 0\n        for idx,ch in enumerate(s):\n            if ch==letter:\n                counts +=1\n            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): \n                occ -= stack.pop()==letter\n            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):\n                stack.append(ch)\n            elif ch==letter and len(stack)+(total-counts)<k:\n                stack.append(ch)\n                occ +=1\n        return ''.join(stack)"}
{"nl": "Roll dice so that you get the same number 5 times", "code": "import random\r\n\r\ndice = [1, 2, 3, 4, 5, 6]\r\nprint(\"Randomly selecting same number of a dice\")\r\nfor i in range(5):\r\n    random.seed(25)\r\n    print(random.choice(dice))"}
{"nl": "File errors property", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\ngvn_file = open(givenFilename, 'w') \n# Apply errors function to the given file and print it\nprint(\"In write-mode:\", gvn_file.errors)\n# Close the given file using the close function\ngvn_file.close()\n# Open the file in append mode. In this case, we're appending the contents into the file.\ngvn_file = open(givenFilename, 'a') \n# Apply errors function to the given file and print it\nprint(\"In append-mode:\", gvn_file.errors)\n# Close the given file using the close function\ngvn_file.close()\n# Open the file in write mode and pass errors ='ignore' as the \n# arguments to the open() function\ngvn_file = open(givenFilename, 'w', errors='ignore') \n# Apply errors function to the given file and print it\nprint(\"In write-mode with errors=ignore:\", gvn_file.errors)\n# Close the given file using the close function\ngvn_file.close()"}
{"nl": "String to Dictionary", "code": "def str_to_dict(lst):\n    return dict(i.split('=') for i in lst)"}
{"nl": "Check if a given Circle lies Completely Inside the Ring formed by Two Concentric Circles", "code": "# import the math module using the import keyword\r\nimport math\r\n# Give the first circle radius(small circle) r as static input and\r\n# store it in a variable say rVal.\r\nrVal = 8\r\n# Give the second circle radius (Big circle) R as static input and\r\n# store it in another variable say RVal.\r\nRVal = 4\r\n# Give the Third Circle(Which we want to check Condition) radius r1 as\r\n# static input and store it in another variable say r1Val\r\nr1Val = 2\r\n# Give the x coordinates and y coordinates of the third circle and\r\n# store them in two separate variables.\r\nxCoordinate = 6\r\nyCoordinate = 0\r\n# Calculate the distance(dis value) using Pythagoras theorem and sqrt() function\r\n# and store the result in a variable say disVal.\r\ndisVal = math.sqrt(xCoordinate * xCoordinate + yCoordinate * yCoordinate)\r\n# Check the Condition (dis \u2013 r1)> = r and (dis + r1)< = R \r\n# using the if conditional Statement.\r\nif((disVal-r1Val >= RVal and disVal+r1Val <= rVal)):\r\n    # If it is true then Print the given circle inside the ring \r\n    print('The given circle lies inside the ring')\r\nelse:\r\n    # Else print the circle does not lie inside.\r\n    print('The given circle does not lies inside the ring')"}
{"nl": "The kth largest xor coordinate value", "code": "def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n  R, C = map(len, (matrix, matrix[0]))\n  ans = [[0] * (C + 1) for _ in range(R + 1)]\n  heap = []\n  for r, row in enumerate(matrix):\n  for c, cell in enumerate(row):\n  ans[r + 1][c + 1] = cell ^ ans[r + 1][c] ^ ans[r][c + 1] ^ ans[r][c]\n  heapq.heappush(heap, ans[r + 1][c + 1])\n  if len(heap) > k:\n heapq.heappop(heap)\n  return heap[0]"}
{"nl": "Find the minimum cost to reach destination using a train", "code": "# A Dynamic Programming based\n# solution to find min cost\n# to reach station N-1\n# from station 0.\n \nINF = 2147483647\nN = 4\n  \n# This function returns the\n# smallest possible cost to\n# reach station N-1 from station 0.\ndef minCost(cost):\n \n    # dist[i] stores minimum\n    # cost to reach station i\n    # from station 0.\n    dist=[0 for i in range(N)]\n    for i in range(N):\n        dist[i] = INF\n    dist[0] = 0\n  \n    # Go through every station\n    # and check if using it\n    # as an intermediate station\n    # gives better path\n    for i in range(N):\n        for j in range(i+1,N):\n            if (dist[j] > dist[i] + cost[i][j]):\n                dist[j] = dist[i] + cost[i][j]\n  \n    return dist[N-1]\n \n  \n# Driver program to\n# test above function\n \ncost= [ [0, 15, 80, 90],\n            [INF, 0, 40, 50],\n            [INF, INF, 0, 70],\n            [INF, INF, INF, 0]]\n             \nprint(\"The Minimum cost to reach station \",\n           N,\" is \",minCost(cost))\n \n# This code is contributed\n# by Anant Agarwal."}
{"nl": "Souvenir Shop", "code": "def maximum_items(prices, budget):\n  n=0\n  prices=sorted([int(i[1:]) for i in prices])\n  budget=int(budget[1:])\n  while prices and prices[0]<=budget:\n    n+=1\n    budget-=prices.pop(0)\n  return n if n else 'Not enough funds!'"}
{"nl": "A Practical approach to Simple Linear Regression", "code": "# Simple Linear Regression\n\n# Importing the libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Importing the dataset\ndataset = pd.read_csv('Salary_Data.csv')\nX = dataset.iloc[:, :-1].values\ny = dataset.iloc[:, 1].values\n\n# Splitting the dataset into the Training set and Test set\nfrom sklearn.cross_validation import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(\n\t\t\tX, y, test_size = 1/3, random_state = 0)\n\n# Fitting Simple Linear Regression to the Training set\nfrom sklearn.linear_model import LinearRegression\nregressor = LinearRegression()\nregressor.fit(X_train, y_train)\n\n# Predicting the Test set results\ny_pred = regressor.predict(X_test)\n\n# Visualising the Training set results\nplt.scatter(X_train, y_train, color = 'red')\nplt.plot(X_train, regressor.predict(X_train), color = 'blue')\nplt.title('Salary vs Experience (Training set)')\nplt.xlabel('Years of Experience')\nplt.ylabel('Salary')\nplt.show()\n\n# Visualising the Test set results\nplt.scatter(X_test, y_test, color = 'red')\nplt.plot(X_train, regressor.predict(X_train), color = 'blue')\nplt.title('Salary vs Experience (Test set)')\nplt.xlabel('Years of Experience')\nplt.ylabel('Salary')\nplt.show()"}
{"nl": "Same Parity?", "code": "def parityAnalysis(num):\n  digit_sum = sum(int(i) for i in str(num))\n  return digit_sum%2 == num%2"}
{"nl": "Python Program to Copy a File", "code": "from shutil import copyfile\ncopyfile(\"/root/a.txt\", \"/root/b.txt\")"}
{"nl": "Multidimensional List Into Single Dimensional List", "code": "def flatten(lst):\n  return sum((flatten(l) for l in lst),[]) if type(lst)==list else [lst]"}
{"nl": "Implementing the game \"Scrabble Score\"", "code": "scores = {}\r\nfor k, v in {\r\n            \"AEIOULNRST\": 1,\r\n            \"DG\": 2,\r\n            \"BCMP\": 3,\r\n            \"FHVWY\": 4,\r\n            \"K\": 5,\r\n            \"JX\": 8,\r\n            \"QZ\": 10\r\n        }.items():\r\n    scores.update({x: v for x in k})\r\ndef score(word):\r\n    return sum([scores[char] for char in word.upper()])"}
{"nl": "Happy Numbers", "code": "def happy(n):\n  n = sum(int(i)**2 for i in str(n))\n  return True if n == 1 else False if n == 4 else happy(n)"}
{"nl": "Diamond Star Pattern in Python", "code": "# Python program to print diamond star pattern using for loop # take input n = 4 # printing pyramid for i in range(n): for j in range(n-i-1): # print spaces print(\"\", end=\" \") for j in range(2*i+1): # print stars print(\"*\", end=\"\") print() # printing downward pyramid for i in range(n-1): for j in range(i+1): # print spaces print(\"\", end=\" \") for j in range(2*(n-i-1)-1): # print stars print(\"*\", end=\"\") print()"}
{"nl": "An Absolute", "code": "def absolute(txt):\n    return txt.replace('a ','an absolute ').replace('A ','an absolute ').capitalize()"}
{"nl": "Specific Matrix question", "code": "# Python3 Code For A Boolean Matrix Question\r\nR = 3\r\nC = 4\r\n \r\ndef modifyMatrix(mat):\r\n    row = [0] * R\r\n    col = [0] * C\r\n     \r\n    # Initialize all values of row[] as 0\r\n    for i in range(0, R):\r\n        row[i] = 0\r\n         \r\n    # Initialize all values of col[] as 0\r\n    for i in range(0, C) :\r\n        col[i] = 0\r\n \r\n \r\n    # Store the rows and columns to be marked\r\n    # as 1 in row[] and col[] arrays respectively\r\n    for i in range(0, R) :\r\n         \r\n        for j in range(0, C) :\r\n            if (mat[i][j] == 1) :\r\n                row[i] = 1\r\n                col[j] = 1\r\n             \r\n    # Modify the input matrix mat[] using the\r\n    # above constructed row[] and col[] arrays\r\n    for i in range(0, R) :\r\n         \r\n        for j in range(0, C):\r\n            if ( row[i] == 1 or col[j] == 1 ) :\r\n                mat[i][j] = 1\r\n                 \r\n# A utility function to print a 2D matrix\r\ndef printMatrix(mat) :\r\n    for i in range(0, R):\r\n         \r\n        for j in range(0, C) :\r\n            print(mat[i][j], end = \" \")\r\n        print()\r\n         \r\n# Driver Code\r\nmat = [ [1, 0, 0, 1],\r\n        [0, 0, 1, 0],\r\n        [0, 0, 0, 0] ]\r\n \r\nprint(\"Input Matrix n\")\r\nprintMatrix(mat)\r\n \r\nmodifyMatrix(mat)\r\n \r\nprint(\"Matrix after modification n\")\r\nprintMatrix(mat)\r\n \r\n# This code is contributed by Nikita Tiwari."}
{"nl": "Python Get the Length of a Set\r\n", "code": "thisset = {\"apple\", \"banana\", \"cherry\"}\r\n\r\nprint(len(thisset))"}
{"nl": "Maximum spiral sum in Binary Tree", "code": "# Python3 Implementation to find the maximum Spiral Sum\n\n# Structure of a node in binary tree\nclass Node:\n\t\n\tdef __init__(self, data):\n\t\t\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# function to find the maximum sum contiguous subarray\n# implementing kadane's algorithm\ndef maxSum(Arr):\n\n\tcurrSum = maxSum = 0\n\tfor element in Arr:\n\t\tcurrSum = max(currSum + element, element)\n\t\tmaxSum = max(maxSum, currSum)\n\n\treturn maxSum\n\n# function to find maximum spiral sum\ndef maxSpiralSum(root):\n\n\t# if tree is empty\n\tif not root:\n\t\treturn 0\n\n\t# create two stacks to stopre alternative levels\n\tstack_s1 = [] # from levels right to left\n\tstack_s2 = [] # from levels left to right\n\n\t# store spiral order traversal in Arr\n\tArr = []\n\tstack_s1.append(root)\n\n\t# traversing tree in spiral form\n\t# until there are elements in any one\n\t# of the stack\n\twhile stack_s1 or stack_s2:\n\n\t\t# traverse current level from s1 and\n\t\t# push node of next level to s2\n\t\twhile stack_s1:\n\t\t\t\n\t\t\ttemp = stack_s1.pop()\n\n\t\t\t# append temp-> data to Arr\n\t\t\tArr.append(temp.data)\n\n\t\t\tif temp.right:\n\t\t\t\tstack_s2.append(temp.right)\n\t\t\tif temp.left:\n\t\t\t\tstack_s2.append(temp.left)\n\n\t\t# traverse current level from s2 and\n\t\t# push node of next level to s1\n\t\twhile stack_s2:\n\t\t\t\n\t\t\ttemp = stack_s2.pop()\n\n\t\t\t# append temp-> data to Arr\n\t\t\tArr.append(temp.data)\n\n\t\t\tif temp.left:\n\t\t\t\tstack_s1.append(temp.left)\n\t\t\tif temp.right:\n\t\t\t\tstack_s1.append(temp.right)\n\n\treturn maxSum(Arr)\n\n# Driver code\nif __name__ == \"__main__\":\n\n\troot = Node(-2)\n\troot.left = Node(-3)\n\troot.right = Node(4)\n\troot.left.left = Node(5)\n\troot.left.right = Node(1)\n\troot.right.left = Node(-2)\n\troot.right.right = Node(-1)\n\troot.left.left.left = Node(-3)\n\troot.right.right.right = Node(2)\n\n\tprint(\"Maximum Spiral Sum is : \", maxSpiralSum(root))\n\n# This code is contributed by\n# Mayank Chaudhary (chaudhary_19)\n"}
{"nl": "Coding Website Score Calculator", "code": "def score_calculator(e, m, h):\n  return \"invalid\" if min([e,m,h]) < 0 else e * 5 + m * 10 + h * 20"}
{"nl": "Star Ratings", "code": "def star_rating(lst):\n  x = sum(lst[i] * (i+1) for i in range(len(lst))) / sum(lst)\n  return \"[{:.2f}] {}\".format(x, \"*\" * int(round(x,0)))"}
{"nl": "Print X star pattern given the number of rows of the pattern", "code": "# Give the number of rows of the x pattern as static input and store it in a variable.\r\nxrows=10\r\n\r\n#Loop from 0 to the number of rows using For loop.\r\nfor m in range(0, xrows):\r\n    # Loop from 0 to the number of rows using another For loop(Inner For loop).\r\n    for n in range(0, xrows):\r\n        '''Check if the parent loop iterator value is equal to the inner loop \r\n        iterator value or if the inner loop iterator value is equal to the number\r\n        of rows-parent loop iterator value-1 using If conditional Statement.'''\r\n        if(m==n or n==xrows - 1 - m):\r\n          #Print the star character with space if the condition is true.\r\n          print('*',end=' ')\r\n        else:\r\n          #Else print space character.\r\n          print(' ',end=' ')\r\n     #Print the newline character after the end of the inner For loop.      \r\n    print()"}
{"nl": "Key - Mouse (Logic)", "code": "def KM(table):\n    c = round((float(table[\"Total\"][:-1]) - float(table[\"Difference\"][:-1])) / 2, )\n    table[\"Mouse\"] = \"{}$\".format(c)\n    return table"}
{"nl": "Convert \"Zero\" and \"One\" to \"1\" and \"0\"", "code": "def text_to_number_binary(txt):\n  s = ''.join('1' if t.lower()=='one' else '0' if t.lower()=='zero' else '' for   txt.split(' '))\n  return s[:(8*(len(s)//8))]"}
{"nl": "Construct Ancestor Matrix from a Given Binary Tree", "code": "# Python3 program to construct ancestor\r\n# matrix for given tree.\r\nsize = 6\r\n\r\nM = [[0 for j in range(size)]\r\n\t\tfor i in range(size)]\r\n\r\n# A binary tree node\r\nclass Node:\r\n\t\r\n\tdef __init__(self, data):\r\n\t\t\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\t\tself.data = data\r\n\t\t\r\n# Helper function to create a new node\r\ndef newnode(data):\r\n\r\n\ttemp = Node(data)\r\n\t\r\n\treturn temp\r\n\r\ndef printMatrix():\r\n\t\r\n\tfor i in range(size):\r\n\t\tfor j in range(size):\r\n\t\t\tprint(M[i][j], end = ' ')\r\n\t\t\r\n\t\tprint()\t\r\n\r\n# First PreOrder Traversal\r\ndef MatrixUtil(root, index):\r\n\t\r\n\tif (root == None):\r\n\t\treturn\r\n\t\r\n\tpreData = root.data\r\n\t\t\t\r\n\t# Since there is no ancestor for\r\n\t# root node, so we doesn't assign\r\n\t# it's value as 1\t\t\r\n\tif (index == -1):\r\n\t\tindex = root.data\r\n\telse:\r\n\t\tM[index][preData] = 1\r\n\t\r\n\tMatrixUtil(root.left, preData)\r\n\tMatrixUtil(root.right, preData)\r\n\r\ndef Matrix(root):\r\n\t\r\n\t# Call Func MatrixUtil\r\n\tMatrixUtil(root, -1)\r\n\t\r\n\t# Applying Transitive Closure\r\n\t# for the given Matrix\r\n\tfor i in range(size):\r\n\t\tfor j in range(size):\r\n\t\t\tfor k in range(size):\r\n\t\t\t\tM[j][k] = (M[j][k] or\r\n\t\t\t\t\t\t(M[j][i] and\r\n\t\t\t\t\t\tM[i][k]))\r\n\t\r\n\t# Printing Matrix\r\n\tprintMatrix()\r\n\r\n# Driver code\r\nif __name__==\"__main__\":\r\n\t\r\n\troot = newnode(5)\r\n\troot.left = newnode(1)\r\n\troot.right = newnode(2)\r\n\troot.left.left = newnode(0)\r\n\troot.left.right = newnode(4)\r\n\troot.right.left = newnode(3)\r\n\r\n\tMatrix(root)\r\n\t\r\n# This code is contributed by rutvik_56\r"}
{"nl": "Concatenate to Form Target List", "code": "def canConcatenate(lst, target):\n  return sorted(sum(lst,[])) == sorted(target)"}
{"nl": "Given a matrix, generate its upper triangular matrix and print it.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[5, 3, 2], [6, 1, 5], [4, 8, 2]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\nprint(\"The Upper Triangular matrix of the given matrix is :\")\r\n# To print all the elements of the given matrix.\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n is greater than m using the if conditional statement where n\r\n      # is the iterator value of the parent For loop and m is the iterator value of the\r\n      # inner For loop.\r\n        if n > m:\r\n          # If the statement is true, then print 0.\r\n            print(\"0 \", end=\"\")\r\n        else:\r\n          # Else Print the element of the matrix by printing gvnmatrix[n][m] value.\r\n            print(mtrx[n][m], end=\" \")\r\n    print()"}
{"nl": "Check Rational Number", "code": "from __future__ import division\nimport math\nclass Rational(object):\n    def __init__(self, numer, denom):\n        gcd = math.gcd(numer, denom)\n        self.numer = int(numer / gcd)\n        self.denom = int(denom / gcd)\n        if numer < 0 or denom < 0:\n            self.numer = -1 * abs(self.numer)\n            self.denom = abs(self.denom)\n            \n    def __eq__(self, other):\n        return self.numer == other.numer and self.denom == other.denom\n    def __repr__(self):\n        return '{}/{}'.format(self.numer, self.denom)\n    def __add__(self, other):\n        return Rational(self.numer*other.denom + self.denom*other.numer,\n                        self.denom * other.denom)\n    def __sub__(self, other):\n        return Rational(self.numer*other.denom - self.denom*other.numer,\n                        self.denom * other.denom)\n    def __mul__(self, other):\n        return Rational(self.numer*other.numer, self.denom * other.denom)\n    def __truediv__(self, other):\n        if (self.numer < 0 and other.numer < 0) or (self.numer > 0 and other.numer > 0):\n            return Rational(abs(self.numer*other.denom), abs(self.denom * other.numer))\n        else:\n            return Rational(-1*abs(self.numer*other.denom), abs(self.denom * other.numer))\n    def __abs__(self):\n        return Rational(abs(self.numer),abs(self.denom))\n    def __pow__(self, power):\n        if type(power) is int and power >= 0:\n            return Rational(self.numer ** power,self.denom ** power)\n        elif type(power) is int and power < 0:\n            return Rational(self.denom ** abs(power),self.numer ** abs(power))\n        else:\n            return self.numer ** power / self.denom ** power\n    def __rpow__(self, base):\n        return math.pow(base**self.numer, 1/self.denom)"}
{"nl": "Swapping Three Variables Without Using any Temporary Variable", "code": "# Give the first number as static input and store it in a variable.\r\nfst_numb = 30\r\n# Give the second number as static input and store it in another variable.\r\nscnd_numb = 45\r\n# Give the third number as static input and store it in another variable.\r\nthrd_numb = 21\r\nprint(\"The above given three numbers before swapping :\")\r\nprint(\"first number = \", fst_numb, \"second number = \",\r\n      scnd_numb, \"third number = \", thrd_numb)\r\n# Add first, second, and third numbers and assign the result to the first number.\r\nfst_numb = fst_numb + scnd_numb + thrd_numb\r\n# Add second, and third numbers and subtract the result from the given first number.\r\n# Assign the result to the second number.\r\nscnd_numb = fst_numb - (scnd_numb+thrd_numb)\r\n# Add second, and third numbers and subtract the result from the given first number.\r\n# Assign the result to the given third number.\r\nthrd_numb = fst_numb - (scnd_numb+thrd_numb)\r\n# Add second, and third numbers and subtract the result from the given first number.\r\n# Assign the result to the given first number.\r\nfst_numb = fst_numb - (scnd_numb+thrd_numb)\r\n# Print the given three numbers after swapping without using a temporary variable.\r\nprint(\"The above given three numbers after swapping without using temporary variable:\")\r\nprint(\"first number = \", fst_numb, \"second number = \",\r\n      scnd_numb, \"third number = \", thrd_numb)"}
{"nl": "N Tables + 1", "code": "def n_tables_plus_one(num):\n  return ','.join(str(num * n + 1) for n in range(1, 11))"}
{"nl": "find the maximum distance between two houses with different colors given an array of colors and number of houses", "code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans  = 0\n        for i, color in enumerate(colors):\n            if color != colors[0]: ans = max(ans, i)\n            if color != colors[-1]: ans = max(ans, len(colors) - 1 - i)\n        return ans"}
{"nl": "number of minimum operations to convert words", "code": "class Solution:\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        n = len(word1)\n        m = len(word2)\n        \n        # if one of the strings is empty\n        if n * m == 0:\n            return n + m\n        \n        # array to store the convertion history\n        d = [ [0] * (m + 1) for _ in range(n + 1)]\n        \n        # init boundaries\n        for i in range(n + 1):\n            d[i][0] = i\n        for j in range(m + 1):\n            d[0][j] = j\n        \n        # DP compute \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                left = d[i - 1][j] + 1\n                down = d[i][j - 1] + 1\n                left_down = d[i - 1][j - 1] \n                if word1[i - 1] != word2[j - 1]:\n                    left_down += 1\n                d[i][j] = min(left, down, left_down)\n        \n        return d[n][m]"}
{"nl": "Python Program to Convert Kilometers to Miles", "code": "# Taking kilometers input from the user\nkilometers = float(input(\"Enter value in kilometers: \"))\n\n# conversion factor\nconv_fac = 0.621371\n\n# calculate miles\nmiles = kilometers * conv_fac\nprint('%0.2f kilometers is equal to %0.2f miles' %(kilometers,miles))"}
{"nl": "process restricted friend requests given an array of restrictions and a number of people in a network", "code": "class UniSet:\n    def __init__(self, n):\n        self.uni = list(range(n))\n        self.rep = [1 << i for i in range(n)]\n        self.cnf = [0] * n\n    \n    def find(self, x):\n        if self.uni[x] != x: self.uni[x] = self.find(self.uni[x])\n        return self.uni[x]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def check_merge(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if self.cnf[x] & self.rep[y] | self.rep[x] & self.cnf[y]: return False\n        x, y = min(x, y), max(x, y)\n        self.uni[y] = x\n        self.rep[x] |= self.rep[y]\n        self.cnf[x] |= self.cnf[y]\n        return True\n\nclass Solution:\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n        uni = UniSet(n)\n        for x, y in restrictions:\n            uni.cnf[x] |= 1 << y\n            uni.cnf[y] |= 1 << x\n        return [uni.check_merge(x, y) for x, y in requests]"}
{"nl": "find the kth largest integer in an array", "code": "class Solution(object):\n    def kthLargestNumber(self, nums, k):\n        \"\"\"\n        :type nums: List[str]\n        :type k: int\n        :rtype: str\n        \"\"\"\n        nums.sort(reverse = True, key=lambda x:int(x))\n        return nums[k-1]"}
{"nl": "Generate a random Password with given conditions", "code": "import random\r\nimport string\r\n\r\ndef randomPassword():\r\n    randomSource = string.ascii_letters + string.digits + string.punctuation\r\n    password = random.sample(randomSource, 6)\r\n    password += random.sample(string.ascii_uppercase, 2)\r\n    password += random.choice(string.digits)\r\n    password += random.choice(string.punctuation)\r\n\r\n    passwordList = list(password)\r\n    random.SystemRandom().shuffle(passwordList)\r\n    password = ''.join(passwordList)\r\n    return password\r\n\r\nprint (\"Password is \", randomPassword())"}
{"nl": "Python Program to Print all Perfect Squares from a List using List Comprehension and Math Module", "code": "# Import the math module using the import statement.\n import math\n # Give the list as static input and store it in a variable.\n gvnlst = [19, 24, 25, 36, 81, 144, 600, 900,\n  225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n print('The given list is =', gvnlst)\n # Using List comprehension, floor(), and sqrt() functions\n # to check whether the element value of the list is a perfect square or not.\n # (An Element is said to be a perfect square if the floor value of the square root\n # of the number is equal to the sqrt of the number)\n prftsquareslist = [elemen for elemen in gvnlst if (\n  math.sqrt(elemen) == math.floor(math.sqrt(elemen)))]\n # Print the new list which contains only perfect squares of the original list.\n print('The perfect squares numbers of the given list is =', prftsquareslist)"}
{"nl": "Hamiltonian Cycle Finder", "code": "# Python program for solution of\n# hamiltonian cycle problem\n\nclass Graph():\n\tdef __init__(self, vertices):\n\t\tself.graph = [[0 for column in range(vertices)]\n\t\t\t\t\t\t\tfor row in range(vertices)]\n\t\tself.V = vertices\n\n\t''' Check if this vertex is an adjacent vertex\n\t\tof the previously added vertex and is not\n\t\tincluded in the path earlier '''\n\tdef isSafe(self, v, pos, path):\n\t\t# Check if current vertex and last vertex\n\t\t# in path are adjacent\n\t\tif self.graph[ path[pos-1] ][v] == 0:\n\t\t\treturn False\n\n\t\t# Check if current vertex not already in path\n\t\tfor vertex in path:\n\t\t\tif vertex == v:\n\t\t\t\treturn False\n\n\t\treturn True\n\n\t# A recursive utility function to solve\n\t# hamiltonian cycle problem\n\tdef hamCycleUtil(self, path, pos):\n\n\t\t# base case: if all vertices are\n\t\t# included in the path\n\t\tif pos == self.V:\n\t\t\t# Last vertex must be adjacent to the\n\t\t\t# first vertex in path to make a cycle\n\t\t\tif self.graph[ path[pos-1] ][ path[0] ] == 1:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\n\t\t# Try different vertices as a next candidate\n\t\t# in Hamiltonian Cycle. We don't try for 0 as\n\t\t# we included 0 as starting point in hamCycle()\n\t\tfor v in range(1,self.V):\n\n\t\t\tif self.isSafe(v, pos, path) == True:\n\n\t\t\t\tpath[pos] = v\n\n\t\t\t\tif self.hamCycleUtil(path, pos+1) == True:\n\t\t\t\t\treturn True\n\n\t\t\t\t# Remove current vertex if it doesn't\n\t\t\t\t# lead to a solution\n\t\t\t\tpath[pos] = -1\n\n\t\treturn False\n\n\tdef hamCycle(self):\n\t\tpath = [-1] * self.V\n\n\t\t''' Let us put vertex 0 as the first vertex\n\t\t\tin the path. If there is a Hamiltonian Cycle,\n\t\t\tthen the path can be started from any point\n\t\t\tof the cycle as the graph is undirected '''\n\t\tpath[0] = 0\n\n\t\tif self.hamCycleUtil(path,1) == False:\n\t\t\tprint (\"Solution does not exist\\n\")\n\t\t\treturn False\n\n\t\tself.printSolution(path)\n\t\treturn True\n\n\tdef printSolution(self, path):\n\t\tprint (\"Solution Exists: Following\",\n\t\t\t\t\"is one Hamiltonian Cycle\")\n\t\tfor vertex in path:\n\t\t\tprint (vertex, end = \" \")\n\t\tprint (path[0], \"\\n\")\n\n# Driver Code\n\n''' Let us create the following graph\n\t(0)--(1)--(2)\n\t| / \\ |\n\t| / \\ |\n\t| /\t \\ |\n\t(3)-------(4) '''\ng1 = Graph(5)\ng1.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1],\n\t\t\t[0, 1, 0, 0, 1,],[1, 1, 0, 0, 1],\n\t\t\t[0, 1, 1, 1, 0], ]\n\n# Print the solution\ng1.hamCycle();\n\n''' Let us create the following graph\n\t(0)--(1)--(2)\n\t| / \\ |\n\t| / \\ |\n\t| /\t \\ |\n\t(3)\t (4) '''\ng2 = Graph(5)\ng2.graph = [ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1],\n\t\t[0, 1, 0, 0, 1,], [1, 1, 0, 0, 0],\n\t\t[0, 1, 1, 0, 0], ]\n\n# Print the solution\ng2.hamCycle();\n\n# This code is contributed by Divyanshu Mehta"}
{"nl": "Create dictionary from given string with first characters as keys and words beginning from that character as values", "code": "# Scanning the given string\ngiven_string = input(\"Enter some random string separated by spaces = \")\n# Split the given string into words using split() function\n# Convert this into list using list() function.\nlistString = given_string.split()\n# Declare a dictionary which is empty using {} or dict()\nresultdict = {}\n# Traverse the list String\nfor stringword in listString:\n  # checking if the first character of the word exists in dictionary resultdict keys or not\n    if(stringword[0] not in resultdict.keys()):\n        resultdict[stringword[0]] = []\n        # adding this character to the resultdict\n        resultdict[stringword[0]].append(stringword)\n    else:\n      # If it is present, add the word to the associated sublist as the value.\n        if(stringword not in resultdict[stringword[0]]):\n            resultdict[stringword[0]].append(stringword)\nfor key, value in resultdict.items():\n    print(key, \":::\", value)"}
{"nl": "Is the Input Factorial of an Integer?", "code": "def is_factorial(n):\n  i,f = 1,1\n  while f < n:\n    i+=1\n    f*= i\n  return n == f"}
{"nl": "Implement Floyd-Warshall Algorithm", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def __len__(self):\n        return len(self.vertices)\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef floyd_warshall(g):\n    \"\"\"Return dictionaries distance and next_v.\n\u00a0\n    distance[u][v] is the shortest distance from vertex u to v.\n    next_v[u][v] is the next vertex after vertex v in the shortest path from u\n    to v. It is None if there is no path between them. next_v[u][u] should be\n    None for all u.\n\u00a0\n    g is a Graph object which can have negative edge weights.\n    \"\"\"\n    distance = {v:dict.fromkeys(g, float('inf')) for v in g}\n    next_v = {v:dict.fromkeys(g, None) for v in g}\n\u00a0\n    for v in g:\n        for n in v.get_neighbours():\n            distance[v][n] = v.get_weight(n)\n            next_v[v][n] = n\n\u00a0\n    for v in g:\n         distance[v][v] = 0\n         next_v[v][v] = None\n\u00a0\n    for p in g: \n        for v in g:\n            for w in g:\n                if distance[v][w] > distance[v][p] + distance[p][w]:\n                    distance[v][w] = distance[v][p] + distance[p][w]\n                    next_v[v][w] = next_v[v][p]\n\u00a0\n    return distance, next_v\n\u00a0\n\u00a0\ndef print_path(next_v, u, v):\n    \"\"\"Print shortest path from vertex u to v.\n\u00a0\n    next_v is a dictionary where next_v[u][v] is the next vertex after vertex u\n    in the shortest path from u to v. It is None if there is no path between\n    them. next_v[u][u] should be None for all u.\n\u00a0\n    u and v are Vertex objects.\n    \"\"\"\n    p = u\n    while (next_v[p][v]):\n        print('{} -> '.format(p.get_key()), end='')\n        p = next_v[p][v]\n    print('{} '.format(v.get_key()), end='')\n\u00a0\n\u00a0\ng = Graph()\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('floyd-warshall')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'floyd-warshall':\n        distance, next_v = floyd_warshall(g)\n        print('Shortest distances:')\n        for start in g:\n            for end in g:\n                if next_v[start][end]:\n                    print('From {} to {}: '.format(start.get_key(),\n                                                    end.get_key()),\n                            end = '')\n                    print_path(next_v, start, end)\n                    print('(distance {})'.format(distance[start][end]))\n\u00a0\n    elif operation == 'display':\n        print('Vertices: ', end='')\n        for v in g:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in g:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "C++ Program to Print Identity Matrix", "code": "#include \n using namespace std;\n // function which prints the identity matrix of the given\n // dimension\n int printIdentityMat(int dimen)\n { // taking two variables rownum and colnum of integer type\n  int rownum, colnum;\n  // using nested for loops\n  for (rownum = 0; rownum < dimen; rownum++) {\n  for (colnum = 0; colnum < dimen; colnum++) {\n  // if the rownum is equal to colnum then print 1\n  if (rownum == colnum)\n  cout << 1 << \" \";\n  // else print 0\n  else\n  cout << 0 << \" \";\n  }\n  cout << endl;\n  }\n  return 0;\n }\n // Driver Code\n int main()\n { // given dimensions\n  int dimensions = 10;\n  // passing the given dimension to printIdentityMat\n  // function to print identity matrix\n  printIdentityMat(dimensions);\n  return 0;\n }"}
{"nl": "Minimum Possible value of |ai + aj \u2013 k| for given array and k.", "code": "# Python3 program to find number of pairs\n# and minimal possible value\n\n# function for finding pairs and min value\ndef pairs(arr, n, k):\n\t\n\t# initialize smallest and count\n\tsmallest = 999999999999\n\tcount = 0\n\n\t# iterate over all pairs\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\t\n\t\t\t# is abs value is smaller than smallest\n\t\t\t# update smallest and reset count to 1\n\t\t\tif abs(arr[i] + arr[j] - k) < smallest:\n\t\t\t\tsmallest = abs(arr[i] + arr[j] - k)\n\t\t\t\tcount = 1\n\n\t\t\t# if abs value is equal to smallest\n\t\t\t# increment count value\n\t\t\telif abs(arr[i] + arr[j] - k) == smallest:\n\t\t\t\tcount += 1\n\n\t# print result\n\tprint(\"Minimal Value = \", smallest)\n\tprint(\"Total Pairs = \", count)\n\n# Driver Code\nif __name__ == '__main__':\n\tarr = [3, 5, 7, 5, 1, 9, 9]\n\tk = 12\n\tn = len(arr)\n\tpairs(arr, n, k)\n\t\n# This code is contributed by PranchalK"}
{"nl": "Automorphic Numbers", "code": "def is_automorphic(n):\n  return str(n**2).endswith(str(n))"}
{"nl": "Global Variables", "code": "x = \"awesome\"\r\n\r\ndef myfunc():\r\n  print(\"Python is \" + x)\r\n\r\nmyfunc()"}
{"nl": "The Million Dollar Fence", "code": "def construct_fence(p):\n  p = int(p.replace(',', '')[1:])\n  return 'H' * (1000000//p)"}
{"nl": "Unique cells in a binary matrix", "code": "# Python3 program to count unique cells in\n# a matrix\n\u00a0\nMAX = 100\n\u00a0\n# Returns true if mat[i][j] is unique\ndef isUnique(mat, i, j, n, m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# checking in row calculating sumrow\n\u00a0\u00a0\u00a0\u00a0# will be moving column wise\n\u00a0\u00a0\u00a0\u00a0sumrow = 0\n\u00a0\u00a0\u00a0\u00a0for k in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumrow += mat[i][k]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sumrow > 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# checking in column calculating sumcol\n\u00a0\u00a0\u00a0\u00a0# will be moving row wise\n\u00a0\u00a0\u00a0\u00a0sumcol = 0\n\u00a0\u00a0\u00a0\u00a0for k in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumcol += mat[k][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sumcol > 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\ndef countUnique(mat, n, m):\n\u00a0\u00a0\u00a0\u00a0uniquecount = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] and isUnique(mat, i, j, n, m)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0uniquecount += 1\n\u00a0\u00a0\u00a0\u00a0return uniquecount\n\u00a0\n# Driver code\n\u00a0\nmat = [[0, 1, 0, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 0, 1]]\nprint(countUnique(mat, 3, 4))\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "SVM Hyperparameter Tuning using GridSearchCV", "code": "import pandas as pd\nimport numpy as np\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.datasets import load_breast_cancer\nfrom sklearn.svm import SVC\n\ncancer = load_breast_cancer()\n\n# The data set is presented in a dictionary form:\nprint(cancer.keys())\ndf_feat = pd.DataFrame(cancer['data'],\n\t\t\t\t\tcolumns = cancer['feature_names'])\n\n# cancer column is our target\ndf_target = pd.DataFrame(cancer['target'],\n\t\t\t\t\tcolumns =['Cancer'])\n\nprint(\"Feature Variables: \")\nprint(df_feat.info())\nprint(\"Dataframe looks like : \")\nprint(df_feat.head())\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(\n\t\t\t\t\t\tdf_feat, np.ravel(df_target),\n\t\t\t\ttest_size = 0.30, random_state = 101)\n# train the model on train set\nmodel = SVC()\nmodel.fit(X_train, y_train)\n\n# print prediction results\npredictions = model.predict(X_test)\nprint(classification_report(y_test, predictions))\nfrom sklearn.model_selection import GridSearchCV\n\n# defining parameter range\nparam_grid = {'C': [0.1, 1, 10, 100, 1000],\n\t\t\t'gamma': [1, 0.1, 0.01, 0.001, 0.0001],\n\t\t\t'kernel': ['rbf']}\n\ngrid = GridSearchCV(SVC(), param_grid, refit = True, verbose = 3)\n\n# fitting the model for grid search\ngrid.fit(X_train, y_train)\n# print best parameter after tuning\nprint(grid.best_params_)\n\n# print how our model looks after hyper-parameter tuning\nprint(grid.best_estimator_)\ngrid_predictions = grid.predict(X_test)\n\n# print classification report\nprint(classification_report(y_test, grid_predictions))\n"}
{"nl": "Count sub-matrices having sum divisible \u2018k\u2019", "code": "# Python implementation to\n# count sub-matrices having\n# sum divisible by the\n# value 'k'\n\u00a0\n# function to count all\n# sub-arrays divisible by k\ndef subCount(arr, n, k) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# create auxiliary hash\n\u00a0\u00a0\u00a0\u00a0# array to count frequency\n\u00a0\u00a0\u00a0\u00a0# of remainders\n\u00a0\u00a0\u00a0\u00a0mod = [0] * k;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse original array\n\u00a0\u00a0\u00a0\u00a0# and compute cumulative\n\u00a0\u00a0\u00a0\u00a0# sum take remainder of\n\u00a0\u00a0\u00a0\u00a0# this current cumulative\n\u00a0\u00a0\u00a0\u00a0# sum and increase count\n\u00a0\u00a0\u00a0\u00a0# by 1 for this remainder\n\u00a0\u00a0\u00a0\u00a0# in mod array\n\u00a0\u00a0\u00a0\u00a0cumSum = 0;\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cumSum = cumSum + arr[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as the sum can be\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# negative, taking\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# modulo twice\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mod[((cumSum % k) + k) % k] = mod[\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((cumSum % k) + k) % k] + 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0result = 0; # Initialize result\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse mod\n\u00a0\u00a0\u00a0\u00a0for i in range(0, k) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If there are more than\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one prefix subarrays\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# with a particular mod value.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mod[i] > 1) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result + int((mod[i] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(mod[i] - 1)) / 2);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# add the subarrays starting\n\u00a0\u00a0\u00a0\u00a0# from the arr[i] which are\n\u00a0\u00a0\u00a0\u00a0# divisible by k itself\n\u00a0\u00a0\u00a0\u00a0result = result + mod[0];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return result;\n\u00a0\n# function to count all\n# sub-matrices having sum\n# divisible by the value 'k'\ndef countSubmatrix(mat, n, k) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Variable to store\n\u00a0\u00a0\u00a0\u00a0# the final output\n\u00a0\u00a0\u00a0\u00a0tot_count = 0;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0temp = [0] * n;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Set the left column\n\u00a0\u00a0\u00a0\u00a0for left in range(0, n - 1) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Set the right column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for the left column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# set by outer loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for right in range(left, n) :\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum between\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current left and right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for every row 'i'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(0, n) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp[i] = (temp[i] +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][right]);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Count number of subarrays\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in temp having sum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# divisible by 'k' and then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# add it to 'tot_count'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tot_count = (tot_count +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subCount(temp, n, k));\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# required count of\n\u00a0\u00a0\u00a0\u00a0# sub-matrices having\n\u00a0\u00a0\u00a0\u00a0# sum divisible by 'k'\n\u00a0\u00a0\u00a0\u00a0return tot_count;\n\u00a0\n# Driver Code\nmat = [[5, -1, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[-2, 3, 8],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[7, 4, -9]];\nn = 3;\nk = 4;\nprint (\"Count = {}\" . format(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0countSubmatrix(mat, n, k)));\n\u00a0\n# This code is contributed by\n# Manish Shaw(manishshaw1)\n"}
{"nl": "Program to Interchange Diagonals of Matrix", "code": "# Python program to interchange\n# the diagonals of matrix\nN = 3;\n\u00a0\n# Function to interchange diagonals\ndef interchangeDiagonals(array):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# swap elements of diagonal\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i != N / 2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = array[i][i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0array[i][i] = array[i][N - i - 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0array[i][N - i - 1] = temp;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(array[i][j], end = \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print();\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0array = [ 4, 5, 6 ],[ 1, 2, 3 ],[ 7, 8, 9 ];\n\u00a0\u00a0\u00a0\u00a0interchangeDiagonals(array);\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by Rajput-Ji\n"}
{"nl": "Python math.erfc() Method", "code": "# Import math Library\r\nimport math\r\n\r\n# Print complementary error function for different numbers\r\nprint (math.erfc(0.67))\r\nprint (math.erfc(1.34))\r\nprint (math.erfc(-6))"}
{"nl": "Python math.acosh() Method", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the inverse hyperbolic cosine of different numbers\r\nprint (math.acosh(7))\r\nprint (math.acosh(56))\r\nprint (math.acosh(2.45))\r\nprint (math.acosh(1))"}
{"nl": "Format III: Keyword Arguments", "code": "template = \"My {0} is {me}. His {0} is {him}.\""}
{"nl": "Space optimization using bit manipulations", "code": "# Python3 code to for marking multiples\r\nimport math\r\n\r\n# index >> 5 corresponds to dividing index by 32\r\n# index & 31 corresponds to modulo operation of\r\n# index by 32\r\n\r\n# Function to check value of bit position whether\r\n# it is zero or one\r\ndef checkbit( array, index):\r\n\treturn array[index >> 5] & (1 << (index & 31))\r\n\r\n# Sets value of bit for corresponding index\r\ndef setbit( array, index):\r\n\tarray[index >> 5] |= (1 << (index & 31))\r\n\r\n# Driver code\r\na = 2\r\nb = 10\r\nsize = abs(b - a)\r\n\r\n# Size that will be used is actual_size/32\r\n# ceil is used to initialize the array with\r\n# positive number\r\nsize = math.ceil(size / 32)\r\n\t\r\n# Array is dynamically initialized as\r\n# we are calculating size at run time\r\narray = [0 for i in range(size)]\r\n\r\n# Iterate through every index from a to b and\r\n# call setbit() if it is a multiple of 2 or 5\r\nfor i in range(a, b + 1):\r\n\tif (i % 2 == 0 or i % 5 == 0):\r\n\t\tsetbit(array, i - a)\r\n\r\nprint(\"MULTIPLES of 2 and 5:\")\r\nfor i in range(a, b + 1):\r\n\tif (checkbit(array, i - a)):\r\n\t\tprint(i, end = \" \")\r\n\r\n# This code is contributed by rohitsingh07052\r"}
{"nl": "find the minimun non-zero product of an array of elements", "code": "class Solution:\n    def minNonZeroProduct(self, p: int) -> int:\n        x = (1 << p) - 1\n        return pow(x-1, (x-1)//2, 1_000_000_007) * x % 1_000_000_007"}
{"nl": "Write a list content to a file", "code": "# Give the list as static input and store it in a variable.\ngvn_lst = ['hello', 'this', 'is', 'Btechgeeks', 'good morning']\n# Make a single variable to store the path of the file. This is a constant value. \n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\nwith open(givenFilename, 'w') as givenfilecontent:\n  # Iterate in the above given list using the for loop\n  for itr in gvn_lst:\n  # Write the iterator value(list elements) into the file using the write() function\n  givenfilecontent.write(\"%s\\n\" % itr)\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nfilecontent = open(\"samplefile.txt\")\n# Read the above file using the read() function(get the content) and print it.\nprint(filecontent.read())"}
{"nl": "Anagram Substring Search", "code": "# Python program to search all\r\n# anagrams of a pattern in a text\r\n \r\nMAX=256\r\n \r\n# This function returns true\r\n# if contents of arr1[] and arr2[]\r\n# are same, otherwise false.\r\ndef compare(arr1, arr2):\r\n    for i in range(MAX):\r\n        if arr1[i] != arr2[i]:\r\n            return False\r\n    return True\r\n     \r\n# This function search for all\r\n# permutations of pat[] in txt[] \r\ndef search(pat, txt):\r\n \r\n    M = len(pat)\r\n    N = len(txt)\r\n \r\n    # countP[]:  Store count of\r\n    # all characters of pattern\r\n    # countTW[]: Store count of\r\n    # current window of text\r\n    countP = [0]*MAX\r\n \r\n    countTW = [0]*MAX\r\n \r\n    for i in range(M):\r\n        (countP[ord(pat[i]) ]) += 1\r\n        (countTW[ord(txt[i]) ]) += 1\r\n \r\n    # Traverse through remaining\r\n    # characters of pattern\r\n    for i in range(M,N):\r\n \r\n        # Compare counts of current\r\n        # window of text with\r\n        # counts of pattern[]\r\n        if compare(countP, countTW):\r\n            print(\"Found at Index\", (i-M))\r\n \r\n        # Add current character to current window\r\n        (countTW[ ord(txt[i]) ]) += 1\r\n \r\n        # Remove the first character of previous window\r\n        (countTW[ ord(txt[i-M]) ]) -= 1\r\n     \r\n    # Check for the last window in text   \r\n    if compare(countP, countTW):\r\n        print(\"Found at Index\", N-M)\r\n         \r\n# Driver program to test above function      \r\ntxt = \"BACDGABCDA\"\r\npat = \"ABCD\"      \r\nsearch(pat, txt)  \r\n \r\n# This code is contributed\r\n# by Upendra Singh Bartwal"}
{"nl": "Lexicographically smallest string after applying operations", "code": "def findLexSmallestString(self, s: str, a: int, b: int) -> str:\n  \n  def dfs(s: str) -> str:\n  if s not in seen:\n  seen.add(s)\n  addA = list(s)\n  for i, c in enumerate(addA):\n  if i % 2 == 1:\n  addA[i] = str((int(c) + a) % 10)\n  return min(s, dfs(''.join(addA)), dfs(s[b :] + s[: b]))\n  return s  \n  \n  seen = set()\n  return dfs(s)"}
{"nl": "Identical Sublists", "code": "def count_identical(lst):\n  return len([c for c in lst if len(set(c))==1])"}
{"nl": "3n + 1 Problem (Collatz Conjecture)", "code": "def steps(x, count = 0):\n    while x > 1:\n        count += 1\n        if x % 2:\n            x = 3*x +1\n        else:\n            x //= 2\n    return count\n            def collatz(a, b):\n    return \"a\" if steps(a) < steps(b) else \"b\""}
{"nl": "Python statistics.mean() Method\r\n\r\n", "code": "# Import statistics Library\r\nimport statistics\r\n\r\n# Calculate average values\r\nprint(statistics.mean([1, 3, 5, 7, 9, 11, 13]))\r\nprint(statistics.mean([1, 3, 5, 7, 9, 11]))\r\nprint(statistics.mean([-11, 5.5, -3.4, 7.1, -9, 22]))"}
{"nl": "Find an Anagram of a String in Another String", "code": "from itertools import *\r\ndef ana_str_str(needle, haystack):\r\n  return any(''.join(p) in haystack for p in permutations(needle))"}
{"nl": "Python Program to Add Two Matrices", "code": "X = [[1,2,3],  \n       [4,5,6],  \n       [7,8,9]]  \n  \nY = [[10,11,12],  \n       [13,14,15],  \n       [16,17,18]]  \n  \nResult = [[0,0,0],  \n                [0,0,0],  \n                [0,0,0]]  \n# iterate through rows  \nfor i in range(len(X)):  \n   # iterate through columns  \n   for j in range(len(X[0])):  \n       result[i][j] = X[i][j] + Y[i][j]  \nfor r in result:  \n   print(r)  "}
{"nl": "Check if there is a path from the upper-left cell to the bottom-right cell", "code": "def hasValidPath(self, A):\n  m, n = len(A), len(A[0])\n  uf = {(i, j): (i, j) for i in xrange(-1, m * 2) for j in xrange(-1, n * 2)}\n\n  def find(x):\n  if uf[x] != x:\n  uf[x] = find(uf[x])\n  return uf[x]\n\n  def merge(i, j, di, dj):\n  uf[find((i, j))] = find((i + di, j + dj))\n\n  for i in xrange(m):\n  for j in xrange(n):\n  if A[i][j] in [2, 5, 6]: merge(i * 2, j * 2, -1, 0)\n  if A[i][j] in [1, 3, 5]: merge(i * 2, j * 2, 0, -1)\n  if A[i][j] in [2, 3, 4]: merge(i * 2, j * 2, 1, 0)\n  if A[i][j] in [1, 4, 6]: merge(i * 2, j * 2, 0, 1)\n  return find((0, 0)) == find((m * 2 - 2, n * 2 - 2))"}
{"nl": "Inclusive List Ranges", "code": "def inclusive_list(startNum, endNum):\n  return list(range(startNum, endNum+1)) or [startNum]"}
{"nl": "Find ugly numbers ", "code": "# Python program to find n'th Ugly number\n\n# Function to get the nth ugly number\n\n\ndef getNthUglyNo(n):\n\n\tugly = [0] * n # To store ugly numbers\n\n\t# 1 is the first ugly number\n\tugly[0] = 1\n\n\t# i2, i3, i5 will indicate indices for\n\t# 2,3,5 respectively\n\ti2 = i3 = i5 = 0\n\n\t# Set initial multiple value\n\tnext_multiple_of_2 = 2\n\tnext_multiple_of_3 = 3\n\tnext_multiple_of_5 = 5\n\n\t# Start loop to find value from\n\t# ugly[1] to ugly[n]\n\tfor l in range(1, n):\n\n\t\t# Choose the min value of all\n\t\t# available multiples\n\t\tugly[l] = min(next_multiple_of_2,\n\t\t\t\t\tnext_multiple_of_3,\n\t\t\t\t\tnext_multiple_of_5)\n\n\t\t# Increment the value of index accordingly\n\t\tif ugly[l] == next_multiple_of_2:\n\t\t\ti2 += 1\n\t\t\tnext_multiple_of_2 = ugly[i2] * 2\n\n\t\tif ugly[l] == next_multiple_of_3:\n\t\t\ti3 += 1\n\t\t\tnext_multiple_of_3 = ugly[i3] * 3\n\n\t\tif ugly[l] == next_multiple_of_5:\n\t\t\ti5 += 1\n\t\t\tnext_multiple_of_5 = ugly[i5] * 5\n\n\t# Return ugly[n] value\n\treturn ugly[-1]\n\n# Driver Code\ndef main():\n\n\tn = 150\n\n\tprint getNthUglyNo(n)\n\n\nif __name__ == '__main__':\n\tmain()\n\n# This code is contributed by Neelam Yadav"}
{"nl": "Efficient way to multiply with 7", "code": "# Python program to multiply any\n# positive number to 7\n\n# Function to multiply any number with 7\ndef multiplyBySeven(n):\n\n\t# Note the inner bracket here.\n\t# This is needed because\n\t# precedence of '-' operator is\n\t# higher than '<<'\n\treturn ((n << 3) - n)\n\n# Driver code\nn = 4\nprint(multiplyBySeven(n))\n\n# This code is contributed by Danish Raza\n"}
{"nl": "Finding missing number in an array", "code": "# getMissingNo takes list as argument\ndef getMissingNo(A):\n\tn = len(A)\n\ttotal = (n + 1)*(n + 2)/2\n\tsum_of_A = sum(A)\n\treturn total - sum_of_A\n\n\n# Driver program to test the above function\nA = [1, 2, 4, 5, 6]\nmiss = getMissingNo(A)\nprint(miss)\n# This code is contributed by Pratik Chhajer"}
{"nl": "QuickSort on Doubly Linked List", "code": "# A Python program to sort a linked list using Quicksort\nhead = None\n\n# a node of the doubly linked list\nclass Node:\n\tdef __init__(self, d):\n\t\tself.data = d\n\t\tself.next = None\n\t\tself.prev = None\n\n# A utility function to find last node of linked list\ndef lastNode(node):\n\twhile(node.next != None):\n\t\t\tnode = node.next;\n\treturn node;\n\n# Considers last element as pivot, places the pivot element at its\n# correct position in sorted array, and places all smaller (smaller than\n# pivot) to left of pivot and all greater elements to right of pivot\ndef partition(l, h):\n\n\t# set pivot as h element\n\t\tx = h.data;\n\t\t\n\t\t# similar to i = l-1 for array implementation\n\t\ti = l.prev;\n\t\t\n\t\tj = l\n\t\t\n\t\t# Similar to \"for (int j = l; j <= h- 1; j++)\"\n\t\twhile(j != h):\n\t\t\tif(j.data <= x):\n\t\t\t\n\t\t\t\t# Similar to i++ for array\n\t\t\t\ti = l if(i == None) else i.next;\n\n\t\t\t\ttemp = i.data;\n\t\t\t\ti.data = j.data;\n\t\t\t\tj.data = temp;\n\t\t\tj = j.next\n\t\t\t\t\t\t\n\t\ti = l if (i == None) else i.next; # Similar to i++\n\t\ttemp = i.data;\n\t\ti.data = h.data;\n\t\th.data = temp;\n\t\treturn i;\n\n# A recursive implementation of quicksort for linked list\ndef _quickSort(l,h):\n\tif(h != None and l != h and l != h.next):\n\t\t\ttemp = partition(l, h);\n\t\t\t_quickSort(l,temp.prev);\n\t\t\t_quickSort(temp.next, h);\n\t\t\n# The main function to sort a linked list. It mainly calls _quickSort()\ndef quickSort(node):\n\n\t# Find last node\n\t\thead = lastNode(node);\n\t\t\n\t\t# Call the recursive QuickSort\n\t\t_quickSort(node,head);\n\n# A utility function to print contents of arr\ndef printList(head):\n\twhile(head != None):\n\t\t\tprint(head.data, end=\" \");\n\t\t\thead = head.next;\n\t\t\n# Function to insert a node at the beginning of the Doubly Linked List\ndef push(new_Data):\n\tglobal head;\n\tnew_Node = Node(new_Data);\t # allocate node\n\t\t\n\t# if head is null, head = new_Node\n\tif(head == None):\n\t\thead = new_Node;\n\t\treturn;\n\t\n\t# link the old list off the new node\n\tnew_Node.next = head;\n\t\t\n\t# change prev of head node to new node\n\thead.prev = new_Node;\n\t\t\n\t# since we are adding at the beginning, prev is always NULL\n\tnew_Node.prev = None;\n\t\t\n\t# move the head to point to the new node\n\thead = new_Node;\n\n# Driver program to test above function\npush(5);\npush(20);\npush(4);\npush(3);\npush(30);\n\n\nprint(\"Linked List before sorting \");\nprintList(head);\nprint(\"\\nLinked List after sorting\");\nquickSort(head);\nprintList(head);\n\n# This code is contributed by _saurabh_jaiswal"}
{"nl": "integer to roman", "code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        thousands = [\"\", \"M\", \"MM\", \"MMM\"]\n        hundreds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        ones = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n        return (thousands[num // 1000] + hundreds[num % 1000 // 100] \n               + tens[num % 100 // 10] + ones[num % 10])"}
{"nl": "Python Program for Selection Sort", "code": "# function which implements the selection_sort algorithm for givenlist\n \n def selectionSort(givenlist):\n \n  length = len(givenlist)\n \n  for i in range(length):\n \n  # To begin, consider the first element in the unsorted section to be the smallest.\n \n  minValue = i\n \n \n \n  for j in range(i+1, length):\n \n  if (givenlist[j] < givenlist[minValue]):\n \n  # If a smaller element is identified, update the position\n \n  # of the minimum element.\n \n  minValue = j\n \n \n \n  # Replace the smallest(minValue) element with the first element\n \n  # of the unsorted portion.\n \n  givenlist[i], givenlist[minValue] = givenlist[minValue], givenlist[i]\n \n \n \n \n \n # given list\n \n givenlist = [\"hello\", \"this\", \"is\", \"BTechGeeeks\", \"python\", \"new\", \"online\",\n \n  \"platform\", \"for\", \"all\", \"students\", \"who\", \"are\", \"excited\", \"about\", \"coding\"]\n \n # printing the list before sorting\n \n print(\"printing the list before sorting :\")\n \n for i in givenlist:\n \n  print(i, end=\" \")\n \n print()\n \n # passing this given list to selectionSort function which sorts the given list\n \n selectionSort(givenlist)\n \n # printing the list after sorting\n \n print(\"printing the list after sorting :\")\n \n for i in givenlist:\n \n  print(i, end=\" \")"}
{"nl": "Minimal VI: Ternary Operator", "code": "def are_true(a, b):\n  return 'both' if a and b else 'first' if a else 'second' if b else 'neither'"}
{"nl": "sum of three numbers equal to 0", "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res, dups = set(), set()\n        seen = {}\n        for i, val1 in enumerate(nums):\n            if val1 not in dups:\n                dups.add(val1)\n                for j, val2 in enumerate(nums[i+1:]):\n                    complement = -val1 - val2\n                    if complement in seen and seen[complement] == i:\n                        res.add(tuple(sorted((val1, val2, complement))))\n                    seen[val2] = i\n        return res"}
{"nl": "All About Strings", "code": "def all_about_strings(txt):\n  return [\n    len(txt),\n    txt[0],\n    txt[-1],\n    txt[(len(txt)-1)//2:(len(txt)+2)//2],\n    \"@ index {}\".format(txt.index(txt[1], 2)) if txt[1] in txt[2:] else \"not found\"\n  ]"}
{"nl": "Pairwise swap elements of a given linked list", "code": "# Python program to swap the elements of linked list pairwise\n\n# Node class\n\n\nclass Node:\n\n\t# Constructor to initialize the node object\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\n\nclass LinkedList:\n\n\t# Function to initialize head\n\tdef __init__(self):\n\t\tself.head = None\n\n\t# Function to pairwise swap elements of a linked list\n\tdef pairwiseSwap(self):\n\t\ttemp = self.head\n\n\t\t# There are no nodes in linked list\n\t\tif temp is None:\n\t\t\treturn\n\n\t\t# Traverse furthethr only if there are at least two\n\t\t# left\n\t\twhile(temp and temp.next):\n\n\t\t\t# If both nodes are same,\n\t\t\t# no need to swap data\n\t\t\tif(temp.data != temp.next.data):\n\n\t\t\t\t# Swap data of node with its next node's data\n\t\t\t\ttemp.data, temp.next.data = temp.next.data, temp.data\n\n\t\t\t# Move temp by 2 to the next pair\n\t\t\ttemp = temp.next.next\n\n\t# Function to insert a new node at the beginning\n\tdef push(self, new_data):\n\t\tnew_node = Node(new_data)\n\t\tnew_node.next = self.head\n\t\tself.head = new_node\n\n\t# Utility function to print the linked LinkedList\n\tdef printList(self):\n\t\ttemp = self.head\n\t\twhile(temp):\n\t\t\tprint temp.data,\n\t\t\ttemp = temp.next\n\n\n# Driver program\nllist = LinkedList()\nllist.push(5)\nllist.push(4)\nllist.push(3)\nllist.push(2)\nllist.push(1)\n\nprint \"Linked list before calling pairWiseSwap() \"\nllist.printList()\n\nllist.pairwiseSwap()\n\nprint \"\\nLinked list after calling pairWiseSwap()\"\nllist.printList()\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "given an array of product quantities, find the minimized maximum of products distributed to any store", "code": "class Solution:\n    def minimizedMaximum(self, n: int, nums: List[int]) -> int:\n        lo, hi = 1, max(nums)\n        while(lo<hi):\n            mid = (lo+hi)//2\n            count = sum([ceil(k/mid) for k in nums])\n            if count > n:\n                lo = mid+1\n            else:\n                hi = mid\n        return lo"}
{"nl": "Check given array of size n can represent BST of n levels or not", "code": "# Python program to Check given array\n# can represent BST or not\n\u00a0\n# A binary tree node has data,\n# left child and right child\nclass newNode():\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# To create a Tree with n levels. We always\n# insert new node to left if it is less than\n# previous value.\ndef createNLevelTree(arr, n):\n\u00a0\u00a0\u00a0\u00a0root = newNode(arr[0])\n\u00a0\u00a0\u00a0\u00a0temp = root\n\u00a0\u00a0\u00a0\u00a0for i in range(1, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.key > arr[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.left = newNode(arr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.right = newNode(arr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Please refer below post for details of this\n# function.\n# https:# www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\ndef isBST(root, min, max):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (root.key < min or root.key > max):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Allow only distinct values\n\u00a0\u00a0\u00a0\u00a0return (isBST(root.left, min, (root.key) - 1) and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isBST(root.right,(root.key) + 1, max))\n\u00a0\n# Returns tree if given array of size n can\n# represent a BST of n levels.\ndef canRepresentNLevelBST(arr, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = createNLevelTree(arr, n)\n\u00a0\u00a0\u00a0\u00a0return isBST(root, 0, 2**32)\n\u00a0\n# Driver code\narr = [512, 330, 78, 11, 8]\nn = len(arr)\n\u00a0\nif (canRepresentNLevelBST(arr, n)):\n\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\n# This code is contributed by SHUBHAMSINGH10\n"}
{"nl": "Alternating Min-Max Sorting", "code": "# Python 3 program to print an array\r\n# in alternate sorted manner.\r\n\r\n# Function to print alternate sorted\r\n# values\r\ndef alternateSort(arr, n):\r\n\r\n\t# Sorting the array\r\n\tarr.sort()\r\n\r\n\t# Printing the last element of array\r\n\t# first and then first element and then\r\n\t# second last element and then second\r\n\t# element and so on.\r\n\ti = 0\r\n\tj = n-1\r\n\t\r\n\twhile (i < j):\r\n\t\r\n\t\tprint(arr[j], end =\" \")\r\n\t\tj-= 1\r\n\t\tprint(arr[i], end =\" \")\r\n\t\ti+= 1\r\n\r\n\t# If the total element in array is odd\r\n\t# then print the last middle element.\r\n\tif (n % 2 != 0):\r\n\t\tprint(arr[i])\r\n\r\n\r\n# Driver code\r\narr = [1, 12, 4, 6, 7, 10]\r\nn = len(arr)\r\n\r\nalternateSort(arr, n)\r\n\r\n# This code is contributed by\r\n# Smitha Dinesh Semwal\r"}
{"nl": "Python Program to Print Hollow Box Pattern of Numbers", "code": "# Python Program to Print Hollow Box Pattern of Numbers 1 and 0\n \nrows = int(input(\"Please Enter the total Number of Rows  : \"))\ncolumns = int(input(\"Please Enter the total Number of Columns  : \"))\n\nprint(\"Hollow Box Pattern of Numbers\") \n \nfor i in range(1, rows + 1):\n    for j in range(1, columns + 1):\n        if(i == 1 or i == rows or j == 1 or j == columns):          \n            print('1', end = '  ')\n        else:\n            print(' ', end = '  ')\n    print()"}
{"nl": "Print all the Prime Numbers within a Given Range", "code": "# Give the number as user input with the help\r\n# of the int(input()) function and store it in a variable.\r\ngivenNumbr = int(input('Enter some random upper limit range = '))\r\nprint('The prime numbers from 2 to upper limit [', givenNumbr, '] :')\r\n# Set the first for loop to have a range of 2 to the upper limit range.\r\nfor valu in range(2, givenNumbr+1):\r\n  # Take a temporary variable which is the count variable and initialize it to zero.\r\n    cntvar = 0\r\n    # Allow the second for loop to have a range of 2 to\r\n    # half the number (excluding 1 and the number itself).\r\n    for divi in range(2, valu//2+1):\r\n      # Then, using the if statement, determine the number of divisors\r\n      # and increment the count variable each time.\r\n        if(valu % divi == 0):\r\n            cntvar = cntvar+1\r\n    # The number is prime if the number of divisors is lower than or equal to zero.\r\n    if(cntvar <= 0):\r\n        print(valu, end=' ')"}
{"nl": "The smallest string with numeric value k", "code": "class Solution:\n  def getSmallestString(self, n: int, k: int) -> str:\n  res, k, i = ['a'] * n, k - n, n - 1\n  while k:\n  k += 1\n  if k/26 >= 1:\n  res[i], k, i = 'z', k - 26, i - 1\n  else:\n  res[i], k = chr(k + 96), 0\n\n  return ''.join(res)"}
{"nl": "Python JSON\r", "code": "import json"}
{"nl": "determine if the linked list has a cycle in it", "code": "class Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        if head is None:\n            return False\n        slow = head\n        fast = head.next\n        while slow != fast:\n            if fast is None or fast.next is None:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n        return True"}
{"nl": "How to check if a given array represents a Binary Heap?", "code": "# Python3 program to check whether a\n# given array represents a max-heap or not\n\n# Returns true if arr[i..n-1]\n# represents a max-heap\ndef isHeap(arr, i, n):\n\t\n\t# If (2 * i) + 1 >= n, then leaf node, so return true\n\tif i >= int((n - 1) / 2):\n\t\treturn True\n\t\n\t# If an internal node and is greater\n\t# than its children, and same is\n\t# recursively true for the children\n\tif(arr[i] >= arr[2 * i + 1] and\n\tarr[i] >= arr[2 * i + 2] and\n\tisHeap(arr, 2 * i + 1, n) and\n\tisHeap(arr, 2 * i + 2, n)):\n\t\treturn True\n\t\n\treturn False\n\n# Driver Code\nif __name__ == '__main__':\n\tarr = [90, 15, 10, 7, 12, 2, 7, 3]\n\tn = len(arr) - 1\n\n\tif isHeap(arr, 0, n):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n\n# This code is contributed by PranchalK"}
{"nl": "Error Messages", "code": "def error(n):\n  return {\n    1: 'Check the fan: e1',\n    2: 'Emergency stop: e2',\n    3: 'Pump Error: e3',\n    4: 'c: e4',\n    5: 'Temperature Sensor Error: e5',\n  }.get(n, 101)"}
{"nl": "Python Program to Find the Sum of all Elements in a 2D Array/Matrix", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[1, 6, 4], [8, 1, 3], [1, 6, 2]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n print(\"The sum of all elements in 2 dimensional array for a given matrix is :\")\n # Take a variable say rslt_sum and initialize its value to 0.\n rslt_sum = 0\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Add the gvnmatrix[n][m] to the above-initialized\n  # rslt_sum and store it in the same variable rslt_sum.\n  rslt_sum += mtrx[n][m]\n # Print the variable rslt_sum to get the sum of all elements in a 2 dimensional array for\n # a given matrix\n print(rslt_sum)"}
{"nl": "Count the number of times the binary string is prefix-aligned during the flipping process", "code": "def numTimesAllBlue(self, A):\n  right = res = 0\n  for i, a in enumerate(A, 1):\n  right = max(right, a)\n  res += right == i\n  return res"}
{"nl": "Print mirrored right triangle star pattern", "code": "# Give the number of rows of the right triangle pattern as static input and store it in a variable.\ntriNumRows = 6\n# Iterate from 1 to given rows using the First for loop.\nfor m in range(1, triNumRows+1):\n  # Iterate from 1 to given rows using another for loop(Nested For loop)\n  for n in range(1, triNumRows+1):\n  # Check if the iterator value of the inner for loop is less than or equal to given rows - first iterator value using If statement.\n  if(n <= triNumRows - m):\n  # If the statement is true then print space.\n  print(' ', end=' ')\n  else:\n  # Else print star character with space.\n  print('*', end=' ')\n  #Print the newline character after the exit of the inner for loop.\n  print()"}
{"nl": "Dungeons & Dragons Game", "code": "import random\nABILITIES = (\n    'strength', 'dexterity', 'constitution',\n    'intelligence', 'wisdom', 'charisma')\ndef modifier(score):\n    return (score - 10) // 2\nclass Character:\n    def __init__(self):\n        for ability in ABILITIES:\n            setattr(self, ability, self.ability())\n        self.hitpoints = 10 + modifier(self.constitution)\n    def ability(self):\n        dices = sorted(random.randint(1, 6) for _ in range(4))\n        return sum(dices[1:])"}
{"nl": "Find sum of all elements in a matrix except the elements in row and/or column of given cell?", "code": "# Python3 implementation of the approach\n\u00a0\n# A structure to represent a cell index\nclass Cell:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, r, c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.r = r # r is row, varies from 0 to R-1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.c = c # c is column, varies from 0 to C-1\n\u00a0\n# A simple solution to find sums\n# for a given array of cell indexes\ndef printSums(mat, arr, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Iterate through all cell indexes\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Sum = 0; r = arr[i].r; c = arr[i].c\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Compute sum for current cell index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0, R):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(0, C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j != r and k != c:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Sum += mat[j][k]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(Sum)\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[1, 1, 2], [3, 4, 6], [5, 3, 2]]\n\u00a0\u00a0\u00a0\u00a0R = C = 3\n\u00a0\u00a0\u00a0\u00a0arr = [Cell(0, 0), Cell(1, 1), Cell(0, 1)]\n\u00a0\u00a0\u00a0\u00a0n = len(arr)\n\u00a0\u00a0\u00a0\u00a0printSums(mat, arr, n)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by Rituraj Jain\n"}
{"nl": "Prefix to Postfix Conversion", "code": "# Write Python3 code here\n# -*- coding: utf-8 -*-\n\u00a0\n# Example Input\ns = \"*-A/BC-/AKL\"\n\u00a0\n# Stack for storing operands\nstack = []\n\u00a0\noperators = set(['+', '-', '*', '/', '^'])\n\u00a0\n# Reversing the order\ns = s[::-1]\n\u00a0\n# iterating through individual tokens\nfor i in s:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if token is operator\n\u00a0\u00a0\u00a0\u00a0if i in operators:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop 2 elements from stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a = stack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b = stack.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# concatenate them as operand1 +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# operand2 + operator\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = a+b+i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(temp)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# else if operand\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(i)\n\u00a0\n# printing final output\nprint(*stack)\n"}
{"nl": "Implement Dijkstra\u2019s Shortest Path Algorithm", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef dijkstra(g, source):\n    \"\"\"Return distance where distance[v] is min distance from source to v.\n\u00a0\n    This will return a dictionary distance.\n\u00a0\n    g is a Graph object.\n    source is a Vertex object in g.\n    \"\"\"\n    unvisited = set(g)\n    distance = dict.fromkeys(g, float('inf'))\n    distance[source] = 0\n\u00a0\n    while unvisited != set():\n        # find vertex with minimum distance\n        closest = min(unvisited, key=lambda v: distance[v])\n\u00a0\n        # mark as visited\n        unvisited.remove(closest)\n\u00a0\n        # update distances\n        for neighbour in closest.get_neighbours():\n           if neighbour in unvisited:\n               new_distance = distance[closest] + closest.get_weight(neighbour)\n               if distance[neighbour] > new_distance:\n                   distance[neighbour] = new_distance\n\u00a0\n    return distance\n\u00a0\n\u00a0\ng = Graph()\nprint('Undirected Graph')\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('shortest <source vertex key>')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                    g.add_edge(dest, src, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'shortest':\n        key = int(do[1])\n        source = g.get_vertex(key)\n        distance = dijkstra(g, source)\n        print('Distances from {}: '.format(key))\n        for v in distance:\n            print('Distance to {}: {}'.format(v.get_key(), distance[v]))\n        print()\n\u00a0\n    elif operation == 'display':\n        print('Vertices: ', end='')\n        for v in g:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in g:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "print the series ( 0,2,8,14,24,34 \u2026N) till the given number N in Python.", "code": "# Give the number N as static input and store it in a variable.\r\ngvn_numb = 5\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Take another variable say previous_val and initialize its value to 0.\r\nprevious_val = 0\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nwhile itr <= gvn_numb:\r\n  # Inside the loop, check if the above itr value is even or not using the if\r\n  # conditional statement.\r\n    if(itr % 2 == 0):\r\n      # If it is true, calculate the value of itr raised to the power 2 using the pow()\r\n          # function and subtract 2 from it.\r\n      # Store it in the same variable previous_val.\r\n        previous_val = pow(itr, 2) - 2\r\n        # Print the value of the above previous_val separated by spaces.\r\n        print(previous_val, end=\" \")\r\n    else:\r\n     # Else, If it is false calculate the value of itr raised to the power 2 using the pow()\r\n         # function and subtract 1 from it.\r\n         # Store it in the same variable previous_val.\r\n        previous_val = pow(itr, 2) - 1\r\n        # Print the value of the above previous_val separated by spaces.\r\n        print(previous_val, end=\" \")\r\n  # Increment the above itr value by 1.\r\n    itr += 1"}
{"nl": "Minimum edge reversals to make a root", "code": "# Python3 program to find min edge reversal\n# to make every node reachable from root\nimport sys\n\u00a0\u00a0\n# Method to dfs in tree and populates\u00a0\n# disRev values\ndef dfs(g, disRev, visit, u):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Visit current node\n\u00a0\u00a0\u00a0\u00a0visit[u] = True\n\u00a0\u00a0\u00a0\u00a0totalRev = 0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Looping over all neighbors\n\u00a0\u00a0\u00a0\u00a0for i in range(len(g[u])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = g[u][i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not visit[v]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Distance of v will be one more\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than distance of u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[v][0] = disRev[u][0] + 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Initialize back edge count same as\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# parent node's count\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[v][1] = disRev[u][1]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If there is a reverse edge from u to i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then only update\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (g[u][i][1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[v][1] = disRev[u][1] + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalRev += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalRev += dfs(g, disRev, visit, v)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return total reversal in subtree rooted at u\n\u00a0\u00a0\u00a0\u00a0return totalRev\n\u00a0\u00a0\n# Method prints root and minimum number of\n# edge reversal\ndef printMinEdgeReverseForRootNode(edges, e):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Number of nodes are one more than\n\u00a0\u00a0\u00a0\u00a0# number of edges\n\u00a0\u00a0\u00a0\u00a0V = e + 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Data structure to store directed tree\n\u00a0\u00a0\u00a0\u00a0g = [[] for i in range(V)]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# disRev stores two values - distance\n\u00a0\u00a0\u00a0\u00a0# and back edge count from root node\n\u00a0\u00a0\u00a0\u00a0disRev = [[0, 0] for i in range(V)]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0visit = [False for i in range(V)]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# u, v\n\u00a0\u00a0\u00a0\u00a0for i in range(e):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = edges[i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = edges[i][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add 0 weight in direction of u to v\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g[u].append([v, 0])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add 1 weight in reverse direction\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g[v].append([u, 1])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize all variables\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visit[i] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0disRev[i][0] = disRev[i][1] = 0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = 0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# dfs populates disRev data structure and\n\u00a0\u00a0\u00a0\u00a0# store total reverse edge counts\n\u00a0\u00a0\u00a0\u00a0totalRev = dfs(g, disRev, visit, root)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# UnComment below lines to preach node's\n\u00a0\u00a0\u00a0\u00a0# distance and edge reversal count from root node\n\u00a0\u00a0\u00a0\u00a0# for (i = 0 i < V i++)\n\u00a0\u00a0\u00a0\u00a0# {\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 cout << i << \" : \" << disRev[i][0]\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 << \" \" << disRev[i][1] << endl\n\u00a0\u00a0\u00a0\u00a0# }\n\u00a0\u00a0\u00a0\u00a0res = sys.maxsize\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Loop over all nodes to choose\u00a0\n\u00a0\u00a0\u00a0\u00a0# minimum edge reversal\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (reversal in path to i) + (reversal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in all other tree parts)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edgesToRev = ((totalRev - disRev[i][1]) +\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(disRev[i][0] - disRev[i][1]))\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Choose minimum among all values\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (edgesToRev < res):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = edgesToRev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = i\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the designated root and total\n\u00a0\u00a0\u00a0\u00a0# edge reversal made\n\u00a0\u00a0\u00a0\u00a0print(root, res)\u00a0\n\u00a0\u00a0\n# Driver code\u00a0\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0edges = [ [ 0, 1 ], [ 2, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 3, 2 ], [ 3, 4 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 5, 4 ], [ 5, 6 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 7, 6 ] ]\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0e = len(edges)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0printMinEdgeReverseForRootNode(edges, e)\n\u00a0\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Find subarray with given sum", "code": "# An efficient program\r\n# to print subarray\r\n# with sum as given sum\r\n\r\n# Returns true if the\r\n# there is a subarray\r\n# of arr[] with sum\r\n# equal to 'sum'\r\n# otherwise returns\r\n# false. Also, prints\r\n# the result.\r\ndef subArraySum(arr, n, sum_):\r\n\t\r\n\t# Initialize curr_sum as\r\n\t# value of first element\r\n\t# and starting point as 0\r\n\tcurr_sum = arr[0]\r\n\tstart = 0\r\n\r\n\t# Add elements one by\r\n\t# one to curr_sum and\r\n\t# if the curr_sum exceeds\r\n\t# the sum, then remove\r\n\t# starting element\r\n\ti = 1\r\n\twhile i <= n:\r\n\t\t\r\n\t\t# If curr_sum exceeds\r\n\t\t# the sum, then remove\r\n\t\t# the starting elements\r\n\t\twhile curr_sum > sum_ and start < i-1:\r\n\t\t\r\n\t\t\tcurr_sum = curr_sum - arr[start]\r\n\t\t\tstart += 1\r\n\t\t\t\r\n\t\t# If curr_sum becomes\r\n\t\t# equal to sum, then\r\n\t\t# return true\r\n\t\tif curr_sum == sum_:\r\n\t\t\tprint (\"Sum found between indexes\")\r\n\t\t\tprint (\"% d and % d\"%(start, i-1))\r\n\t\t\treturn 1\r\n\r\n\t\t# Add this element\r\n\t\t# to curr_sum\r\n\t\tif i < n:\r\n\t\t\tcurr_sum = curr_sum + arr[i]\r\n\t\ti += 1\r\n\r\n\t# If we reach here,\r\n\t# then no subarray\r\n\tprint (\"No subarray found\")\r\n\treturn 0\r\n\r\n# Driver program\r\narr = [15, 2, 4, 8, 9, 5, 10, 23]\r\nn = len(arr)\r\nsum_ = 23\r\n\r\nsubArraySum(arr, n, sum_)\r\n\r\n# This code is Contributed by shreyanshi_arun.\r"}
{"nl": "Prime Factorization", "code": "def factorize(n):\r\n\td = {}\r\n\tfor i in range(2, n+1):\r\n\t\twhile n % i == 0:\r\n\t\t\td[i] = 1 if i not in d else d[i] + 1\r\n\t\t\tn //= i\r\n\treturn sorted(d.items())"}
{"nl": "Reverse Coding Challenge #3", "code": "def mystery_func(lst, n):\n  return [i%n for i in lst]"}
{"nl": "Check if the given path crosses itself", "code": "def isPathCrossing(self, path: str) -> bool:\n  cur = (0, 0)\n  seen = {cur}\n  dir = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}\n  for char in path:\n  cur = tuple(map(operator.add, cur, dir[char]))\n  if cur in seen:\n  return True\n  seen.add(cur)\n  return False"}
{"nl": "Circular Queue (Circular Linked List Implementation)", "code": "# Python3 program for insertion and\u00a0\n# deletion in Circular Queue\u00a0\n\u00a0\u00a0\n# Structure of a Node\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.link = None\n\u00a0\u00a0\nclass Queue:\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0front = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rear = None\n\u00a0\u00a0\n# Function to create Circular queue\u00a0\ndef enQueue(q, value):\n\u00a0\u00a0\u00a0\u00a0temp = Node()\u00a0\n\u00a0\u00a0\u00a0\u00a0temp.data = value\u00a0\n\u00a0\u00a0\u00a0\u00a0if (q.front == None):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.front = temp\u00a0\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.rear.link = temp\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0q.rear = temp\u00a0\n\u00a0\u00a0\u00a0\u00a0q.rear.link = q.front\n\u00a0\u00a0\n# Function to delete element from\u00a0\n# Circular Queue\u00a0\ndef deQueue(q):\n\u00a0\u00a0\u00a0\u00a0if (q.front == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue is empty\")\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -999999999999\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If this is the last node to be deleted\u00a0\n\u00a0\u00a0\u00a0\u00a0value = None # Value to be dequeued\u00a0\n\u00a0\u00a0\u00a0\u00a0if (q.front == q.rear):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value = q.front.data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.front = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.rear = None\n\u00a0\u00a0\u00a0\u00a0else: # There are more than one nodes\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = q.front\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value = temp.data\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.front = q.front.link\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.rear.link = q.front\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return value\u00a0\n\u00a0\u00a0\n# Function displaying the elements\u00a0\n# of Circular Queue\u00a0\ndef displayQueue(q):\n\u00a0\u00a0\u00a0\u00a0temp = q.front\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Elements in Circular Queue are: \",\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end = \" \")\u00a0\n\u00a0\u00a0\u00a0\u00a0while (temp.link != q.front):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(temp.data, end = \" \")\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.link\n\u00a0\u00a0\u00a0\u00a0print(temp.data)\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a queue and initialize\n\u00a0\u00a0\u00a0\u00a0# front and rear\u00a0\n\u00a0\u00a0\u00a0\u00a0q = Queue()\u00a0\n\u00a0\u00a0\u00a0\u00a0q.front = q.rear = None\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Inserting elements in Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 14)\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 22)\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 6)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Display elements present in\u00a0\n\u00a0\u00a0\u00a0\u00a0# Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0displayQueue(q)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Deleting elements from Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Deleted value = \", deQueue(q))\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Deleted value = \", deQueue(q))\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Remaining elements in Circular Queue\u00a0\n\u00a0\u00a0\u00a0\u00a0displayQueue(q)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 9)\u00a0\n\u00a0\u00a0\u00a0\u00a0enQueue(q, 20)\u00a0\n\u00a0\u00a0\u00a0\u00a0displayQueue(q)\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Replace a Word with Asterisks in User Input", "code": "# Give the string as user input using the input() function and store it in a variable.\r\ngvn_str = input(\"Enter some random sentence = \")\r\n# Give the replaceable word as user input using the input() function and store it in another variable.\r\ngvn_wrd = input(\"Enter some random word = \")\r\n# Split the given string into a list of words using the split() function and\r\n# store it in another variable say \"wrd_lst\".\r\nwrd_lst = gvn_str.split()\r\n# Multiply the asterisk symbol with the length of the given input word using\r\n# the len() function and store it in another variable.\r\nreplacd_word = '*' * len(gvn_wrd)\r\n# Loop in the above-obtained word list using the for loop.\r\nfor itr in range(len(wrd_lst)):\r\n  # Check if the iterator value is equal to the given input word using the if\r\n  # conditional statement.\r\n # check if thw word at the iterator index is equal is given\r\n    if wrd_lst[itr] == gvn_wrd:\r\n      # if it is truw thwn replce the word t the iterator index with the replaced word\r\n        wrd_lst[itr] = replacd_word\r\n# Convert the above-got word list to string using the join() function.\r\nfinl_str = ' '.join(wrd_lst)\r\n# Print the above-obtained string to replace a word with an asterisk in a\r\n# given input sentence.\r\nprint(\"The given string [\", gvn_str,\r\n      \"] after replacing with a given word with an asterisk :\")\r\nprint(finl_str)"}
{"nl": "Convert Miles to Kilometers", "code": "# miles input from the user\r\nmiles = float(input(\"Enter value in miles: \"))\r\n\r\n# calculate kilometers and display\r\nkilometers = miles * 1.60934\r\nprint('%0.3f miles is equal to %0.3f kilometers' %(miles, kilometers))"}
{"nl": "Find Second largest element in an array", "code": "# Python3 program to find second\n# largest element in an array\n\n# Function to print the\n# second largest elements\ndef print2largest(arr,\n\t\t\t\tarr_size):\n\n# There should be\n# atleast two elements\nif (arr_size < 2):\n\tprint(\" Invalid Input \")\n\treturn\n\n# Sort the array\narr.sort\n\n# Start from second last\n# element as the largest\n# element is at last\nfor i in range(arr_size-2,\n\t\t\t\t-1, -1):\n\n\t# If the element is not\n\t# equal to largest element\n\tif (arr[i] != arr[arr_size - 1]) :\n\t\n\tprint(\"The second largest element is\",\n\t\t\tarr[i])\n\treturn\n\nprint(\"There is no second largest element\")\n\n# Driver code\narr = [12, 35, 1, 10, 34, 1]\nn = len(arr)\nprint2largest(arr, n)\n\n# This code is contributed by divyeshrabadiya07"}
{"nl": "Hollow Pyramid Star Pattern in Python", "code": "# Hollow pyramid star pattern in Python # user-defined function def pattern(n): for i in range(n): for j in range(n-i-1): # print the spaces print(\" \", end=\" \") for j in range(2*i+1): # printing stars if j == 0 or j == 2*i: # print the stars print(\"*\", end=\" \") else: if i == n-1: # print the stars print(\"*\", end=\" \") else: # print the spaces print(\" \", end=\" \") print() # input from the user n = int(input('Enter any number: ')) # the function call pattern(n)"}
{"nl": "Check if Two Numbers are Equal Without using Arithmetic and Comparison Operators", "code": "# Create a function isEqualNumbers()\r\n# which takes the given two numbers as arguments and\r\n# returns true if they are equal\r\n# else returns false if they are not equal.\r\n\r\n\r\ndef isEqualNumbers(first_numb, second_numb):\r\n        # Inside the isEqualNumbers() function.\r\n        # Apply xor to the first number and second number and\r\n    # store it in a variable say xor_result.\r\n    xor_result = first_numb ^ second_numb\r\n    # Check if the value of xor_result is not equal to 0\r\n    # using the if conditional statement.\r\n    if(xor_result != 0):\r\n        # If it is true then return False\r\n        return False\r\n    # Else return True.\r\n    return True\r\n\r\n\r\n# Inside the main code.\r\n# Give the first number as static input and store it in a variable.\r\nfirstnumb = 10\r\n# Give the second number as static input and store it in another variable.\r\nsecondnumb = 10\r\n# Pass the given two numbers as the arguments to isEqualNumbers() function\r\n# and store the result in a variable Reslt.\r\nReslt = isEqualNumbers(firstnumb, secondnumb)\r\n# Check if the Value of Reslt using the If conditional statement.\r\nif(Reslt):\r\n        # If it is true then print the given two numbers are Equal.\r\n    print('The given two numbers {', firstnumb,\r\n          ',', secondnumb, '} are Equal')\r\n# Else print the given two numbers are Not Equal.\r\nelse:\r\n    print('The given two numbers {', firstnumb,\r\n          ',', secondnumb, '} are Not equal')"}
{"nl": "Given an n x n square matrix, find sum of all sub-squares of size k x k", "code": "# A simple Python 3 program to find sum\n# of all subsquares of size k x k\n\u00a0\n# Size of given matrix\nn = 5\n\u00a0\n# A simple function to find sum of all\n# sub-squares of size k x k in a given\n# square matrix of size n x n\ndef printSumSimple(mat, k):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# k must be smaller than or equal to n\n\u00a0\u00a0\u00a0\u00a0if (k > n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# row number of first cell in current\n\u00a0\u00a0\u00a0\u00a0# sub-square of size k x k\n\u00a0\u00a0\u00a0\u00a0for i in range(n - k + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# column of first cell in current\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sub-square of size k x k\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n - k + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate and print sum of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current sub-square\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for p in range(i, k + i):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for q in range(j, k + j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += mat[p][q]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(sum, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Line separator for sub-squares\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# starting with next row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[1, 1, 1, 1, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 2, 2, 2, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[3, 3, 3, 3, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 4, 4, 4, 4],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[5, 5, 5, 5, 5]]\n\u00a0\u00a0\u00a0\u00a0k = 3\n\u00a0\u00a0\u00a0\u00a0printSumSimple(mat, k)\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": "Python Program to Calculate the Area of a Trapezoid", "code": "# Give the first base as static input and store it in a variable.\nfst_base = 2\n# Give the second base as static input and store it in another variable.\nsecnd_base = 4\n# Give the height of the given trapezoid as static input and store it in another variable\ngvn_Heigt = 1.5\n# Calculate the area of the given trapezoid using the above given mathematical formula\n# and store it in another variable.\ntrapezod_area = 0.5 * (fst_base + secnd_base) * gvn_Heigt\nprint(\"The Area of the given Trapezoid = \", trapezod_area)"}
{"nl": "Consecutive Sum Check", "code": "def consecutive_sum(n):\n  i, res = 2, 0\n  while 2 ** i <= n:\n    res = 2 ** i\n    i += 1\n  return res != n"}
{"nl": "Find the Lost Dog", "code": "def lost_dog(*args, n=0):\n    res = dict()\n    for r, row in enumerate(args):\n        if 0 in row:\n            n += 1\n            res[\"Dog{}\".format(n)] = (\"House ({}) and Room ({})\"\n                                      .format(r + 1, row.index(0) + 1))\n    return res if n else \"Dog not found!\""}
{"nl": "Up the Hill, Down the Hill", "code": "def ave_spd(_, up, down):\n  return 2*up*down/(up+down)"}
{"nl": "Caesar Cipher", "code": "def caesar_cipher(text, key):\n    in_ = 'abcdefghijklmnopqrstuvwxyz'\n    out = in_[key:] + in_[:key]\n    return text.translate(str.maketrans(in_, out))"}
{"nl": "Python Program to Find Sum of Series 1^1/1+2^2/2+3^3/3\u2026+n^n/n", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the number N(limit) as static input and store it in a variable.\n \n gvn_numb = 4\n \n # Take a variable to say rsltseries_summ and initialize its value to 0.0\n \n # (Floating point number)\n \n rsltseries_summ = 0.0\n \n # Loop from 1 to the given number using the for loop.\n \n for itr in range(1, gvn_numb+1):\n \n  # Inside the loop, calculate the value of the iterator raised to the power itself and\n \n  # divided by the iterator value using the pow() function.\n \n  # Store it in another variable.\n \n  a = pow(itr, itr) / itr\n \n  # Add the above result to the rsltseries_summ and store it in the same variable.\n \n  rsltseries_summ += a\n \n # Print the sum of series till the given number N.\n \n print(\n \n  \"The above series sum till the given number N{\", gvn_numb, \"} = \", rsltseries_summ)\n \n </pre>"}
{"nl": "Sort Numbers in Ascending Order", "code": "def sort_nums_ascending(lst):\n  return sorted(lst)"}
{"nl": "Transform a BST to greater sum tree", "code": "# Python3 program to transform a BST to sum tree\n\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, x):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = x\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Recursive function to transform a BST to sum tree.\n# This function traverses the tree in reverse inorder so\n# that we have visited all greater key nodes of the currently\n# visited node\ndef transformTreeUtil(root):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0# Base case\n\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0# Recur for right subtree\n\u00a0\u00a0\u00a0transformTreeUtil(root.right)\n\u00a0\n\u00a0\u00a0\u00a0# Update sum\n\u00a0\u00a0\u00a0global sum\n\u00a0\u00a0\u00a0sum = sum + root.data\n\u00a0\n\u00a0\u00a0\u00a0# Store old sum in current node\n\u00a0\u00a0\u00a0root.data = sum - root.data\n\u00a0\n\u00a0\u00a0\u00a0# Recur for left subtree\n\u00a0\u00a0\u00a0transformTreeUtil(root.left)\n\u00a0\n# A wrapper over transformTreeUtil()\ndef transformTree(root):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# sum = 0 #Initialize sum\n\u00a0\u00a0\u00a0\u00a0transformTreeUtil(root)\n\u00a0\n# A utility function to prindorder traversal of a\n# binary tree\ndef printInorder(root):\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0printInorder(root.left)\n\u00a0\u00a0\u00a0\u00a0print(root.data, end = \" \")\n\u00a0\u00a0\u00a0\u00a0printInorder(root.right)\n\u00a0\n# Driver Program to test above functions\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0sum=0\n\u00a0\u00a0\u00a0\u00a0root = Node(11)\n\u00a0\u00a0\u00a0\u00a0root.left = Node(2)\n\u00a0\u00a0\u00a0\u00a0root.right = Node(29)\n\u00a0\u00a0\u00a0\u00a0root.left.left = Node(1)\n\u00a0\u00a0\u00a0\u00a0root.left.right = Node(7)\n\u00a0\u00a0\u00a0\u00a0root.right.left = Node(15)\n\u00a0\u00a0\u00a0\u00a0root.right.right = Node(40)\n\u00a0\u00a0\u00a0\u00a0root.right.right.left = Node(35)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Inorder Traversal of given tree\")\n\u00a0\u00a0\u00a0\u00a0printInorder(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0transformTree(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"\\nInorder Traversal of transformed tree\")\n\u00a0\u00a0\u00a0\u00a0printInorder(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by mohit kumar 29\n"}
{"nl": "The maximum total value after selling balls", "code": "class Solution:\n  def maxProfit(self, inv: List[int], orders: int) -> int:\n  arr=sorted(Counter(inv).items(), reverse=True)+[(0,0)]\n  ans, ind, width=0,0,0\n  \n  while orders>0:\n  width += arr[ind][1]\n  sell=min(orders, width * (arr[ind][0] - arr[ind+1][0]))\n  whole, remainder= divmod(sell, width)\n  ans += width*(whole*(arr[ind][0]+arr[ind][0]-(whole-1)))//2 + remainder*(arr[ind][0]-whole)\n  orders -= sell\n  ind += 1\n  return ans % 1_000_000_007"}
{"nl": "Create a class", "code": "class MyClass:\r\n  x = 5"}
{"nl": "check if given four points form a square", "code": "# A Python3 program to check if\n# four given points form a square or not.\nclass Point:\n\t\n\t# Structure of a point in 2D space\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\n# A utility function to find square of\n# distance from point 'p' to point 'q'\ndef distSq(p, q):\n\treturn (p.x - q.x) * (p.x - q.x) +\\\n\t\t(p.y - q.y) * (p.y - q.y)\n\n# This function returns true if (p1, p2, p3, p4)\n# form a square, otherwise false\ndef isSquare(p1, p2, p3, p4):\n\n\td2 = distSq(p1, p2) # from p1 to p2\n\td3 = distSq(p1, p3) # from p1 to p3\n\td4 = distSq(p1, p4) # from p1 to p4\n\n\tif d2 == 0 or d3 == 0 or d4 == 0:\n\t\treturn False\n\n\t# If lengths if (p1, p2) and (p1, p3) are same, then\n\t# following conditions must be met to form a square.\n\t# 1) Square of length of (p1, p4) is same as twice\n\t# the square of (p1, p2)\n\t# 2) Square of length of (p2, p3) is same\n\t# as twice the square of (p2, p4)\n\n\tif d2 == d3 and 2 * d2 == d4 and \\\n\t\t\t\t\t2 * distSq(p2, p4) == distSq(p2, p3):\n\t\treturn True\n\n\t# The below two cases are similar to above case\n\tif d3 == d4 and 2 * d3 == d2 and \\\n\t\t\t\t\t2 * distSq(p3, p2) == distSq(p3, p4):\n\t\treturn True\n\n\tif d2 == d4 and 2 * d2 == d3 and \\\n\t\t\t\t\t2 * distSq(p2, p3) == distSq(p2, p4):\n\t\treturn True\n\n\treturn False\n\n# Driver Code\nif __name__==\"__main__\":\n\tp1 = Point(20, 10)\n\tp2 = Point(10, 20)\n\tp3 = Point(20, 20)\n\tp4 = Point(10, 10)\n\t\n\tif isSquare(p1, p2, p3, p4):\n\t\tprint('Yes')\n\telse:\n\t\tprint('No')\n\n# This code is contributed by Mayank Chaudhary\n# aka chaudhary_19"}
{"nl": "find Longest Common Substring using Dynamic Programming with Memoization", "code": "def lcw(u, v):\n    \"\"\"Return length of an LCW of strings u and v and its starting indexes.\n\u00a0\n    (l, i, j) is returned where l is the length of an LCW of the strings u, v\n    where the LCW starts at index i in u and index j in v.\n    \"\"\"\n    c = [[-1]*(len(v) + 1) for _ in range(len(u) + 1)]\n\u00a0\n    lcw_i = lcw_j = -1\n    length_lcw = 0\n    for i in range(len(u)):\n        for j in range(len(v)):\n            temp = lcw_starting_at(u, v, c, i, j)\n            if length_lcw < temp:\n                length_lcw = temp\n                lcw_i = i\n                lcw_j = j\n\u00a0\n    return length_lcw, lcw_i, lcw_j\n\u00a0\n\u00a0\ndef lcw_starting_at(u, v, c, i, j):\n    \"\"\"Return length of the LCW starting at u[i:] and v[j:] and fill table c.\n\u00a0\n    c[i][j] contains the length of the LCW at the start of u[i:] and v[j:].\n    This function fills in c as smaller subproblems for solving c[i][j] are\n    solved.\"\"\"\n    if c[i][j] >= 0:\n        return c[i][j]\n\u00a0\n    if i == len(u) or j == len(v):\n        q = 0\n    elif u[i] != v[j]:\n        q = 0\n    else:\n        q = 1 + lcw_starting_at(u, v, c, i + 1, j + 1)\n\u00a0\n    c[i][j] = q\n    return q\n\u00a0\n\u00a0\nu = input('Enter first string: ')\nv = input('Enter second string: ')\nlength_lcw, lcw_i, lcw_j = lcw(u, v)\nprint('Longest Common Subword: ', end='')\nif length_lcw > 0:\n    print(u[lcw_i:lcw_i + length_lcw])"}
{"nl": "Return the number of rods that have all three colors of rings on them.", "code": "from collections import Counter\nclass Solution(object):\n    def countPoints(self, rings):\n        count=0\n        freq={}\n        final=[str(rings[i:i+2]) for i in range(0,len(rings),2)]\n        for i in range(len(final)):\n            if final[i][-1] in freq:\n                freq[final[i][-1]] += final[i][0]\n            else:\n                freq[final[i][-1]]=final[i][0]\n        for item,value in freq.items():\n            if len(Counter(value))==3:\n                count+=1    \n        return count"}
{"nl": "Print hollow right triangle star pattern", "code": "# Give the number of rows of the hollow right-angled triangle star pattern\n# as static input and store it in a variable.\ntrianglerows = 7\n# Loop from 1 to the number of rows using For loop.\nfor m in range(1, trianglerows+1):\n  # Loop from 1 to first loop iterator value using another Nested For loop.\n  for n in range(1, m+1):\n  # If you closely examine the pattern, you will notice that the\n  # star is available on the first or last column or row.\n  # So, for the first or last column or row, print a star, otherwise, print space.\n  if(m == 1 or m == trianglerows or n == 1 or n == m):\n  print('*', end=' ')\n  else:\n  print(' ', end=' ')\n  # Print the newline character after ending of inner For loop.\n  print()"}
{"nl": "NetworkX : Python software package for study of complex networks", "code": "# Python program to create an undirected\u00a0\n# graph and add nodes and edges to a graph\n\u00a0\u00a0\n# To import package\nimport networkx\n\u00a0\u00a0\u00a0\n# To create an empty undirected graph\nG = networkx.Graph()\n\u00a0\u00a0\u00a0\n# To add a node\nG.add_node(1)\nG.add_node(2)\nG.add_node(3)\nG.add_node(4)\nG.add_node(7)\nG.add_node(9)\n\u00a0\u00a0\u00a0\n# To add an edge\n# Note graph is undirected\n# Hence order of nodes in edge doesn't matter\nG.add_edge(1,2)\nG.add_edge(3,1)\nG.add_edge(2,4)\nG.add_edge(4,1)\nG.add_edge(9,1)\nG.add_edge(1,7)\nG.add_edge(2,9)\n\u00a0\u00a0\u00a0\n# To get all the nodes of a graph\nnode_list = G.nodes()\nprint(\"#1\")\nprint(node_list)\n\u00a0\u00a0\u00a0\n# To get all the edges of a graph\nedge_list = G.edges()\nprint(\"#2\")\nprint(edge_list)\n\u00a0\u00a0\u00a0\n# To remove a node of a graph\nG.remove_node(3)\nnode_list = G.nodes()\nprint(\"#3\")\nprint(node_list)\n\u00a0\u00a0\u00a0\n# To remove an edge of a graph\nG.remove_edge(1,2)\nedge_list = G.edges()\nprint(\"#4\")\nprint(edge_list)\n\u00a0\u00a0\u00a0\n# To find number of nodes\nn = G.number_of_nodes()\nprint(\"#5\")\nprint(n)\n\u00a0\u00a0\u00a0\n# To find number of edges\nm = G.number_of_edges()\nprint(\"#6\")\nprint(m)\n\u00a0\u00a0\u00a0\n# To find degree of a node\n# d will store degree of node 2\nd = G.degree(2)\nprint(\"#7\")\nprint(d)\n\u00a0\u00a0\n# To find all the neighbor of a node\nneighbor_list = G.neighbors(2)\nprint(\"#8\")\nprint(neighbor_list)\n\u00a0\u00a0\n#To delete all the nodes and edges\nG.clear()\n"}
{"nl": "Python Module dir() Function\r\n", "code": "import platform\r\n\r\nx = dir(platform)\r\nprint(x)"}
{"nl": "Find n-th node in Postorder traversal of a Binary Tree", "code": "\"\"\"Python3 program to find n-th node of\r\nPostorder Traversal of Binary Tree\"\"\"\r\n\r\n# A Binary Tree Node\r\n# Utility function to create a new tree node\r\nclass createNode:\r\n\r\n\t# Constructor to create a newNode\r\n\tdef __init__(self, data):\r\n\t\tself.data= data\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# function to find the N-th node\r\n# in the postorder traversal of\r\n# a given binary tree\r\nflag = [0]\r\ndef NthPostordernode(root, N):\r\n\r\n\tif (root == None):\r\n\t\treturn\r\n\r\n\tif (flag[0] <= N[0]):\r\n\t\t\r\n\t\t# left recursion\r\n\t\tNthPostordernode(root.left, N)\r\n\r\n\t\t# right recursion\r\n\t\tNthPostordernode(root.right, N)\r\n\r\n\t\tflag[0] += 1\r\n\r\n\t\t# prints the n-th node of\r\n\t\t# preorder traversal\r\n\t\tif (flag[0] == N[0]):\r\n\t\t\tprint(root.data)\r\n\t\t\t\t\t\t\r\n# Driver Code\r\nif __name__ == '__main__':\r\n\troot = createNode(25)\r\n\troot.left = createNode(20)\r\n\troot.right = createNode(30)\r\n\troot.left.left = createNode(18)\r\n\troot.left.right = createNode(22)\r\n\troot.right.left = createNode(24)\r\n\troot.right.right = createNode(32)\r\n\r\n\tN = [6]\r\n\r\n\t# prints n-th node found\r\n\tNthPostordernode(root, N)\r\n\r\n# This code is contributed by\r\n# SHUBHAMSINGH10\r"}
{"nl": "Harshad Number in Python", "code": "# given number\nnum = 18\n# intiialize sum of digits to 0\nsum_of_digits = 0\n# copy the number in another variable(duplicate)\ndup_number = num\n# Traverse the digits of number using for loop\nwhile dup_number > 0:\n    sum_of_digits = sum_of_digits + dup_number % 10\n    dup_number = dup_number // 10\n# It is harshad number if sum of digits is equal to given number\n\nif(num % sum_of_digits == 0):\n    print(num, \"is harshad number\")\nelse:\n    print(num, \"is not harshad number\")"}
{"nl": "Regex Series: String Contains at Least One Digit", "code": "import re\ndef has_digit(txt):\n  return bool(re.search(r'\\d', txt))"}
{"nl": "Maximum equilibrium sum in an array", "code": "# Python3 program to find\r\n# maximum equilibrium sum.\r\n\r\n# Function to find maximum\r\n# equilibrium sum.\r\ndef findMaxSum(arr, n):\r\n\r\n\t# Array to store prefix sum.\r\n\tpreSum = [0 for i in range(n)]\r\n\r\n\t# Array to store suffix sum.\r\n\tsuffSum = [0 for i in range(n)]\r\n\r\n\t# Variable to store maximum sum.\r\n\tans = -10000000\r\n\r\n\t# Calculate prefix sum.\r\n\tpreSum[0] = arr[0]\r\n\t\r\n\tfor i in range(1, n):\r\n\t\r\n\t\tpreSum[i] = preSum[i - 1] + arr[i]\r\n\r\n\t# Calculate suffix sum and compare\r\n\t# it with prefix sum. Update ans\r\n\t# accordingly.\r\n\tsuffSum[n - 1] = arr[n - 1]\r\n\tif (preSum[n - 1] == suffSum[n - 1]):\r\n\t\tans = max(ans, preSum[n - 1])\r\n\t\r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tsuffSum[i] = suffSum[i + 1] + arr[i]\r\n\t\tif (suffSum[i] == preSum[i]):\r\n\t\t\tans = max(ans, preSum[i])\r\n\t\r\n\treturn ans\r\n\r\n# Driver Code\r\nif __name__=='__main__':\r\n\r\n\tarr = [-2, 5, 3, 1,2, 6, -4, 2]\r\n\tn = len(arr)\r\n\tprint(findMaxSum(arr, n))\r\n\t\r\n# This code i contributed by pratham76\r"}
{"nl": "maximum amount of money you can rob tonight without alerting the police", "code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 0 or nums is None:\n            return 0\n\n        if len(nums) == 1:\n            return nums[0]\n\n        return max(self.rob_simple(nums[:-1]), self.rob_simple(nums[1:]))\n\n    def rob_simple(self, nums: List[int]) -> int:\n        t1 = 0\n        t2 = 0\n        for current in nums:\n            temp = t1\n            t1 = max(current + t2, t1)\n            t2 = temp\n\n        return t1"}
{"nl": "Creating and using a module", "code": "#Save this code in a file named mymodule.py\n\ndef greeting(name):\n  print(\"Hello, \" + name)\nimport mymodule\nmymodule.greeting(\"Jonathan\")"}
{"nl": "Find the Most Frequent Element in a List\r", "code": "def find_frequent(lst):\r\n\treturn sorted(lst , key = lst.count)[-1];"}
{"nl": "Remove duplicate lines from text file", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\nreadFile = open(givenFilename, 'r')\n# Make another variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system.\nwriteFileName = \"samplewritefile.txt\"\n# Open another file in write mode. In this case, we're simply writing the contents of the file.\nwritingFile = open(\"writeFileName\", 'w')\n# Take an empty list to store the unique lines of the file.\nlineslist = []\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nfor line in readFile:\n  # Iterate through the lines of the file using the For loop.\n  # Check if the line is not in the list using the if, not, in operators.\n  if line not in lineslist:\n  # If the condition is true then write the line in the second file using the write function.\n  writingFile.write(line)\n  # Add the line to the above list using the append() function.\n  lineslist.append(line)"}
{"nl": "Python Program to Print Right Triangle of Mirrored Alphabets Pattern\n", "code": "rows = int(input(\"Enter Right Triangle Mirrored Alphabets Rows = \"))\n\nprint(\"====The Right Triangle of Mirrored Alphabets Pattern====\")\nalphabet = 65\n\nfor i in range(rows):\n    for j in range(i + 1):\n        print('%c' %(alphabet + j), end = '')\n    for k in range(i - 1, -1, -1):\n        print('%c' %(alphabet + k), end = '')\n    print()"}
{"nl": "Get Students with Names and Notes Average", "code": "def avg_note(students):\n    lst = students[0]['notes']\n    students[0]['avgNote'] = round(sum(lst) / len(lst)) if lst else 0\n    students[0].pop('notes')\n    return students"}
{"nl": "Find Minimum Depth of a Binary Tree", "code": "# Python program to find minimum depth of a given Binary Tree\n\n# Tree node\nclass Node:\n\tdef __init__(self , key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\ndef minDepth(root):\n\t# Corner Case.Should never be hit unless the code is\n\t# called on root = NULL\n\tif root is None:\n\t\treturn 0\n\t\n\t# Base Case : Leaf node.This accounts for height = 1\n\tif root.left is None and root.right is None:\n\t\treturn 1\n\t\n\t# If left subtree is Null, recur for right subtree\n\tif root.left is None:\n\t\treturn minDepth(root.right)+1\n\t\n\t# If right subtree is Null , recur for left subtree\n\tif root.right is None:\n\t\treturn minDepth(root.left) +1\n\t\n\treturn min(minDepth(root.left), minDepth(root.right))+1\n\n# Driver Program\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nprint (minDepth(root))\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\t\n"}
{"nl": "Python Program to Convert Temperature in Celsius to Fahrenheit & Kelvin", "code": "# Celsius to Fahrenheit & Kelvin\r\n\r\n# Reading temperature in Celsius\r\ncelsius = float(input('Enter temperature in celsius: '))\r\n\r\n# Converting\r\nfahrenheit = 1.8 * celsius + 32\r\nkelvin = 273.15 + celsius\r\n\r\n# Displaying output\r\nprint('%0.3f Celsius = %0.3f Fahrenheit.' % (celsius, fahrenheit))\r\nprint('%0.3f Celsius = %0.3f Kelvin.' % (celsius, kelvin))"}
{"nl": "Find Maximum Length Chain of Pairs using Dynamic Programming", "code": "# Python program for above approach\n\n# Structure val\nclass val:\n\tdef __init__(self,first,second):\n\t\tself.first = first\n\t\tself.second = second\n\t\n# Memoisation function\ndef findMaxChainLen(p, n, prev, pos):\n\t\n\tglobal m\n\t\n\t# Check if pair { pos, prev } exists\n\t# in m\n\tif (val(pos, prev) in m):\n\t\treturn m[val(pos, prev)]\n\n\t# Check if pos is >=n\n\tif (pos >= n):\n\t\treturn 0\n\n\t# Check if p[pos].first is\n\t# less than prev\n\tif (p[pos].first <= prev):\n\t\treturn findMaxChainLen(p, n, prev, pos + 1)\n\n\telse:\n\t\tans = max(findMaxChainLen(p, n,\n\t\t\t\t\t\t\tp[pos].second, 0) + 1,\n\t\t\t\t\tfindMaxChainLen(p, n,\n\t\t\t\t\t\t\t\tprev, pos + 1))\n\t\tm[val(pos, prev)] = ans\n\t\treturn ans\n\n# Function to calculate maximum\n# chain length\ndef maxChainLen(p,n):\n\n\tglobal m\n\tm.clear()\n\n\t# Call memoisation function\n\tans = findMaxChainLen(p, n, 0, 0)\n\treturn ans\n\n# Driver Code\nn = 5\np = [0]*n\np[0] = val(5,24)\n\np[1] = val(39,60)\n\np[2] = val(15,28)\n\np[3] = val(27,40)\n\np[4] = val(50,90)\n\nm = {}\n\n# Function Call\nprint(maxChainLen(p, n))\n\n# This code is contributed by shinjanpatra"}
{"nl": "Divide and Conquer Algorithm", "code": "# Python3 code to demonstrate Divide and\n# Conquer Algorithm\n\n# Function to find the maximum no.\n# in a given array.\ndef DAC_Max(a, index, l):\n\tmax = -1;\n\n\tif (index >= l - 2):\n\t\tif (a[index] > a[index + 1]):\n\t\t\treturn a[index];\n\t\telse:\n\t\t\treturn a[index + 1];\n\n\t# Logic to find the Maximum element\n\t# in the given array.\n\tmax = DAC_Max(a, index + 1, l);\n\n\tif (a[index] > max):\n\t\treturn a[index];\n\telse:\n\t\treturn max;\n\n# Function to find the minimum no.\n# in a given array.\ndef DAC_Min(a, index, l):\n\tmin = 0;\n\tif (index >= l - 2):\n\t\tif (a[index] < a[index + 1]):\n\t\t\treturn a[index];\n\t\telse:\n\t\t\treturn a[index + 1];\n\n\t# Logic to find the Minimum element\n\t# in the given array.\n\tmin = DAC_Min(a, index + 1, l);\n\n\tif (a[index] < min):\n\t\treturn a[index];\n\telse:\n\t\treturn min;\n\n# Driver Code\nif __name__ == '__main__':\n\n\t# Defining the variables\n\tmin, max = 0, -1;\n\n\t# Initializing the array\n\ta = [70, 250, 50, 80, 140, 12, 14];\n\n\t# Recursion - DAC_Max function called\n\tmax = DAC_Max(a, 0, 7);\n\n\t# Recursion - DAC_Max function called\n\tmin = DAC_Min(a, 0, 7);\n\tprint(\"The minimum number in a given array is : \", min);\n\tprint(\"The maximum number in a given array is : \", max);\n\n# This code is contributed by 29AjayKumar"}
{"nl": "Minimum insertions to form a palindrome with permutations allowed", "code": "# Python3 program to find minimum number\n# of insertions to make a string\n# palindrome\nimport math as mt\n\n# Function will return number of\n# characters to be added\ndef minInsertion(tr1):\n\n        # To store string length\n        n = len(str1)\n\n        # To store number of characters\n        # occurring odd number of times\n        res = 0\n\n        # To store count of each\n        # character\n        count = [0 for i in range(26)]\n\n        # To store occurrence of each\n        # character\n        for i in range(n):\n                count[ord(str1[i]) - ord('a')] += 1\n\n        # To count characters with odd\n        # occurrence\n        for i in range(26):\n                if (count[i] % 2 == 1):\n                        res += 1\n\n        # As one character can be odd return\n        # res - 1 but if string is already\n        # palindrome return 0\n        if (res == 0):\n                return 0\n        else:\n                return res - 1\n\n# Driver Code\nstr1 = \"geeksforgeeks\"\nprint(minInsertion(str1))\n\n# This code is contributed by\n# Mohit kumar 29\n"}
{"nl": "Count Possible Decodings of a given Digit Sequence", "code": "# Recursive implementation of numDecodings\ndef numDecodings(s: str) -> int:\n\tif len(s) == 0\n\tor (len(s) == 1\n\t\tand s[0] == '0'):\n\t\treturn 0\n\treturn numDecodingsHelper(s, len(s))\n\n\ndef numDecodingsHelper(s: str, n: int) -> int:\n\tif n == 0 or n == 1:\n\t\treturn 1\n\tcount = 0\n\tif s[n-1] > \"0\":\n\t\tcount = numDecodingsHelper(s, n-1)\n\tif (s[n - 2] == '1'\n\t\tor (s[n - 2] == '2'\n\t\t\tand s[n - 1] < '7')):\n\t\tcount += numDecodingsHelper(s, n - 2)\n\treturn count\n\n\n# Driver code\ndigits = \"1234\"\nprint(\"Count is \", numDecodings(digits))\n# This code is contributed by Frank Hu"}
{"nl": "Check for Symmetric Binary Tree (Iterative Approach)", "code": "# Python3 program to program to check if a\n# given Binary Tree is symmetric or not\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pairs.\t\t\t\t\t\t\t\t\t\nclass newNode:\n\n\t# Constructor to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\n# function to check if a given\n# Binary Tree is symmetric or not\ndef isSymmetric( root) :\n\n\t# if tree is empty\n\tif (root == None) :\n\t\treturn True\n\t\n\t# If it is a single tree node,\n\t# then it is a symmetric tree.\n\tif(not root.left and not root.right):\n\t\treturn True\n\t\n\tq = []\t\n\t\n\t# Add root to queue two times so that\n\t# it can be checked if either one\n\t# child alone is NULL or not.\n\tq.append(root)\n\tq.append(root)\n\t\n\t# To store two nodes for checking\n\t# their symmetry.\n\tleftNode = 0\n\trightNode = 0\n\t\n\twhile(not len(q)):\n\t\t\n\t\t# Remove first two nodes to\n\t\t# check their symmetry.\n\t\tleftNode = q[0]\n\t\tq.pop(0)\n\t\t\n\t\trightNode = q[0]\n\t\tq.pop(0)\n\t\t\n\t\t# if both left and right nodes\n\t\t# exist, but have different\n\t\t# values-. inequality, return False\n\t\tif(leftNode.key != rightNode.key):\n\t\t\treturn False\n\t\t\n\t\t# append left child of left subtree\n\t\t# node and right child of right\n\t\t# subtree node in queue.\n\t\tif(leftNode.left and rightNode.right) :\n\t\t\tq.append(leftNode.left)\n\t\t\tq.append(rightNode.right)\n\t\t\n\t\t# If only one child is present\n\t\t# alone and other is NULL, then\n\t\t# tree is not symmetric.\n\t\telse if (leftNode.left or rightNode.right) :\n\t\t\treturn False\n\t\t\n\t\t# append right child of left subtree\n\t\t# node and left child of right subtree\n\t\t# node in queue.\n\t\tif(leftNode.right and rightNode.left):\n\t\t\tq.append(leftNode.right)\n\t\t\tq.append(rightNode.left)\n\t\t\n\t\t# If only one child is present\n\t\t# alone and other is NULL, then\n\t\t# tree is not symmetric.\n\t\telse if(leftNode.right or rightNode.left):\n\t\t\treturn False\n\t\n\treturn True\n\t\t\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# Let us construct the Tree\n\t# shown in the above figure\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(2)\n\troot.left.left = newNode(3)\n\troot.left.right = newNode(4)\n\troot.right.left = newNode(4)\n\troot.right.right = newNode(3)\n\tif (isSymmetric(root)) :\n\t\tprint(\"The given tree is Symmetric\")\n\telse:\n\t\tprint(\"The given tree is not Symmetric\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Python Dictionary items() Method\r\n\r", "code": "car = {\r\n  \"brand\": \"Ford\",\r\n  \"model\": \"Mustang\",\r\n  \"year\": 1964\r\n}\r\n\r\nx = car.items()\r\n\r\nprint(x)"}
{"nl": "Calculate Distance Between Two Points ( Co-ordinates)", "code": "# Python Program to Calculate Distance \r\n\r\n# Reading co-ordinates\r\nx1 = float(input('Enter x1: '))\r\ny1 = float(input('Enter y1: '))\r\nx2 = float(input('Enter x2: '))\r\ny2 = float(input('Enter y2: '))\r\n\r\n# Calculating distance\r\nd = ( (x2-x1)**2 + (y2-y1)**2 ) ** 0.5\r\n\r\n# Displaying result\r\nprint('Distance = %f' %(d))"}
{"nl": "Area of a Circular Sector", "code": "# Give the radius as static input and store it in a variable.\r\ngvn_radiuss = 24\r\n# Give the angle as static input and store it in another variable.\r\ngvn_angl = 90\r\n# Take a variable and initialize its value to 22/7.\r\ngvn_pi = 22/7\r\n# Check if the given angle is greater than or equal to 360 degrees or not using the\r\n# if conditional statement.\r\nif gvn_angl >= 360:\r\n    # If it is true, then print \"Invalid Angle. Please enter the other\"\r\n    print(\"Invalid Angle. Please enter the other\")\r\nelse:\r\n    # Else, calculate the area of circular sector using the above given mathematical\r\n    # formula and store it in a variable.\r\n    area_of_sectr = (gvn_pi * gvn_radiuss ** 2) * (gvn_angl / 360)\r\n    # Print the area of circular sector for the given angle.\r\n    print(\"The area of circular sector for the given angle {\",\r\n          gvn_angl, \"} degrees = \", area_of_sectr)"}
{"nl": "maximum product of the length of two palindromic substrings", "code": "class Solution:\n    \n    def maxProduct(self, s: str) -> int:\n        mod = 10**9 + 7\n        base = 27\n        n = len(s)\n        forward_hash = [0] * (len(s) + 1)\n        backward_hash = [0] * (len(s) + 1)\n        for i in range(1, n+1):\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord('a'))) % mod\n        for i in range(n-1, -1, -1):\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord('a'))) % mod\n            \n        def is_parlin(s, center, l):\n            # check if it is a palin, with l being the radius\n            # [left, center-1] vs [center+1, right]\n            p = pow(base, l, mod)\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\n            return left_hash == right_hash\n        \n        # inclusive\n        before_idx_max_len = [1] * n\n        after_idx_max_len = [1] * n\n        \n        # for each center, expand\n        for i in range(1, n-1):\n            max_radius = 1\n            if s[i-1] != s[i+1]: # radius = 1 fails\n                continue\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\n            start, end = 1, min(i, n-i)\n            while start + 1 < end:\n                mid = (start + end) // 2\n                if is_parlin(s, i, mid):\n                    start = mid\n                else:\n                    end = mid\n            if i + end < n and is_parlin(s, i, end):\n                max_radius = end\n            else:\n                max_radius = start\n                \n            left = i - max_radius\n            right = i + max_radius\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\n        \n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\n        for i in range(n-2, -1, -1):\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\n        for i in range(1, n):\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\n        \n        # case2: find max till now using next array\n        for i in range(n-1, 0, -1):\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\n        for i in range(n-2, -1, -1):\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\n        \n        # print(before_idx_max_len, after_idx_max_len)\n        # find the best possible\n        res = 1\n        for i in range(n-1):\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\n            \n        return res"}
{"nl": "solving a sudoku puzzle", "code": "class Solution:\n    def solveSudoku(self, g: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        row, col, box, q = ['']*9, ['']*9, [['']*3 for _ in range(3)], []\n        for i in range(9):\n            for j in range(9):\n                if g[i][j]=='.':\n                    q.append((i,j))\n                else:\n                    row[i] += g[i][j]\n                    col[j] += g[i][j]\n                    box[i//3][j//3] += g[i][j]\n        \n        def backtrack():           \n            if not q:\n                return True\n            x, y = q[-1]\n            for n in '123456789':\n                if n not in row[x] and n not in col[y] and n not in box[x//3][y//3]:\n                    g[x][y] = n\n                    row[x] += n\n                    col[y] += n\n                    box[x//3][y//3] += n\n                    q.pop()\n                    if backtrack():\n                        return True\n                    else:\n                        g[x][y] = '.'\n                        row[x] = row[x][:-1]\n                        col[y] = col[y][:-1]\n                        box[x//3][y//3] = box[x//3][y//3][:-1]\n                        q.append((x, y))\n            return False\n        \n        backtrack()"}
{"nl": "Minimum Cost Path Dynamic Programming ", "code": "# Dynamic Programming Python implementation of Min Cost Path\n# problem\nR = 3\nC = 3\n\ndef minCost(cost, m, n):\n\n\t# Instead of following line, we can use int tc[m+1][n+1] or\n\t# dynamically allocate memoery to save space. The following\n\t# line is used to keep te program simple and make it working\n\t# on all compilers.\n\ttc = [[0 for x in range(C)] for x in range(R)]\n\n\ttc[0][0] = cost[0][0]\n\n\t# Initialize first column of total cost(tc) array\n\tfor i in range(1, m+1):\n\t\ttc[i][0] = tc[i-1][0] + cost[i][0]\n\n\t# Initialize first row of tc array\n\tfor j in range(1, n+1):\n\t\ttc[0][j] = tc[0][j-1] + cost[0][j]\n\n\t# Construct rest of the tc array\n\tfor i in range(1, m+1):\n\t\tfor j in range(1, n+1):\n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]\n\n\treturn tc[m][n]\n\n# Driver program to test above functions\ncost = [[1, 2, 3],\n\t\t[4, 8, 2],\n\t\t[1, 5, 3]]\nprint(minCost(cost, 2, 2))\n\n# This code is contributed by Bhavya Jain"}
{"nl": "List with Zero Sum", "code": "def list_with_zero_sum(n):\n    return list(range(n - 1)) + [(1 - n) * (n - 2) // 2]"}
{"nl": "Python Remove Duplicates from List", "code": "# Python program to remove duplicates from list # take list my_list = [1, 2, 3, 1, 5, 3, 4, 2, 7] # printing original list print('List:', my_list) # removed duplicates item using native method new_list = [] for i in my_list: if i not in new_list: new_list.append(i) # print list after item deletion print('New list:', new_list)"}
{"nl": "Print (Generate) Inverted Pyramid Star Pattern", "code": "# Generating Inverse Pyramid Pattern Using Stars\r\n\r\nrow = int(input('Enter number of rows required: '))\r\n\r\nfor i in range(row,0,-1):\r\n    for j in range(row-i):\r\n        print(' ', end='') # printing space and staying in same line\r\n    \r\n    for j in range(2*i-1):\r\n        print('*',end='') # printing * and staying in same line\r\n    print() # printing new line\r"}
{"nl": "Bridge Shuffle", "code": "def bridge_shuffle(lst1, lst2):\n  step = 1\n  for x in lst2:\n    lst1.insert(step,x)\n    step += 2\n  return lst1"}
{"nl": "Find perimeter of shapes formed with 1s in binary matrix", "code": "# Python3 program to find perimeter of area\n# covered by 1 in 2D matrix consists of 0's and 1's.\n\u00a0\nR = 3\nC = 5\n\u00a0\n# Find the number of covered side for mat[i][j].\ndef numofneighbour(mat, i, j):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0count = 0;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# UP\n\u00a0\u00a0\u00a0\u00a0if (i > 0 and mat[i - 1][j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# LEFT\n\u00a0\u00a0\u00a0\u00a0if (j > 0 and mat[i][j - 1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# DOWN\n\u00a0\u00a0\u00a0\u00a0if (i < R-1 and mat[i + 1][j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# RIGHT\n\u00a0\u00a0\u00a0\u00a0if (j < C-1 and mat[i][j + 1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+= 1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return count;\n\u00a0\n# Returns sum of perimeter of shapes formed with 1s\ndef findperimeter(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0perimeter = 0;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing the matrix and finding ones to\n\u00a0\u00a0\u00a0\u00a0# calculate their contribution.\n\u00a0\u00a0\u00a0\u00a0for i in range(0, R):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0, C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0perimeter += (4 - numofneighbour(mat, i, j));\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return perimeter;\n\u00a0\n# Driver Code\nmat = [ [0, 1, 0, 0, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 1, 0, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 0, 0, 0] ]\n\u00a0\nprint(findperimeter(mat), end=\"\\n\");\n\u00a0\n# This code is contributed by Akanksha Rai\n"}
{"nl": "Check if all characters of string are alphanumeric or not", "code": "# Give the string as static input and store it in a variable.\ngvn_strng = \"Hellobtechgeeks123\"\n# Check whether the Given string is alphanumeric using built-in alnum() method\n# and store it in another variable.\nBol_val = gvn_strng.isalnum()\n# Check whether the above result is True or not using the if conditional statement.\nif(Bol_val == True):\n # If it is True, Print the given string is  alphanumeric.\n  print(\"The Given string {\", gvn_strng, \"} is Alpha Numeric\")\nelse:\n  # If it is False, Print the given string is not alphanumeric.\n  print(\"The Given string {\", gvn_strng, \"} is not Alpha Numeric\")"}
{"nl": "Python Program to Find Maximum and Minimum Elements in List/Array Using Recursion", "code": "# Create a recursive function to say max_elemnt which takes the given list and\n \n # length of the given list as the arguments and returns the maximum element in a\n \n # given list using recursion.\n \n \n \n \n \n def max_elemnt(gven_lst, len_lst):\n \n  # Check if the length of the given list is 1 using the if conditional statement.\n \n  if len_lst == 1:\n \n  # If the statement is true, then return the first element of the list.\n \n  return gven_lst[0]\n \n  # Return maximum of (gven_lst[len_lst - 1], max_elemnt(gven_lst, len_lst - 1)\n \n  # {Recursive logic}.\n \n  return max(gven_lst[len_lst - 1], max_elemnt(gven_lst, len_lst - 1))\n \n \n \n # Create a recursive function to say min_elemnt which takes the given list and\n \n # length of the given list as the arguments and returns the minimum element in a\n \n # given list using recursion.\n \n \n \n \n \n def min_elemnt(gven_lst, len_lst):\n \n  # Check if the length of the given list is 1 using the if conditional statement.\n \n  if len_lst == 1:\n \n  # If the statement is true, then return the first element of the list.\n \n  return gven_lst[0]\n \n  # Return minimum of (gven_lst[len_lst-1], min_elemnt(gven_lst, len_lst-1)\n \n  # {Recursive logic}.\n \n  return min(gven_lst[len_lst-1], min_elemnt(gven_lst, len_lst-1))\n \n \n \n \n \n # Give the list as static input and store it in a variable.\n \n gven_lst = [1, 6, 3, 7, 8, 4]\n \n # Calculate the length of the given list and store it in another variable.\n \n len_lst = len(gven_lst)\n \n # Pass the given list and length of the given list as the arguments to the max_elemnt,\n \n # min_elemnt functions.\n \n # Print the maximum element of the given list.\n \n print(\"The Maximum element in a given list\",\n \n  gven_lst, \"=\", max_elemnt(gven_lst, len_lst))\n \n # Print the minimum element of the given list.\n \n print(\"The Minimum element in a given list\",\n \n  gven_lst, \"=\", min_elemnt(gven_lst, len_lst))"}
{"nl": "Move weighting scale alternate under given constraints", "code": "# Python3 program to print weights for\u00a0\u00a0\n# alternating the weighting scale\u00a0\n\u00a0\u00a0\n# DFS method to traverse among states\u00a0\n# of weighting scales\u00a0\ndef dfs(residue, curStep, wt, arr, N, steps):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If we reach to more than required\u00a0\n\u00a0\u00a0\u00a0\u00a0# steps, return true\u00a0\n\u00a0\u00a0\u00a0\u00a0if (curStep >= steps):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Try all possible weights and choose\u00a0\n\u00a0\u00a0\u00a0\u00a0# one which returns 1 afterwards\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Try this weight only if it is greater\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than current residueand not same as\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# previous chosen weight\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i] > residue and\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i] != wt[curStep - 1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# assign this weight to array and\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recur for next state\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wt[curStep] = arr[i]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dfs(arr[i] - residue, curStep + 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wt, arr, N, steps)):\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if any weight is not possible,\n\u00a0\u00a0\u00a0\u00a0# return false\u00a0\n\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\n# method prints weights for alternating scale\u00a0\n# and if not possible prints 'not possible'\u00a0\ndef printWeightsOnScale(arr, N, steps):\n\u00a0\u00a0\u00a0\u00a0wt = [0] * (steps)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# call dfs with current residue as 0\u00a0\n\u00a0\u00a0\u00a0\u00a0# and current steps as 0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (dfs(0, 0, wt, arr, N, steps)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(steps):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(wt[i], end = \" \")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Not possible\")\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0arr = [2, 3, 5, 6]\u00a0\n\u00a0\u00a0\u00a0\u00a0N = len(arr)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0steps = 10\n\u00a0\u00a0\u00a0\u00a0printWeightsOnScale(arr, N, steps)\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Remove Element from Tuple", "code": "# Give the tuple as static input and store it in a variable.\r\ngven_tup = (14, 32, 16, 85, 47, 65)\r\n# Give the number as static input and store it in another variable.\r\nnum = 3\r\n# Do out the Slicing from '0 ' to given 'n-1' and store it in a variable.\r\nfst_part = gven_tup[:num]\r\n# Again do out the Slicing from 'n+1' to given length of tuple (till end) and\r\n# store it in another variable.\r\nsecnd_part = gven_tup[num+1:]\r\n# Add the above two slicing parts using '+' operator and store it in a variable.\r\ngven_tup = fst_part + secnd_part\r\n# Print the final tuple after removal of given elements from the above given tuple.\r\nprint(\r\n    \"The above given tuple after removal of {\", num, \"} Element = \", gven_tup)"}
{"nl": "the number of trailing zeroes in n!", "code": "def trailingZeroes(self, n: int) -> int:\n        \n    # Calculate n!\n    n_factorial = 1\n    for i in range(2, n + 1):\n        n_factorial *= i\n    \n    # Count how many 0's are on the end.\n    zero_count = 0\n    while n_factorial % 10 == 0:\n        zero_count += 1\n        n_factorial //= 10\n        \n    return zero_count"}
{"nl": "print 1 and 0 in alternative rows", "code": "# Give the number of rows and number of columns as static input.\n# Store them in two separate variables row numbers and column numbers.\nrownumbs = 15\ncolnumbs = 11\n# Run an outer loop from 1 to rows to iterate through the rows using For loop.\nfor m in range(1, rownumbs+1):\n  # Iterate through the columns from 1 to cols using another For inner loop.\n  for n in range(1, colnumbs+1):\n  # Before printing any number, we must first check the condition inside the inner loop.\n  # This means that for every odd row, 1 is displayed, and for every even row, 0 is displayed.\n  # We check whether the row is odd or not using the if statement.\n  # If it is true then print 1 else print 0.\n  if(m % 2 == 1):\n  print('1', end=' ')\n  # If it is true then print 1 else print 0.\n  else:\n  print('0', end=' ')\n  print()"}
{"nl": "the value of an arithmetic expression in Reverse Polish Notation", "code": "def evalRPN(self, tokens: List[str]) -> int:\n        \n    operations = {\n        \"+\": lambda a, b: a + b,\n        \"-\": lambda a, b: a - b,\n        \"/\": lambda a, b: int(a / b),\n        \"*\": lambda a, b: a * b\n    }\n    \n    stack = []\n    for token in tokens:\n        if token in operations:\n            number_2 = stack.pop()\n            number_1 = stack.pop()\n            operation = operations[token]\n            stack.append(operation(number_1, number_2))\n        else:\n            stack.append(int(token))\n    return stack.pop()"}
{"nl": "maximum genetic difference query", "code": "class Solution:\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n        mp = {}\n        for i, (node, val) in enumerate(queries): \n            mp.setdefault(node, []).append([val, i])\n        \n        tree, root = {}, -1\n        for i, x in enumerate(parents): \n            if x == -1: root = i\n            else: tree.setdefault(x, []).append(i)\n        \n        ans = [0]*len(queries)\n        trie = Trie()\n        \n        def fn(x): \n            \"\"\"Collect query results while traversing the tree.\"\"\"\n            trie.insert(x)\n            for v, i in mp.get(x, []): ans[i] = trie.search(v)\n            for xx in tree.get(x, []): fn(xx)\n            trie.remove(x)\n        \n        fn(root)\n        return ans "}
{"nl": "Reverse a path in BST using queue", "code": "# Python3 code to demonstrate insert\n# operation in binary search tree\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# A utility function to\n# do inorder traversal of BST\ndef inorder(root):\n\u00a0\u00a0\u00a0\u00a0if root != None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(root.key, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.right)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# reverse tree path using queue\ndef reversePath(node, key, q1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty,\n\u00a0\u00a0\u00a0\u00a0# return a new node */\n\u00a0\u00a0\u00a0\u00a0if node == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the node key equal\n\u00a0\u00a0\u00a0\u00a0# to key then\n\u00a0\u00a0\u00a0\u00a0if node.key == key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push current node key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.insert(0, node.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# replace first node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# with last element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.key = q1[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# remove first element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if key smaller than node key then\n\u00a0\u00a0\u00a0\u00a0elif key < node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push node key into queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.insert(0, node.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursive call itself\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reversePath(node.left, key, q1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# replace queue front to node key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.key = q1[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# performe pop in queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if key greater than node key then\n\u00a0\u00a0\u00a0\u00a0elif (key > node.key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push node key into queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.insert(0, node.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursive call itself\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reversePath(node.right, key, q1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# replace queue front to node key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.key = q1[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# performe pop in queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return\n\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# A utility function to insert\n#a new node with given key in BST */\ndef insert(node, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty,\n\u00a0\u00a0\u00a0\u00a0# return a new node */\n\u00a0\u00a0\u00a0\u00a0if node == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Otherwise, recur down the tree */\n\u00a0\u00a0\u00a0\u00a0if key < node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.left = insert(node.left, key)\n\u00a0\u00a0\u00a0\u00a0elif key > node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.right = insert(node.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return the (unchanged) node pointer */\n\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us create following BST\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 50\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 /\u00a0\u00a0\u00a0\u00a0 \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 30\u00a0\u00a0\u00a0\u00a0 70\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 / \\ / \\\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0 20 40 60 80 */\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0q1 = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# reverse path till k\n\u00a0\u00a0\u00a0\u00a0k = 80;\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 50)\n\u00a0\u00a0\u00a0\u00a0insert(root, 30)\n\u00a0\u00a0\u00a0\u00a0insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0insert(root, 40)\n\u00a0\u00a0\u00a0\u00a0insert(root, 70)\n\u00a0\u00a0\u00a0\u00a0insert(root, 60)\n\u00a0\u00a0\u00a0\u00a0insert(root, 80)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Before Reverse :\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# print inorder traversal of the BST\n\u00a0\u00a0\u00a0\u00a0inorder(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# reverse path till k\n\u00a0\u00a0\u00a0\u00a0reversePath(root, k, q1)\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0print(\"After Reverse :\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# print inorder of reverse path tree\n\u00a0\u00a0\u00a0\u00a0inorder(root)\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "find target indices after sorting array", "code": "class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        ans = [0, 0]\n        for num in nums:\n            if num<target:\n                ans[0]+=1\n            elif num==target:\n                ans[1]+=1\n        return list(range(ans[0],ans[0]+ans[1]))"}
{"nl": "Lowercase, Uppercase or Mixed?", "code": "def get_case(txt):\n  return 'upper' if txt.isupper() else 'lower' if txt.islower() else 'mixed'"}
{"nl": "Python Program to Find the Greatest Digit in a Number.", "code": "# Give the number as static input and store it in a variable.\n \n gvn_num = 154\n \n # Convert the given number into string using str() function and\n \n # store it in another variable. \n \n str_numbr = str(gvn_num)\n \n # Convert the above obtained string number into list of digits using bulit-in list()\n \n # method and store it in another variable.\n \n lst = list(str_numbr)\n \n # Find the maximum of list of digits using bulit-in max() function\n \n # and store it in another variable.\n \n maxim_digit = max(lst)\n \n # Print the greatest digit in a given number.\n \n print(\"The maximum digit in given number {\", gvn_num, \"} = \", maxim_digit)"}
{"nl": "Find missing elements of a range", "code": "# Python library for binary search\nfrom bisect import bisect_left\n\n# A sorting based C++ program to find missing\n# elements from an array\n\n# Print all elements of range [low, high] that\n# are not present in arr[0..n-1]\n\ndef printMissing(arr, n, low, high):\n\t\n\t# Sort the array\n\tarr.sort()\n\t\n\t# Do binary search for 'low' in sorted\n\t# array and find index of first element\n\t# which either equal to or greater than\n\t# low.\n\tptr = bisect_left(arr, low)\n\tindex = ptr\n\t\n\t# Start from the found index and linearly\n\t# search every range element x after this\n\t# index in arr[]\n\ti = index\n\tx = low\n\twhile (i < n and x <= high):\n\t# If x doesn't match with current element\n\t# print it\n\t\tif(arr[i] != x):\n\t\t\tprint(x, end =\" \")\n\n\t# If x matches, move to next element in arr[]\n\t\telse:\n\t\t\ti = i + 1\n\t# Move to next element in range [low, high]\n\t\tx = x + 1\n\n\t# Print range elements that are greater than the\n\t# last element of sorted array.\n\twhile (x <= high):\n\t\tprint(x, end =\" \")\n\t\tx = x + 1\n\n\n# Driver code\n\narr = [1, 3, 5, 4]\nn = len(arr)\nlow = 1\nhigh = 10\nprintMissing(arr, n, low, high);\n\n# This code is contributed by YatinGupta"}
{"nl": "Lowercase and Uppercase Map", "code": "def mapping(letters):\n  return {i:i.upper() for i in letters}"}
{"nl": "tokenizing text, sentence, words works", "code": "from nltk.tokenize import sent_tokenize\r\n  \r\ntext = \"Hello everyone. Welcome to GeeksforGeeks. You are studying NLP article\"\r\nsent_tokenize(text)"}
{"nl": "every character in t (including duplicates) is included in the minimum substring window s", "code": "def minWindow(self, s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: str\n    \"\"\"\n    if not t or not s:\n        return \"\"\n\n    dict_t = Counter(t)\n\n    required = len(dict_t)\n\n    # Filter all the characters from s into a new list along with their index.\n    # The filtering criteria is that the character should be present in t.\n    filtered_s = []\n    for i, char in enumerate(s):\n        if char in dict_t:\n            filtered_s.append((i, char))\n\n    l, r = 0, 0\n    formed = 0\n    window_counts = {}\n\n    ans = float(\"inf\"), None, None\n\n    # Look for the characters only in the filtered list instead of entire s. This helps to reduce our search.\n    # Hence, we follow the sliding window approach on as small list.\n    while r < len(filtered_s):\n        character = filtered_s[r][1]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if window_counts[character] == dict_t[character]:\n            formed += 1\n\n        # If the current window has all the characters in desired frequencies i.e. t is present in the window\n        while l <= r and formed == required:\n            character = filtered_s[l][1]\n\n            # Save the smallest window until now.\n            end = filtered_s[r][0]\n            start = filtered_s[l][0]\n            if end - start + 1 < ans[0]:\n                ans = (end - start + 1, start, end)\n\n            window_counts[character] -= 1\n            if window_counts[character] < dict_t[character]:\n                formed -= 1\n            l += 1    \n\n        r += 1    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]"}
{"nl": "Select a random number from stream, with O(1) space", "code": "# An efficient python3 program\n# to randomly select a number\n# from stream of numbers.\nimport random\n\n# A function to randomly select a item\n# from stream[0], stream[1], .. stream[i-1]\n# The resultant random number\nres=0\n# Count of numbers visited\n# so far in stream\ncount=0\ndef selectRandom(x):\n\t\n\tglobal res\n\tglobal count\n\n\t# increment count of numbers\n\t# seen so far\n\tcount += 1;\n\n\t# If this is the first element\n\t# from stream, return it\n\tif (count == 1):\n\t\tres = x;\n\telse:\n\t\t\n\t\t# Generate a random number\n\t\t# from 0 to count - 1\n\t\ti = random.randrange(count);\n\n\t\t# Replace the prev random number\n\t\t# with new number with 1/count\n\t\t# probability\n\t\tif (i == count - 1):\n\t\t\tres = x;\n\treturn res;\n\n# Driver Code\nstream = [1, 2, 3, 4];\nn = len(stream);\n\n# Use a different seed value\n# for every run.\nfor i in range (n):\n\tprint(\"Random number from first\",\n\t\t(i + 1), \"numbers is\",\n\t\tselectRandom(stream[i]));\n\n# This code is contributed by mits"}
{"nl": "Fast Fibonacci", "code": "def fibFast(num):\n    a, b = 0, 1\n    for _ in range(num - 1):\n        a, b = b, a + b\n    return b"}
{"nl": "Turn off a particular bit in a number", "code": "# Returns a number that\n# has all bits same as n\n# except the k'th bit\n# which is made 0\n\ndef turnOffK(n,k):\n\n\t# k must be greater than 0\n\tif (k <= 0):\n\t\treturn n\n\n\t# Do & of n with a number\n\t# with all set bits except\n\t# the k'th bit\n\treturn (n & ~(1 << (k - 1)))\n\n\n# Driver code\nn = 15\nk = 4\nprint(turnOffK(n, k))\n\n# This code is contributed\n# by Anant Agarwal.\n"}
{"nl": "Print rhombus star pattern given number of rows", "code": "# Give the number of rows of the rhombus as static input and store it in a variable.\r\nrhombusrows = 19\r\n# Using Nested For loops print the rhombus star pattern.\r\nfor m in range(rhombusrows, 0, -1):\r\n    for n in range(1, m):\r\n        print(' ', end='')\r\n    for k in range(0, rhombusrows):\r\n        print('*', end='')\r\n    print()"}
{"nl": "Create Object\r\n", "code": "p1 = MyClass()\r\nprint(p1.x)"}
{"nl": "Median of two sorted arrays of same size", "code": "# A Simple Merge based O(n) Python 3 solution\n# to find median of two sorted lists\n\n# This function returns median of ar1[] and ar2[].\n# Assumptions in this function:\n# Both ar1[] and ar2[] are sorted arrays\n# Both have n elements\ndef getMedian( ar1, ar2 , n):\n\ti = 0 # Current index of i/p list ar1[]\n\t\n\tj = 0 # Current index of i/p list ar2[]\n\t\n\tm1 = -1\n\tm2 = -1\n\t\n\t# Since there are 2n elements, median\n\t# will be average of elements at index\n\t# n-1 and n in the array obtained after\n\t# merging ar1 and ar2\n\tcount = 0\n\twhile count < n + 1:\n\t\tcount += 1\n\t\t\n\t\t# Below is to handle case where all\n\t\t# elements of ar1[] are smaller than\n\t\t# smallest(or first) element of ar2[]\n\t\tif i == n:\n\t\t\tm1 = m2\n\t\t\tm2 = ar2[0]\n\t\t\tbreak\n\t\t\n\t\t# Below is to handle case where all\n\t\t# elements of ar2[] are smaller than\n\t\t# smallest(or first) element of ar1[]\n\t\telif j == n:\n\t\t\tm1 = m2\n\t\t\tm2 = ar1[0]\n\t\t\tbreak\n\t\t# equals sign because if two\n\t\t# arrays have some common elements\n\t\tif ar1[i] <= ar2[j]:\n\t\t\tm1 = m2 # Store the prev median\n\t\t\tm2 = ar1[i]\n\t\t\ti += 1\n\t\telse:\n\t\t\tm1 = m2 # Store the prev median\n\t\t\tm2 = ar2[j]\n\t\t\tj += 1\n\treturn (m1 + m2)/2\n\n# Driver code to test above function\nar1 = [1, 12, 15, 26, 38]\nar2 = [2, 13, 17, 30, 45]\nn1 = len(ar1)\nn2 = len(ar2)\nif n1 == n2:\n\tprint(\"Median is \", getMedian(ar1, ar2, n1))\nelse:\n\tprint(\"Doesn't work for arrays of unequal size\")\n\n# This code is contributed by \"Sharad_Bhardwaj\"."}
{"nl": "print the series (1,2,4,8,16,32\u2026N) till the given number N in Python.", "code": "# Give the number N as static input and store it in a variable.\r\ngvn_numb = 200\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\nwhile itr <= gvn_numb:\r\n  # If it is true then print the value of itr separated by spaces.\r\n    print(itr, end=\" \")\r\n    # Multiply the itr value with 2 and store it in the same variable itr.\r\n    itr *= 2"}
{"nl": "Sum Zero Tuples", "code": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        \n        # hashmap and final result count\n        nums12, res = defaultdict(int), 0\n        \n        # storing all possible combinations of sum\n        for i in nums1:\n            for j in nums2:\n                nums12[i+j] += 1\n        \n        # iterating the left out two array to find negation of same value\n        for k in nums3:\n            for l in nums4:\n                res += nums12[-(k+l)]\n        \n        return res"}
{"nl": "Understanding the difference Between == and \u2018is\u2019 in Python", "code": "listone = [\"this\", \"is\", \"BTechGeeks\"]\r\nlisttwo = [\"this\", \"is\", \"BTechGeeks\"]\r\nprint(listone == listtwo)\r\nprint(listone is listtwo)\r\n# assigning list two with list one\r\nlisttwo = listone\r\nprint(\"After assigning list two with list one:\")\r\n# using is\r\nprint(listone is listtwo)"}
{"nl": "Python program to remove duplicate elements from a Circular Linked List", "code": "#Represents the node of list.    \n#Represents the node of list.    \nclass Node:    \n  def __init__(self,data):    \n    self.data = data;    \n    self.next = None;    \n    \nclass CreateList:    \n  #Declaring head and tail pointer as null.    \n  def __init__(self):    \n    self.head = Node(None);    \n    self.tail = Node(None);    \n    self.head.next = self.tail;    \n    self.tail.next = self.head;    \n      \n  #This function will add the new node at the end of the list.    \n  def add(self,data):    \n    newNode = Node(data);    \n    #Checks if the list is empty.    \n    if self.head.data is None:    \n      #If list is empty, both head and tail would point to new node.    \n      self.head = newNode;    \n      self.tail = newNode;    \n      newNode.next = self.head;    \n    else:    \n      #tail will point to new node.    \n      self.tail.next = newNode;    \n      #New node will become new tail.    \n      self.tail = newNode;    \n      #Since, it is circular linked list tail will point to head.    \n      self.tail.next = self.head;    \n      \n  #Removes duplicate from the list    \n  def removeDuplicate(self):    \n    #Current will point to head    \n    current = self.head;    \n    if(self.head == None):    \n      print(\"List is empty\");    \n    else:    \n      while(True):    \n        #Temp will point to previous node of index.    \n        temp = current;    \n        #Index will point to node next to current    \n        index = current.next;    \n        while(index != self.head):    \n          #If current node is equal to index data    \n          if(current.data == index.data):    \n            #Here, index node is pointing to the node which is duplicate of current node    \n            #Skips the duplicate node by pointing to next node    \n            temp.next = index.next;    \n          else:    \n            #Temp will point to previous node of index.    \n            temp = index;    \n          index= index.next;    \n        current =current.next;    \n        if(current.next == self.head):    \n          break;    \n              \n  #Displays all the nodes in the list    \n  def display(self):    \n    current = self.head;    \n    if self.head is None:    \n      print(\"List is empty\");    \n      return;    \n    else:    \n      #Prints each node by incrementing pointer.    \n      print(current.data);    \n      while(current.next != self.head):    \n        current = current.next;    \n        print(current.data);    \n    print(\"\\n\");    \n          \nclass CircularLinkedList:    \n  cl = CreateList();    \n  #Adds data to the list    \n  cl.add(1);    \n  cl.add(2);    \n  cl.add(3);    \n  cl.add(2);    \n  cl.add(2);    \n  cl.add(4);    \n      \n  print(\"Originals list: \");    \n  cl.display();    \n  #Removes duplicate nodes    \n  cl.removeDuplicate();    \n  print(\"List after removing duplicates: \");    \n  cl.display();    "}
{"nl": "the ordering of courses you should take to finish all courses", "code": "from collections import defaultdict\nclass Solution:\n\n    WHITE = 1\n    GRAY = 2\n    BLACK = 3\n\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n\n        # Create the adjacency list representation of the graph\n        adj_list = defaultdict(list)\n\n        # A pair [a, b] in the input represents edge from b --> a\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n\n        topological_sorted_order = []\n        is_possible = True\n\n        # By default all vertces are WHITE\n        color = {k: Solution.WHITE for k in range(numCourses)}\n        def dfs(node):\n            nonlocal is_possible\n\n            # Don't recurse further if we found a cycle already\n            if not is_possible:\n                return\n\n            # Start the recursion\n            color[node] = Solution.GRAY\n\n            # Traverse on neighboring vertices\n            if node in adj_list:\n                for neighbor in adj_list[node]:\n                    if color[neighbor] == Solution.WHITE:\n                        dfs(neighbor)\n                    elif color[neighbor] == Solution.GRAY:\n                         # An edge to a GRAY vertex represents a cycle\n                        is_possible = False\n\n            # Recursion ends. We mark it as black\n            color[node] = Solution.BLACK\n            topological_sorted_order.append(node)\n\n        for vertex in range(numCourses):\n            # If the node is unprocessed, then call dfs on it.\n            if color[vertex] == Solution.WHITE:\n                dfs(vertex)\n\n        return topological_sorted_order[::-1] if is_possible else []"}
{"nl": "Remove duplicate values from dictionary", "code": "# Give the dictionary as static input and store it in a variable.\ngvn_dict ={1: 100, 2: 90, 3: 80, 4: 100, 5:80}\n# Print the given dictionary\nprint(\"The given dictionary:\",gvn_dict)\n# Take an empty list and store it in aother variable.\nnew_lst =[]\n# Create a new empty dictionary and store it in aother variable.\noutput_dict ={}\n# Loop in the key, value of the given dictionary using the for loop and the items() functions\nfor key, value in gvn_dict.items():\n    # Check if the corresponding value is not present in the above created new list using the \n    # if conditional statement\n    if value not in new_lst:\n        # If it is true then append that value to the above list \n        # Here it appends the value to the new list if it is a unique element\n        new_lst.append(value)\n        # Assign this unique key and value to the new dictionary\n        output_dict[key] = value\n# Print the result dictionary after the removal of duplicates\nprint(\"The result dictionary after the removal of duplicates:\",output_dict)"}
{"nl": "Kth ancestor of a tree node", "code": "step = 15\n  def __init__(self, n, A):\n  A = dict(enumerate(A))\n  jump = [A]\n  for s in xrange(self.step):\n  B = {}\n  for i in A:\n  if A[i] in A:\n  B[i] = A[A[i]]\n  jump.append(B)\n  A = B\n  self.jump = jump\n\n  def getKthAncestor(self, x, k):\n  step = self.step\n  while k > 0 and x > -1:\n  if k >= 1 << step:\n  x = self.jump[step].get(x, -1)\n  k -= 1 << step\n  else:\n  step -= 1\n  return x"}
{"nl": "Python Program to Solve Triangular Matchstick Number", "code": "# Give the number as user input using the int(input()) function and Store it in a variable.\nno_bse_subtringls = int(input(\"Enter some random number =  \"))\n# Calculate the total number of sub triangle's required by using above mathematical formula\n# (N * (N + 1)) / 2) and store it in another variable.\ntot_subtringle = (no_bse_subtringls * (no_bse_subtringls + 1)) // 2\n# Multiply the above obtained total sub triangle's with '3' to get the total number of\n# sticks required and Store it in another variable.\ntot_sticks = tot_subtringle * 3\n# Print the Total number of sticks required to form a above given entire triangle.\nprint(\"The Total number of matchsticks needed to form a above given entire triangle = \", tot_sticks)"}
{"nl": "Print Ancestors of a given node in Binary Tree", "code": "# Python program to print ancestors of given node in\n# binary tree\n\u00a0\n# A Binary Tree node\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# If target is present in tree, then prints the ancestors\n# and returns true, otherwise returns false\ndef printAncestors(root, target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if root.data == target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If target is present in either left or right subtree\n\u00a0\u00a0\u00a0\u00a0# of this node, then print this node\n\u00a0\u00a0\u00a0\u00a0if (printAncestors(root.left, target) or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printAncestors(root.right, target)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(root.data,end=' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Else return False\n\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.left.left.left = Node(7)\n\u00a0\nprintAncestors(root, 7)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Find the number of islands", "code": "# Program to count islands in boolean 2D matrix\nclass Graph:\n\n        def __init__(self, row, col, g):\n                self.ROW = row\n                self.COL = col\n                self.graph = g\n\n        # A function to check if a given cell\n        # (row, col) can be included in DFS\n        def isSafe(self, i, j, visited):\n                # row number is in range, column number\n                # is in range and value is 1\n                # and not yet visited\n                return (i >= 0 and i < self.ROW and\n                                j >= 0 and j < self.COL and\n                                not visited[i][j] and self.graph[i][j])\n                        \n\n        # A utility function to do DFS for a 2D\n        # boolean matrix. It only considers\n        # the 8 neighbours as adjacent vertices\n        def DFS(self, i, j, visited):\n\n                # These arrays are used to get row and\n                # column numbers of 8 neighbours\n                # of a given cell\n                rowNbr = [-1, -1, -1, 0, 0, 1, 1, 1];\n                colNbr = [-1, 0, 1, -1, 1, -1, 0, 1];\n                \n                # Mark this cell as visited\n                visited[i][j] = True\n\n                # Recur for all connected neighbours\n                for k in range(8):\n                        if self.isSafe(i + rowNbr[k], j + colNbr[k], visited):\n                                self.DFS(i + rowNbr[k], j + colNbr[k], visited)\n\n\n        # The main function that returns\n        # count of islands in a given boolean\n        # 2D matrix\n        def countIslands(self):\n                # Make a bool array to mark visited cells.\n                # Initially all cells are unvisited\n                visited = [[False for j in range(self.COL)]for i in range(self.ROW)]\n\n                # Initialize count as 0 and traverse\n                # through the all cells of\n                # given matrix\n                count = 0\n                for i in range(self.ROW):\n                        for j in range(self.COL):\n                                # If a cell with value 1 is not visited yet,\n                                # then new island found\n                                if visited[i][j] == False and self.graph[i][j] == 1:\n                                        # Visit all cells in this island\n                                        # and increment island count\n                                        self.DFS(i, j, visited)\n                                        count += 1\n\n                return count\n\n\ngraph = [[1, 1, 0, 0, 0],\n                [0, 1, 0, 0, 1],\n                [1, 0, 0, 1, 1],\n                [0, 0, 0, 0, 0],\n                [1, 0, 1, 0, 1]]\n\n\nrow = len(graph)\ncol = len(graph[0])\n\ng = Graph(row, col, graph)\n\nprint (\"Number of islands is:\")\nprint (g.countIslands())\n\n# This code is contributed by Neelam Yadav\n"}
{"nl": "Shuffle string", "code": "class Solution:\n  def restoreString(self, s: str, indices: List[int]) -> str:\n  res = [''] * len(s)\n  for index, char in enumerate(s):\n  res[indices[index]] = char\n  return \"\".join(res)"}
{"nl": "check if all characters have equal number of occurences", "code": "```class Solution:\n    def areOccurrencesEqual(self, s: str) -> bool:\n        \n        save = []\n        \n        news = list([str(x) for x in s])  # change s from string to a list  \n        \n        for i in set(news): # save the count of occurrances in save\n            save.append(news.count(i))\n        \n        for i in save: # if any number is not the same like save[0], return False\n            if i != save[0]:\n                return False\n            \n        return True"}
{"nl": "Random Choice of Random Module in Python with no Repeat", "code": "# Import the random module using the import keyword.\r\nimport random\r\n# Give the number n as static input and store it in a variable.\r\nnumbe = 13\r\n# Give the lower limit range and upper limit range as static input\r\n# and store them in two separate variables.\r\nlowerlimitrange = 19\r\nupperlimitrange = 45\r\n# Take an empty list (say rndmnumbs) and initialize it with an empty list\r\n# using [] or list().\r\nrndmnumbs = []\r\n# Loop till n times using For loop.\r\nfor m in range(numbe):\r\n        # Generate a random number using randint(lowerlimitrange,upperlimitrange)\r\n    # and store it in a variable.\r\n    randomnumbe = random.randint(lowerlimitrange, upperlimitrange)\r\n    # Check whether the above random number is present in the list or not\r\n    # using not in operator.\r\n    if randomnumbe not in rndmnumbs:\r\n        # If it is not in the list then append the element\r\n        # to the rndmnumbs list using the append() function.\r\n        rndmnumbs.append(randomnumbe)\r\n\r\n# Print the rndmnumbs\r\nprint('The random numbers present in the range from',\r\n      lowerlimitrange, 'to', upperlimitrange, 'are :')\r\nfor q in rndmnumbs:\r\n    print(q, end=' ')"}
{"nl": "Exercise working with ciphers: create an implementation of the affine cipher, an ancient encryption system created in the Middle East.", "code": "import math\r\nimport string\r\ndef lookup(a, b, reverse=False):\r\n    if math.gcd(a, 26) > 1:\r\n        raise ValueError('a and m must be coprime.')\r\n    lookup = ''.join(chr(((ord(c)-ord('a'))*a+b)%26+ord('a'))\r\n                     for c in string.ascii_lowercase)\r\n    if reverse:\r\n        return str.maketrans(lookup, string.ascii_lowercase,\r\n                             string.whitespace)\r\n    else:\r\n        return str.maketrans(string.ascii_lowercase, lookup,\r\n                             string.whitespace+string.punctuation)\r\ndef encode(plain_text, a, b):\r\n    encoded = plain_text.lower().translate(lookup(a, b))\r\n    return ' '.join(encoded[i:i+5] for i in range(0,len(encoded),5))\r\ndef decode(ciphered_text, a, b):\r\n    return ciphered_text.lower().translate(lookup(a, b, reverse=True))"}
{"nl": "Python Program to Print Square of Right Decrement Numbers Pattern\n", "code": "rows = int(input(\"Enter Square of Right Decrement Numbers Rows = \"))\n\nprint(\"====The Square of Right Decremented Numbers Pattern====\")\n\nfor i in range(rows, 0, -1):\n    for j in range(rows, i - 1, -1):\n        print(j, end = ' ')\n    for k in range(rows - i + 1, rows):\n        print(i, end = ' ')\n    print()"}
{"nl": "maximum product difference between two pairs", "code": "class Solution:\n    def maxProductDifference(self, nums: List[int]) -> int:\n        nums.sort()\n        return ((nums[len(nums)-1] * nums[len(nums)-2]) - (nums[0] * nums[1]))"}
{"nl": "Magic Square | Even Order", "code": "# Python program to print magic square of double order\n\u00a0\ndef DoublyEven(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2-D matrix with all entries as 0\n\u00a0\u00a0\u00a0\u00a0arr = [[(n*y)+x+1 for x in range(n)]for y in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Change value of array elements at fix location\n\u00a0\u00a0\u00a0\u00a0# as per the rule (n*n+1)-arr[i][[j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Corners of order (n/4)*(n/4)\n\u00a0\u00a0\u00a0\u00a0# Top left corner\n\u00a0\u00a0\u00a0\u00a0for i in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Top right corner\n\u00a0\u00a0\u00a0\u00a0for i in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Bottom Left corner\n\u00a0\u00a0\u00a0\u00a0for i in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0,n//4):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Bottom Right corner\n\u00a0\u00a0\u00a0\u00a0for i in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(3 * (n//4),n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Centre of matrix,order (n/2)*(n/2)\n\u00a0\u00a0\u00a0\u00a0for i in range(n//4,3 * (n//4)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n//4,3 * (n//4)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i][j] = (n*n + 1) - arr[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Printing the square\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print ('%2d ' %(arr[i][j]),end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Program\nn = 8\nDoublyEven(n)\n\u00a0\n# Contributed by Harshit Agrawal\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n"}
{"nl": "Python math.atanh() Method", "code": "#Import math Library\r\nimport math\r\n\r\n#print the hyperbolic arctangent of different numbers\r\nprint(math.atanh(0.59))\r\nprint(math.atanh(-0.12))"}
{"nl": "Python Program for Given Two Numbers a and b Find all x Such that a % x = b", "code": "# Import the math module using the import keyword.\nimport math\n\n# Create a function to say a_mod_xisb which takes the given two numbers as the arguments\n# and returns all the values of x such that given a % x = b.\n\n\ndef a_mod_xisb(gvn_a_val, gvn_b_val):\n    # Check if the given number a is less than the given b value using the if conditional\n    # statement.\n\n    if (gvn_a_val < gvn_b_val):\n      # If it is true then print \"There are no solutions possible\".\n        print(\"There are no solutions possible\")\n        # Return.\n        return\n    # Check if the given a value is equal to the given b value using the if conditional\n    # statement.\n    if (gvn_a_val == gvn_b_val):\n        # If it is true then print \"Infinite Solutions are possible for the equation\".\n        # Return.\n        print(\"Infinite Solutions are possible for the equation\")\n        return\n    # Take a variable say cnt and initialize its value to 0.\n    cnt = 0\n    # Subtract the given b value from the given a value and store it in another variable\n    # say rslt.\n\n    rslt = gvn_a_val - gvn_b_val\n    # Calculate the value of square root of (gvn_a_val - gvn_b_val) using the math.sqrt()\n    # function and convert result to an integer using the int() function.\n    # Store it in another variable say k.\n    k = (int)(math.sqrt(gvn_a_val - gvn_b_val))\n    # Loop from 1 to the above result k using the for loop.\n    for itr in range(1, k+1):\n      # Inside the loop, check if the above value of rslt modulus iterator value is equal\n      # to 0 using the if conditional statement.\n        if (rslt % itr == 0):\n          # Again check if the rslt divided by the iterator value greater than the given b value\n          # using the if conditional statement.\n            if (rslt / itr > gvn_b_val):\n              # If it is true, increment the count value by 1 and store it in the same variable.\n                cnt = cnt + 1\n      # Check if the iterator value is greater than the given b value using the if\n          # conditional statement.\n            if (itr > gvn_b_val):\n                # If it is true, increment the count value by 1 and store it in the same variable.\n                cnt = cnt + 1\n        # Check if the k multiplied with itself is equal to the rslt and k greater than the\n        # given b value using the if conditional statement.\n    if (k * k == rslt and k > gvn_b_val):\n        # If it is true, decrement the count value by 1 and store it in the same variable.\n        cnt = cnt - 1\n    # Print the value of x such that given a%x==b.\n    print(\n        \"The value of x such that given a%x==b {a,b =\", gvn_a_val, gvn_b_val, \"} = \", cnt)\n\n\n# Give the number as user input using the int(input()) function and\n# store it in a variable.\ngvn_a_val = int(input(\"Enter some random number = \"))\n# Give the other number as user input using the int(input()) function and\n# store it in another variable.\ngvn_b_val = int(input(\"Enter some random number = \"))\n# Pass the given number two numbers as the arguments to the a_mod_xisb function.\na_mod_xisb(gvn_a_val, gvn_b_val)"}
{"nl": "Clear nth Bit of a Number", "code": "# Give the number as user input using the int(input()) function and \r\n# store it in a variable.\r\ngvn_numb = int(input(\"Enter some random number = \"))\r\n# Give the bit position as user input using the int(input()) function \r\n# and store it in another variable.\r\nbitpositin = int(input(\"Enter some random number = \"))\r\n# Apply the left shift operator to 1 and the above-given bit position and\r\n# store it in another variable.\r\nnumbr_bit = (1 << bitpositin)\r\n# Apply the complement operator (which converts 0 to 1 and vice-versa) to the above result\r\n# and store it in another variable.\r\ncomplemt = (~numbr_bit)\r\n# Apply bitwise & operation for the given number and the above result and store it in\r\n# another variable say rslt_numb.\r\nrslt_numb = gvn_numb & complemt\r\n# Print the number after clearing the bit at the given position for a given number.\r\nprint(\"The Number after clearing the bit at the given position{\",\r\n      bitpositin, \"} for a given number{\", gvn_numb, \"} =\", rslt_numb)"}
{"nl": "Python program to check if the given number is a Disarium Number", "code": "#calculateLength() will count the digits present in a number    \ndef calculateLength(n):    \n    length = 0;    \n    while(n != 0):    \n        length = length + 1;    \n        n = n//10;    \n    return length;    \n     \nnum = 175;    \nrem = sum = 0;    \nlen = calculateLength(num);    \n     \n#Makes a copy of the original number num    \nn = num;    \n     \n#Calculates the sum of digits powered with their respective position    \nwhile(num > 0):    \n    rem = num%10;    \n    sum = sum + int(rem**len);    \n    num = num//10;    \n    len = len - 1;    \n     \n#Checks whether the sum is equal to the number itself    \nif(sum == n):    \n    print(str(n) + \" is a disarium number\");    \nelse:    \n    print(str(n) + \" is not a disarium number\");    "}
{"nl": "Implement Insertion Sort", "code": "def insertion_sort(alist):\n    for i in range(1, len(alist)):\n        temp = alist[i]\n        j = i - 1\n        while (j >= 0 and temp < alist[j]):\n            alist[j + 1] = alist[j]\n            j = j - 1\n        alist[j + 1] = temp\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\ninsertion_sort(alist)\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "Python Program to Print Triangle of Mirrored Numbers Pattern\n", "code": "rows = int(input(\"Enter Triangle Mirrored Numbers Rows = \"))\n\nprint(\"====The Triangle of Mirrored Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(rows, i, -1):\n        print(end = ' ')\n    for k in range(1, i + 1):\n        print(k, end = '')\n    for l in range(i - 1, 0, -1):\n        print(l, end = '')\n    print()"}
{"nl": "Detect cycle in an undirected graph", "code": "# Python Program to detect cycle in an undirected graph\nfrom collections import defaultdict\n\u00a0\u00a0\n# This class represents a undirected\n# graph using adjacency list representation\nclass Graph:\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self,vertices):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# No. of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V= vertices #No. of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Default dictionary to store graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to add an edge to graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,v,w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#Add w to v_s list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[v].append(w)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#Add v to w_s list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[w].append(v)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# A recursive function that uses\n\u00a0\u00a0\u00a0\u00a0# visited[] and parent to detect\n\u00a0\u00a0\u00a0\u00a0# cycle in subgraph reachable from vertex v.\n\u00a0\u00a0\u00a0\u00a0def isCyclicUtil(self,v,visited,parent):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark the current node as visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[v]= True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Recur for all the vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# adjacent to this vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in self.graph[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the node is not\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited then recurse on it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0 visited[i]==False :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(self.isCyclicUtil(i,visited,v)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If an adjacent vertex is\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited and not parent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# of current vertex,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then there is a cycle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif\u00a0 parent!=i:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if the graph\n\u00a0\u00a0\u00a0\u00a0# contains a cycle, else false.\n\u00a0\u00a0\u00a0\u00a0def isCyclic(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark all the vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as not visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited =[False]*(self.V)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Call the recursive helper\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# function to detect cycle in different\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# DFS trees\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(self.V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Don't recur for u if it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is already visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[i] ==False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(self.isCyclicUtil\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(i,visited,-1)) == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n# Create a graph given in the above diagram\ng = Graph(5)\ng.addEdge(1, 0)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(0, 3)\ng.addEdge(3, 4)\n\u00a0\nif g.isCyclic():\n\u00a0\u00a0\u00a0\u00a0print (\"Graph contains cycle\")\nelse :\n\u00a0\u00a0\u00a0\u00a0print (\"Graph does not contain cycle \")\ng1 = Graph(3)\ng1.addEdge(0,1)\ng1.addEdge(1,2)\n\u00a0\n\u00a0\nif g1.isCyclic():\n\u00a0\u00a0\u00a0\u00a0print (\"Graph contains cycle\")\nelse :\n\u00a0\u00a0\u00a0\u00a0print (\"Graph does not contain cycle \")\n\u00a0\u00a0\n#This code is contributed by Neelam Yadav\n"}
{"nl": "Count Instances of a Character in a String", "code": "def char_count(txt1, txt2):\n  return txt2.count(txt1)"}
{"nl": "Minimize the maximum difference between the heights", "code": "# User function Template\r\ndef getMinDiff(arr, n, k):\r\n\tarr.sort()\r\n\tans = arr[n - 1] - arr[0] # Maximum possible height difference\r\n\r\n\ttempmin = arr[0]\r\n\ttempmax = arr[n - 1]\r\n\r\n\tfor i in range(1, n):\r\n\t\ttempmin = min(arr[0] + k, arr[i] - k)\r\n\t\t\r\n\t\t# Minimum element when we\r\n\t\t# add k to whole array\r\n\t\t# Maximum element when we\r\n\t\ttempmax = max(arr[i - 1] + k, arr[n - 1] - k)\r\n\t\t\r\n\t\t# subtract k from whole array\r\n\t\tans = min(ans, tempmax - tempmin)\r\n\r\n\treturn ans\r\n\r\n# Driver Code Starts\r\nk = 6\r\nn = 6\r\narr = [7, 4, 8, 8, 8, 9]\r\nans = getMinDiff(arr, n, k)\r\nprint(ans)\r\n\r\n# This code is contributed by ninja_hattori.\r"}
{"nl": "Reversal algorithm for array rotation", "code": "# Python program for reversal algorithm of array rotation\n\n# Function to reverse arr[] from index start to end\n\n\ndef reverseArray(arr, start, end):\n        while (start < end):\n                temp = arr[start]\n                arr[start] = arr[end]\n                arr[end] = temp\n                start += 1\n                end = end-1\n\n# Function to left rotate arr[] of size n by d\n\n\ndef leftRotate(arr, d):\n\n        if d == 0:\n                return\n        n = len(arr)\n        # in case the rotating factor is\n        # greater than array length\n        d = d % n\n        reverseArray(arr, 0, d-1)\n        reverseArray(arr, d, n-1)\n        reverseArray(arr, 0, n-1)\n\n# Function to print an array\n\n\ndef printArray(arr):\n        for i in range(0, len(arr)):\n                print (arr[i],end=' ')\n\n\n# Driver function to test above functions\narr = [1, 2, 3, 4, 5, 6, 7]\nn = len(arr)\nd = 2\n\nleftRotate(arr, d) # Rotate array by 2\nprintArray(arr)\n\n# This code is contributed by Devesh Agrawal\n"}
{"nl": "Pair with given sum and maximum shortest distance from end", "code": "# Python3 code to find maximum shortest\n# distance from endpoints\n\n# function to find maximum shortest distance\ndef find_maximum(a, n, k):\n\t\n\t# stores the shortest distance of every\n\t# element in original array.\n\tb = dict()\n\t\n\tfor i in range(n):\n\t\tx = a[i]\n\t\t\n\t\t# shortest distance from ends\n\t\td = min(1 + i, n - i)\n\t\tif x not in b.keys():\n\t\t\tb[x] = d\n\t\telse:\n\n\t\t\t# if duplicates are found, b[x]\n\t\t\t# is replaced with minimum of the\n\t\t\t# previous and current position's\n\t\t\t# shortest distance*/\n\t\t\tb[x] = min(d, b[x])\n\t\n\tans = 10**9\n\tfor i in range(n):\n\t\tx = a[i]\n\t\t\n\t\t# similar elements ignore them\n\t\t# cause we need distinct elements\n\t\tif (x != (k - x) and (k - x) in b.keys()):\t\t\n\t\t\tans = min(max(b[x], b[k - x]), ans)\n\n\treturn ans\n\n# Driver code\na = [3, 5, 8, 6, 7]\nK = 11\nn = len(a)\nprint(find_maximum(a, n, K))\n\n# This code is contributed by mohit kumar"}
{"nl": "rotate the array to the right by k steps", "code": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        n = len(nums)\n        a = [0] * n\n        for i in range(n):\n            a[(i + k) % n] = nums[i]\n            \n        nums[:] = a"}
{"nl": "Python Program to Check Whether a String is a Palindrome or not Using Recursion", "code": "# function which checks the given string is palindrome or not using recursion\n# if th given string is palindrome then it is true else the string is false.\n\n\ndef checkPalindromeRecursion(givenstr):\n  # Calculate the length of the string using the len() function.\n    stringLen = len(givenstr)\n    # If the length of the string is less than 1, the function returns True.\n    if stringLen < 1:\n        return True\n    else:\n      # If the end letter is the same as the initial letter, execute the function\n      # recursively with the parameter as the sliced list\n      # with the first and last characters deleted, otherwise return False.\n      # Use an if statement to determine whether the given string is\n      # True or False and then print the result.\n        if givenstr[0] == givenstr[-1]:\n            return checkPalindromeRecursion(givenstr[1:-1])\n        else:\n            return False\n\n\n# Give some string as static input and store it in a variable.\ngiven_str = 'btechgeeksskeeghcetb'\n# Pass the string to a recursive function checkPalindromeRecursion function as an argument.\n# If the function returns true then the given string is a palindrome.\nif(checkPalindromeRecursion(given_str)):\n    print(\"The given string [\", given_str, '] is a palindrome')\n# Else the given string is not a palindrome.\nelse:\n    print(\"The given string\", given_str, 'is not a palindrome')"}
{"nl": "count words that can be obtained after adding a letter to a string", "code": "class Solution:\n    def wordCount(self, sw: List[str], t: List[str]) -> int:\n        hash=set()\n        \n        for word in sw:\n            s=0\n            for x in word:\n                k=ord(x)-97\n                s=s|(1<<k)\n            hash.add(s)\n        ans=0\n        for word in t:\n            s=0\n            for x in word:\n                k=ord(x)-97\n                s=s|(1<<k)\n            for x in word:\n                k=ord(x)-97\n                if s^(1<<k) in hash:\n                    ans+=1\n                    break\n                \n                \n                    \n        return ans\n        "}
{"nl": "Write a function to delete a Linked List\n", "code": "# Python3 program to delete all\n# the nodes of singly linked list\n\n# Node class\n\n\nclass Node:\n\n        # Function to initialise the node object\n        def __init__(self, data):\n                self.data = data # Assign data\n                self.next = None # Initialize next as null\n\n\n# Constructor to initialize the node object\nclass LinkedList:\n\n        # Function to initialize head\n        def __init__(self):\n                self.head = None\n\n        def deleteList(self):\n\n                # initialize the current node\n                current = self.head\n                while current:\n                        prev = current.next # move next node\n\n                        # delete the current node\n                        del current.data\n\n                        # set current equals prev node\n                        current = prev\n\n                # In python garbage collection happens\n                # therefore, only\n                # self.head = None\n                # would also delete the link list\n\n        # push function to add node in front of llist\n        def push(self, new_data):\n\n                # Allocate the Node &\n                # Put in the data\n                new_node = Node(new_data)\n\n                # Make next of new Node as head\n                new_node.next = self.head\n\n                # Move the head to point to new Node\n                self.head = new_node\n\n\n# Use push() to construct below\n# list 1-> 12-> 1-> 4-> 1\nif __name__ == '__main__':\n\n        llist = LinkedList()\n        llist.push(1)\n        llist.push(4)\n        llist.push(1)\n        llist.push(12)\n        llist.push(1)\n\n        print(\"Deleting linked list\")\n        llist.deleteList()\n\n        print(\"Linked list deleted\")\n\n\n# This article is provided by Shrikant13\n"}
{"nl": "Check whether kth Bit of a Number is Set", "code": "# Give the number and the value of k as static input # and store it in a variable.\r\nnumb = 19\r\nk = 2\r\n# First, compute number>>(k-1) and store it in a variable called temp, resulting in temp=number>>(k-1).\r\n# If the kth bit is set, the last bit of temp will be 1, otherwise, it will be 0.\r\ntemp = numb >> (k-1)\r\n# You must execute a bitwise AND of 1 and temp in this step.\r\n# If this gives a non-zero integer,\r\n# the kth bit of the number is set, otherwise, it is not.\r\nif (1 & temp):\r\n        # If it is true then print the kth bit is set bit.\r\n    print('The', k, 'nd bit in the number ', numb,\r\n          '(binary representation =', bin(numb)[2:], ') is set bit')\r\n# Else print it is not set bit.\r\nelse:\r\n    print('The', k, 'nd bit in the number', numb,\r\n          '(binary representation =', bin(numb)[2:], ')is not a set bit')"}
{"nl": "corresponding column title as it appears in an Excel sheet", "code": "class Solution:\n    # @return a string\n    def convertToTitle(self, num):\n        capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\n        result = []\n        while num > 0:\n            result.append(capitals[(num-1)%26])\n            num = (num-1) // 26\n        result.reverse()\n        return ''.join(result)"}
{"nl": "Check if X can give change to every person in the Queue", "code": "# Python program to check whether X can\r\n# give change to every person in the Queue\r\n\r\n# Function to check if every person\r\n# will get the change from X\r\ndef isChangeable(notes, n):\r\n\t\r\n\t# To count the 5$ and 10& notes\r\n\tfiveCount = 0\r\n\ttenCount = 0\r\n\t\r\n\t# Serve the customer in order\r\n\tfor i in range(n):\r\n\t\t\r\n\t\t# Increase the number of 5$ note by one\r\n\t\tif (notes[i] == 5):\r\n\t\t\tfiveCount += 1\r\n\t\telif(notes[i] == 10):\r\n\t\t\t\r\n\t\t\t# decrease the number of note 5$\r\n\t\t\t# and increase 10$ note by one\r\n\t\t\tif (fiveCount > 0):\r\n\t\t\t\tfiveCount -= 1\r\n\t\t\t\ttenCount += 1\r\n\t\t\telse:\r\n\t\t\t\treturn 0\r\n\t\telse:\r\n\t\t\t\r\n\t\t\t# decrease 5$ and 10$ note by one\r\n\t\t\tif (fiveCount > 0 and tenCount > 0):\r\n\t\t\t\tfiveCount -= 1\r\n\t\t\t\ttenCount -= 1\r\n\t\t\t\t\r\n\t\t\t# decrease 5$ note by three\r\n\t\t\telif (fiveCount >= 3):\r\n\t\t\t\tfiveCount -= 3\r\n\t\t\telse:\r\n\t\t\t\treturn 0\r\n\treturn 1\r\n\r\n# Driver Code\r\n\r\n# queue of customers with available notes.\r\na = [5, 5, 5, 10, 20 ]\r\nn = len(a)\r\n\r\n# Calling function\r\nif (isChangeable(a, n)):\r\n\tprint(\"YES\")\r\nelse:\r\n\tprint(\"NO\")\r\n\r\n# This code is contributed by PrinciRaj1992\r"}
{"nl": "Efficient Huffman Coding for Sorted Input", "code": "# Python3 program for Efficient Huffman Coding\n# for Sorted input\n\n# Class for the nodes of the Huffman tree\nclass QueueNode:\n\t\n\tdef __init__(self, data = None, freq = None,\n\t\t\t\tleft = None, right = None):\n\t\tself.data = data\n\t\tself.freq = freq\n\t\tself.left = left\n\t\tself.right = right\n\n\t# Function to check if the following\n\t# node is a leaf node\n\tdef isLeaf(self):\n\t\treturn (self.left == None and\n\t\t\t\tself.right == None)\n\n# Class for the two Queues\nclass Queue:\n\t\n\tdef __init__(self):\n\t\tself.queue = []\n\n\t# Function for checking if the\n\t# queue has only 1 node\n\tdef isSizeOne(self):\n\t\treturn len(self.queue) == 1\n\n\t# Function for checking if\n\t# the queue is empty\n\tdef isEmpty(self):\n\t\treturn self.queue == []\n\n\t# Function to add item to the queue\n\tdef enqueue(self, x):\n\t\tself.queue.append(x)\n\n\t# Function to remove item from the queue\n\tdef dequeue(self):\n\t\treturn self.queue.pop(0)\n\n# Function to get minimum item from two queues\ndef findMin(firstQueue, secondQueue):\n\t\n\t# Step 3.1: If second queue is empty,\n\t# dequeue from first queue\n\tif secondQueue.isEmpty():\n\t\treturn firstQueue.dequeue()\n\n\t# Step 3.2: If first queue is empty,\n\t# dequeue from second queue\n\tif firstQueue.isEmpty():\n\t\treturn secondQueue.dequeue()\n\n\t# Step 3.3: Else, compare the front of\n\t# two queues and dequeue minimum\n\tif (firstQueue.queue[0].freq <\n\t\tsecondQueue.queue[0].freq):\n\t\treturn firstQueue.dequeue()\n\n\treturn secondQueue.dequeue()\n\n# The main function that builds Huffman tree\ndef buildHuffmanTree(data, freq, size):\n\t\n\t# Step 1: Create two empty queues\n\tfirstQueue = Queue()\n\tsecondQueue = Queue()\n\n\t# Step 2: Create a leaf node for each unique\n\t# character and Enqueue it to the first queue\n\t# in non-decreasing order of frequency.\n\t# Initially second queue is empty.\n\tfor i in range(size):\n\t\tfirstQueue.enqueue(QueueNode(data[i], freq[i]))\n\n\t# Run while Queues contain more than one node.\n\t# Finally, first queue will be empty and\n\t# second queue will contain only one node\n\twhile not (firstQueue.isEmpty() and\n\t\t\tsecondQueue.isSizeOne()):\n\t\t\t\t\t\n\t\t# Step 3: Dequeue two nodes with the minimum\n\t\t# frequency by examining the front of both queues\n\t\tleft = findMin(firstQueue, secondQueue)\n\t\tright = findMin(firstQueue, secondQueue)\n\n\t\t# Step 4: Create a new internal node with\n\t\t# frequency equal to the sum of the two\n\t\t# nodes frequencies. Enqueue this node\n\t\t# to second queue.\n\t\ttop = QueueNode(\"$\", left.freq + right.freq,\n\t\t\t\t\t\tleft, right)\n\t\tsecondQueue.enqueue(top)\n\n\treturn secondQueue.dequeue()\n\n# Prints huffman codes from the root of\n# Huffman tree. It uses arr[] to store codes\ndef printCodes(root, arr):\n\t\n\t# Assign 0 to left edge and recur\n\tif root.left:\n\t\tarr.append(0)\n\t\tprintCodes(root.left, arr)\n\t\tarr.pop(-1)\n\n\t# Assign 1 to right edge and recur\n\tif root.right:\n\t\tarr.append(1)\n\t\tprintCodes(root.right, arr)\n\t\tarr.pop(-1)\n\n\t# If this is a leaf node, then it contains\n\t# one of the input characters, print the\n\t# character and its code from arr[]\n\tif root.isLeaf():\n\t\tprint(f\"{root.data}: \", end = \"\")\n\t\tfor i in arr:\n\t\t\tprint(i, end = \"\")\n\t\t\t\n\t\tprint()\n\n# The main function that builds a Huffman\n# tree and print codes by traversing the\n# built Huffman tree\ndef HuffmanCodes(data, freq, size):\n\t\n\t# Construct Huffman Tree\n\troot = buildHuffmanTree(data, freq, size)\n\n\t# Print Huffman codes using the Huffman\n\t# tree built above\n\tarr = []\n\tprintCodes(root, arr)\n\n# Driver code\narr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\nfreq = [5, 9, 12, 13, 16, 45]\nsize = len(arr)\n\nHuffmanCodes(arr, freq, size)\n\n# This code is contributed by Kevin Joshi"}
{"nl": "best time to sell a stock at most two transactions", "code": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        t1_cost, t2_cost = float('inf'), float('inf')\n        t1_profit, t2_profit = 0, 0\n\n        for price in prices:\n            # the maximum profit if only one transaction is allowed\n            t1_cost = min(t1_cost, price)\n            t1_profit = max(t1_profit, price - t1_cost)\n            # reinvest the gained profit in the second transaction\n            t2_cost = min(t2_cost, price - t1_profit)\n            t2_profit = max(t2_profit, price - t2_cost)\n\n        return t2_profit"}
{"nl": "Correctly determine the fewest number of coins to be given to a customer such that the sum of the coins' value would equal the correct amount of change.", "code": "change = []\r\ndef find_fewest_coins(coins, target):\r\n    if target < 0:\r\n        raise ValueError(\"target can't be negative\")\r\n    if target == 0:\r\n        return []\r\n    if target < coins[0]:\r\n        raise ValueError(\"can't make target with given coins\")\r\n    global change\r\n    change = list()\r\n    for index in range(len(coins))[::-1]:\r\n        find_combination(0, coins, target, [], index)\r\n    if len(change) == 0:\r\n        raise ValueError(\"can't make target with given coins\")\r\n    return sorted(change)\r\ndef find_combination(balance, coins, target, p, index):\r\n    global change\r\n    p = list(p)\r\n    if balance == target:\r\n        change = list(p)\r\n        return\r\n    if len(p) >= len(change) > 0:\r\n        return\r\n    if index < 0:\r\n        return\r\n    if coins[index] + balance > target:\r\n        find_combination(balance, coins, target, p, index - 1)\r\n        return\r\n    balance = balance + coins[index]\r\n    p.append(coins[index])\r\n    find_combination(balance, coins, target, p, index)\r\n    find_combination(balance, coins, target, p, index - 1)"}
{"nl": "Python Program to Swap Major and Minor Diagonals of a Square Matrix", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[6, 2, 0], [1, 4, 2], [3, 7, 5]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n print(\"The given matix after swapping the major and the minor diagonal elements: \")\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, swap mtrx[n][n], mtrx[n][mtrxrows-n-1] using the comma(,) operator\n  # ( where n is the iterator value and mtrxrows is the no of rows of matrix).\n  mtrx[n][n], mtrx[n][mtrxrows-n-1] = mtrx[n][mtrxrows-n-1], mtrx[n][n]\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of rows using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Print the element of the matrix by printing gvnmatrix[n][m] value\n  # where n is the iterator value of the parent For loop and m is the iterator\n  # value of the inner For loop.\n  print(mtrx[n][m], end=' ')\n  print()"}
{"nl": "Find product of values of dictionary", "code": "# Take a dictionary and initialize it with an empty dictionary using dict() or {}.\ngvn_dict = {}\n# Give the number of keys as user input using int(input()) and store it in a variable.\nnumb_of_kys = int(\n    input('Enter some random number of keys of the dictionary = '))\n# Loop till the given number of keys using for loop.\nfor p in range(numb_of_kys):\n        # Inside the for loop scan the key and value as\n    # user input using input(),split() functions\n    # and store them in two separate variables.\n    keyy, valuee =  input(\n        'Enter key and value separated by spaces = ').split()\n    # Initialize the key with the value of the dictionary.\n    gvn_dict[keyy] = valuee\n\n# Get all the values of given dictionary using dictionary.values() method\n# and store it in another variable.\ndict_vlue = gvn_dict.values()\n# Take a variable say 'product' and initialize it's value with '1'\nfnl_prod = 1\n# Iterate in the above given dictionary values using using For loop.\nfor itrator in dict_vlue:\n  # Inside the loop, Multiply the above initialized product variable with the iterator\n  # and store it in a same variable.\n    fnl_prod = fnl_prod*int(itrator)\n# Print the product of values for the above given dictionary.\nprint(\"The Product of values in a given dictionary = \", fnl_prod)"}
{"nl": "Mangle The String", "code": "def mangle(txt):\n  x = ['A' if i in 'zZ' else chr(ord(i)+1) if i.isalpha() else i for i in txt]\n  return ''.join(i.upper() if i in 'aeiou' else i for i in x)"}
{"nl": "Python Program to Flatten a Nested List", "code": "my_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = [num for sublist in my_list for num in sublist]\nprint(flat_list)\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = []\nfor sublist in my_list:\n    for num in sublist:\n        flat_list.append(num)\n\nprint(flat_list)\nimport itertools\n\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = list(itertools.chain(*my_list))\nprint(flat_list)\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\n\nflat_list = sum(my_list, [])\nprint(flat_list)\nfrom functools import reduce\n\nmy_list = [[1], [2, 3], [4, 5, 6, 7]]\nprint(reduce(lambda x, y: x+y, my_list))"}
{"nl": "Find the Largest Prime within a Range", "code": "def fat_prime(a, b):\n  s, e = min(a,b), max(a,b)\n  return max(i for i in range(s,e+1) if all(i%j for j in range(2,int(i**0.5)+1)))"}
{"nl": "Inplace rotate square matrix by 90 degrees", "code": "# Python3 program to rotate a matrix by 90 degrees\r\nN = 4\r\n\r\n# An Inplace function to rotate\r\n# N x N matrix by 90 degrees in\r\n# anti-clockwise direction\r\ndef rotateMatrix(mat):\r\n\t\r\n\t# Consider all squares one by one\r\n\tfor x in range(0, int(N / 2)):\r\n\t\t\r\n\t\t# Consider elements in group\r\n\t\t# of 4 in current square\r\n\t\tfor y in range(x, N-x-1):\r\n\t\t\t\r\n\t\t\t# store current cell in temp variable\r\n\t\t\ttemp = mat[x][y]\r\n\r\n\t\t\t# move values from right to top\r\n\t\t\tmat[x][y] = mat[y][N-1-x]\r\n\r\n\t\t\t# move values from bottom to right\r\n\t\t\tmat[y][N-1-x] = mat[N-1-x][N-1-y]\r\n\r\n\t\t\t# move values from left to bottom\r\n\t\t\tmat[N-1-x][N-1-y] = mat[N-1-y][x]\r\n\r\n\t\t\t# assign temp to left\r\n\t\t\tmat[N-1-y][x] = temp\r\n\r\n\r\n# Function to print the matrix\r\ndef displayMatrix( mat ):\r\n\t\r\n\tfor i in range(0, N):\r\n\t\t\r\n\t\tfor j in range(0, N):\r\n\t\t\t\r\n\t\t\tprint (mat[i][j], end = ' ')\r\n\t\tprint (\"\")\r\n\t\r\n\t\r\n\r\n\r\n# Driver Code\r\nmat = [[0 for x in range(N)] for y in range(N)]\r\n\r\n# Test case 1\r\nmat = [ [1, 2, 3, 4 ],\r\n\t\t[5, 6, 7, 8 ],\r\n\t\t[9, 10, 11, 12 ],\r\n\t\t[13, 14, 15, 16 ] ]\r\n\t\t\r\n'''\r\n# Test case 2\r\nmat = [ [1, 2, 3 ],\r\n\t\t[4, 5, 6 ],\r\n\t\t[7, 8, 9 ] ]\r\n\r\n# Test case 3\r\nmat = [ [1, 2 ],\r\n\t\t[4, 5 ] ]\r\n\t\t\r\n'''\r\n\r\nrotateMatrix(mat)\r\n\r\n# Print rotated matrix\r\ndisplayMatrix(mat)\r\n\r\n\r\n# This code is contributed by saloni1297\r"}
{"nl": "minimum total wasted space by choosing the box supplier optimally given n packages", "code": "class Solution:\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\n        packages.sort()\n        largest_package = packages[-1]\n        all_boxes = []\n\n        for i, box in enumerate(boxes):\n            # Optional: ignore box lists that don't work at the start. \n            # Spends time finding max to save time sorting/iterating later.\n            if max(box) >= largest_package:\n                all_boxes.extend(((x, i) for x in box))\n\n        if not all_boxes:\n            return -1\n\n        all_boxes.sort(key=lambda j: j[0])\n\n        space_wasted_by_box = [0] * len(boxes)\n        last_package_handled = [-1] * len(boxes)\n        package_ptr, num_packages = 0, len(packages)\n\n        # Find smallest box that fits the smallest package\n        start_index = bisect.bisect_right(all_boxes, (packages[0], -1))\n\n        for box_size, orig_ind in all_boxes[start_index:]:\n            # Package_ptr always points to the largest package with size <= box_size\n            while package_ptr + 1 < num_packages and packages[package_ptr + 1] <= box_size:\n                package_ptr += 1\n\n            if last_package_handled[orig_ind] < package_ptr:\n                space_wasted_by_box[orig_ind] += (package_ptr - last_package_handled[orig_ind]) * box_size\n                last_package_handled[orig_ind] = package_ptr\n\n        smallest_waste = min(space_wasted_by_box[i] for i in range(len(boxes)) if last_package_handled[i] == num_packages - 1)\n        return (smallest_waste - sum(packages)) % 1000000007"}
{"nl": "Python Program to Compute Sum of Digits in a String", "code": "# python program to compute sum of digits in a string # take input string = input(\"Enter any string: \") # find sum of digits sum_digit = 0 for x in string: if x.isdigit(): sum_digit += int(x) # display result print(\"Sum of digits =\", sum_digit)"}
{"nl": "Given a list, move the negative elements in the list to the end of the list.", "code": "# Give the list as static input and store it in a variable.\r\ngvnlst = [1, 9, -3, 6, 8, 11, 35, -5, -7, 10, -1, -2, -3]\r\n# Using list comprehension and if conditional statements\r\n# separate the positive numbers from the list\r\n# and store it in a variable to say the positive list.\r\npstivelist = [elemn for elemn in gvnlst if elemn >= 0]\r\n# Using list comprehension and if conditional statements\r\n# separate the negative numbers from the list and store it\r\n# in a variable to say the negative list.\r\nngtivelist = [elemn for elemn in gvnlst if elemn < 0]\r\n# Add the positive list and negative list using the + operator\r\n# and store it in another variable to say result list\r\n# (This operation moves all the negative list).\r\nresltlist = pstivelist+ngtivelist\r\n# Print the result list.\r\nprint('The given list after moving negative elements to the end is', resltlist)"}
{"nl": "Find the Largest Element in a Doubly Linked List", "code": "class Node:\n    def __init__(self, data):\n       self.data = data\n       self.next = None\n       self.prev = None\n\u00a0\n\u00a0\nclass DoublyLinkedList:\n    def __init__(self):\n        self.first = None\n        self.last = None\n\u00a0\n    def append(self, data):\n        self.insert_at_end(Node(data))\n\u00a0\n    def insert_at_end(self, new_node):\n        if self.last is None:\n            self.last = new_node\n            self.first = new_node\n        else:\n            new_node.prev = self.last\n            self.last.next = new_node\n            self.last = new_node\n\u00a0\n\u00a0\ndef find_largest(dllist):\n    if dllist.first is None:\n        return None\n    largest = dllist.first.data\n    current = dllist.first.next\n    while current:\n        if current.data > largest:\n            largest = current.data\n        current = current.next\n    return largest\n\u00a0\n\u00a0\na_dllist = DoublyLinkedList()\n\u00a0\ndata_list = input('Please enter the elements in the doubly linked list: ').split()\nfor data in data_list:\n    a_dllist.append(int(data))\n\u00a0\nlargest = find_largest(a_dllist)\nif largest:\n    print('The largest element is {}.'.format(largest))\nelse:\n    print('The list is empty.')"}
{"nl": "Python Program to Convert Gray Code to Binary", "code": "# function which accepts the gray code  and returns the binary code  of the gray code\ndef grayToBin(grayCde):\n   # Converting the given gray code to integer\n    graynum = int(grayCde, 2)\n   # Taking a temporary variable which stores the the gray code integer number\n    tempnum = graynum\n    # using while loop\n    while tempnum != 0:\n        tempnum >>= 1\n        graynum ^= tempnum\n\n        # bin(n) returns n's binary representation with the prefix '0b' removed\n        # the slice operation removes the prefix.\n    return bin(graynum)[2:]\n\n\n# given gray code as static\ngraycode = input(\"Enter some random gray code string = \")\n# passing this graycode to grayToBin function\nresultbin = grayToBin(graycode)\nprint('The Binary string of the given gray code=', graycode, 'is', resultbin)"}
{"nl": "Reverse an array or string", "code": "# Iterative python program to reverse an array\n\n# Function to reverse A[] from start to end\ndef reverseList(A, start, end):\n\twhile start < end:\n\t\tA[start], A[end] = A[end], A[start]\n\t\tstart += 1\n\t\tend -= 1\n\n# Driver function to test above function\nA = [1, 2, 3, 4, 5, 6]\nprint(A)\nreverseList(A, 0, 5)\nprint(\"Reversed list is\")\nprint(A)\n# This program is contributed by Pratik Chhajer"}
{"nl": "Create UIs for prototyping machine learning model with Gradio", "code": "\r\ndef factorial(integer):\r\n    \"\"\" Returns factorial of the given integer\"\"\"\r\n    n = int(integer)\r\n    if n<=1:\r\n        return 1\r\n    fact=1\r\n    for i in range(1, n+1):\r\n        fact*=i\r\n    return fact\r\nimport gradio\r\ngradio.Interface(factorial, inputs=\"text\", outputs=\"text\").launch(share=True)\r\n# imported necessary libraries\r\nimport gradio as gr\r\nimport tensorflow as tf\r\nimport numpy as np\r\nimport requests\r\n \r\n# loading the model\r\ninception_net = tf.keras.applications.InceptionV3()\r\n \r\n# Download human-readable labels.\r\nresponse = requests.get(\"https://git.io/JJkYN\")\r\nlabels = response.text.split(\"\\n\")\r\n \r\ndef classify_image(image):\r\n    \"\"\" Returns a dictionary with key as label and values\r\n    as the predicted confidence for that label\"\"\"\r\n    # reshaping the image\r\n    image = image.reshape((-1, 299, 299, 3))\r\n    # preprocessing the image for inception_v3\r\n    image = tf.keras.applications.inception_v3.preprocess_input(image)\r\n    # predicting the output\r\n    prediction = inception_net.predict(image).flatten()\r\n    return {labels[i]: float(prediction[i]) for i in range(1000)}\r\n \r\n# initializing the input component\r\nimage = gr.inputs.Image(shape = (299, 299, 3))\r\n# initializing the output component\r\nlabel = gr.outputs.Label(num_top_classes = 3)\r\n \r\n# launching the interface\r\ngr.Interface(fn = classify_image, inputs = image,\r\n             outputs = label, capture_session = True).launch()"}
{"nl": "Count Vowels in a String in Python", "code": "# Python program to count vowels in a string def countVowels(string): num_vowels=0 # to count the vowels for char in string: if char in \"aeiouAEIOU\": num_vowels = num_vowels+1 return num_vowels # take input string = input('Enter any string: ') # calling function and display result print('No of vowels =',countVowels(string))"}
{"nl": "Length of the longest valid substring", "code": "# Python program to find length of the longest valid\n# substring\n\u00a0\n\u00a0\ndef findMaxLen(string):\n\u00a0\u00a0\u00a0\u00a0n = len(string)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a stack and push -1\n\u00a0\u00a0\u00a0\u00a0# as initial index to it.\n\u00a0\u00a0\u00a0\u00a0stk = []\n\u00a0\u00a0\u00a0\u00a0stk.append(-1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize result\n\u00a0\u00a0\u00a0\u00a0result = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse all characters of given string\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If opening bracket, push index of it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if string[i] == '(':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If closing bracket, i.e., str[i] = ')'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pop the previous opening bracket's index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if len(stk) != 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if this length formed with base of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current valid substring is more than max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# so far\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if len(stk) != 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = max(result,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i - stk[len(stk)-1])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If stack is empty. push current index as\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# base for next valid substring (if any)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return result\n\u00a0\n\u00a0\n# Driver code\nstring = \"((()()\"\n\u00a0\n# Function call\nprint (findMaxLen(string))\n\u00a0\nstring = \"()(()))))\"\n\u00a0\n# Function call\nprint (findMaxLen(string))\n\u00a0\n# This code is contributed by Bhavya Jain\n"}
{"nl": "Number of Covered Integers", "code": "def covered_integers(lst):\n  return len({i for l, u in lst for i in range(l, u+1)})"}
{"nl": "Python Program to Find the Sum of Natural Numbers", "code": "# Sum of natural numbers up to num\n\nnum = 16\n\nif num < 0:\n   print(\"Enter a positive number\")\nelse:\n   sum = 0\n   # use while loop to iterate until zero\n   while(num > 0):\n       sum += num\n       num -= 1\n   print(\"The sum is\", sum)"}
{"nl": "Print a pattern using a combination of numbers and stars, given the number of rows", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumberOfRows = 8\r\n# Loop from 0 to the number of rows using For loop.\r\nfor m in range(0, numberOfRows):\r\n    # Inside the For, loop Take a variable(say Tempo) and initialize its value with 1.\r\n    Tempo = 1\r\n    # Print the value of the Tempo variable with space.\r\n    print(Tempo, end=' ')\r\n    # Loop from the number of rows -m-1 to 0 in decreasing order using another for loop(Nested For loop)\r\n    # where m is the iterator value of the parent For loop.\r\n    for n in range(numberOfRows-m-1, 0, -1):\r\n      # Print the Star Character with space.\r\n        print('*', end=' ')\r\n        # Increment the value of Tempo by 1.\r\n        Tempo = Tempo + 1\r\n        # Print the value of the Tempo variable with space.\r\n        print(Tempo, end=' ')\r\n\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "Python Program to Count Number of Lowercase Characters in a String", "code": "# Give the string as static input and save it in a variable.\n \n given_strng = 'Hello this is BTechGeeks'\n \n # Take a variable to say countlow that stores the total number of lowercase characters present in the given string.\n \n # Initialize the countlow to 0.\n \n countlow = 0\n \n # Traverse the given string using for loop.\n \n for charact in given_strng:\n \n  # Check if the iterator value is lowercase or not using islower() function.\n \n  if(charact.islower()):\n \n  # If the character is in lowercase then increment the countlow by 1.\n \n  countlow = countlow+1\n \n # Print the countlow.\n \n print(\n \n  'The total number of lower case letters present in the given string [', given_strng, '] = ', countlow)"}
{"nl": "A Capital Challenge", "code": "def select_letters(s1, s2):\n    left = ''.join(a for a, b in zip(s1, s2) if b.isupper())\n    right = ''.join(b for a, b in zip(s1, s2) if a.isupper())\n    return left + right"}
{"nl": "Substituting the The", "code": "import re\ndef replace_the(txt):\n  def repl(match):\n    a,b = match.group(1,2)\n    return ('an ' if b in 'aeiou' else 'a ') + b\n  return re.sub('(the) (\\w)', repl, txt)"}
{"nl": "Search in Unsorted Array", "code": "# Python program for searching in\r\n# unsorted array\r\n\r\ndef findElement(arr, n, key):\r\n\tfor i in range (n):\r\n\t\tif (arr[i] == key):\r\n\t\t\treturn i\r\n\treturn -1\r\n\r\narr = [12, 34, 10, 6, 40]\r\nkey = 40\r\nn = len(arr)\r\n\r\n#search operation\r\nindex = findElement(arr, n, key)\r\nif index != -1:\r\n\tprint (\"element found at position: \" + str(index + 1 ))\r\nelse:\r\n\tprint (\"element not found\")\r\n\t\r\n# Thanks to Aditi Sharma for contributing\r\n# this code\r\n"}
{"nl": "Convert a List to a String", "code": "def list_to_string(lst):\n    return ''.join(map(str, lst))"}
{"nl": "List from Comma-Delimited String", "code": "def to_array(txt):\n  return txt.split(', ') if txt else []"}
{"nl": "Bagging classifier", "code": "from sklearn import model_selection\nfrom sklearn.ensemble import BaggingClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nimport pandas as pd\n\n# load the data\nurl = \"/home/debomit/Downloads/wine_data.xlsx\"\ndataframe = pd.read_excel(url)\narr = dataframe.values\nX = arr[:, 1:14]\nY = arr[:, 0]\n\nseed = 8\nkfold = model_selection.KFold(n_splits = 3,\n\t\t\t\t\trandom_state = seed)\n\n# initialize the base classifier\nbase_cls = DecisionTreeClassifier()\n\n# no. of base classifier\nnum_trees = 500\n\n# bagging classifier\nmodel = BaggingClassifier(base_estimator = base_cls,\n\t\t\t\t\t\tn_estimators = num_trees,\n\t\t\t\t\t\trandom_state = seed)\n\nresults = model_selection.cross_val_score(model, X, Y, cv = kfold)\nprint(\"accuracy :\")\nprint(results.mean())"}
{"nl": "Exercise working with string manipulation: creating a robot simulator.", "code": "\"\"\"Robot Simulator.\"\"\"\r\n# Directions, complex polar mappings.\r\nEAST = 1\r\nNORTH = 1j\r\nWEST = -1\r\nSOUTH = -1j\r\nclass Robot:\r\n    \"\"\"A robot.\"\"\"\r\n    def __init__(self, direction: complex, x: int, y: int):\r\n        \"\"\"Initialize, mapping inputs to complex numbers.\"\"\"\r\n        self.direction = direction\r\n        self._coord = x + y * 1j\r\n    @property\r\n    def coordinates(self) -> tuple[int, int]:\r\n        \"\"\"Map complex coordinates to Cartesian.\"\"\"\r\n        return (int(self._coord.real), int(self._coord.imag))\r\n    def move(self, instructions: str) -> None:\r\n        \"\"\"Move the robot Right|Left|Advance.\"\"\"\r\n        for instruction in instructions:\r\n            if instruction not in \"RLA\":\r\n                raise ValueError(f\"invalid instruction {instruction}\")\r\n            if instruction == \"A\":\r\n                # Advance.\r\n                self._coord += self.direction\r\n            elif instruction == \"R\":\r\n                # Rotate -90 deg.\r\n                self.direction *= -1j\r\n            elif instruction == \"L\":\r\n                # Rotate 90 deg.\r\n                self.direction *= 1j\r\n"}
{"nl": "Reverse the content of text file and store it in another file", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\nrevFile = \"reversed_file.txt\"\n# Open a file in write mode. In this case, we're writing the contents into the file.\nrev_File = open(revFile,'w')\n# Make another variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open another file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Read the above file using the read() function(get the content) and store it in a variable\n  gvn_data = givenfilecontent.read()\n# Reverse the content of the given file using negative indexing and store it in another variable.\nrevrse_data = gvn_data[::-1] \n# Write the above reversed data into the reversed file using the write() function\nrev_File.write(revrse_data) \n# Close the reversed file(rev_file) using the close() function\nrev_File.close()"}
{"nl": "Multiply Two Complex Numbers", "code": "# Python program to multiply two complex number\r\n\r\n# Enter first complex number i.e. 3+4j not 3+4i\r\nfirst = complex(input('Enter first complex number: '))\r\nsecond = complex(input('Enter first complex number: '))\r\n\r\n# Multiplication of complex number\r\nproduct = first * second\r\n\r\n# Displaying Sum\r\nprint('PRODUCT = ', product)"}
{"nl": "Python Getting Data Types", "code": "x = 5\r\nprint(type(x))"}
{"nl": "Matrix Chain Multiplication Dynamic Programming", "code": "# Dynamic Programming Python implementation of Matrix\n# Chain Multiplication. See the Cormen book for details\n# of the following algorithm\nimport sys\nmaxint=int(1e9+7)\n# Matrix Ai has dimension p[i-1] x p[i] for i = 1..n\n\n\ndef MatrixChainOrder(p, n):\n\t# For simplicity of the program,\n\t# one extra row and one\n\t# extra column are allocated in m[][].\n\t# 0th row and 0th\n\t# column of m[][] are not used\n\tm = [[0 for x in range(n)] for x in range(n)]\n\n\t# m[i, j] = Minimum number of scalar\n\t# multiplications needed\n\t# to compute the matrix A[i]A[i + 1]...A[j] =\n\t# A[i..j] where\n\t# dimension of A[i] is p[i-1] x p[i]\n\n\t# cost is zero when multiplying one matrix.\n\tfor i in range(1, n):\n\t\tm[i][i] = 0\n\n\t# L is chain length.\n\tfor L in range(2, n):\n\t\tfor i in range(1, n-L + 1):\n\t\t\tj = i + L-1\n\t\t\tm[i][j] = maxint\n\t\t\tfor k in range(i, j):\n\n\t\t\t\t# q = cost / scalar multiplications\n\t\t\t\tq = m[i][k] + m[k + 1][j] + p[i-1]*p[k]*p[j]\n\t\t\t\tif q < m[i][j]:\n\t\t\t\t\tm[i][j] = q\n\n\treturn m[1][n-1]\n\n\n# Driver code\narr = [1, 2, 3, 4]\nsize = len(arr)\n\nprint(\"Minimum number of multiplications is \" +\n\tstr(MatrixChainOrder(arr, size)))\n# This Code is contributed by Bhavya Jain"}
{"nl": "Python Program to Calculate the Number of Digits and Letters in a String", "code": "# Give the string as static input and save it in a variable.\n \n given_strng = 'Hel34lo18th3is9is38 BTech23Geeks'\n \n # Take a variable to say stringdigits that stores the total digits in the given string.\n \n # Initialize the stringdigits to 0.\n \n stringdigits = 0\n \n # Take a variable to say stringcharacters that stores the total characters in the given string.\n \n # Initialize the stringcharacters to 0.\n \n stringcharacters = 0\n \n # Traverse the given string using for loop.\n \n for charact in given_strng:\n \n  # Check if the character is a numerical digit or not using the isdigit() function.\n \n  if(charact.isdigit()):\n \n  # If the character is a numerical digit then increment the value of stringdigits by 1.\n \n  stringdigits = stringdigits+1\n \n  # Increase the stringcharacters by 1.\n \n  stringcharacters = stringcharacters+1\n \n # Print the total count of digits and characters present in the given string.\n \n print(\n \n  'The total number of digits present in the given string [', given_strng, '] = ', stringdigits)\n \n print(\n \n  'The total number of characters present in the given string [', given_strng, '] = ', stringcharacters)"}
{"nl": "The number of ways to split a string with the same number of ones in s1,s2,s3", "code": "def numWays(self, s: str) -> int:\n  ones, n, m = s.count('1'), len(s), 10 ** 9 + 7\n  if ones == 0:\n  return (n - 2) * (n - 1) // 2 % m\n  if ones % 3 != 0:\n  return 0\n  ones_in_each_splited_block = ones // 3\n  count = ways_of_first_cut = ways_of_second_cut = 0\n  for char in s:\n  if char == '1':\n  count += 1\n  if count == ones_in_each_splited_block:\n  ways_of_first_cut += 1\n  elif count == 2 * ones_in_each_splited_block:\n  ways_of_second_cut += 1\n  return ways_of_first_cut * ways_of_second_cut % m"}
{"nl": "Harshad Numbers", "code": "def is_harshad(num):\n  return num!= 0 and num % sum(int(x) for x in str(num)) == 0"}
{"nl": "Print Binary Tree vertically", "code": "# Python program for printing vertical order of a given\r\n# binary tree\r\n \r\n# A binary tree node\r\nclass Node:\r\n    # Constructor to create a new node\r\n    def __init__(self, key):\r\n        self.key = key\r\n        self.left = None\r\n        self.right = None\r\n \r\n# Utility function to store vertical order in map 'm'\r\n# 'hd' is horizontal distance of current node from root\r\n# 'hd' is initially passed as 0\r\ndef getVerticalOrder(root, hd, m):\r\n \r\n    # Base Case\r\n    if root is None:\r\n        return\r\n     \r\n    # Store current node in map 'm'\r\n    try:\r\n        m[hd].append(root.key)\r\n    except:\r\n        m[hd] = [root.key]\r\n     \r\n    # Store nodes in left subtree\r\n    getVerticalOrder(root.left, hd-1, m)\r\n     \r\n    # Store nodes in right subtree\r\n    getVerticalOrder(root.right, hd+1, m)\r\n \r\n# The main function to print vertical order of a binary\r\n#tree ith given root\r\ndef printVerticalOrder(root):\r\n     \r\n    # Create a map and store vertical order in map using\r\n    # function getVerticalORder()\r\n    m = dict()\r\n    hd = 0\r\n    getVerticalOrder(root, hd, m)\r\n     \r\n    # Traverse the map and print nodes at every horizontal\r\n    # distance (hd)\r\n    for index, value in enumerate(sorted(m)):\r\n        for i in m[value]:\r\n            print (i,end=\" \")\r\n        print()\r\n \r\n \r\n# Driver program to test above function\r\nroot = Node(1)\r\nroot.left = Node(2)\r\nroot.right = Node(3)\r\nroot.left.left = Node(4)\r\nroot.left.right = Node(5)\r\nroot.right.left = Node(6)\r\nroot.right.right = Node(7)\r\nroot.right.left.right = Node(8)\r\nroot.right.right.right = Node(9)\r\nprint (\"Vertical order traversal is\")\r\nprintVerticalOrder(root)\r\n \r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)"}
{"nl": "Binary to ASCII Conversion", "code": "def binary_conversion(txt):\n  return \"\".join([chr(int(txt[i:i+8],2)) for i in range(0,len(txt),8)])"}
{"nl": "Insertion in a Sorted array", "code": "# Python3 program to implement insert\r\n# operation in an sorted array.\r\n\r\n# Inserts a key in arr[] of given capacity.\r\n# n is current size of arr[]. This function\r\n# returns n+1 if insertion is successful, else n.\r\ndef insertSorted(arr, n, key, capacity):\r\n\t\r\n\t# Cannot insert more elements if n is\r\n\t# already more than or equal to capacity\r\n\tif (n >= capacity):\r\n\t\treturn n\r\n\r\n\ti = n - 1\r\n\twhile i >= 0 and arr[i] > key:\r\n\t\tarr[i + 1] = arr[i]\r\n\t\ti -= 1\r\n\r\n\tarr[i + 1] = key\r\n\r\n\treturn (n + 1)\r\n\r\n# Driver Code\r\narr = [12, 16, 20, 40, 50, 70]\r\n\r\nfor i in range(20):\r\n\tarr.append(0)\r\n\r\ncapacity = len(arr)\r\nn = 6\r\nkey = 26\r\n\r\nprint(\"Before Insertion: \", end = \" \");\r\nfor i in range(n):\r\n\tprint(arr[i], end = \" \")\r\n\t\r\n# Inserting key\r\nn = insertSorted(arr, n, key, capacity)\r\n\r\nprint(\"\\nAfter Insertion: \", end = \"\")\r\nfor i in range(n):\r\n\tprint(arr[i], end = \" \")\r\n\r\n# This code is contributed by Mohit Kumar\r\n"}
{"nl": "Union-find algorithm to detect Cycle within Directed Graph", "code": "# Python Program for union-find algorithm to detect cycle in a undirected graph\r\n# we have one egde for any two vertex i.e 1-2 is either 1-2 or 2-1 but not both\r\n  \r\nfrom collections import defaultdict\r\n  \r\n#This class represents a undirected graph using adjacency list representation\r\nclass Graph:\r\n  \r\n    def __init__(self,vertices):\r\n        self.V= vertices #No. of vertices\r\n        self.graph = defaultdict(list) # default dictionary to store graph\r\n  \r\n \r\n    # function to add an edge to graph\r\n    def addEdge(self,u,v):\r\n        self.graph[u].append(v)\r\n  \r\n    # A utility function to find the subset of an element i\r\n    def find_parent(self, parent,i):\r\n        if parent[i] == -1:\r\n            return i\r\n        if parent[i]!= -1:\r\n             return self.find_parent(parent,parent[i])\r\n \r\n    # A utility function to do union of two subsets\r\n    def union(self,parent,x,y):\r\n        parent[x] = y\r\n \r\n  \r\n  \r\n    # The main function to check whether a given graph\r\n    # contains cycle or not\r\n    def isCyclic(self):\r\n         \r\n        # Allocate memory for creating V subsets and\r\n        # Initialize all subsets as single element sets\r\n        parent = [-1]*(self.V)\r\n \r\n        # Iterate through all edges of graph, find subset of both\r\n        # vertices of every edge, if both subsets are same, then\r\n        # there is cycle in graph.\r\n        for i in self.graph:\r\n            for j in self.graph[i]:\r\n                x = self.find_parent(parent, i)\r\n                y = self.find_parent(parent, j)\r\n                if x == y:\r\n                    return True\r\n                self.union(parent,x,y)\r\n \r\n \r\n# Create a graph given in the above diagram\r\ng = Graph(3)\r\ng.addEdge(0, 1)\r\ng.addEdge(1, 2)\r\ng.addEdge(2, 0)\r\n \r\nif g.isCyclic():\r\n    print (\"Graph contains cycle\")\r\nelse :\r\n    print (\"Graph does not contain cycle \")\r\n  \r\n#This code is contributed by Neelam Yadav"}
{"nl": "Iterative method to find ancestors of a given binary tree", "code": "# Python program to print all ancestors of a given key\n\u00a0\n# A class to create a new tree node\nclass newNode:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\n# Iterative Function to print all ancestors of a\n# given key\ndef printAncestors(root, key):\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a stack to hold ancestors\n\u00a0\u00a0\u00a0\u00a0st = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse the complete tree in postorder way till\n\u00a0\u00a0\u00a0\u00a0# we find the key\n\u00a0\u00a0\u00a0\u00a0while (1):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Traverse the left side. While traversing, push\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the nodes into the stack so that their right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# subtrees can be traversed later\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (root and root.data != key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.append(root) # push current node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = root.left # move to next node\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the node whose ancestors are to be printed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is found, then break the while loop.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (root and root.data == key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if right sub-tree exists for the node at top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If not then pop that node because we don't need\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# this node any more.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (st[-1].right == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = st[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the popped node is right child of top,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then remove the top as well. Left child of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the top must have processed before.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (len(st) != 0 and st[-1].right == root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = st[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if stack is not empty then simply set the root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as right child of top and start traversing right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sub-tree.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = None if len(st) == 0 else st[-1].right\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If stack is not empty, print contents of stack\n\u00a0\u00a0\u00a0\u00a0# Here assumption is that the key is there in tree\n\u00a0\u00a0\u00a0\u00a0while (len(st) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(st[-1].data,end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st.pop()\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us construct a binary tree\n\u00a0\u00a0\u00a0\u00a0root = newNode(1)\n\u00a0\u00a0\u00a0\u00a0root.left = newNode(2)\n\u00a0\u00a0\u00a0\u00a0root.right = newNode(7)\n\u00a0\u00a0\u00a0\u00a0root.left.left = newNode(3)\n\u00a0\u00a0\u00a0\u00a0root.left.right = newNode(5)\n\u00a0\u00a0\u00a0\u00a0root.right.left = newNode(8)\n\u00a0\u00a0\u00a0\u00a0root.right.right = newNode(9)\n\u00a0\u00a0\u00a0\u00a0root.left.left.left = newNode(4)\n\u00a0\u00a0\u00a0\u00a0root.left.right.right = newNode(6)\n\u00a0\u00a0\u00a0\u00a0root.right.right.left = newNode(10)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0key = 6\n\u00a0\u00a0\u00a0\u00a0printAncestors(root, key)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# This code is contributed by PranchalK.\n"}
{"nl": "Python Program to Count the Number of Alphabets in a String", "code": "# Give the String as user input using the input()function and store it in the variable.\ngvn_str = input(\"Enter some random String = \")\n# Take a variable say 'count' and initialize it's value with '0'\ncount_no = 0\n# Loop from 0 to the length of the above given String using For Loop.\nfor itrtor in gvn_str:\n    # Inside the loop, check whether  if the value of iterator is alphabet or\n    # using built-in isalpha() method inside the if conditional statement.\n    if(itrtor.isalpha()):\n     # If the given condition is true ,then increment the above initialized count value by '1'.\n        count_no = count_no+1\n# Print the number of Alphabets in a given string by printing the above count value.\nprint(\n    \"The Number of Characters in a given string {\", gvn_str, \"} = \", count_no)"}
{"nl": "Sorting array using Stacks", "code": "# Python3 program to sort an array using stack\n\u00a0\n# This function return the sorted stack\ndef sortStack(input):\n\u00a0\u00a0\u00a0\u00a0tmpStack = []\n\u00a0\u00a0\u00a0\u00a0while (len(input) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop out the first element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmp = input[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0input.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# while temporary stack is not empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and top of stack is smaller than temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (len(tmpStack) > 0 and tmpStack[-1] < tmp):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop from temporary stack and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# append it to the input stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0input.append(tmpStack[-1])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmpStack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# append temp in temporary of stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmpStack.append(tmp)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return tmpStack\n\u00a0\ndef sortArrayUsingStacks(arr, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# append array elements to stack\n\u00a0\u00a0\u00a0\u00a0input = []\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0while ( i < n ):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0input.append(arr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Sort the temporary stack\n\u00a0\u00a0\u00a0\u00a0tmpStack = sortStack(input)\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Put stack elements in arrp[]\n\u00a0\u00a0\u00a0\u00a0while (i < n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[i] = tmpStack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmpStack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return arr\n\u00a0\n# Driver code\narr = [10, 5, 15, 45]\nn = len(arr)\n\u00a0\narr = sortArrayUsingStacks(arr, n)\ni = 0\n\u00a0\nwhile (i < n):\n\u00a0\u00a0\u00a0\u00a0print(arr[i] ,end= \" \")\n\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\n# This code is contributed by Arnab Kundu\n"}
{"nl": "Segregate even and odd nodes in a Linked List", "code": "# Python program to segregate even and odd nodes in a\n# Linked List\nhead = None # head of list\n\n# Node class\nclass Node:\n\t\n\t# Function to initialise the node object\n\tdef __init__(self, data):\n\t\tself.data = data # Assign data\n\t\tself.next =None\n\ndef segregateEvenOdd():\n\n\tglobal head\n\tend = head\n\tprev = None\n\tcurr = head\n\n\t# Get pointer to last Node\n\twhile (end.next != None):\n\t\tend = end.next\n\n\tnew_end = end\n\n\t# Consider all odd nodes before getting first even node\n\twhile (curr.data % 2 !=0 and curr != end):\n\t\t\n\t\tnew_end.next = curr\n\t\tcurr = curr.next\n\t\tnew_end.next.next = None\n\t\tnew_end = new_end.next\n\t\t\n\t# do following steps only if there is an even node\n\tif (curr.data % 2 == 0):\n\t\t\n\t\thead = curr\n\n\t\t# now curr points to first even node\n\t\twhile (curr != end):\n\t\t\t\n\t\t\tif (curr.data % 2 == 0):\n\t\t\t\t\n\t\t\t\tprev = curr\n\t\t\t\tcurr = curr.next\n\t\t\t\t\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t# Break the link between prev and curr\n\t\t\t\tprev.next = curr.next\n\n\t\t\t\t# Make next of curr as None\n\t\t\t\tcurr.next = None\n\n\t\t\t\t# Move curr to end\n\t\t\t\tnew_end.next = curr\n\n\t\t\t\t# Make curr as new end of list\n\t\t\t\tnew_end = curr\n\n\t\t\t\t# Update curr pointer\n\t\t\t\tcurr = prev.next\n\t\t\t\n\t# We have to set prev before executing rest of this code\n\telse:\n\t\tprev = curr\n\n\tif (new_end != end and end.data % 2 != 0):\n\t\t\n\t\tprev.next = end.next\n\t\tend.next = None\n\t\tnew_end.next = end\n\t\t\n# Given a reference (pointer to pointer) to the head\n# of a list and an int, push a new node on the front\n# of the list.\ndef push(new_data):\n\tglobal head\n\n\t# 1 & 2: Allocate the Node &\n\t#\t\t Put in the data\n\tnew_node = Node(new_data)\n\n\t# 3. Make next of new Node as head\n\tnew_node.next = head\n\n\t# 4. Move the head to point to new Node\n\thead = new_node\n\n# Utility function to print a linked list\ndef printList():\n\tglobal head\n\ttemp = head\n\twhile(temp != None):\n\t\t\n\t\tprint(temp.data, end = \" \")\n\t\ttemp = temp.next\n\t\t\n\tprint(\" \")\n\n# Driver program to test above functions\n\npush(11)\npush(10)\npush(8)\npush(6)\npush(4)\npush(2)\npush(0)\nprint(\"Original Linked List\")\nprintList()\n\nsegregateEvenOdd()\n\nprint(\"Modified Linked List\")\nprintList()\n\n# This code is contributed by Arnab Kundu\n"}
{"nl": "Add two numbers without using arithmetic operators", "code": "# Python3 Program to add two numbers\n# without using arithmetic operator\ndef Add(x, y):\n\n\t# Iterate till there is no carry\n\twhile (y != 0):\n\t\n\t\t# carry now contains common\n\t\t# set bits of x and y\n\t\tcarry = x & y\n\n\t\t# Sum of bits of x and y where at\n\t\t# least one of the bits is not set\n\t\tx = x ^ y\n\n\t\t# Carry is shifted by one so that\n\t\t# adding it to x gives the required sum\n\t\ty = carry << 1\n\t\n\treturn x\n\nprint(Add(15, 32))\n\n# This code is contributed by\n# Smitha Dinesh Semwal\n"}
{"nl": "How Heavy Is It?", "code": "def weight(r, h):\n  from math import pi\n  return round((pi*r**2*h) / 1000, 2)"}
{"nl": "Count Negative Numbers in a Column-Wise and Row-Wise Sorted Matrix", "code": "# Python implementation of Naive method to count of\n# negative numbers in M[n][m]\n\u00a0\ndef countNegative(M, n, m):\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Follow the path shown using arrows above\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(m):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if M[i][j] < 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# no more negative numbers in this row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\n\u00a0\n# Driver code\nM = [\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[-3, -2, -1,\u00a0 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[-2,\u00a0 2,\u00a0 3,\u00a0 4],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 4,\u00a0 5,\u00a0 7,\u00a0 8]\n\u00a0\u00a0\u00a0\u00a0]\nprint(countNegative(M, 3, 4))\n"}
{"nl": "Largest Rectangular Area in a Histogram", "code": "# Python3 program to find maximum\n# rectangular area in linear time\n\u00a0\ndef max_area_histogram(histogram):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# This function calculates maximum\n\u00a0\u00a0\u00a0\u00a0# rectangular area under given\n\u00a0\u00a0\u00a0\u00a0# histogram with n bars\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an empty stack. The stack\n\u00a0\u00a0\u00a0\u00a0# holds indexes of histogram[] list.\n\u00a0\u00a0\u00a0\u00a0# The bars stored in the stack are\n\u00a0\u00a0\u00a0\u00a0# always in increasing order of\n\u00a0\u00a0\u00a0\u00a0# their heights.\n\u00a0\u00a0\u00a0\u00a0stack = list()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0max_area = 0 # Initialize max area\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Run through all bars of\n\u00a0\u00a0\u00a0\u00a0# given histogram\n\u00a0\u00a0\u00a0\u00a0index = 0\n\u00a0\u00a0\u00a0\u00a0while index < len(histogram):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this bar is higher\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than the bar on top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# stack, push it to stack\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not stack) or (histogram[stack[-1]] <= histogram[index]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(index)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this bar is lower than top of stack,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then calculate area of rectangle with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# stack top as the smallest (or minimum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# height) bar.'i' is 'right index' for\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the top and element before top in stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is 'left index'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop the top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0top_of_stack = stack.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate the area with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# histogram[top_of_stack] stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as smallest bar\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0area = (histogram[top_of_stack] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((index - stack[-1] - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if stack else index))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# update max area, if needed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_area = max(max_area, area)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Now pop the remaining bars from\n\u00a0\u00a0\u00a0\u00a0# stack and calculate area with\n\u00a0\u00a0\u00a0\u00a0# every popped bar as the smallest bar\n\u00a0\u00a0\u00a0\u00a0while stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop the top\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0top_of_stack = stack.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate the area with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# histogram[top_of_stack]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# stack as smallest bar\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0area = (histogram[top_of_stack] *\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((index - stack[-1] - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if stack else index))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# update max area, if needed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_area = max(max_area, area)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return maximum area under\n\u00a0\u00a0\u00a0\u00a0# the given histogram\n\u00a0\u00a0\u00a0\u00a0return max_area\n\u00a0\n# Driver Code\nhist = [6, 2, 5, 4, 5, 1, 6]\nprint(\"Maximum area is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_area_histogram(hist))\n\u00a0\n# This code is contributed\n# by Jinay Shah\n"}
{"nl": "Random Number\r", "code": "import random\r\n\r\nprint(random.randrange(1,10))"}
{"nl": "sort the linked list using insertion sort", "code": "class Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        curr = head\n\n        while curr:\n            # At each iteration, we insert an element into the resulting list.\n            prev = dummy\n\n            # find the position to insert the current node\n            while prev.next and prev.next.val < curr.val:\n                prev = prev.next\n\n            next = curr.next\n            # insert the current node to the new list\n            curr.next = prev.next\n            prev.next = curr\n\n            # moving on to the next iteration\n            curr = next\n\n        return dummy.next"}
{"nl": "Python If Elif\r\n", "code": "a = 33\r\nb = 33\r\nif b > a:\r\n  print(\"b is greater than a\")\r\nelif a == b:\r\n  print(\"a and b are equal\")"}
{"nl": "Implement the logic of the hangman game using functional reactive programming", "code": "# Game status categories\n# Change the values as you see fit\nSTATUS_WIN = 'win'\nSTATUS_LOSE = 'lose'\nSTATUS_ONGOING = 'ongoing'\nclass Hangman:\n    def __init__(self, word):\n        self.remaining_guesses = 9\n        self.status = STATUS_ONGOING\n        self.word = word\n        self.masked_word = ['_'] * len(word)\n        \n    def guess(self, char):\n        if self.remaining_guesses < 0 or self.status != STATUS_ONGOING:\n            raise ValueError(\"The game has already ended.\")\n        iscorrect = False\n        for i in range(len(self.word)):\n            if self.word[i] == char and self.masked_word[i] == '_':\n                self.masked_word[i] = self.word[i]\n                iscorrect = True\n        if not iscorrect:\n            self.remaining_guesses -= 1\n    def get_masked_word(self):\n        return ''.join(self.masked_word)\n    def get_status(self):\n        res = ''.join(self.masked_word)\n        if self.remaining_guesses < 0 and self.word != res:\n            self.status = STATUS_LOSE\n        if self.remaining_guesses >= 0 and self.word == res:\n            self.status = STATUS_WIN\n        return self.status"}
{"nl": "Python program to delete a new node from the end of the doubly linked list", "code": "#Represent a node of doubly linked list    \nclass Node:    \n    def __init__(self,data):    \n        self.data = data;    \n        self.previous = None;    \n        self.next = None;    \n            \nclass DeleteEnd:    \n    #Represent the head and tail of the doubly linked list    \n    def __init__(self):    \n        self.head = None;    \n        self.tail = None;    \n            \n    #addNode() will add a node to the list    \n    def addNode(self, data):    \n        #Create a new node    \n        newNode = Node(data);    \n            \n        #If list is empty    \n        if(self.head == None):    \n            #Both head and tail will point to newNode    \n            self.head = self.tail = newNode;    \n            #head's previous will point to None    \n            self.head.previous = None;    \n            #tail's next will point to None, as it is the last node of the list    \n            self.tail.next = None;    \n        else:    \n            #newNode will be added after tail such that tail's next will point to newNode    \n            self.tail.next = newNode;    \n            #newNode's previous will point to tail    \n            newNode.previous = self.tail;    \n            #newNode will become new tail    \n            self.tail = newNode;    \n            #As it is last node, tail's next will point to None    \n            self.tail.next = None;    \n                \n    #deleteFromEnd() will delete a node from the end of the list    \n    def deleteFromEnd(self):    \n        #Checks whether list is empty    \n        if(self.head == None):    \n            return;    \n        else:    \n            #Checks whether the list contains only one node    \n            if(self.head != self.tail):    \n                #Previous node to the tail will become new tail    \n                self.tail = self.tail.previous;    \n                #Node next to current tail will be made None    \n                self.tail.next = None;    \n                    \n            #If the list contains only one element     \n            #Then it will remove the node, and now both head and tail will point to None    \n    \n            else:    \n                self.head = self.tail = None;    \n                    \n    #display() will print out the nodes of the list    \n    def display(self):    \n        #Node current will point to head    \n        current = self.head;    \n        if(self.head == None):    \n            print(\"List is empty\");    \n            return;    \n        while(current != None):    \n            #Prints each node by incrementing pointer.    \n            print(current.data),    \n            current = current.next;    \n        print();    \n           \ndList = DeleteEnd();    \n#Add nodes to the list    \ndList.addNode(1);    \ndList.addNode(2);    \ndList.addNode(3);    \ndList.addNode(4);    \ndList.addNode(5);    \n     \n#Printing original list    \nprint(\"Original List: \");    \ndList.display();    \nwhile(dList.head != None):    \n    dList.deleteFromEnd();    \n    #Printing updated list    \n    print(\"Updated List: \");    \n    dList.display();    "}
{"nl": "Transitive Closure of a Graph using DFS\r\n", "code": "\r\n# Python program to print transitive\r\n# closure of a graph.\r\nfrom collections import defaultdict\r\n  \r\nclass Graph:\r\n  \r\n    def __init__(self,vertices):\r\n        # No. of vertices\r\n        self.V = vertices\r\n  \r\n        # default dictionary to store graph\r\n        self.graph = defaultdict(list)\r\n  \r\n        # To store transitive closure\r\n        self.tc = [[0 for j in range(self.V)] for i in range(self.V)]\r\n  \r\n    # function to add an edge to graph\r\n    def addEdge(self, u, v):\r\n        self.graph[u].append(v)\r\n  \r\n    # A recursive DFS traversal function that finds\r\n    # all reachable vertices for s\r\n    def DFSUtil(self, s, v):\r\n  \r\n        # Mark reachability from s to v as true.\r\n        if(s == v):\r\n            if( v in self.graph[s]):\r\n              self.tc[s][v] = 1\r\n        else:\r\n            self.tc[s][v] = 1\r\n  \r\n        # Find all the vertices reachable through v\r\n        for i in self.graph[v]:\r\n            if self.tc[s][i] == 0:\r\n                if s==i:\r\n                   self.tc[s][i]=1\r\n                else:\r\n                   self.DFSUtil(s, i)\r\n  \r\n    # The function to find transitive closure. It uses\r\n    # recursive DFSUtil()\r\n    def transitiveClosure(self):\r\n  \r\n        # Call the recursive helper function to print DFS\r\n        # traversal starting from all vertices one by one\r\n        for i in range(self.V):\r\n            self.DFSUtil(i, i)\r\n         \r\n        print(self.tc)\r\n  \r\n# Create a graph given in the above diagram\r\ng = Graph(4)\r\ng.addEdge(0, 1)\r\ng.addEdge(0, 2)\r\ng.addEdge(1, 2)\r\ng.addEdge(2, 0)\r\ng.addEdge(2, 3)\r\ng.addEdge(3, 3)\r\n  \r\ng.transitiveClosure()"}
{"nl": "Rotate for Max Number", "code": "def rotate_max_number(num):\n  return int(''.join(sorted(str(num), reverse=True)))"}
{"nl": "Python Program to Print 8 Star Pattern", "code": "rows = int(input(\"Enter 8 Star Pattern Rows = \"))\n\nprint(\"====The 8 Star Pattern====\")\n\nfor i in range(1, rows * 2):\n    if i == 1 or i == rows or i == rows * 2 - 1:\n        for j in range(1, rows + 1):\n            if j == 1 or j == rows:\n                print(end = ' ')\n            else:\n                print('*', end = '')\n    else:\n        for k in range(1, rows + 1):\n            if k == 1 or k == rows:\n                print('*', end = '')\n            else:\n                print(end = ' ')\n    print()"}
{"nl": "Ransom Letter", "code": "def can_build(s1, s2):\n  return all(s2.count(i)<=s1.count(i) for i in s2)"}
{"nl": "Python Program to Print nth Iteration of Lucas Sequence", "code": "# Give the First term =2 (since the first term in Lucas Sequence is 2 which is a constant)\n \n # as static input and store it in a variable.\n \n fst_trm = 2\n \n # Give the Second term =1 (since the second term in Lucas Sequence is 1 which is a constant)\n \n # as static input and store it in another variable.\n \n secnd_trm = 1\n \n # Give the number as static input and store it in another variable.\n \n gvn_n_vlue = 6\n \n # Loop from '1' to the above given n+1 value (since doesn't include last term) range\n \n # using For loop.\n \n for i in range(1, gvn_n_vlue+1):\n \n  # Inside the loop , get the third term which is the sum of first and the second term\n \n  # and store it in a variable.\n \n  third_trm = fst_trm+secnd_trm\n \n  # Assign the value of second term to the first term.\n \n  fst_trm = secnd_trm\n \n  # Assign the value of the third term to the second term and come out of For Loop.\n \n  secnd_trm = third_trm\n \n # Print the Value of above given nth iteration of Lucas Sequence(i.e. first term).\n \n print(\"The above Given nth iteration of Lucas Sequence = \", fst_trm)\n \n </pre>"}
{"nl": "Convert an upper case string to a lower case string and add an exclamation point at the end.", "code": "def normalize(txt):\r\n\t\treturn txt.capitalize() + ('!' if txt.isupper() else '')"}
{"nl": "Implementation of Polynomial Regression", "code": "# Importing the libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Importing the dataset\ndatas = pd.read_csv('data.csv')\nX = datas.iloc[:, 1:2].values\ny = datas.iloc[:, 2].values\n# Fitting Linear Regression to the dataset\nfrom sklearn.linear_model import LinearRegression\nlin = LinearRegression()\n\nlin.fit(X, y)\n# Fitting Polynomial Regression to the dataset\nfrom sklearn.preprocessing import PolynomialFeatures\n\npoly = PolynomialFeatures(degree = 4)\nX_poly = poly.fit_transform(X)\n\npoly.fit(X_poly, y)\nlin2 = LinearRegression()\nlin2.fit(X_poly, y)\n# Visualising the Linear Regression results\nplt.scatter(X, y, color = 'blue')\n\nplt.plot(X, lin.predict(X), color = 'red')\nplt.title('Linear Regression')\nplt.xlabel('Temperature')\nplt.ylabel('Pressure')\n\nplt.show()\n# Visualising the Polynomial Regression results\nplt.scatter(X, y, color = 'blue')\n\nplt.plot(X, lin2.predict(poly.fit_transform(X)), color = 'red')\nplt.title('Polynomial Regression')\nplt.xlabel('Temperature')\nplt.ylabel('Pressure')\n\nplt.show()\n# Predicting a new result with Linear Regression after converting predict variable to 2D array\npred = 110.0\npredarray = np.array([[pred]])\nlin.predict(predarray)\n# Predicting a new result with Polynomial Regression after converting predict variable to 2D array\npred2 = 110.0\npred2array = np.array([[pred2]])\nlin2.predict(poly.fit_transform(pred2array))\n\n"}
{"nl": "Explanation of Fundamental Functions involved in A3C algorithm", "code": "\n# Initializing the class\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n   \n            # Input and visually encoding the layers\n            self.inputs = tf.placeholder(shape =[None, s_size], \n                                         dtype = tf.float32)\n            self.imageIn = tf.reshape(self.inputs, shape =[-1, 84, 84, 1])\n            self.conv1 = slim.conv2d(activation_fn = tf.nn.elu,\n                                    inputs = self.imageIn, num_outputs = 16,\n                                    kernel_size =[8, 8],\n                                    stride =[4, 4], padding ='VALID')\n            self.conv2 = slim.conv2d(activation_fn = tf.nn.elu,\n                                    inputs = self.conv1, num_outputs = 32,\n                                    kernel_size =[4, 4],\n                                    stride =[2, 2], padding ='VALID')\n            hidden = slim.fully_connected(slim.flatten(self.conv2),\n                                          256, activation_fn = tf.nn.elu)\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n  \n            # Building the Recurrent network for temporal dependencies\n            lstm_cell = tf.nn.rnn_cell.BasicLSTMCell(256, state_is_tuple = True)\n            c_init = np.zeros((1, lstm_cell.state_size.c), np.float32)\n            h_init = np.zeros((1, lstm_cell.state_size.h), np.float32)\n            self.state_init = [c_init, h_init]\n            c_Init = tf.placeholder(tf.float32, [1, lstm_cell.state_size.c])\n            h_Init = tf.placeholder(tf.float32, [1, lstm_cell.state_size.h])\n            self.state_Init = (c_Init, h_Init)\n            rnn_init = tf.expand_dims(hidden, [0])\n            step_size = tf.shape(self.imageIn)[:1]\n            state_Init = tf.nn.rnn_cell.LSTMStateTuple(c_Init, h_Init)\n            lstm_outputs, lstm_state = tf.nn.dynamic_rnn(lstm_cell, rnn_init,\n                                                    initial_state = state_Init,\n                                                    sequence_length = step_size,\n                                                    time_major = False)\n            lstm_c, lstm_h = lstm_state\n            self.state_out = (lstm_c[:1, :], lstm_h[:1, :])\n            rnn_out = tf.reshape(lstm_outputs, [-1, 256])\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n  \n           # Building the output layers for value and policy estimations\n            self.policy = slim.fully_connected(rnn_out, a_size,\n                                               activation_fn = tf.nn.softmax,\n                   weights_initializer = normalized_columns_initializer(0.01),\n                                               biases_initializer = None)\n            self.value = slim.fully_connected(rnn_out, 1,\n                activation_fn = None,\n                weights_initializer = normalized_columns_initializer(1.0),\n                biases_initializer = None)\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n           with tf.device(\"/cpu:0\"): \n  \n              # Generating the global network\n               master_network = AC_Network(s_size, a_size, 'global', None)\n                 \n               # Keeping the number of workers\n               # as the number of available CPU threads\n               num_workers = multiprocessing.cpu_count()\n  \n               # Creating and deploying the workers\n               workers = []\n               for i in range(num_workers):\n                   workers.append(Worker(DoomGame(), i, s_size, a_size,\n                                 trainer, saver, model_path))\ndef __init__(self, s_size, a_size, scope, trainer):\n        with tf.variable_scope(scope):\n           . . . . . . . . . . \n           . . . . . . . . . .\n           . . . . . . . . . .\n  \n           with tf.Session() as sess:\n               coord = tf.train.Coordinator()\n               if load_model == True:\n                   ckpt = tf.train.get_checkpoint_state(model_path)\n                   saver.restore(sess, ckpt.model_checkpoint_path)\n               else:\n                   sess.run(tf.global_variables_initializer())\n          \n               worker_threads = []\n               for worker in workers:\n                   worker_work = lambda: worker.work(max_episode_length,\n                                         gamma, master_network, sess, coord)\n                   t = threading.Thread(target =(worker_work))\n                   t.start()\n                   worker_threads.append(t)\n               coord.join(worker_threads)\r\ndef __init__(self, s_size, a_size, scope, trainer):\r\n        with tf.variable_scope(scope):\r\n           . . . . . . . . . . \r\n           . . . . . . . . . .\r\n           . . . . . . . . . .\r\n  \r\n           if scope != 'global':\r\n               self.actions = tf.placeholder(shape =[None], dtype = tf.int32)\r\n               self.actions_onehot = tf.one_hot(self.actions,\r\n                                                a_size, dtype = tf.float32)\r\n               self.target_v = tf.placeholder(shape =[None], dtype = tf.float32)\r\n               self.advantages = tf.placeholder(shape =[None], dtype = tf.float32)\r\n  \r\n               self.responsible_outputs = tf.reduce_sum(self.policy * \r\n                                                        self.actions_onehot, [1])\r\n  \r\n                # Computing the error\r\n                self.value_loss = 0.5 * tf.reduce_sum(tf.square(self.target_v -\r\n                                                    tf.reshape(self.value, [-1])))\r\n                self.entropy = - tf.reduce_sum(self.policy * tf.log(self.policy))\r\n                self.policy_loss = -tf.reduce_sum(tf.log(self.responsible_outputs)\r\n                                                         *self.advantages)\r\n                self.loss = 0.5 * self.value_loss + \r\n                self.policy_loss-self.entropy * 0.01\r\n  \r\n                # Get gradients from the local network\r\n                local_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES,\r\n                                               scope)\r\n                self.gradients = tf.gradients(self.loss, local_vars)\r\n                self.var_norms = tf.global_norm(local_vars)\r\n                grads, self.grad_norms = tf.clip_by_global_norm(self.gradients,\r\n                                                               40.0)\r\n  \r\n                # Apply the local gradients to the global network\r\n                global_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES,\r\n                                               'global')\r\n                self.apply_grads = trainer.apply_gradients(\r\n                        zip(grads, global_vars))\r\ndef update_target_graph(from_scope, to_scope):\r\n    from_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, from_scope)\r\n    to_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, to_scope)\r\n  \r\n    op_holder = []\r\n    for from_var, to_var in zip(from_vars, to_vars):\r\n        op_holder.append(to_var.assign(from_var))\r\n    return op_holder"}
{"nl": "Sort the given matrix", "code": "# Python3 implementation to sort\r\n# the given matrix\r\n\r\nSIZE = 10\r\n\r\n# Function to sort the given matrix\r\ndef sortMat(mat, n) :\r\n        \r\n        # Temporary matrix of size n^2\r\n        temp = [0] * (n * n)\r\n        k = 0\r\n\r\n        # Copy the elements of matrix\r\n        # one by one into temp[]\r\n        for i in range(0, n) :\r\n                \r\n                for j in range(0, n) :\r\n                        \r\n                        temp[k] = mat[i][j]\r\n                        k += 1\r\n\r\n        # sort temp[]\r\n        temp.sort()\r\n        \r\n        # copy the elements of temp[]\r\n        # one by one in mat[][]\r\n        k = 0\r\n        \r\n        for i in range(0, n) :\r\n                \r\n                for j in range(0, n) :\r\n                        mat[i][j] = temp[k]\r\n                        k += 1\r\n\r\n\r\n# Function to print the given matrix\r\ndef printMat(mat, n) :\r\n        \r\n        for i in range(0, n) :\r\n                \r\n                for j in range( 0, n ) :\r\n                        \r\n                        print(mat[i][j] , end = \" \")\r\n                        \r\n                print()\r\n        \r\n        \r\n# Driver program to test above\r\nmat = [ [ 5, 4, 7 ],\r\n                [ 1, 3, 8 ],\r\n                [ 2, 9, 6 ] ]\r\nn = 3\r\n\r\nprint( \"Original Matrix:\")\r\nprintMat(mat, n)\r\n\r\nsortMat(mat, n)\r\n\r\nprint(\"\\nMatrix After Sorting:\")\r\nprintMat(mat, n)\r\n\r\n\r\n# This code is contributed by Nikita Tiwari.\r"}
{"nl": "Secure Passwords", "code": "# Take a variable(say secpassword) and create some random characters as tuple\r\n# (('s', '$'), ('and', '&'), ('a', '@'), ('o', '0'), ('i', '1'), ('I', '|')).\r\nsecpassword = (('s', '$'), ('and', '&'),\r\n               ('a', '@'), ('o', '0'), ('i', '1'),\r\n               ('I', '|'))\r\n# Create a function createSecurePassword() which accepts the given password\r\n# as an argument and returns the secure password.\r\n\r\n\r\ndef createSecurePassword(givenpassword):\r\n    # Loop using two variables in the secpassword using For loop.\r\n    for m, n in secpassword:\r\n      # Replace the password with the two variables.\r\n        givenpassword = givenpassword.replace(m, n)\r\n    # Return the modified Password.\r\n    return givenpassword\r\n\r\n\r\n# Give the password as static input and store it in a variable.\r\ngivenpassword = 'Italian'\r\nprint('The original Password = ', givenpassword)\r\n# Pass the given password as an argument to createSecurePassword() function.\r\nmodifiedpassword = createSecurePassword(givenpassword)\r\n# Print the New Modified Password.\r\n\r\nprint('The new modified password = ', modifiedpassword)"}
{"nl": "Maze Escape", "code": "def exit_maze(maze, directions):\n  i = 9\n  j = 8\n  for direction in directions:\n    if direction == \"N\":\n      i -= 1\n    elif direction == \"S\":\n      i += 1\n    elif direction == \"E\":\n      j += 1\n    else:\n      j -= 1\n    if i < 0 or i > 9 or j < 0 or j > 9:\n      return \"Dead\"\n    elif maze[i][j] == 1:\n      return \"Dead\"\n    elif maze[i][j] == 3:\n      return \"Finish\"\n  return \"Lost\""}
{"nl": "Python Program to Calculate the Standard Deviation", "code": "# importing statistics\nimport statistics\n# given list\ngiven_list = [34, 14, 7, 13, 26, 22, 12, 19,\n              29, 33, 31, 30, 20, 10, 9, 27, 31, 24]\n# using stdev() fun to calculate standard devaition\nstandarddevList = statistics.stdev(given_list)\n# print the given list and standard deviation\nprint(\"The given list of numbers : \")\nfor i in given_list:\n    print(i, end=\" \")\n# printing new empty line\nprint()\n# printing the standard deviation of the given list of numbers\nprint(\"Standard deviation of the given list =\", standarddevList)"}
{"nl": "Python Program to Implement the Latin Alphabet Cipher", "code": "# Give the string as user input(which consists of only alphabets and spaces)\n# using input() and store it in a variable.\ngivenstring = input('Enter some random string = ')\nprint('The encrypted message of the given string{', givenstring, '}is :')\n# Iterate through the characters of the string using For loop.\n# We can calculate the ASCII value of the character using the ord() function.\nfor m in givenstring:\n    # Now, transform each input string character to its ASCII value\n    # and subtract it from the ASCII\n    # value of alphabet A for uppercase characters and 'a' for lowercase ones.\n    if (m >= \"A\" and m <= \"Z\"):\n      # The operation is written as ord(givenstring[i])-ord(\u201cA\u201d)+1 for uppercase letters.\n        print(ord(m)-ord(\"A\")+1, end=\" \")\n    elif (m >= \"a\" and m <= 'z'):\n        # ord(givenstring[i])-ord(\u201ca\u201d)+1 for lowercase letters.\n        print(ord(m)-ord(\"a\")+1, end=\" \")\n    # If the character is space then print it(That is printing\n    # space character without endl which makes it to print in next line)\n    if m == (\" \"):\n        print(m)"}
{"nl": "Python else Keyword", "code": "x = 2\r\nif x > 3:\r\n  print(\"YES\")\r\nelse:\r\n  print(\"NO\")\r\n"}
{"nl": "Apocalyptic Numbers", "code": "def is_apocalyptic(number):\n  return ['Safe','Single','Double','Triple'][str(2**number).count('666')]"}
{"nl": "Convert a Binary Tree into Doubly Linked List in spiral fashion", "code": "# Python3 program to convert Binary Tree\n# into Doubly Linked List where the nodes\n# are represented spirally.\n\t\n# Binary tree node\nclass newNode:\n\n\t# Constructor to create a newNode\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\t\t\n\"\"\" Given a reference to the head of a list\n\tand a node, inserts the node on the front\n\tof the list. \"\"\"\ndef push(head_ref, node):\n\n\t# Make right of given node as\n\t# head and left as None\n\tnode.right = (head_ref)\n\tnode.left = None\n\n\t# change left of head node to\n\t# given node\n\tif ((head_ref) != None):\n\t\t(head_ref).left = node\n\n\t# move the head to point to\n\t# the given node\n\t(head_ref) = node\n\n# Function to prints contents of DLL\ndef printList(node):\n\ti = 0\n\twhile (i < len(node)):\n\t\n\t\tprint(node[i].data, end = \" \")\n\t\ti += 1\n\t\n\"\"\" Function to print corner node at each level \"\"\"\ndef spiralLevelOrder(root):\n\n\t# Base Case\n\tif (root == None):\n\t\treturn\n\n\t# Create an empty deque for doing spiral\n\t# level order traversal and enqueue root\n\tq = []\n\tq.append(root)\n\n\t# create a stack to store Binary\n\t# Tree nodes to insert into DLL later\n\tstk = []\n\n\tlevel = 0\n\twhile (len(q)):\n\t\n\t\t# nodeCount indicates number of\n\t\t# Nodes at current level.\n\t\tnodeCount = len(q)\n\t\t\n\t\t# Dequeue all Nodes of current level\n\t\t# and Enqueue all Nodes of next level\n\t\tif (level&1): # odd level\n\t\t\twhile (nodeCount > 0):\n\t\t\t\n\t\t\t\t# dequeue node from front &\n\t\t\t\t# push it to stack\n\t\t\t\tnode = q[0]\n\t\t\t\tq.pop(0)\n\t\t\t\tstk.append(node)\n\n\t\t\t\t# insert its left and right children\n\t\t\t\t# in the back of the deque\n\t\t\t\tif (node.left != None):\n\t\t\t\t\tq.append(node.left)\n\t\t\t\tif (node.right != None):\n\t\t\t\t\tq.append(node.right)\n\n\t\t\t\tnodeCount -= 1\n\t\t\t\n\t\telse:\t # even level\n\t\t\n\t\t\twhile (nodeCount > 0):\n\t\t\t\n\t\t\t\t# dequeue node from the back &\n\t\t\t\t# push it to stack\n\t\t\t\tnode = q[-1]\n\t\t\t\tq.pop(-1)\n\t\t\t\tstk.append(node)\n\n\t\t\t\t# inserts its right and left\n\t\t\t\t# children in the front of\n\t\t\t\t# the deque\n\t\t\t\tif (node.right != None):\n\t\t\t\t\tq.insert(0, node.right)\n\t\t\t\tif (node.left != None):\n\t\t\t\t\tq.insert(0, node.left)\n\t\t\t\tnodeCount -= 1\n\t\tlevel += 1\n\t\t\n\t# head pointer for DLL\n\thead = []\n\t\n\t# pop all nodes from stack and push\n\t# them in the beginning of the list\n\twhile (len(stk)):\n\t\n\t\thead.append(stk[0])\n\t\tstk.pop(0)\n\n\tprint(\"Created DLL is:\")\n\tprintList(head)\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t\"\"\"Let us create Binary Tree as\n\tshown in above example \"\"\"\n\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(6)\n\troot.right.right = newNode(7)\n\n\troot.left.left.left = newNode(8)\n\troot.left.left.right = newNode(9)\n\troot.left.right.left = newNode(10)\n\troot.left.right.right = newNode(11)\n\t#root.right.left.left = newNode(12)\n\troot.right.left.right = newNode(13)\n\troot.right.right.left = newNode(14)\n\t#root.right.right.right = newNode(15)\n\n\tspiralLevelOrder(root)\n\n# This code is contributed\n# by SHUBHAMSINGH10\n"}
{"nl": "Adding Parentheses to Expression to Minimize Result ", "code": "class Solution:\n    def minimizeResult(self, E: str) -> str:\n        idx=E.index('+') ; L=E[:idx] ; R=E[idx+1:] ; ans=[]\n        for i in range(len(L)):\n            for j in range(1,len(R)+1):\n                sm=(int(L[:i]) if L[:i] else 1)*((int(L[i:]) if L[i:] else 0)+(int(R[:j]) if R[:j] else 0))*(int(R[j:]) if R[j:] else 1)\n                exp=L[:i]+'('+L[i:]+'+'+R[:j]+')'+R[j:]\n                ans.append([sm, exp])\n        return sorted(ans, key=lambda x:x[0])[0][1]"}
{"nl": "Sort words in Alphabetic Order", "code": "# Give the string as user input using input() function and store it in a variable.\r\ngven_str = input(\"Enter some random string = \")\r\n# Split the given string into list of words using the split() function and store\r\n# it in another variable say \"wrd_lst\".\r\nwrd_lst = gven_str.split()\r\n# Sort the above obtained word list using the sort() method.\r\nwrd_lst.sort()\r\n# Loop in the above list \"wrd_lst\" using the for loop.\r\nprint(\"The all sorted words of given sentence in Alphabetic order :\")\r\nfor wrd in wrd_lst:\r\n  # Print the iterator value to sort all words in a given sentence in alphabetic order.\r\n    print(wrd)"}
{"nl": "File close() method", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\ngvn_file = open(givenFilename, 'w') \n# Print some random text for acknowledgment\nprint(\"your file is opened now!\")\n# Print the given file\nprint(gvn_file)\n# Close the given file using the close() function\ngvn_file.close()\n# Print some random text for acknowledgment\nprint(\"your file is closed now!\")"}
{"nl": "Python Program to Find the Least Frequent Character in a String", "code": "# Import the Counter() function from collections using the import keyword.\nfrom collections import Counter\n# Give the string a static input and store it in a variable.\ngvnstrng = 'zzzyyddddeeeee'\n# Calculate the frequency of all the given string elements\n# using the Counter() function which returns the element\n# and its frequency as key-value pair and store this\n# dictionary in a variable(say elementsfrequency)\nelementsfrequency = Counter(gvnstrng)\n# Calculate the minimum frequency character in the given string\n# using the min() and \"get\" function and store it in a variable.\nminfreqchar = str(min(elementsfrequency, key=elementsfrequency.get))\n# Print the least frequency character in the given string\n# by printing the above variable.\nprint('The least frequency character in the given string',\n      gvnstrng, 'is [', minfreqchar, ']')"}
{"nl": "Matrix Subtraction", "code": "def subtract_matrix(A, B):\n  return [\n    [float(i) - float(j) for i, j in zip(a, b)] \n    for a, b in zip(A, B)\n  ]"}
{"nl": "The mean of the array after removals", "code": "def trimMean(self, arr: List[int]) -> float:\n  n = len(arr)\n  return sum(sorted(arr)[n // 20 : -n // 20]) / (n * 9 // 10)"}
{"nl": "Type Conversion", "code": "x = 1 # int\r\ny = 2.8 # float\r\nz = 1j # complex\r\n\r\n#convert from int to float:\r\na = float(x)\r\n\r\n#convert from float to int:\r\nb = int(y)\r\n\r\n#convert from int to complex:\r\nc = complex(x)\r\n\r\nprint(a)\r\nprint(b)\r\nprint(c)\r\n\r\nprint(type(a))\r\nprint(type(b))\r\nprint(type(c))"}
{"nl": "The sum of the Arithmetic progression Series", "code": "# Give the first term of arithmetic progression series as static input\n # and store it in a variable.\n fst_trm = 2\n # Give the total number of terms of the A.P. series as static input and\n # store it in another variable.\n total_terms = 6\n # Give the common difference of the A.P. series as static input and store it\n # in another variable.\n common_diff = 4\n # Calculate the sum of the given arithmetic progression series using the above given\n # mathematical formula(n/2(2a + (n \u2013 1) d)) and store it in a variable.\n sum_ap = (total_terms * (2 * fst_trm + (total_terms - 1) * common_diff)) / 2\n # Calculate the nth term of the given arithmetic progression series using the above\n # given mathematical formula ( Tn = a + (n \u2013 1) d) and store it in another variable.\n nth_trm_ap = fst_trm + (total_terms - 1) * common_diff\n # Print the sum and nth term of the given Arithmetic Progression series.\n print(\"Given Arithmetic Progression Series Sum with [a,n,d]:(\",\n  fst_trm, total_terms, common_diff, \") = \", sum_ap)\n print(\"The Given Arithmetic Progression Series nth Term with [a,n,d]:(\",\n  fst_trm, total_terms, common_diff, \") = \", nth_trm_ap)"}
{"nl": "In N Days...", "code": "def afterNdays(days, n):\n  weekdays = ['Monday','Tuesday','Wednesday','Thursday','Friday',\n  'Saturday','Sunday']\n  return [weekdays[(weekdays.index(day) + n) % 7] for day in days]"}
{"nl": "find the minimum total soace wasterd if you can resize an array k times at most", "code": "class Solution:\n    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\n        # imagine I know the min space wasted for the first i cases\n        # i+1, either we do a resize at i+1 or we skip it\n        n = len(nums)\n        cumsum = list(accumulate(nums))\n        revsum = list(accumulate(nums[::-1]))[::-1]\n        cummax = [nums[0]]\n        for i in range(1,n):\n            cummax.append(max(cummax[-1], nums[i]))\n        revmax = [nums[-1]]\n        for i in range(n-2, -1, -1):\n            revmax.append(max(revmax[-1], nums[i]))\n        revmax = revmax[::-1]\n        revmax = revmax+[0]\n        revsum = revsum+[0]\n        max_arr = [[0]*n for _ in range(n)]\n        for i in range(n):\n            curmax = nums[i]\n            for j in range(i, n):\n                curmax = max(curmax, nums[j])\n                max_arr[i][j] = curmax\n                    \n        @lru_cache(None)\n        def dp(i,p):\n            if(p == 0): # if there are no more resizes available,\n                return cummax[i]*(i+1)-cumsum[i] #correct\n            if(i==0): # at index 0 no matter what p, we can finish up to i\n                return 0\n            ansr = float('Inf')\n            for j in range(i): \n                cusum = revsum[j+1]-revsum[i+1]\n                revmax_c= max_arr[j+1][i]#max(nums[j+1:i+1])\n                ansr = min(ansr, dp(j, p-1) + (revmax_c*(i-j)-cusum))  \n            return ansr\n        \n        return dp(n-1, k)\n            "}
{"nl": "Print Numbers, that contain 1, 2 and 3, in Ascending Order", "code": "# Give the list as static input and store it in a variable.\r\ngven_lst = [67123, 1234, 985, 126, 1011]\r\n# Take a new empty list say \"numb\" and store it in another variable.\r\nnumb = []\r\n# Loop in the given list using the for loop.\r\nfor itr in gven_lst:\r\n # Inside the loop, convert the iterator value to the string using the str() function\r\n    # and store it in another variable.\r\n    strng_number = str(itr)\r\n# Check if 1 and 2 and 3 are present in the string number using the if conditional\r\n# statement and 'and' keyword.\r\n    if '1' in strng_number and '2' in strng_number and '3' in strng_number:\r\n        # If the statement is true, then append the iterator value to the above initialized\r\n        # new empty list \"numb\".\r\n        numb.append(itr)\r\n # Sort the above list \"numb\" using the sort() function.\r\nnumb.sort()\r\n# print the list \"numb\" to print the numbers with the digits 1, 2, and 3 in ascending order,\r\n# which is separated by commas.\r\nprint(\"The numbers with the digits 1, 2, and 3 in ascending order, which is separated by commas= \", numb)"}
{"nl": "Armstrong Number Program in Python", "code": "# Python program to check armstrong number def digits_count(n): i = 0 while n > 0: n //= 10 i += 1 return i def sum(n): i = digits_count(n) s = 0 while n > 0: digit = n%10 n //= 10 s += pow(digit,i) return s # take inputs num = int(input(\"Enter number: \")) # calling function s = sum(num) # check armstrong number or not if s == num: print(\"The number is an Armstrong number.\") else: print(\"The number is not an Armstrong number.\")"}
{"nl": "Perform XOR on Two Lists", "code": "# Give the first list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\nlstt1 = list(map(int, input(\r\n    'Enter some random List Elements separated by spaces = ').split()))\r\n# Give the second list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\nlstt2 = list(map(int, input(\r\n    'Enter some random List Elements separated by spaces = ').split()))\r\nprint('The given First list elements are =', lstt1)\r\nprint('The given Second list elements are =', lstt2)\r\n# Calculate the length of the first list using the len()\r\n# function(as both lists have same length) and store it in a variable.\r\nlenlst = len(lstt1)\r\n# Loop till the above length using the For loop.\r\nfor p in range(lenlst):\r\n    # Inside the for loop initialize the list 1 element as xor operation\r\n    # between list1 and list2 using xor operator i.e lst1[p]=lst1[p]^lst2[p]\r\n    # where p is the iterator value of the For loop.\r\n    lstt1[p] = lstt1[p] ^ lstt2[p]\r\n# Print the list1 which is the result.\r\nprint('The result after applying xor operation on both lists is', lstt1)"}
{"nl": "Python math.asinh() Method", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the inverse hyperbolic sine of numbers\r\nprint(math.asinh(7))\r\nprint(math.asinh(56))\r\nprint(math.asinh(2.45))\r\nprint(math.asinh(1))"}
{"nl": "Remove BST keys outside the given range", "code": "# Python3 program to remove BST keys\n# outside the given range\n\u00a0\n# A BST node has key, and left and right\u00a0\n# pointers. A utility function to create\n# a new BST node with key as given num\nclass newNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Removes all nodes having value outside\n# the given range and returns the root\n# of modified tree\ndef removeOutsideRange(root, Min, Max):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# First fix the left and right\n\u00a0\u00a0\u00a0\u00a0# subtrees of root\n\u00a0\u00a0\u00a0\u00a0root.left = removeOutsideRange(root.left,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Min, Max)\n\u00a0\u00a0\u00a0\u00a0root.right = removeOutsideRange(root.right,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Min, Max)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Now fix the root. There are 2\n\u00a0\u00a0\u00a0\u00a0# possible cases for root\n\u00a0\u00a0\u00a0\u00a0# 1.a) Root's key is smaller than\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0 min value (root is not in range)\n\u00a0\u00a0\u00a0\u00a0if root.key < Min:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rChild = root.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return rChild\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# 1.b) Root's key is greater than max\n\u00a0\u00a0\u00a0\u00a0#\u00a0\u00a0\u00a0\u00a0\u00a0 value (root is not in range)\n\u00a0\u00a0\u00a0\u00a0if root.key > Max:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lChild = root.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return lChild\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2. Root is in range\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\n# A utility function to insert a given\n# key to BST\ndef insert(root, key):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return newNode(key)\n\u00a0\u00a0\u00a0\u00a0if root.key > key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, key)\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, key)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# Utility function to traverse the binary\n# tree after conversion\ndef inorderTraversal(root):\n\u00a0\u00a0\u00a0\u00a0if root:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorderTraversal( root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(root.key, end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorderTraversal( root.right)\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 6)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, -13)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 14)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, -8)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 13)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 7)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Inorder traversal of the given tree is:\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end = \" \")\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0root = removeOutsideRange(root, -10, 13)\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\u00a0\u00a0print(\"Inorder traversal of the modified tree is:\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end = \" \")\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Convert two lists into a dictionary", "code": "keys = ['Ten', 'Twenty', 'Thirty']\r\nvalues = [10, 20, 30]\r\n\r\nres_dict = dict(zip(keys, values))\r\nprint(res_dict)\r"}
{"nl": "Program to Read a Number n and Compute n+nn+nnn in C++ and Python", "code": "# given number numb\nnumb = 8\n# converting the given number to string\nstrnum = str(numb)\n# Add the string twice to concatenate it and store it in another variable.\nstrnum1 = strnum+strnum\n# Add the string thrice  to concatenate it and store it in another variable.\nstrnum2 = strnum+strnum+strnum\n# converting the strnum1 and strnum2 from string to integer using int() function\nintnum1 = int(strnum1)\nintnum2 = int(strnum2)\n# Calculating the result value\nresultVal = numb+intnum1+intnum2\nprint(\"The value of\", strnum, \"+\", strnum1, \"+\", strnum2, \"=\", resultVal)"}
{"nl": "Program to evaluate simple expressions", "code": "# Python3 program to evaluate a\r\n# given expression\r\n \r\n# A utility function to check if\r\n# a given character is operand\r\ndef isOperand(c):\r\n  \r\n    return (c >= '0' and c <= '9');\r\n \r\n# utility function to find\r\n# value of and operand\r\ndef value(c):\r\n    return ord(c) - ord('0');\r\n \r\n# This function evaluates simple\r\n# expressions. It returns -1 if the\r\n# given expression is invalid.\r\ndef evaluate(exp):\r\n \r\n    len1 = len(exp);\r\n     \r\n    # Base Case: Given expression is empty\r\n    if (len1 == 0):\r\n        return -1;\r\n \r\n    # The first character must be\r\n    # an operand, find its value\r\n    res = value(exp[0]);\r\n \r\n    # Traverse the remaining\r\n    # characters in pairs\r\n    for i in range(1,len1,2):\r\n        # The next character must be\r\n        # an operator, and next to\r\n        # next an operand\r\n        opr = exp[i];\r\n        opd = exp[i + 1];\r\n \r\n        # If next to next character\r\n        # is not an operand\r\n        if (isOperand(opd)==False):\r\n            return -1;\r\n \r\n        # Update result according\r\n        # to the operator\r\n        if (opr == '+'):\r\n            res += value(opd);\r\n        elif (opr == '-'):\r\n            res -= int(value(opd));\r\n        elif (opr == '*'):\r\n            res *= int(value(opd));\r\n        elif (opr == '/'):\r\n            res /= int(value(opd));\r\n \r\n        # If not a valid operator\r\n        else:\r\n            return -1;\r\n     \r\n    return res;\r\n \r\n# Driver Code\r\nexpr1 = \"1+2*5+3\";\r\nres = evaluate(expr1);\r\nprint(expr1,\"is Invalid\") if (res == -1) else print(\"Value of\",expr1,\"is\",res);\r\n \r\nexpr2 = \"1+2*3\";\r\nres = evaluate(expr2);\r\nprint(expr2,\"is Invalid\") if (res == -1) else print(\"Value of\",expr2,\"is\",res);\r\n \r\nexpr3 = \"4-2+6*3\";\r\nres = evaluate(expr3);\r\nprint(expr3,\"is Invalid\") if (res == -1) else print(\"Value of\",expr3,\"is\",res);\r\n \r\nexpr4 = \"1++2\";\r\nres = evaluate(expr4);\r\nprint(expr4,\"is Invalid\") if (res == -1) else print(\"Value of\",expr4,\"is\",res);\r\n \r\n# This code is contributed by mits"}
{"nl": "Generating Words from Names", "code": "def anagram(name, words):\n  return sorted(''.join(words) + ' ') == sorted(name.lower())"}
{"nl": "Matrix Multiplication using Recursion", "code": "# Recursive code for Matrix Multiplication\nMAX = 100\ni = 0\nj = 0\nk = 0\n\u00a0\ndef multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Note that below variables are static\n\u00a0\u00a0\u00a0\u00a0# i and j are used to know current cell of\n\u00a0\u00a0\u00a0\u00a0# result matrix C[][]. k is used to know\n\u00a0\u00a0\u00a0\u00a0# current column number of A[][] and row\n\u00a0\u00a0\u00a0\u00a0# number of B[][] to be multiplied\n\u00a0\u00a0\u00a0\u00a0global i\n\u00a0\u00a0\u00a0\u00a0global j\n\u00a0\u00a0\u00a0\u00a0global k\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If all rows traversed.\n\u00a0\u00a0\u00a0\u00a0if (i >= row1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If i < row1\n\u00a0\u00a0\u00a0\u00a0if (j < col2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k < col1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C[i][j] += A[i][k] * B[k][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2,B, C)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0j = 0\n\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C)\n\u00a0\n# Function to multiply two matrices\n# A[][] and B[][]\ndef multiplyMatrix(row1, col1, A, row2, col2, B):\n\u00a0\u00a0\u00a0\u00a0if (row2 != col1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Not Possible\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0C = [[0 for i in range(MAX)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(MAX)]\n\u00a0\u00a0\u00a0\u00a0multiplyMatrixRec(row1, col1, A,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row2, col2, B, C)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the result\n\u00a0\u00a0\u00a0\u00a0for i in range(row1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(col2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print( C[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\nA = [[1, 2, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0[4, 5, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0[7, 8, 9]]\nB = [[1, 2, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0[4, 5, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0[7, 8, 9]]\n\u00a0\nrow1 = 3\ncol1 = 3\nrow2 = 3\ncol2 = 3\nmultiplyMatrix(row1, col1, A, row2, col2, B)\n\u00a0\n# This code is contributed by sahilshelangia\n"}
{"nl": "Sort the matrix row-wise and column-wise", "code": "# Python 3 implementation to\n# sort the matrix row-wise\n# and column-wise\nMAX_SIZE = 10\n\u00a0\n# function to sort each\n# row of the matrix\ndef sortByRow(mat, n):\n\u00a0\u00a0\u00a0\u00a0for i in range (n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sorting row number 'i'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if mat[i][j] > mat[i][j + 1]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = mat[i][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = mat[i][j + 1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j + 1] = temp\n\u00a0\n# function to find\n# transpose of the matrix\ndef transpose(mat, n):\n\u00a0\u00a0\u00a0\u00a0for i in range (n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(i + 1, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# swapping element at\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# index (i, j) by element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# at index (j, i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = mat[i][j]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = mat[j][i]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[j][i] = t\n\u00a0\n# function to sort\n# the matrix row-wise\n# and column-wise\ndef sortMatRowAndColWise(mat, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# sort rows of mat[][]\n\u00a0\u00a0\u00a0\u00a0sortByRow(mat, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# get transpose of mat[][]\n\u00a0\u00a0\u00a0\u00a0transpose(mat, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# again sort rows of mat[][]\n\u00a0\u00a0\u00a0\u00a0sortByRow(mat, n)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# again get transpose of mat[][]\n\u00a0\u00a0\u00a0\u00a0transpose(mat, n)\n\u00a0\n# function to print the matrix\ndef printMat(mat, n):\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(str(mat[i][j] ), end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\nmat = [[ 4, 1, 3 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 9, 6, 8 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 5, 2, 7 ]]\nn = 3\n\u00a0\nprint(\"Original Matrix:\")\nprintMat(mat, n)\n\u00a0\nsortMatRowAndColWise(mat, n)\n\u00a0\nprint(\"\\nMatrix After Sorting:\")\nprintMat(mat, n)\n\u00a0\n# This code is contributed\n# by ChitraNayal\n"}
{"nl": "Python Program to Print Odd Numbers Within a Given Range", "code": "# Give the lower limit and upper limit as static input\n \n # and store them in two separate variables.\n \n # given lower limit range\n \n lowLimitRange = 23\n \n # given upper limit range\n \n uppLimitRange = 143\n \n print('Odd numbers from', lowLimitRange, 'to', uppLimitRange, 'are :')\n \n # Loop from lower limit range to upper limit range using For loop.\n \n for iterval in range(lowLimitRange, uppLimitRange+1):\n \n  # Check if the iterator value is even or odd using if statement and modulus operator.\n \n  if(iterval % 2 != 0):\n \n  # If the iterator value is odd then print it.\n \n  print(iterval, end=\" \")\n \n </pre>"}
{"nl": "Digits Sum Root", "code": "def root_digit(n):\n  while n > 9:\n    n = sum(int(i) for i in str(n))\n  return n"}
{"nl": "Python Program to Find the Sum of Sine Series", "code": "# importing math module\nimport math\n# function which returns sum of sine series\n\n\ndef sumsine(degrees, terms):\n  # taking a variable which stores sum of sine series\n    sumSeries = 0\n    for i in range(terms):\n      # getting sign\n        signofNum = (-1)**i\n        # pie value\n        pievalue = 22/7\n        # degree value of given number\n        degval = degrees*(pievalue/180)\n        sumSeries = sumSeries + ((degval**(2.0*i+1)) /\n                                 math.factorial(2*i+1))*signofNum\n     # returning the sum of sine series\n    return sumSeries\n\n\ndegrees = int(input(\"enter the number of degrees = \"))\nterms = int(input(\"enter number of terms = \"))\nprint(\"The sum of sine series of \", degrees, \"degrees\", \"of\",\n      terms, \"terms =\", round(sumsine(degrees, terms), 2))"}
{"nl": "Write a function to solve alphametics puzzles", "code": "from itertools import permutations\nfrom operator import mul\nimport re\ndef solve(puzzle):\n    words = re.findall(r\"\\w+\", puzzle)[::-1]\n    d = {w[0]: 0 for w in words}\n    knz = len(d)\n    d.update({c: 0 for c in filter(str.isalpha, puzzle)})\n    for i, w in enumerate(words):\n        for j, c in enumerate(w[::-1]):\n            d[c] = d[c] + 10**j * (bool(i) * 2 - 1)\n    factors = d.values()\n    for p in permutations(range(10), len(d)):\n        if 0 in p[:knz]:\n            continue\n        if not sum(map(mul, factors, p)):\n            return dict(zip(d.keys(), p))"}
{"nl": "Shhh Be Quiet Function", "code": "def shhh(txt):\n  return '\"{}\", whispered Edabit.'.format(txt.capitalize())"}
{"nl": "Reversing a Queue", "code": "# Python3 program to reverse a queue\nfrom queue import Queue\n\u00a0\n# Utility function to print the queue\ndef Print(queue):\n\u00a0\u00a0\u00a0\u00a0while (not queue.empty()):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(queue.queue[0], end = \", \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.get()\n\u00a0\n# Function to reverse the queue\ndef reversequeue(queue):\n\u00a0\u00a0\u00a0\u00a0Stack = []\n\u00a0\u00a0\u00a0\u00a0while (not queue.empty()):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Stack.append(queue.queue[0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.get()\n\u00a0\u00a0\u00a0\u00a0while (len(Stack) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.put(Stack[-1])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Stack.pop()\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0queue = Queue()\n\u00a0\u00a0\u00a0\u00a0queue.put(10)\n\u00a0\u00a0\u00a0\u00a0queue.put(20)\n\u00a0\u00a0\u00a0\u00a0queue.put(30)\n\u00a0\u00a0\u00a0\u00a0queue.put(40)\n\u00a0\u00a0\u00a0\u00a0queue.put(50)\n\u00a0\u00a0\u00a0\u00a0queue.put(60)\n\u00a0\u00a0\u00a0\u00a0queue.put(70)\n\u00a0\u00a0\u00a0\u00a0queue.put(80)\n\u00a0\u00a0\u00a0\u00a0queue.put(90)\n\u00a0\u00a0\u00a0\u00a0queue.put(100)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0reversequeue(queue)\n\u00a0\u00a0\u00a0\u00a0Print(queue)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Read char-by-char from file", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  print('The Characters in the given file : ')\n  for gvnfileline in givenfilecontent:\n  # Split the words of the line using the split() function and store them in a variable(it is of type list).\n  gvnfilewords = gvnfileline.split()\n  # Loop in the above list using another Nested For loop.\n  for words in gvnfilewords:\n  # Print all the characters of the word using another Nested For loop and print function.\n  for charactrs in words:\n  print(charactrs)"}
{"nl": "Python For Loops\r\n", "code": "fruits = [\"apple\", \"banana\", \"cherry\"]\r\nfor x in fruits:\r\n  print(x)"}
{"nl": "sum of subaaray ranges", "code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        sm=0\n        n=len(nums)\n        for i in range(n-1):\n            mx=nums[i]\n            mn=nums[i]\n            for j in range(i+1,n):\n                \n                mx=max(mx,nums[j])\n                mn=min(mn,nums[j])\n                sm+=(mx-mn)\n        return sm\n        "}
{"nl": "Function that returns True if exactly one word in the list differs in length from the rest. Return False in all other cases.", "code": "def odd_one_out(lst):\r\n  lst = [len(item) for item in lst]\r\n  counts = [lst.count(i) for i in set(lst)]\r\n  return len(set(lst)) == 2 and 1 in counts"}
{"nl": "maximum number of words found in an array of sentences", "code": "class Solution:\n    def mostWordsFound(self, sentences: List[str]) -> int:\n        max=0\n        for i in sentences:\n            temp=i.split(\" \")\n            res=len(temp)\n            if res>max:\n                max=res\n        return max"}
{"nl": "Python Program to Print the Fibonacci sequence", "code": "# Program to display the Fibonacci sequence up to n-th term\n\nnterms = int(input(\"How many terms? \"))\n\n# first two terms\nn1, n2 = 0, 1\ncount = 0\n\n# check if the number of terms is valid\nif nterms <= 0:\n   print(\"Please enter a positive integer\")\n# if there is only one term, return n1\nelif nterms == 1:\n   print(\"Fibonacci sequence upto\",nterms,\":\")\n   print(n1)\n# generate fibonacci sequence\nelse:\n   print(\"Fibonacci sequence:\")\n   while count < nterms:\n       print(n1)\n       nth = n1 + n2\n       # update values\n       n1 = n2\n       n2 = nth\n       count += 1"}
{"nl": "Python Program to Determine Whether one String is a Rotation of Another", "code": "# Give the first string as user input using input() function and store it in a variable.\nfst_str = input(\"Enter some random string = \")\n# Give the second string as user input using input() function and store it in another variable.\nsecnd_str = input(\"Enter some random string = \")\n# Check if the length of the first string is not equal to the length of the second\n# string using the if conditional statement and using the len() function.\nif(len(fst_str) != len(secnd_str)):\n    # If the statement is true, print \"The given second string is not the rotation of the given first string\".\n    print(\"The given second string is not the rotation of the given first string\")\nelse:\n    # Else concat the first string with the first string itself using the '+ ' operator\n    # and store it in a variable say \"conat_str\".\n    conct_str = fst_str + fst_str\n# Check if the second string is present in the \"conca_str\" using the if\n# conditional statement.\n    if(secnd_str in conct_str):\n        # If the statement is true, print  \"The given second string is the rotation of the given first string\".\n        print(\"The given second string is the rotation of the given first string\")\n    else:\n        # Else print  \"The given second string is not the rotation of the given first string\".\n        print(\"The given second string is not the rotation of the given first string\")"}
{"nl": "Python Program to Read Print Prime Numbers in a Range using Sieve of Eratosthenes", "code": "# Give the value of the upper limit n as static input.\n \n numb = 20\n \n print('The prime numbers from 1 to', numb, 'are :')\n \n # Fill the sieve with numbers ranging from 2 to n.\n \n sievearray = set(range(2, numb+1))\n \n # Use a while loop that checks to see if the sieve is empty.\n \n while sievearray:\n \n  # Find the smallest prime number.\n \n  primenum = min(sievearray)\n \n  # printing the primenum\n \n  print(primenum, end=\" \")\n \n  sievearray -= set(range(primenum, numb+1, primenum))\n \n </pre>"}
{"nl": "Pascal\u2019s Triangle", "code": "# Python 3 code for Pascal's Triangle\n# A simple O(n^3)\n# program for\n# Pascal's Triangle\n\n# Function to print\n# first n lines of\n# Pascal's Triangle\ndef printPascal(n) :\n\t\n\t# Iterate through every line\n\t# and print entries in it\n\tfor line in range(0, n) :\n\t\t\n\t\t# Every line has number of\n\t\t# integers equal to line\n\t\t# number\n\t\tfor i in range(0, line + 1) :\n\t\t\tprint(binomialCoeff(line, i),\n\t\t\t\t\" \", end = \"\")\n\t\tprint()\n\t\n\n# See https://www.geeksforgeeks.org/space-and-time-efficient-binomial-coefficient/\n# for details of this function\ndef binomialCoeff(n, k) :\n\tres = 1\n\tif (k > n - k) :\n\t\tk = n - k\n\tfor i in range(0 , k) :\n\t\tres = res * (n - i)\n\t\tres = res // (i + 1)\n\t\n\treturn res\n\n# Driver program\nn = 7\nprintPascal(n)\n\n\n# This code is contributed by Nikita Tiwari."}
{"nl": "Multiply Two Numbers Without Using Multiplication(*) Operator", "code": "# Give the first number as user input using the int(input()) function and\r\n# store it in a variable.\r\nfst_numb = int(input(\"Enter some random number = \"))\r\n# Give the second number as user input using the int(input()) function and\r\n# store it in another variable.\r\nscnd_numb = int(input(\"Enter some random number = \"))\r\n# Take a variable say rslt_sum and initialize its value to 0.\r\nrslt_sum = 0\r\n# Loop from 1 to the given first number using the for loop.\r\nfor itr in range(1, fst_numb+1):\r\n    # Inside the loop, add the given second number to the above-initialized variable\r\n    # rslt_sum and store it in the same variable rslt_sum.\r\n    rslt_sum = rslt_sum+scnd_numb\r\n# Print the variable rslt_sum to get the multiplication of given two numbers without\r\n# using the multiplication(*) Operator.\r\nprint(\"The multiplication of given two numbers{\",\r\n      fst_numb, \"*\", scnd_numb, \"} = \", rslt_sum)"}
{"nl": "Python Program to Print Triangle of Alphabets in Reverse Pattern\n", "code": "rows = int(input(\"Enter Triangle of Reverse Alphabets Rows = \"))\n\nprint(\"====The Triangle of Alphabets in Reverse Pattern====\")\nalphabet = 65\n\nfor i in range(rows - 1, -1, -1):\n    for j in range(i):\n        print(end = ' ')\n    for k in range(i, rows):\n        print('%c' %(alphabet + k), end = ' ')\n    print()"}
{"nl": "Given a Boolean Matrix, find k such that all elements in k\u2019th row are 0 and k\u2019th column are 1.", "code": "''' Python program to find k such that all elements in k'th row\n\u00a0\u00a0\u00a0\u00a0are 0 and k'th column are 1'''\n\u00a0\ndef find(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# store length of the array\n\u00a0\u00a0\u00a0\u00a0n = len(arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# start from top right-most corner\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0j = n - 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# initialise result\n\u00a0\u00a0\u00a0\u00a0res = -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# find the index (This loop runs at most 2n times, we\n\u00a0\u00a0\u00a0\u00a0# either increment row number or decrement column number)\n\u00a0\u00a0\u00a0\u00a0while i < n and j >= 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if the current element is 0, then this row may be a solution\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr[i][j] == 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check for all the elements in this row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while j >= 0 and (arr[i][j] == 0 or i == j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if all values are 0, update result as row number\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if found a 1 in current row, the row can't be a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# solution, increment row number\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else: i += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if the current element is 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#check for all the elements in this column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while i < n and (arr[i][j] == 1 or i == j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i +=1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if all elements are 1, update result as col number\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == n:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = j\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if found a 0 in current column, the column can't be a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# solution, decrement column number\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else: j -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if we couldn't find result in above loop, result doesn't exist\n\u00a0\u00a0\u00a0\u00a0if res == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# check if the above computed res value is valid\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if res != i and arr[i][res] != 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\u00a0\u00a0for j in range(0, j):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if res != j and arr[res][j] != 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\n# test find(arr) function\narr = [ [0,0,1,1,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0,0,0,1,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1,1,1,1,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0,0,0,0,0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1,1,1,1,1] ]\n\u00a0\nprint (find(arr))\n"}
{"nl": "The power of base and exponent", "code": "# Take a variable to say numb and initialize its value with 1000000007(10^9+7).\n numb = 1000000007\n # Create a function to say exponentl_squaring() which takes the given two base and\n # exponential values as the arguments and returns the value of the power of base and\n # exponent modular 10^9+7.\n def exponentl_squaring(gvn_baseval, gvn_exponentlval):\n  # Inside the function, take a variable say p, and initialize its value to 1.\n  p = 1\n  # Loop until the given exponential value is greater than 0 using the while loop.\n  while(gvn_exponentlval > 0):\n  # Check if the given exponential value is odd using the if conditional statement.\n  if (gvn_exponentlval % 2 != 0):\n  # If it is true, multiply p with the given base value and store it in another\n  # variable.\n  k = p * gvn_baseval\n  # Calculate the value of the above result modulus numb(10^9+7) and store it in the\n  # same variable p.\n  p = k % numb\n  # Multiply the given base value with itself and apply the modulus operator with\n  # 10^9+7(numb).\n  # Store it in the same variable given base value.\n  gvn_baseval = (gvn_baseval * gvn_baseval) % numb\n  # Divide the given exponential value by 2 and convert it to an integer using the\n  # int() function.\n  # Store it in the same variable given exponential value.\n  gvn_exponentlval = int(gvn_exponentlval / 2)\n  # Return the value of p modulus 10^9+7.\n  return p % numb\n # Give the base value as static input and store it in a variable.\n gvn_baseval = 5\n # Give the exponential value as static input and store it in another variable.\n gvn_exponentlval = 3\n # Pass the given base and exponential values as the arguments to the exponentl_squaring()\n # function and store it in a variable.\n rslt = exponentl_squaring(gvn_baseval, gvn_exponentlval)\n # Print the value of the power of base and exponent modular 10^9+7.\n print(\"The value of the power of base and exponent modular 10^9+7 = \", rslt)"}
{"nl": "Python Program to Calculate the Number of Digits and Letters in a String", "code": "# Give the string as static input and save it in a variable.\ngiven_strng = 'Hel34lo18th3is9is38 BTech23Geeks'\n# Take a variable to say stringdigits that stores the total digits in the given string.\n# Initialize the stringdigits to 0.\nstringdigits = 0\n# Take a variable to say stringcharacters that stores the total characters in the given string.\n# Initialize the stringcharacters to 0.\nstringcharacters = 0\n# Traverse the given string using for loop.\nfor charact in given_strng:\n    # Check if the character is a numerical digit or not using the isdigit() function.\n    if(charact.isdigit()):\n        # If the character is a numerical digit then increment the value of stringdigits by 1.\n        stringdigits = stringdigits+1\n    # Increase the stringcharacters by 1.\n    stringcharacters = stringcharacters+1\n# Print the total count of digits and characters present in the given string.\nprint(\n    'The total number of digits present in the given string [', given_strng, '] = ', stringdigits)\nprint(\n    'The total number of characters present in the given string [', given_strng, '] = ', stringcharacters)"}
{"nl": "Exercise working with binary search trees: implement the insert and search methods", "code": "\r\nfrom __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import Any, Generic, Iterable, Iterator, List, Optional, Protocol, TypeVar\r\nclass Comparable(Protocol):\r\n    def __lt__(self, other: Any) -> bool:\r\n        ...\r\nT = TypeVar(\"T\", bound=Comparable)\r\n@dataclass\r\nclass TreeNode(Generic[T]):\r\n    data: T\r\n    left: Optional[TreeNode[T]]\r\n    right: Optional[TreeNode[T]]\r\nclass BinarySearchTree(Generic[T]):\r\n    def __init__(self, tree_data: Iterable[T]) -> None:\r\n        self.root = None\r\n        for data in tree_data:\r\n            self.root = insert(self.root, data)\r\n    def data(self) -> Optional[TreeNode[T]]:\r\n        return self.root\r\n    def sorted_data(self) -> List[T]:\r\n        return list(visit(self.root))\r\ndef insert(node: Optional[TreeNode[T]], data: T) -> TreeNode[T]:\r\n    if node is None:\r\n        node = TreeNode(data, None, None)\r\n    elif node.data < data:\r\n        node.right = insert(node.right, data)\r\n    else:\r\n        node.left = insert(node.left, data)\r\n    return node\r\ndef visit(node: Optional[TreeNode[T]]) -> Iterator[T]:\r\n    if node is not None:\r\n        yield from visit(node.left)\r\n        yield node.data\r\n        yield from visit(node.right\r\n"}
{"nl": "Comment in python", "code": "#Use # to start a line comment"}
{"nl": "Search,insertion and deletion in an array", "code": "# Python program for inserting\n# an element in an unsorted array\n \n# method to insert element\ndef insert(arr, element):\n    arr.append(element)\n \n# declaring array and key to insert\narr = [12, 16, 20, 40, 50, 70]\nkey = 26\n  \n# array before inserting an element\nprint (\"Before Inserting: \")\nprint (arr)\n  \n# array after Inserting element\ninsert(arr, key)\nprint(\"After Inserting: \")\nprint (arr)\n \n# Thanks to Aditi Sharma for contributing\n# this code\n# Python program for inserting\n# an element in an unsorted array\n \n# method to insert element\ndef insert(arr, element):\n    arr.append(element)\n \n# declaring array and key to insert\narr = [12, 16, 20, 40, 50, 70]\nkey = 26\n  \n# array before inserting an element\nprint (\"Before Inserting: \")\nprint (arr)\n  \n# array after Inserting element\ninsert(arr, key)\nprint(\"After Inserting: \")\nprint (arr)\n \n# Thanks to Aditi Sharma for contributing\n# this code \n# Python program to delete an element\n# from an unsorted array\n \n# Declaring array and key to delete\narr = [10, 50, 30, 40, 20]\nkey = 30\n  \nprint(\"Array before deletion:\")\nprint (arr)\n  \n# deletes key if found in the array\n# otherwise shows error not in list\narr.remove(key)\nprint(\"Array after deletion\")\nprint(arr)\n  \n# This code is contributed by Aditi Sharma.\"\n# python 3  program to implement\n# binary search in sorted array\n  \ndef binarySearch(arr, low, high, key):\n    # low + (high - low)/2\n    mid = (low + high)/2\n  \n    if (key == arr[int(mid)]):\n        return mid\n  \n    if (key > arr[int(mid)]):\n        return binarySearch(arr,\n           (mid + 1), high, key)\n  \n    if (key < arr[int(mid)]):\n        return binarySearch(arr,low, (mid-1), key)\n      \n    return 0\n  \n# Driver program to check above functions \n# Let us search 3 in below array\narr = [5, 6, 7, 8, 9, 10]\nn = len(arr)\nkey = 10\nprint(\"\"Index:\"\", int(binarySearch(arr, 0, n-1, key) ))\n  \n# This code is contributed by\n# Smitha Dinesh Semwal\"\n# Python program to implement delete operation in a \n# sorted array \n  \n#/* Function to delete an element */\ndef deleteElement(arr, n, key):\n      \n    # Find position of element to be deleted \n    pos = binarySearch(arr, 0, n - 1, key) \n      \n    if (pos == -1):\n        print(\"Element not found\")\n        return n \n          \n    # Deleting element \n    for i in range(pos,n - 1):\n        arr[i] = arr[i + 1] \n      \n    return n - 1 \n      \n# To search a key to be deleted \ndef binarySearch(arr, low, high, key):\n      \n    if (high < low):\n        return -1 \n    mid = (low + high) // 2 \n      \n    if (key == arr[mid]):\n        return mid \n    if (key > arr[mid]):\n        return binarySearch(arr, (mid + 1), high, key) \n      \n    return binarySearch(arr, low, (mid - 1), key) \n   \n# Driver code \narr = [10, 20, 30, 40, 50 ]\n  \nn = len(arr)\nkey = 30 \n  \nprint(\"Array before deletion\")\n  \nfor i in range(n):\n    print(arr[i],end=\" \")\n      \nn = deleteElement(arr, n, key) \nprint(\"\\n\\nArray after deletion\")\nfor i in range(n):\n    print(arr[i],end=\" \")\n  \n# This code is contributed by shubhamsingh10   "}
{"nl": "Swapping nodes", "code": "\n# Python program to swap two given nodes of a linked list\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n \n    # head of list\n    class Node(object):\n        def __init__(self, d):\n            self.data = d\n            self.next = None\n \n    # Function to swap Nodes x and y in linked list by\n    # changing links\n    def swapNodes(self, x, y):\n \n        # Nothing to do if x and y are same\n        if x == y:\n            return\n \n        # Search for x (keep track of prevX and CurrX)\n        prevX = None\n        currX = self.head\n        while currX != None and currX.data != x:\n            prevX = currX\n            currX = currX.next\n \n        # Search for y (keep track of prevY and currY)\n        prevY = None\n        currY = self.head\n        while currY != None and currY.data != y:\n            prevY = currY\n            currY = currY.next\n \n        # If either x or y is not present, nothing to do\n        if currX == None or currY == None:\n            return\n        # If x is not head of linked list\n        if prevX != None:\n            prevX.next = currY\n        else:  # make y the new head\n            self.head = currY\n \n        # If y is not head of linked list\n        if prevY != None:\n            prevY.next = currX\n        else:  # make x the new head\n            self.head = currX\n \n        # Swap next pointers\n        temp = currX.next\n        currX.next = currY.next\n        currY.next = temp\n "}
{"nl": "Recursion: Sum of Multiplication", "code": "def multi_sum(n, ten=10):\n  return ten and n * ten + multi_sum(n, ten - 1)"}
{"nl": "Decoded xored array", "code": "def decode(self, A, first):\n  res = [first]\n  for a in A:\n  res.append(res[-1] ^ a)\n  return res"}
{"nl": "Return the Factorial", "code": "def factorial(num):\n  return 1 if num < 2 else num * factorial(num - 1)"}
{"nl": "Count number of lines in text file", "code": "# Take a variable that stores the count of a number of lines in a given file and initialize it to 0.\nlinecount = 0\n# Enter the file name of the  file using the input() function and store it in a variable.\nfilename = input(\"Enter the file name = \")\n# In read mode, open the file with the entered file name.\nwith open(filename, 'r') as givenfile:\n    # Using for loop, Traverse the lines in the file.\n    # Increment the value of line count by 1.\n    for line in givenfile:\n        linecount = linecount+1\n# Print the line count.\nprint('The total number of lines in the given file = ', linecount)"}
{"nl": "Find position of the only set bit", "code": "# Python3 program to find position of\n# only set bit in a given number\n\n# A utility function to check\n# whether n is power of 2 or\n# not.\ndef isPowerOfTwo(n):\n\treturn (True if(n > 0 and\n\t\t\t\t((n & (n - 1)) > 0))\n\t\t\t\telse False);\n\t\n# Returns position of the\n# only set bit in 'n'\ndef findPosition(n):\n\tif (isPowerOfTwo(n) == True):\n\t\treturn -1;\n\n\ti = 1;\n\tpos = 1;\n\n\t# Iterate through bits of n\n\t# till we find a set bit i&n\n\t# will be non-zero only when\n\t# 'i' and 'n' have a set bit\n\t# at same position\n\twhile ((i & n) == 0):\n\t\t\n\t\t# Unset current bit and\n\t\t# set the next bit in 'i'\n\t\ti = i << 1;\n\n\t\t# increment position\n\t\tpos += 1;\n\n\treturn pos;\n\n# Driver Code\nn = 16;\npos = findPosition(n);\nif (pos == -1):\n\tprint(\"n =\", n, \", Invalid number\");\nelse:\n\tprint(\"n =\", n, \", Position \", pos);\n\nn = 12;\npos = findPosition(n);\nif (pos == -1):\n\tprint(\"n =\", n, \", Invalid number\");\nelse:\n\tprint(\"n =\", n, \", Position \", pos);\n\nn = 128;\npos = findPosition(n);\nif (pos == -1):\n\tprint(\"n =\", n, \", Invalid number\");\nelse:\n\tprint(\"n =\", n, \", Position \", pos);\n\n# This code is contributed by mits"}
{"nl": "K-th Largest Sum Contiguous Subarray", "code": "# Python program to find the k-th largest sum\n# of subarray\nimport heapq\n\n# function to calculate kth largest element\n# in contiguous subarray sum\ndef kthLargestSum(arr, n, k):\n\t\n\t# array to store prefix sums\n\tsum = []\n\tsum.append(0)\n\tsum.append(arr[0])\n\tfor i in range(2, n + 1):\n\t\tsum.append(sum[i - 1] + arr[i - 1])\n\t\t\n\t# priority_queue of min heap\n\tQ = []\n\theapq.heapify(Q)\n\t\n\t# loop to calculate the contiguous subarray\n\t# sum position-wise\n\tfor i in range(1, n + 1):\n\t\t\n\t\t# loop to traverse all positions that\n\t\t# form contiguous subarray\n\t\tfor j in range(i, n + 1):\n\t\t\tx = sum[j] - sum[i - 1]\n\t\t\t\n\t\t\t# if queue has less then k elements,\n\t\t\t# then simply push it\n\t\t\tif len(Q) < k:\n\t\t\t\theapq.heappush(Q, x)\n\t\t\telse:\n\t\t\t\t# it the min heap has equal to\n\t\t\t\t# k elements then just check\n\t\t\t\t# if the largest kth element is\n\t\t\t\t# smaller than x then insert\n\t\t\t\t# else its of no use\n\t\t\t\tif Q[0] < x:\n\t\t\t\t\theapq.heappop(Q)\n\t\t\t\t\theapq.heappush(Q, x)\n\t\n\t# the top element will be then kth\n\t# largest element\n\treturn Q[0]\n\n# Driver program to test above function\na = [10,-10,20,-40]\nn = len(a)\nk = 6\n\n# calls the function to find out the\n# k-th largest sum\nprint(kthLargestSum(a,n,k))\n\n\n# This code is contributed by Kumar Suman"}
{"nl": "Function that squishes a list from the left or the right.", "code": "def squish(lst, d):\r\n  if d == 'left':\r\n    return [[sum(lst[:i])] + lst[i:] for i in range(1, len(lst) + 1)]\r\n  return [lst[:-i] + [sum(lst[-i:])] for i in range(1, len(lst) + 1)]"}
{"nl": "Primitive Darts Game", "code": "def darts_scoring(x, y):\n  dist = (x ** 2 + y ** 2) ** 0.5\n  return (dist <= 10) + (dist <= 5) * 4 + (dist <= 1) * 5"}
{"nl": "Find the Sum of Series 1^1+2^2+3^3\u2026+N^N using For loop and pow() function", "code": "# Give the number N as static input and store it in a variable.\r\ngvnNumbr = 3\r\n# Take a variable say resltsum which gives the sum of\r\n# the given series till N and initialize its value to 0.\r\nresltsum = 0\r\n# Loop from 1 to given number using the For loop.\r\nfor k in range(1, gvnNumbr+1):\r\n        # Inside the For loop, Calculate the value of iterator value ^ iterator value\r\n    # using the pow function and store it in a variable.\r\n    powervl = pow(k, k)\r\n    # Add the above variable to the resltsum\r\n    resltsum = resltsum+powervl\r\n\r\n# Print the resltsum value which is the result of the series till the given Number N.\r\nprint(\r\n    'The sum of the series till the given number {', gvnNumbr, '} is :', resltsum)"}
{"nl": "Print matrix in zig-zag fashion", "code": "# Program to print matrix in Zig-zag pattern\n\u00a0\nmatrix =[\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 2, 3,],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 4, 5, 6 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 7, 8, 9 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\nrows=3\ncolumns=3\n\u00a0\u00a0\u00a0\nsolution=[[] for i in range(rows+columns-1)]\n\u00a0\nfor i in range(rows):\n\u00a0\u00a0\u00a0\u00a0for j in range(columns):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum=i+j\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if(sum%2 ==0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#add at beginning\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0solution[sum].insert(0,matrix[i][j])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#add at end of the list\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0solution[sum].append(matrix[i][j])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# print the solution as it as\nfor i in solution:\n\u00a0\u00a0\u00a0\u00a0for j in i:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(j,end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n"}
{"nl": "The minimum number of characters to delete to make s good", "code": "class Solution:\n  def minDeletions(self, s: str) -> int:\n  cnt, res, used = collections.Counter(s), 0, set()\n  for ch, freq in cnt.items():\n  while freq > 0 and freq in used:\n  freq -= 1\n  res += 1\n  used.add(freq)\n  return res"}
{"nl": "Deploying Scrapy spider on ScrapingHub\r\n", "code": "# importing scrapy module\r\nimport scrapy\r\n  \r\n  \r\nclass ExtractUrls(scrapy.Spider):\r\n      \r\n    # Name of the spider\r\n    crawled = set()\r\n      \r\n    # Set to avoiding duplicate url\r\n    name = \"extract\"\r\n  \r\n    def start_requests(self):\r\n  \r\n        # Starting url mentioned\r\n        urls = ['https://www.geeksforgeeks.org', ]\r\n        for url in urls:\r\n            yield scrapy.Request(url = url,\r\n                     callback = self.parse)\r\n  \r\n    def parse(self, response):\r\n        title = response.css('title::text').extract_first()\r\n        links = response.css('a::attr(href)').extract()\r\n        for link in links:\r\n            yield\r\n        {\r\n            'title': title,\r\n            'links': link\r\n        }\r\n  \r\n        if ('geeksforgeeks' in link and\r\n               link not in self.crawled):\r\n            self.crawled.update(link)\r\n            yield scrapy.Request(url = link,\r\n                      callback = self.parse)"}
{"nl": "Python Program to Find the Smallest Divisor of an Integer", "code": "# Give the number as static input and store it in a variable.\ngvnNumb = 91\n# Loop from 2 to given number using For loop.\nfor itervalue in range(2, gvnNumb+1):\n    # Check if the iterator value divides the given number\n    # perfectly using the if statement and modulus operator.\n    if(gvnNumb % itervalue == 0):\n        # Print the iterator value.\n\n        print(\n            'The smallest which divides the given number [', gvnNumb, '] =', itervalue)\n        # Break the loop using the break statement.\n        break"}
{"nl": "Count number of words in text file", "code": "# taking a variable which stores count and initializing it to 0\nword_count = 0\n# given file name\ngiven_filename = \"wordsfile.txt\"\n# opening the file in reading mode\nwith open(given_filename, 'r') as givenfile:\n    # traversing the lines of file using for loop\n    for fileline in givenfile:\n      # split the line into words using split() function.\n      # increasing the word count by counting the number of words in the file\n        word_count += len(fileline.split())\n\nprint(\"The total number of files present in the given file = \", word_count)"}
{"nl": "Print maximum sum square sub-matrix of given size", "code": "# An efficient Python3 program to find maximum sum\n# sub-square matrix\n\u00a0\n# Size of given matrix\nN = 5\n\u00a0\n# A O(n^2) function to the maximum sum sub-\n# squares of size k x k in a given square\n# matrix of size n x n\ndef printMaxSumSub(mat, k):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# k must be smaller than or equal to n\n\u00a0\u00a0\u00a0\u00a0if (k > N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 1: PREPROCESSING\n\u00a0\u00a0\u00a0\u00a0# To store sums of all strips of size k x 1\n\u00a0\u00a0\u00a0\u00a0stripSum = [[0 for j in range(N)] for i in range(N)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Go column by column\n\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum of first k x 1 rectangle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in this column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += mat[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stripSum[0][j] = sum;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum of remaining rectangles\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(1,N-k+1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += (mat[i+k-1][j] - mat[i-1][j]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stripSum[i][j] = sum;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# max_sum stores maximum sum and its\n\u00a0\u00a0\u00a0\u00a0# position in matrix\n\u00a0\u00a0\u00a0\u00a0max_sum = -1000000000\n\u00a0\u00a0\u00a0\u00a0i_ind = 0\n\u00a0\u00a0\u00a0\u00a0j_ind = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2: CALCULATE SUM of Sub-Squares using stripSum[][]\n\u00a0\u00a0\u00a0\u00a0for i in range(N-k+1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate and print sum of first subsquare\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in this row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += stripSum[i][j];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update max_sum and position of result\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sum > max_sum):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_sum = sum;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i_ind = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j_ind = 0\n\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate sum of remaining squares in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current row by removing the leftmost\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# strip of previous sub-square and adding\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# a new strip\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(1,N-k+1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += (stripSum[i][j+k-1] - stripSum[i][j-1]);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update max_sum and position of result\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (sum > max_sum):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_sum = sum;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i_ind = i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j_ind = j\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print the result matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i+i_ind][j+j_ind], end = ' ')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver program to test above function\nmat = [[1, 1, 1, 1, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 2, 2, 2, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[3, 8, 6, 7, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 4, 4, 4, 4],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[5, 5, 5, 5, 5],\n\u00a0\u00a0\u00a0\u00a0];\nk = 3;\nprint(\"Maximum sum 3 x 3 matrix is\");\nprintMaxSumSub(mat, k);\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "Convert BST to Min Heap", "code": "# C++ implementation to convert the\n# given BST to Min Heap\n\u00a0\n# structure of a node of BST\n\u00a0\n\u00a0\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# function for the inorder traversal\n# of the tree so as to store the node\n# values in 'arr' in sorted order\n\u00a0\n\u00a0\ndef inorderTraversal(root, arr):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# first recur on left subtree\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root.left, arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# then copy the data of the node\n\u00a0\u00a0\u00a0\u00a0arr.append(root.data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# now recur for right subtree\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root.right, arr)\n\u00a0\n# function to convert the given\n# BST to MIN HEAP performs preorder\n# traversal of the tree\n\u00a0\n\u00a0\ndef BSTToMinHeap(root, arr, i):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# first copy data at index 'i' of\n\u00a0\u00a0\u00a0\u00a0# 'arr' to the node\n\u00a0\u00a0\u00a0\u00a0i[0] += 1\n\u00a0\u00a0\u00a0\u00a0root.data = arr[i[0]]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# then recur on left subtree\n\u00a0\u00a0\u00a0\u00a0BSTToMinHeap(root.left, arr, i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# now recur on right subtree\n\u00a0\u00a0\u00a0\u00a0BSTToMinHeap(root.right, arr, i)\n\u00a0\n# utility function to convert the\n# given BST to MIN HEAP\n\u00a0\n\u00a0\ndef convertToMinHeapUtil(root):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# vector to store the data of\n\u00a0\u00a0\u00a0\u00a0# all the nodes of the BST\n\u00a0\u00a0\u00a0\u00a0arr = []\n\u00a0\u00a0\u00a0\u00a0i = [-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# inorder traversal to populate 'arr'\n\u00a0\u00a0\u00a0\u00a0inorderTraversal(root, arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# BST to MIN HEAP conversion\n\u00a0\u00a0\u00a0\u00a0BSTToMinHeap(root, arr, i)\n\u00a0\n# function for the preorder traversal\n# of the tree\n\u00a0\n\u00a0\ndef preorderTraversal(root):\n\u00a0\u00a0\u00a0\u00a0if root == None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# first print the root's data\n\u00a0\u00a0\u00a0\u00a0print(root.data, end=\" \")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# then recur on left subtree\n\u00a0\u00a0\u00a0\u00a0preorderTraversal(root.left)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# now recur on right subtree\n\u00a0\u00a0\u00a0\u00a0preorderTraversal(root.right)\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# BST formation\n\u00a0\u00a0\u00a0\u00a0root = Node(4)\n\u00a0\u00a0\u00a0\u00a0root.left = Node(2)\n\u00a0\u00a0\u00a0\u00a0root.right = Node(6)\n\u00a0\u00a0\u00a0\u00a0root.left.left = Node(1)\n\u00a0\u00a0\u00a0\u00a0root.left.right = Node(3)\n\u00a0\u00a0\u00a0\u00a0root.right.left = Node(5)\n\u00a0\u00a0\u00a0\u00a0root.right.right = Node(7)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0convertToMinHeapUtil(root)\n\u00a0\u00a0\u00a0\u00a0print(\"Preorder Traversal:\")\n\u00a0\u00a0\u00a0\u00a0preorderTraversal(root)\n\u00a0\n# This code is contributed\n# by PranchalK\n"}
{"nl": "Python Program to Convert a Decimal Number to Binary", "code": "# Give the number as user input using the int(input()) function and store it in a variable.\ngvn_numb = int(input(\"Enter some random Number = \"))\n# Take a variable say 'a 'and initialize its value with 1.\na = 1\n# Take another variable say binry_num and initialize its value with 0.\nbinry_num = 0\nprint(\"The Binary value of the given decimal number {\", gvn_numb, \"} is: \")\n# Loop till the given number is not equal to zero using the while loop.\nwhile (gvn_numb != 0):\n  # Inside the loop, calculate the value of the given number modulus 2 and\n    # store it in a variable remdr.\n    remdr = gvn_numb % 2\n  # Divide the given number by 2 and store it in the same variable gvn_numb.\n    gvn_numb = gvn_numb // 2\n    # Multiply a with the remdr and store it in another variable b\n    b = (remdr * a)\n    # Add b to the binry_num and convert to int using the int() function.\n    # Store it in the same variable binry_num.\n    binry_num = int(binry_num + b)\n    # Multiply a with 10 and Store it in the same variable 'a'.\n    a = int(a * 10)\n # Print the binry_num to get the binary value of the given decimal number.\nprint(binry_num)"}
{"nl": "Removing loop in a linked list", "code": "\n# Python program to detect and remove loop in linked list\n \n# Node class\nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    def detectAndRemoveLoop(self):\n        slow_p = fast_p = self.head\n         \n        while(slow_p and fast_p and fast_p.next):\n            slow_p = slow_p.next\n            fast_p = fast_p.next.next\n \n            # If slow_p and fast_p meet at some point then\n            # there is a loop\n            if slow_p == fast_p:\n                self.removeLoop(slow_p)\n         \n                # Return 1 to indicate that loop is found\n                return 1\n         \n        # Return 0 to indicate that there is no loop\n        return 0\n \n    # Function to remove loop\n    # loop_node --> pointer to one of the loop nodes\n    # head --> Pointer to the start node of the linked list\n    def removeLoop(self, loop_node):\n        ptr1 = loop_node\n        ptr2 = loop_node\n         \n        # Count the number of nodes in loop\n        k = 1\n        while(ptr1.next != ptr2):\n            ptr1 = ptr1.next\n            k += 1\n \n        # Fix one pointer to head\n        ptr1 = self.head\n         \n        # And the other pointer to k nodes after head\n        ptr2 = self.head\n        for i in range(k):\n            ptr2 = ptr2.next\n \n        # Move both pointers at the same place\n        # they will meet at loop starting node\n        while(ptr2 != ptr1):\n            ptr1 = ptr1.next\n            ptr2 = ptr2.next\n \n        # Get pointer to the last node\n        while(ptr2.next != ptr1):\n            ptr2 = ptr2.next\n \n        # Set the next node of the loop ending node\n        # to fix the loop\n        ptr2.next = None\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data, end = ' ')\n            temp = temp.next\n "}
{"nl": "A valid matrix given row and column sums", "code": "def restoreMatrix(self, row, col):\n  m, n = len(row), len(col)\n  A = [[0] * n for i in xrange(m)]\n  for i in xrange(m):\n  for j in xrange(n):\n  A[i][j] = min(row[i], col[j])\n  row[i] -= A[i][j]\n  col[j] -= A[i][j]\n  return A"}
{"nl": "Number whose sum of XOR with given array range is maximum", "code": "# Python3 program to find smallest integer X\r\n# such that sum of its XOR with range is\r\n# maximum.\r\nimport math\r\n\r\none = [[0 for x in range(32)]\r\n\tfor y in range(100001)]\r\nMAX = 2147483647\r\n\r\n# Function to make prefix array\r\n# which counts 1's of each bit\r\n# up to that number\r\ndef make_prefix(A, n) :\r\n\tglobal one, MAX\r\n\t\r\n\tfor j in range(0 , 32) :\r\n\t\tone[0][j] = 0\r\n\r\n\t# Making a prefix array which\r\n\t# sums number of 1's up to\r\n\t# that position\r\n\tfor i in range(1, n+1) :\r\n\t\ta = A[i - 1]\r\n\t\tfor j in range(0 , 32) :\r\n\t\t\r\n\t\t\tx = int(math.pow(2, j))\r\n\r\n\t\t\t# If j-th bit of a number\r\n\t\t\t# is set then add one to\r\n\t\t\t# previously counted 1's\r\n\t\t\tif (a & x) :\r\n\t\t\t\tone[i][j] = 1 + one[i - 1][j]\r\n\t\t\telse :\r\n\t\t\t\tone[i][j] = one[i - 1][j]\r\n\t\t\r\n# Function to find X\r\ndef Solve(L, R) :\r\n\r\n\tglobal one, MAX\r\n\tl = L\r\n\tr = R\r\n\ttot_bits = r - l + 1\r\n\r\n\t# Initially taking maximum\r\n\t# value all bits 1\r\n\tX = MAX\r\n\r\n\t# Iterating over each bit\r\n\tfor i in range(0, 31) :\r\n\t\r\n\t\t# get 1's at ith bit between the\r\n\t\t# range L-R by subtracting 1's till\r\n\t\t# Rth number - 1's till L-1th number\r\n\t\t\r\n\t\tx = one[r][i] - one[l - 1][i]\r\n\r\n\t\t# If 1's are more than or equal\r\n\t\t# to 0's then unset the ith bit\r\n\t\t# from answer\r\n\t\tif (x >= (tot_bits - x)) :\r\n\t\t\t\r\n\t\t\tith_bit = pow(2, i)\r\n\r\n\t\t\t# Set ith bit to 0 by\r\n\t\t\t# doing Xor with 1\r\n\t\t\tX = X ^ ith_bit\r\n\treturn X\r\n\r\n# Driver Code\r\nn = 5\r\nq = 3\r\nA = [ 210, 11, 48, 22, 133 ]\r\nL = [ 1, 4, 2 ]\r\nR = [ 3, 14, 4 ]\r\n\r\nmake_prefix(A, n)\r\n\r\nfor j in range(0, q) :\r\n\tprint (Solve(L[j], R[j]),end=\"\\n\")\r\n\t\r\n# This code is contributed by\r\n# Manish Shaw(manishshaw1)\r"}
{"nl": "Checkerboard Generator", "code": "def checker_board(n, el1, el2):\n    if el1==el2: return 'invalid'\n    return [[el2 if (i+j)%2 else el1 for i in range(n)] for j in range(n)]"}
{"nl": "Check Validity of Triangle Given Three Sides", "code": "# Validity of Triangle given sides\r\n\r\n# Function definition to check validity\r\ndef is_valid_triangle(a,b,c):\r\n    if a+b>=c and b+c>=a and c+a>=b:\r\n        return True\r\n    else:\r\n        return False\r\n\r\n# Reading Three Sides\r\nside_a = float(input('Enter length of side a: '))\r\nside_b = float(input('Enter length of side b: '))\r\nside_c = float(input('Enter length of side c: '))\r\n\r\n# Function call & making decision\r\n\r\nif is_valid_triangle(side_a, side_b, side_c):\r\n    print('Triangle is Valid.')\r\nelse:\r\n    print('Triangle is Invalid.')"}
{"nl": "Generate integer from 1 to 7 with equal probability", "code": "# Python3 code to demonstrate\n# expression returns each integer\n# from 1 to 25 exactly once\n\nif name == '__main__':\n\t\n\tfor first in range(1, 6):\n\t\tfor second in range(1, 6):\n\t\t\t\tprint(5 * first + second - 5)\n\n# This code is contributed by Smitha Dinesh Semwal.\n"}
{"nl": "Degrees() and Radians()", "code": "# Import the math function using the import function.\r\nimport math\r\n# Give the list as static input and store it in a variable.\r\ngivenlist = [8, 1, 9, 12, 45, 1, 7, 3]\r\n# Traverse the given list using For loop.\r\nfor elementval in givenlist:\r\n    # Calculate the value of the degree of the given iterator\r\n    # value using math.degrees() function.\r\n    degreevalu = math.degrees(elementval)\r\n    # Calculate the value of the radians of the given iterator value\r\n    # using math.radians () function.\r\n    radianvalu = math.radians(elementval)\r\n    # Print the degree and radians value of the element.\r\n    print('The degree value of the element', elementval, ' = ', degreevalu)\r\n    print('The radians value of the element', elementval, ' = ', radianvalu)"}
{"nl": "Python Program to Determine How Many Times a Given Letter Occurs in a String Recursively", "code": "# function which returns count of the given character in the string recursively.\n def checkCountRecursively(given_string, character):\n  # Pass the fundamental constraint that the string is not empty.\n  if not given_string:\n  return 0\n  # If the initial character of the string is the same as the character\n  # taken from the user, increment the count.\n  elif given_string[0] == character:\n  return 1+checkCountRecursively(given_string[1:], character)\n  # The string is progressed in either direction, and the number of times\n  # the letter appears in the string is printed.\n  else:\n  return checkCountRecursively(given_string[1:], character)\n # given string as static input\n given_string = 'btechgeeks'\n # given character as static input\n given_character = 'e'\n # passing the given character and given string to checkCountRecursively function\n print('Priting the count of', given_character, 'in the given string',\n  given_string, '=', checkCountRecursively(given_string, given_character))"}
{"nl": "given an array of candy costs, find the minimum cost of buying candies with a discount", "code": "class Solution:\n    def minimumCost(self, cost: List[int]) -> int:\n        save = []\n        cost.sort()  # sort the list cost and since you buy two expensive ones get one for free you always get the one close to the two expensive for free\n        lencost = len(cost)\n        \n        if lencost%3 == 0: # if the length of cost is a product of 3, then first set mincost to 0, then add each number with index that's divisible by 3 and the min cost would be sum(cost) - sum of each freebie\n            mincost = 0\n            for i in range(lencost):\n                if i%3 == 0:\n                    mincost += cost[i]\n            mincost = sum(cost) - mincost\n            return mincost\n        \n        elif lencost >= 3: # if lencost is bigger than 3, then only need to start counting the items that's not in the first indexes\n            mincost = 0\n            for i in range(lencost%3, lencost):\n                if (i-lencost%3)%3 == 0:\n                    mincost += cost[i]\n            mincost = sum(cost) - mincost\n            return mincost\n        \n        else: # if lencost is less than 3, the cost if the sum of cost\n            lencost <3\n            return sum(cost)"}
{"nl": "Check if two expressions with brackets are same", "code": "# Python3 program to check if two expressions\n# evaluate to same.\nMAX_CHAR = 26;\n\u00a0\n# Return local sign of the operand. For example,\n# in the expr a-b-(c), local signs of the operands\n# are +a, -b, +c\ndef adjSign(s, i):\n\u00a0\u00a0if (i == 0):\n\u00a0\u00a0\u00a0\u00a0return True;\n\u00a0\u00a0if (s[i - 1] == '-'):\n\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0return True;\n\u00a0\n# Evaluate expressions into the count vector of\n# the 26 alphabets.If add is True, then add count\n# to the count vector of the alphabets, else remove\n# count from the count vector.\ndef eval(s, v, add):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# stack stores the global sign\n\u00a0\u00a0# for operands.\n\u00a0\u00a0stk = []\n\u00a0\u00a0stk.append(True);\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# + means True\n\u00a0\u00a0# global sign is positive initially\n\u00a0\u00a0i = 0;\n\u00a0\n\u00a0\u00a0while (i < len(s)):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (s[i] == '+' or s[i] == '-'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (s[i] == '('):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# global sign for the bracket is\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pushed to the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (adjSign(s, i)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(stk[-1]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.append(not stk[-1]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# global sign is popped out which\n\u00a0\u00a0\u00a0\u00a0# was pushed in for the last bracket\n\u00a0\u00a0\u00a0\u00a0elif (s[i] == ')'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stk.pop();\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# global sign is positive (we use different\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# values in two calls of functions so that\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# we finally check if all vector elements\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# are 0.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (stk[-1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v[ord(s[i]) - ord('a')] += (1 if add else -1) if adjSign(s, i) else (-1 if add else 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# global sign is negative here\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v[ord(s[i]) - ord('a')] += (-1 if add else 1) if adjSign(s, i) else (1 if add else -1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\n# Returns True if expr1 and expr2 represent\n# same expressions\ndef areSame(expr1, expr2):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# Create a vector for all operands and\n\u00a0\u00a0# initialize the vector as 0.\n\u00a0\u00a0v = [0 for i in range(MAX_CHAR)];\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# Put signs of all operands in expr1\n\u00a0\u00a0eval(expr1, v, True);\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# Subtract signs of operands in expr2\n\u00a0\u00a0eval(expr2, v, False);\n\u00a0\u00a0\u00a0\n\u00a0\u00a0# If expressions are same, vector must\n\u00a0\u00a0# be 0.\n\u00a0\u00a0for i in range(MAX_CHAR):\n\u00a0\u00a0\u00a0\u00a0if (v[i] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0return True;\n\u00a0\n# Driver Code\nif __name__=='__main__':\n\u00a0\u00a0expr1 = \"-(a+b+c)\"\n\u00a0\u00a0expr2 = \"-a-b-c\";\n\u00a0\u00a0if (areSame(expr1, expr2)):\n\u00a0\u00a0\u00a0\u00a0print(\"Yes\");\n\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0print(\"No\");\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by rutvik_56.\n"}
{"nl": "Given a year, report if it is a leap year", "code": "def leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)"}
{"nl": "Read a random line from a file", "code": "# Import random module using the import keyword\nimport random\n# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Get all the lines of the file using the read(), splitlines() functions and \n  # Store it in a variable\n  file_lines = givenfilecontent.read().splitlines()\n  # Print a random line from the given file using the random.choice() function\n  # by passing the above lines as an argument to it\n  print(random.choice(file_lines))"}
{"nl": "Find the Total Number of Bits Needed to be Flipped to Convert One Number into Another ", "code": "# function which accepts the two numbers as arguments\r\n# and return the number of bits to be flipped\r\n\r\n\r\ndef countFlipbits(firstnumber, secondnumber):\r\n    # Calculate the xor value of the two numbers and store it in a result say resultnum.\r\n    resultnum = firstnumber ^ secondnumber\r\n    # Convert this resultnum to binary and calculate the total\r\n    # number of sets bits in it using the count() function.\r\n    binNumber = bin(resultnum)\r\n    setbitCounter = binNumber.count('1')\r\n    return setbitCounter\r\n\r\n\r\n# Driver Code\r\n\r\n# Driver Code\r\n# Give the two numbers as static input and store them in two separate variables.\r\nfirstnumber = 18\r\nsecondnumber = 68\r\n# Pass the given two numbers as arguments to the ( function which calculates the total number\r\n# of bits to be flipped to convert one number into another.\r\nprint('Binary representations of the given two numbers are :')\r\nprint(firstnumber, '=', bin(firstnumber)[2:])\r\nprint(secondnumber, '=', bin(secondnumber)[2:])\r\nprint('The total number of bits to be flipped =',\r\n      countFlipbits(firstnumber, secondnumber))"}
{"nl": "Next Prime", "code": "def next_prime(num):\n  while [i for i in range(2, num) if num%i==0]:\n    num+=1\n  return num"}
{"nl": "Python Set pop() Method", "code": "fruits = {\"apple\", \"banana\", \"cherry\"}\r\n\r\nfruits.pop()\r\n\r\nprint(fruits)"}
{"nl": "Coin Co-Operation", "code": "def get_coin_balances(lst1, lst2):\n  a, b = 3, 3\n  for i, j in zip(lst1, lst2):\n    if i == 'share':  a, b = a-1, b+3\n    if j == 'share':  a, b = a+3, b-1\n  return [a, b]"}
{"nl": "The minimum moves to make array complementary", "code": "class Solution:\n  def minMoves(self, nums: List[int], limit: int) -> int:\n  delta = collections.Counter()\n  n = len(nums)\n  for i in range(n // 2):\n  a, b = nums[i], nums[n - 1 - i]\n  delta[2] += 2\n  delta[min(a, b) + 1] -= 1\n  delta[a + b] -= 1\n  delta[a + b + 1] += 1\n  delta[max(a, b) + limit + 1] += 1\n  \n  curr = 0  \n  res = math.inf\n  for i in range(2, 2 * limit + 1):\n  curr += delta[i]\n  res = min(res, curr)\n  return res"}
{"nl": "Python Access List Items\r\n", "code": "#Print the second item of the list:\r\n\r\nthislist = [\"apple\", \"banana\", \"cherry\"]\r\nprint(thislist[1])"}
{"nl": "Find the Greatest Digit in a Number", "code": "#Give the number as user input using int(input()) and store it in a variable.\r\ngvn_num = int(input(\"Enter some random number = \"))\r\n# Convert the given number into string using str() function and\r\n# store it in another variable. \r\nstr_numbr = str(gvn_num)\r\n# Convert the above obtained string number into list of digits using bulit-in list()\r\n# method and store it in another variable.\r\nlst = list(str_numbr)\r\n# Find the maximum of list of digits using bulit-in max() function\r\n# and store it in another variable.\r\nmaxim_digit = max(lst)\r\n# Print the greatest digit in a given number.\r\nprint(\"The maximum digit in given number {\", gvn_num, \"} = \", maxim_digit)"}
{"nl": "Find root of the tree where children id sum for every node is given", "code": "\"\"\"Find root of tree where children\nsum for every node id is given\"\"\"\n\ndef findRoot(arr, n) :\n\n\t# Every node appears once as an id, and\n\t# every node except for the root appears\n\t# once in a sum. So if we subtract all\n\t# the sums from all the ids, we're left\n\t# with the root id.\n\troot = 0\n\tfor i in range(n):\n\t\troot += (arr[i][0] - arr[i][1])\n\treturn root\n\t\t\t\t\t\t\n# Driver Code\nif __name__ == '__main__':\n\n\tarr = [[1, 5], [2, 0],\n\t\t[3, 0], [4, 0],\n\t\t[5, 5], [6, 5]]\n\tn = len(arr)\n\tprint(findRoot(arr, n))\n\n# This code is contributed\n# by SHUBHAMSINGH10\n"}
{"nl": "Sorting a List using sorted()", "code": "def lengthSort(given_list):\r\n    # sorting the given list by length of elements of the given list\r\n    given_list = sorted(given_list, key=len)\r\n    # return the list\r\n    return given_list\r\n\r\n\r\n# given list\r\ngiven_list = list(\r\n    input(\"Enter the elements of the given list separated by spaces\").split())\r\n# printing the given list before sorting according to length\r\nprint(\"printing the given list before sorting according to length : \")\r\nprint(given_list)\r\n# passing the given_list to lengthSort function to sort\r\n# the list according to the length of the elements of the given list\r\n# printing the given list before sorting according to length\r\nprint(\"printing the given list after sorting according to length : \")\r\nprint(lengthSort(given_list))"}
{"nl": "Count number of digits in a text file", "code": "# Make a single variable to store the path of the file. This is a constant value. \n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Pass the given filename, r (represents read only) as arguments to the open() function\n# to open the given file\nfile = open(givenFilename,\"r\")\n# Read the above file using the read() function(get the content) and store it in a variable\nfiletext = file.read()\n# Take a variable(which gives the count of digits in a file) and initialize its value with zero.\ndigit_cnt = 0\n# Iterate in the above text of the file using the for loop\nfor chr in filetext:\n  # Check if each character of the file text is digit or not using the isdigit() function\n  # and if conditional statement\n  if chr.isdigit():\n  # If it is true, then increment the value of the above initialized \n  # variable(digit_cnt) by 1\n  digit_cnt += 1\n# Print the count of number of digits in a given file\nprint(\"The count of number of digits in a given file = \",digit_cnt)\n# Close the above file\nfile.close()"}
{"nl": "Find Smallest of Two Numbers", "code": "# Finding smallest of two numbers\r\n\r\n# Reading numbers\r\nfirst = float(input('Enter first number: '))\r\nsecond = float(input('Enter second number: '))\r\n\r\n# Making decision and displaying\r\nif first < second:\r\n    small = first\r\nelse:\r\n    small = second\r\n\r\nprint('Smallest = %d' %(small))"}
{"nl": "Minimum Height of a Triangle with Given Base and Area", "code": "# Import math module using the import keyword.\r\nimport math\r\n\r\n# Create a function to say Smallest_height() which takes the given area and base\r\n# of the triangle as the arguments and returns the minimum height so that a\r\n# triangle of least area and base can be formed.\r\n\r\n\r\ndef Smallest_height(gvn_areaoftri, gvn_baseoftri):\r\n    # Inside the function, calculate the value of (2*gvn_areaoftri)/gvn_baseoftri using\r\n    # the above mathematical formula and store it in another variable.\r\n    rslt = (2*gvn_areaoftri)/gvn_baseoftri\r\n    # Apply math.ceil() function to the above result and return the minimum height.\r\n    return math.ceil(rslt)\r\n\r\n\r\n# Give the area as static input and store it in a variable.\r\ngvn_areaoftri = 6\r\n# Give the base as static input and store it in another variable.\r\ngvn_baseoftri = 3\r\n# Pass the given area and base of the triangle as the arguments to the Smallest_height()\r\n# function and store it in a variable.\r\nmin_heigt = Smallest_height(gvn_areaoftri, gvn_baseoftri)\r\n# Print the above result i.e, minimum height so that a triangle of the least area\r\n# and base can be formed.\r\nprint(\"The minimum height so that a triangle of the least area and base can be formed = \", min_heigt)"}
{"nl": "Unpack the tuple into 4 variables", "code": "tuple1 = (10, 20, 30, 40)\r\n\r\n# unpack tuple into 4 variables\r\na, b, c, d = tuple1\r\nprint(a)\r\nprint(b)\r\nprint(c)\r\nprint(d)"}
{"nl": "Program for n\u2019th node from the end of a Linked List\n", "code": "# Python program to find n'th node from end using slow\n# and fast pointer\n\n# Node class\nclass Node:\n\n        # Constructor to initialize the node object\n        def __init__(self, data):\n                self.data = data\n                self.next = None\n\nclass LinkedList:\n\n        # Function to initialize head\n        def __init__(self):\n                self.head = None\n\n        # Function to insert a new node at the beginning\n        def push(self, new_data):\n                new_node = Node(new_data)\n                new_node.next = self.head\n                self.head = new_node\n\n        def printNthFromLast(self, n):\n                main_ptr = self.head\n                ref_ptr = self.head\n        \n                count = 0\n                if(self.head is not None):\n                        while(count < n ):\n                                if(ref_ptr is None):\n                                        print (\"% d is greater than the no. pf nodes in list\" %(n))\n                                        return\n                                ref_ptr = ref_ptr.next\n                                count += 1\n        \n                if(ref_ptr is None):\n                        self.head = self.head.next\n                        if(self.head is not None):\n                                print(\"Node no. % d from last is % d \"\n                                                                %(n, main_ptr.data))\n                else:\n                \n\n                while(ref_ptr is not None):\n                        main_ptr = main_ptr.next\n                        ref_ptr = ref_ptr.next\n\n                print (\"Node no. % d from last is % d \"\n                                                                        %(n, main_ptr.data))\n\n\nif __name__ == '__main__':\n        llist = LinkedList()\n        llist.push(20)\n        llist.push(4)\n        llist.push(15)\n        llist.push(35)\n\n        llist.printNthFromLast(4)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Is the List Circular?", "code": "def is_circular(lst):\n  return sorted(i[0] for i in lst)==sorted(i[-1] for i in lst)"}
{"nl": "Count full nodes in a Binary tree", "code": "# Python program to count\n# full nodes in a Binary Tree\n# using iterative approach\n\n# A node structure\nclass Node:\n\t# A utility function to create a new node\n\tdef __init__(self ,key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# Iterative Method to count full nodes of binary tree\ndef getfullCount(root):\n\t# Base Case\n\tif root is None:\n\t\treturn 0\n\t\n\t# Create an empty queue for level order traversal\n\tqueue = []\n\n\t# Enqueue Root and initialize count\n\tqueue.append(root)\n\t\t\n\tcount = 0 #initialize count for full nodes\n\twhile(len(queue) > 0):\n\t\tnode = queue.pop(0)\n\n\t\t# if it is full node then increment count\n\t\tif node.left is not None and node.right is not None:\n\t\t\tcount = count+1\n\n\t\t# Enqueue left child\n\t\tif node.left is not None:\n\t\t\tqueue.append(node.left)\n\n\t\t# Enqueue right child\n\t\tif node.right is not None:\n\t\t\tqueue.append(node.right)\n\t\t\t\n\treturn count\n\n# Driver Program to test above function\nroot = Node(2)\nroot.left = Node(7)\nroot.right = Node(5)\nroot.left.right = Node(6)\nroot.left.right.left = Node(1)\nroot.left.right.right = Node(11)\nroot.right.right = Node(9)\nroot.right.right.left = Node(4)\n\n\nprint(getfullCount(root))\n"}
{"nl": "Program to Subtract two Matrices in Python & C++ Programming", "code": "# given matrix A\n A = [[2, 3, 1],\n  [1, 2, 3],\n  [-3, 0, 2]]\n # given matrix B\n B = [[1, 4, 2],\n  [-4, 5, -1],\n  [2, 1, 4]]\n # Initialize the difference of matrices elements to 0\n matrixDiff = [[0, 0, 0],\n  [0, 0, 0],\n  [0, 0, 0]]\n # Traverse the rows\n for rows in range(len(A)):\n  # Traverse the columns\n  for columns in range(len(A[0])):\n  matrixDiff[rows][columns] = A[rows][columns] - B[rows][columns]\n # printing the difference of matrices\n print(\"Printing the difference of matrices : \")\n for rows in matrixDiff:\n  print(*rows)"}
{"nl": "Primes Below a Given Number", "code": "def primes_below_num(n):\n  return [i for i in range(2,n+1) if all(i%j for j in range(2,i))]"}
{"nl": "Converting One Binary String to Another", "code": "def min_swaps(s1, s2):\n  return sum(a != b for a, b in zip(s1, s2)) // 2"}
{"nl": "Program for Set max() Method in Python", "code": "# Give the set as static input and initialize it with some random values.\n# Store it in a variable.\ngven_set = {20, 40, 50, 10, 20, 60, 50}\n# Print the above-given set.\nprint(\"The given set is :\")\nprint(gven_set)\n# Apply max() method to the given set to get the maximum value in the given set.\n# Store it in another variable.\nmaxim_val = max(gven_set)\n# Print the maximum value in the above-given set.\nprint(\"The above Given set's maximum value = \", maxim_val)"}
{"nl": "Given two matrices, return their difference.", "code": "# given matrix A\r\nA = [[2, 3, 1],\r\n     [1, 2, 3],\r\n     [-3, 0, 2]]\r\n# given matrix B\r\nB = [[1, 4, 2],\r\n     [-4, 5, -1],\r\n     [2, 1, 4]]\r\n# Initialize the difference of matrices elements to 0\r\nmatrixDiff = [[0, 0, 0],\r\n              [0, 0, 0],\r\n              [0, 0, 0]]\r\n# Traverse the rows\r\nfor rows in range(len(A)):\r\n    # Traverse the  columns\r\n    for columns in range(len(A[0])):\r\n        matrixDiff[rows][columns] = A[rows][columns] - B[rows][columns]\r\n# printing the difference of matrices\r\nprint(\"Printing the difference of matrices : \")\r\nfor rows in matrixDiff:\r\n    print(*rows)"}
{"nl": "find the sum of series (1/2!+2/3!+3/5!+\u2026..N/(N+1)!) till the given number N in Python.", "code": "# Import math module using the import keyword.\r\nimport math\r\n# Give the number N(limit) as static input and store it in a variable.\r\ngvn_numb = 6\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Take a variable to say rsltseries_summ and initialize its value to 0.0\r\n# (Floating point number)\r\nrsltseries_summ = 0.0\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nwhile(itr <= gvn_numb):\r\n    # Calculate the factorial of itr+1 using the math.factorial() method and\r\n    # store it in another variable.\r\n    factrl = math.factorial(itr+1)\r\n    # Calculate the value of itr divided by the above result factorial and convert it\r\n    # into float using the float() function.\r\n    # Store it in another variable.\r\n    p = float(itr/factrl)\r\n    # Add the above result to the rsltseries_summ and store it in the same variable.\r\n    rsltseries_summ += p\r\n    # Increment the above itr value by 1.\r\n    itr += 1\r\n# Print the sum of series till the given number N.\r\nprint(\r\n    \"The above series sum till the given number N{\", gvn_numb, \"} = \", rsltseries_summ)"}
{"nl": "Sparse Matrix and its representations  (Using List of Lists and Dictionary of keys)", "code": "# Python program for Sparse Matrix Representation\n# using Dictionary\nR = 4\nC = 5\n\u00a0\n# Driver of the program\n\u00a0\n# Assume 4x5 sparse matrix\nSparse_Matrix=[[0 , 0 , 3 , 0 , 4] ,\n\u00a0\u00a0\u00a0\u00a0[0 , 0 , 5 , 7 , 0] ,\n\u00a0\u00a0\u00a0\u00a0[0 , 0 , 0 , 0 , 0] ,\n\u00a0\u00a0\u00a0\u00a0[0 , 2 , 6 , 0 , 0]]\n\u00a0\n\u00a0\n''' Declaration of map where first field(pair of\n\u00a0\u00a0\u00a0row and column) represent key and second\n\u00a0\u00a0\u00a0field represent value '''\nnew_matrix = {}\n\u00a0\nfor i in range(R):\n\u00a0\u00a0\u00a0\u00a0for j in range(C):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (Sparse_Matrix[i][j] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new_matrix[(i + 1, j + 1)] = Sparse_Matrix[i][j]\nc = 0\n\u00a0\n# Iteration over map\nfor i in new_matrix:\n\u00a0\u00a0\u00a0\u00a0if (c != i[0]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"row =\", i[0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c = i[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"column =\", i[1], end = \" \")\n\u00a0\u00a0\u00a0\u00a0print(\"value =\", new_matrix[i])\n\u00a0\n# This code is contributed by Shubham Singh\n"}
{"nl": "Little Dictionary", "code": "def dictionary(initial, words):\n  return [i for i in words if i.startswith(initial)]"}
{"nl": "Implementing a simple word-counter", "code": "import re\r\nfrom collections import Counter\r\ndef count_words(sentence):\r\n    return Counter(re.findall(r\"[a-z0-9]+(?:'[a-z]+)?\", sentence.lower()))\r"}
{"nl": "reverse linked list", "code": "class Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n            \n        return prev"}
{"nl": "Print Neon numbers in a Range", "code": "# Create a function checkNeonNumb() which accepts the number as an argument and\r\n# returns true if it is Neon number else returns False.\r\n\r\n\r\ndef checkNeonNumb(numb):\r\n    # Calculate the square of the given number/argument using the ** operator or multiply\r\n    # the given number by itself and store it in a variable.\r\n    squarnumb = numb**2\r\n    # Convert this squared number into a list of digits\r\n    # using list(),int(),map(),str() functions.\r\n    # Store this list in a variable.\r\n    numbedigit = list(map(int, str(squarnumb)))\r\n    # Calculate the sum of digits of this list using the sum() function.\r\n    sumdigi = sum(numbedigit)\r\n    # Check if this sum is equal to the given number\r\n    # or not using the If conditional statement.\r\n    # If it is true then the given number is a Neon Number so return True\r\n    if(sumdigi == numb):\r\n        return True\r\n    # Else the given number is not a Neon Number so return False.\r\n    else:\r\n        return False\r\n\r\n\r\n# Give the lower limit range as static input and store it in a variable.\r\nlowlimrange = 1\r\n# Give the upper limit range as static input and store it in another variable.\r\nupplimrange = 7\r\nprint('The Neon numbers in the given range',\r\n      lowlimrange, 'and', upplimrange, 'are:')\r\n# Loop from lower limit range to upper limit range using For loop.\r\nfor p in range(lowlimrange, upplimrange+1):\r\n        # Inside the for loop pass the iterator value to checkNeonnumb() function.\r\n    if(checkNeonNumb(p)):\r\n        # If it returns true then print the iterator value.\r\n        print(p, end=' ')"}
{"nl": "convert sorted array to a height-balanced binary search tree", "code": "class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            # always choose right middle node as a root\n            p = (left + right) // 2 \n            if (left + right) % 2:\n                p += 1 \n\n            # preorder traversal: node -> left -> right\n            root = TreeNode(nums[p])\n            root.left = helper(left, p - 1)\n            root.right = helper(p + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}
{"nl": "Count single node isolated sub-graphs in a disconnected graph", "code": "# Python code to count the singleton sub-graphs\n# in a disconnected graph\n\u00a0\u00a0\n# Function to compute the count\ndef compute(graph, N):\n\u00a0\u00a0\u00a0\u00a0# Storing intermediate result\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing the Nodes\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N+1):\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Singleton component\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(graph[i]) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count += 1\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returning the result\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\u00a0\n# Driver\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Number of nodes\n\u00a0\u00a0\u00a0\u00a0N = 6\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Adjacency list for edges 1..6\n\u00a0\u00a0\u00a0\u00a0graph = [[] for i in range(7)]\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Representing edges\n\u00a0\u00a0\u00a0\u00a0graph[1].append(2)\n\u00a0\u00a0\u00a0\u00a0graph[2].append(1)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0graph[2].append(3)\n\u00a0\u00a0\u00a0\u00a0graph[3].append(2)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0graph[5].append(6)\n\u00a0\u00a0\u00a0\u00a0graph[6].append(5)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(compute(graph, N))\n"}
{"nl": "Union-Find Algorithm | (Union By Rank and Find by Optimized Path Compression)", "code": "# Python3 program to implement Union-Find\u00a0\n# with union by rank and path compression.\n\u00a0\u00a0\n# set parent of every node to itself\u00a0\n# and size of node to one\u00a0\ndef initialize(n):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0for i in range(n + 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[i] = i\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size[i] = 1\n\u00a0\u00a0\n# Each time we follow a path, find\u00a0\n# function compresses it further\u00a0\n# until the path length is greater\u00a0\n# than or equal to 1.\u00a0\ndef find(i):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# while we reach a node whose\u00a0\n\u00a0\u00a0\u00a0\u00a0# parent is equal to itself\u00a0\n\u00a0\u00a0\u00a0\u00a0while (Arr[i] != i):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[i] = Arr[Arr[i]] # Skip one level\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = Arr[i] # Move to the new level\n\u00a0\u00a0\u00a0\u00a0return i\n\u00a0\u00a0\n# A function that does union of two\u00a0\n# nodes x and y where xr is root node\u00a0\n# of x and yr is root node of y\u00a0\ndef _union(xr, yr):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0if (size[xr] < size[yr]): # Make yr parent of xr\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[xr] = Arr[yr]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size[yr] += size[xr]\n\u00a0\u00a0\u00a0\u00a0else: # Make xr parent of yr\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arr[yr] = Arr[xr]\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size[xr] += size[yr]\n\u00a0\u00a0\n# The main function to check whether\u00a0\n# a given graph contains cycle or not\u00a0\ndef isCycle(adj, V):\n\u00a0\u00a0\u00a0\u00a0global Arr, size\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Itexrte through all edges of gxrph,\u00a0\n\u00a0\u00a0\u00a0\u00a0# find nodes connecting them.\u00a0\n\u00a0\u00a0\u00a0\u00a0# If root nodes of both are same,\u00a0\n\u00a0\u00a0\u00a0\u00a0# then there is cycle in gxrph.\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(adj[i])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x = find(i) # find root of i\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y = find(adj[i][j]) # find root of adj[i][j]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (x == y):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1 # If same parent\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_union(x, y) # Make them connect\n\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\n# Driver Code\nMAX_VERTEX = 101\n\u00a0\u00a0\n# Arr to represent parent of index i\u00a0\nArr = [None] * MAX_VERTEX\u00a0\n\u00a0\u00a0\n# Size to represent the number of nodes\u00a0\n# in subgxrph rooted at index i\u00a0\nsize = [None] * MAX_VERTEX\u00a0\n\u00a0\u00a0\nV = 3\n\u00a0\u00a0\n# Initialize the values for arxry\u00a0\n# Arr and Size\u00a0\ninitialize(V)\u00a0\n\u00a0\u00a0\n# Let us create following gxrph\u00a0\n#\u00a0\u00a0\u00a0\u00a0 0\u00a0\n# | \\\u00a0\n# | \\\u00a0\n# 1-----2\u00a0\n\u00a0\u00a0\n# Adjacency list for graph\u00a0\nadj = [[] for i in range(V)]\u00a0\n\u00a0\u00a0\nadj[0].append(1)\u00a0\nadj[0].append(2)\u00a0\nadj[1].append(2)\u00a0\n\u00a0\u00a0\n# call is_cycle to check if it\u00a0\n# contains cycle\u00a0\nif (isCycle(adj, V)):\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Graph contains Cycle.\")\u00a0\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"Graph does not contain Cycle.\")\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "The maximum score of a good subarray", "code": "def maximumScore(self, A, k):\n  res = mini = A[k]\n  i, j, n = k, k, len(A)\n  while i > 0 or j < n - 1:\n  if (A[i - 1] if i else 0) < (A[j + 1] if j < n - 1 else 0):\n  j += 1\n  else:\n  i -= 1\n  mini = min(mini, A[i], A[j])\n  res = max(res, mini * (j - i + 1))\n  return res"}
{"nl": "find the different elements between two elements", "code": "class Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        nums1, nums2 = set(nums1), set(nums2)\n        \n        def iterator(nums1, nums2):\n            temp = []\n            for i in nums1:\n                if i not in nums2:\n                    temp.append(i)\n            return temp\n                \n        return [iterator(nums1, nums2), iterator(nums2, nums1)]"}
{"nl": "Python program to right rotate the elements of an array", "code": "#Initialize array     \narr = [1, 2, 3, 4, 5];     \n#n determine the number of times an array should be rotated    \nn = 3;    \n     \n#Displays original array    \nprint(\"Original array: \");    \nfor i in range(0, len(arr)):    \n    print(arr[i]),     \n     \n#Rotate the given array by n times toward right    \nfor i in range(0, n):    \n    #Stores the last element of array    \n    last = arr[len(arr)-1];    \n        \n    for j in range(len(arr)-1, -1, -1):    \n        #Shift element of array by one    \n        arr[j] = arr[j-1];    \n            \n    #Last element of the array will be added to the start of the array.    \n    \n    arr[0] = last;    \n     \nprint();    \n     \n#Displays resulting array after rotation    \nprint(\"Array after right rotation: \");    \nfor i in range(0, len(arr)):    \n    print(arr[i]),  "}
{"nl": "Create a Matrix in Python", "code": "import numpy as np num = np.array([[1, 1, 2], [3, 5, 3], [5, 6, 9]]) print(num)"}
{"nl": "Implement two stacks in an array", "code": "# Python Script to Implement two stacks in a list\r\nclass twoStacks:\r\n\t\r\n\tdef __init__(self, n):\t # constructor\r\n\t\tself.size = n\r\n\t\tself.arr = [None] * n\r\n\t\tself.top1 = -1\r\n\t\tself.top2 = self.size\r\n\t\t\r\n\t# Method to push an element x to stack1\r\n\tdef push1(self, x):\r\n\t\t\r\n\t\t# There is at least one empty space for new element\r\n\t\tif self.top1 < self.top2 - 1 :\r\n\t\t\tself.top1 = self.top1 + 1\r\n\t\t\tself.arr[self.top1] = x\r\n\r\n\t\telse:\r\n\t\t\tprint(\"Stack Overflow \")\r\n\t\t\texit(1)\r\n\r\n\t# Method to push an element x to stack2\r\n\tdef push2(self, x):\r\n\r\n\t\t# There is at least one empty space for new element\r\n\t\tif self.top1 < self.top2 - 1:\r\n\t\t\tself.top2 = self.top2 - 1\r\n\t\t\tself.arr[self.top2] = x\r\n\r\n\t\telse :\r\n\t\tprint(\"Stack Overflow \")\r\n\t\texit(1)\r\n\r\n\t# Method to pop an element from first stack\r\n\tdef pop1(self):\r\n\t\tif self.top1 >= 0:\r\n\t\t\tx = self.arr[self.top1]\r\n\t\t\tself.top1 = self.top1 -1\r\n\t\t\treturn x\r\n\t\telse:\r\n\t\t\tprint(\"Stack Underflow \")\r\n\t\t\texit(1)\r\n\r\n\t# Method to pop an element from second stack\r\n\tdef pop2(self):\r\n\t\tif self.top2 < self.size:\r\n\t\t\tx = self.arr[self.top2]\r\n\t\t\tself.top2 = self.top2 + 1\r\n\t\t\treturn x\r\n\t\telse:\r\n\t\t\tprint(\"Stack Underflow \")\r\n\t\t\texit()\r\n\r\n# Driver program to test twoStacks class\r\nts = twoStacks(5)\r\nts.push1(5)\r\nts.push2(10)\r\nts.push2(15)\r\nts.push1(11)\r\nts.push2(7)\r\n\r\nprint(\"Popped element from stack1 is \" + str(ts.pop1()))\r\nts.push2(40)\r\nprint(\"Popped element from stack2 is \" + str(ts.pop2()))\r\n\r\n# This code is contributed by Sunny Karira\r\n"}
{"nl": "turn the tree upside down and return the new root", "code": "def upsideDownBinaryTree(self, root):\n    if not root or not root.left:\n        return root\n    lRoot = self.upsideDownBinaryTree(root.left)\n    rMost = lRoot\n    while rMost.right:\n        rMost = rMost.right\n    root, rMost.left, rMost.right = lRoot, root.right, TreeNode(root.val)\n    return root"}
{"nl": "Print a square pattern using numbers given the number of rows", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumbrrows = 9\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numbrrows+1):\r\n    # Loop from 1 to the number of rows using another for loop(Nested For loop).\r\n    for n in range(1, numbrrows+1):\r\n        ''' Check if the iterator value of the inner For loop is less than or equal \r\n            to the parent loop iterator value of the\r\n            For Loop using the If conditional Statement.'''\r\n        if(n <= m):\r\n            # If it is true then print the iterator value of the parent For loop.\r\n            print(m, end=' ')\r\n        else:\r\n            print(n, end=' ')\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "String Literals\r\nString literals in python are surrounded by either single quotation marks, or double quotation marks.\r\n\r\n'hello' is the same as \"hello\".\r\n\r\nYou can display a string literal with the print() function:", "code": "print(\"Hello\")\r\nprint('Hello')\r\n"}
{"nl": "Python program to create a doubly linked list from a ternary tree", "code": "#Represent a node of ternary tree    \nclass Node:    \n    def __init__(self,data):    \n        self.data = data;    \n        self.left = None;    \n        self.middle = None;    \n        self.right = None;    \n            \nclass TernaryTreeToDLL:    \n    def __init__(self):    \n        #Represent the root of ternary tree    \n        self.root = None;    \n        #Represent the head and tail of the doubly linked list    \n        self.head = None;    \n        self.tail = None;    \n            \n    #convertTernaryToDLL() will convert the given ternary tree to corresponding doubly linked list    \n    def convertTernaryToDLL(self, node):    \n        #Checks whether node is None    \n        if(node == None):    \n            return;    \n                \n        #Keep three pointers to all three children    \n        left = node.left;    \n        middle = node.middle;    \n        right = node.right;    \n            \n        #If list is empty then, add node as head of the list    \n        if(self.head == None):    \n            #Both head and tail will point to node    \n            self.head = self.tail = node;    \n            node.middle = None;    \n            #head's left will point to None    \n            self.head.left = None;    \n            #tail's right will point to None, as it is the last node of the list    \n            self.tail.right = None;    \n        #Otherwise, add node to the end of the list    \n        else:    \n            #node will be added after tail such that tail's right will point to node    \n            self.tail.right = node;    \n            #node's left will point to tail    \n            node.left = self.tail;    \n            node.middle = None;    \n            #node will become new tail    \n            self.tail = node;    \n            #As it is last node, tail's right will point to None    \n            self.tail.right = None;    \n                \n        #Add left child of current node to the list    \n        self.convertTernaryToDLL(left);    \n        #Then, add middle child of current node to the list    \n        self.convertTernaryToDLL(middle);    \n        #Then, add right child of current node to the list    \n        self.convertTernaryToDLL(right);    \n        \n    #displayDLL() will print out the nodes of the list    \n    def displayDLL(self):    \n        #Node current will point to head    \n        current = self.head;    \n        if(self.head == None):    \n            print(\"List is empty\");    \n            return;    \n        print(\"Nodes of generated doubly linked list: \");    \n        while(current != None):    \n            #Prints each node by incrementing pointer.    \n            print(current.data),    \n            current = current.right;    \n                \ntree = TernaryTreeToDLL();    \n#Add nodes to the ternary tree    \ntree.root = Node(5);    \ntree.root.left = Node(10);    \ntree.root.middle = Node(12);    \ntree.root.right = Node(15);    \ntree.root.left.left = Node(20);    \ntree.root.left.middle = Node(40);    \ntree.root.left.right = Node(50);    \ntree.root.middle.left = Node(24);    \ntree.root.middle.middle = Node(36);    \ntree.root.middle.right = Node(48);    \ntree.root.right.left = Node(30);    \ntree.root.right.middle = Node(45);    \ntree.root.right.right = Node(60);    \n     \n#Converts the given ternary tree to doubly linked list    \ntree.convertTernaryToDLL(tree.root);    \n     \n#Displays the nodes present in the list    \ntree.displayDLL();    "}
{"nl": "find number of collisions based on a string representation of how cars move. Each character in a string represent a car's position", "code": "class Solution:\n    def countCollisions(self, directions: str) -> int:\n        l, r = 0, 0\n        ans = 0\n        \n        for i in directions:\n            if i == \"L\":\n                ans += l\n            else:\n                l = 1\n        \n        for i in directions[::-1]:\n            if i == \"R\":\n                ans += r\n            else:\n                r = 1\n        \n        return ans"}
{"nl": "function that generates one of 3 numbers according to given probabilities", "code": "import random\n\n# This function generates 'x' with probability px/100, 'y' with\n# probability py/100 and 'z' with probability pz/100:\n# Assumption: px + py + pz = 100 where px, py and pz lie\n# between 0 to 100\ndef random(x, y, z, px, py, pz):\n\t\n\t# Generate a number from 1 to 100\n\tr = random.randint(1, 100)\n\t\n\t# r is smaller than px with probability px/100\n\tif (r <= px):\n\t\treturn x\n\t\n\t# r is greater than px and smaller than\n\t# or equal to px+py with probability py/100\n\tif (r <= (px+py)):\n\t\treturn y\n\t\t\n\t# r is greater than px+py and smaller than\n\t# or equal to 100 with probability pz/100\n\telse:\n\t\treturn z\n\t\n# This code is contributed by rohan07"}
{"nl": "Convert a Binary Tree into its Mirror Tree", "code": "# Python3 program to convert a binary\n# tree to its mirror\n\n# Utility function to create a new\n# tree node\nclass newNode:\n\tdef __init__(self,data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\n\"\"\" Change a tree so that the roles of the\n\tleft and right pointers are swapped at\n\tevery node.\n\nSo the tree...\n\t\t4\n\t\t/ \\\n\t2 5\n\t/ \\\n\t1 3\n\nis changed to...\n\t4\n\t/ \\\n\t5 2\n\t/ \\\n\t3 1\n\"\"\"\ndef mirror(node):\n\n\tif (node == None):\n\t\treturn\n\telse:\n\n\t\ttemp = node\n\t\t\n\t\t\"\"\" do the subtrees \"\"\"\n\t\tmirror(node.left)\n\t\tmirror(node.right)\n\n\t\t\"\"\" swap the pointers in this node \"\"\"\n\t\ttemp = node.left\n\t\tnode.left = node.right\n\t\tnode.right = temp\n\n\"\"\" Helper function to print Inorder traversal.\"\"\"\ndef inOrder(node) :\n\n\tif (node == None):\n\t\treturn\n\t\t\n\tinOrder(node.left)\n\tprint(node.data, end = \" \")\n\tinOrder(node.right)\n\n# Driver code\nif __name__ ==\"__main__\":\n\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\n\t\"\"\" Print inorder traversal of\n\t\tthe input tree \"\"\"\n\tprint(\"Inorder traversal of the\",\n\t\t\t\"constructed tree is\")\n\tinOrder(root)\n\t\n\t\"\"\" Convert tree to its mirror \"\"\"\n\tmirror(root)\n\n\t\"\"\" Print inorder traversal of\n\t\tthe mirror tree \"\"\"\n\tprint(\"\\nInorder traversal of\",\n\t\t\t\"the mirror treeis \")\n\tinOrder(root)\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Python Program to Set nth Bit of a Number", "code": "# Give the number as static input and store it in a variable.\n \n gvn_numb = 5\n \n # Give the bit position as static input and store it in another variable.\n \n bitpositin = 1\n \n # Apply the left shift operator to 1 and the above-given bit position and\n \n # store it in another variable.\n \n numbr_bit = (1 &lt;&lt; bitpositin)\n \n # Apply bitwise | operation for the given number and the above result and\n \n # store it in another variable say set_numb.\n \n set_numb = gvn_numb | numbr_bit\n \n # Print the given number after set the nth bit of the given Number.\n \n print(\"The given number {\", gvn_numb,\n \n  \"} after set the {\", bitpositin, \"} bit position = \", set_numb)\n \n </pre>"}
{"nl": "Python Program to Print Right Arrow Alphabets Pattern\n", "code": "rows = int(input(\"Enter Right Arrow Alphabets Pattern Rows = \"))\n\nprint(\"====The Right Arrow Alphabets Pattern====\")\nalphabet = 65\n\nfor i in range(rows):\n    for j in range(i):\n        print(end = ' ')\n    for k in range(i, rows):\n        print('%c' %(alphabet + k), end = '')\n    print()\n\nfor i in range(rows - 2, -1, -1):\n    for j in range(i):\n        print(end = ' ')\n    for k in range(i, rows):\n        print('%c' %(alphabet + k), end = '')\n    print()"}
{"nl": "Python Program to Find the Sum of all Even Occurring Elements in an Array/List", "code": "# Take a dictionary and initialize it to empty\n \n # using the {} or dict() say freqncyDictionary.\n \n freqncyDictionary = {}\n \n # Give the list as static input and store it in a variable.\n \n gvnlst = [6, 1, 4, 1, 1, 6, 4, 4, 2, 2]\n \n # Loop in the given list using the For loop.\n \n for i in gvnlst:\n \n  # Inside the For loop,\n \n  # Check if the list element is present in the dictionary\n \n  # or not using the if conditional statement and 'in' keyword.\n \n  if i in freqncyDictionary.keys():\n \n  # If it is true then increment the count of the list element\n \n  # in the dictionary by 1.\n \n  freqncyDictionary[i] = freqncyDictionary[i]+1\n \n  # Else initialize the dictionary with the list element as key and value as 1.\n \n  else:\n \n  freqncyDictionary[i] = 1\n \n \n \n # Take a variable say evenfreqncycnt and initialize its value to 0.\n \n evenfreqncycnt = 0\n \n # Loop in the freqncyDictionary using the For loop.\n \n for elemnt in freqncyDictionary:\n \n  # Check if the key in the freqncyDictionary having value even\n \n  # using the if conditional statement.\n \n  if(freqncyDictionary[elemnt] % 2 == 0):\n \n  # If it is true then increment the evenfreqncycnt by the key\n \n  # and store it in the same variable.\n \n  evenfreqncycnt += elemnt\n \n # After the end of For loop then print the evenfreqncycnt value.\n \n print('The sum of all even frequency elements in the given list', gvnlst, 'is:')\n \n print(evenfreqncycnt)"}
{"nl": "Python Program to Check Whether a Matrix is a Scalar or Not", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[5, 0, 0], [0, 5, 0], [0, 0, 5]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n # Take a variable and initialize its value to zero.\n tempo = 0\n # To print all the elements of the given matrix.\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another\n  # Nested For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Check if the condition n is not equal to m and gvnmatrix[n][m] not equal to 0 using the\n  # if conditional statement where n is the iterator value of the parent For loop and m\n  # is the iterator value of the inner For loop.\n  if n != m and mtrx[n][m] != 0:\n  # If the statement is true, then make the value of tempo as 1.\n  tempo = 1\n  # Break the statement.\n  break\n  # Check if the condition n is equal to m and gvnmatrix[n][m] not equal to gvnmatrix[n][m]\n  # using the if conditional statement where n is the iterator value of the parent For loop\n  # and m is the iterator value of the inner For loop.\n  if n == m and mtrx[n][m] != mtrx[n][m]:\n  # If the statement is true, then make the value of tempo as 1.\n  tempo = 1\n  # Break the statement.\n  break\n # Check if the value of tempo is equal to 1 using the if conditional statement.\n if tempo == 1:\n  # If the statement is true, then print \"The Matrix given is not a Scalar Matrix.\"\n  print(\"The Matrix given is not a Scalar Matrix.\")\n else:\n  # Else print \"The Matrix given is a Scalar Matrix.\"\n  print(\"The Matrix given is a Scalar Matrix.\")"}
{"nl": "Add a week and 12 hours to a given date", "code": "from datetime import datetime, timedelta\r\n\r\ngiven_date = datetime(2020, 3, 22, 10, 00, 00)\r\nprint(\"Given date\")\r\nprint(given_date)\r\n\r\ndays_to_add = 7\r\nres_date = given_date + timedelta(days=days_to_add, hours=12)\r\nprint(\"New Date\")\r\nprint(res_date)"}
{"nl": "Illustrate the Operations of Singly Linked List", "code": "class Node:\n    def __init__(self, data):\n       self.data = data\n       self.next = None\n\u00a0\n\u00a0\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\u00a0\n    def get_node(self, index):\n        current = self.head\n        for i in range(index):\n            if current is None:\n                return None\n            current = current.next\n        return current\n\u00a0\n    def get_prev_node(self, ref_node):\n        current = self.head\n        while (current and current.next != ref_node):\n            current = current.next\n        return current\n\u00a0\n    def insert_after(self, ref_node, new_node):\n        new_node.next = ref_node.next\n        ref_node.next = new_node\n\u00a0\n    def insert_before(self, ref_node, new_node):\n        prev_node = self.get_prev_node(ref_node)\n        self.insert_after(prev_node, new_node)\n\u00a0\n    def insert_at_beg(self, new_node):\n        if self.head is None:\n            self.head = new_node\n        else:\n            new_node.next = self.head\n            self.head = new_node\n\u00a0\n    def insert_at_end(self, new_node):\n        if self.head is None:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next is not None:\n                current = current.next\n            current.next = new_node\n\u00a0\n    def remove(self, node):\n        prev_node = self.get_prev_node(node)\n        if prev_node is None:\n            self.head = self.head.next\n        else:\n            prev_node.next = node.next\n\u00a0\n    def display(self):\n        current = self.head\n        while current:\n            print(current.data, end = ' ')\n            current = current.next\n\u00a0\n\u00a0\na_llist = LinkedList()\n\u00a0\nprint('Menu')\nprint('insert <data> after <index>')\nprint('insert <data> before <index>')\nprint('insert <data> at beg')\nprint('insert <data> at end')\nprint('remove <index>') \nprint('quit')\n\u00a0\nwhile True:\n    print('The list: ', end = '')\n    a_llist.display()\n    print()\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n\u00a0\n    if operation == 'insert':\n        data = int(do[1])\n        position = do[3].strip().lower()\n        new_node = Node(data)\n        suboperation = do[2].strip().lower() \n        if suboperation == 'at':\n            if position == 'beg':\n                a_llist.insert_at_beg(new_node)\n            elif position == 'end':\n                a_llist.insert_at_end(new_node)\n        else:\n            index = int(position)\n            ref_node = a_llist.get_node(index)\n            if ref_node is None:\n                print('No such index.')\n                continue\n            if suboperation == 'after':\n                a_llist.insert_after(ref_node, new_node)\n            elif suboperation == 'before':\n                a_llist.insert_before(ref_node, new_node)\n\u00a0\n    elif operation == 'remove':\n        index = int(do[1])\n        node = a_llist.get_node(index)\n        if node is None:\n            print('No such index.')\n            continue\n        a_llist.remove(node)\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Swap nodes in a linked list without swapping data", "code": "# Python program to swap two given nodes of a linked list\nclass LinkedList(object):\n\tdef __init__(self):\n\t\tself.head = None\n\n\t# head of list\n\tclass Node(object):\n\t\tdef __init__(self, d):\n\t\t\tself.data = d\n\t\t\tself.next = None\n\n\t# Function to swap Nodes x and y in linked list by\n\t# changing links\n\tdef swapNodes(self, x, y):\n\n\t\t# Nothing to do if x and y are same\n\t\tif x == y:\n\t\t\treturn\n\n\t\t# Search for x (keep track of prevX and CurrX)\n\t\tprevX = None\n\t\tcurrX = self.head\n\t\twhile currX != None and currX.data != x:\n\t\t\tprevX = currX\n\t\t\tcurrX = currX.next\n\n\t\t# Search for y (keep track of prevY and currY)\n\t\tprevY = None\n\t\tcurrY = self.head\n\t\twhile currY != None and currY.data != y:\n\t\t\tprevY = currY\n\t\t\tcurrY = currY.next\n\n\t\t# If either x or y is not present, nothing to do\n\t\tif currX == None or currY == None:\n\t\t\treturn\n\t\t# If x is not head of linked list\n\t\tif prevX != None:\n\t\t\tprevX.next = currY\n\t\telse: # make y the new head\n\t\t\tself.head = currY\n\n\t\t# If y is not head of linked list\n\t\tif prevY != None:\n\t\t\tprevY.next = currX\n\t\telse: # make x the new head\n\t\t\tself.head = currX\n\n\t\t# Swap next pointers\n\t\ttemp = currX.next\n\t\tcurrX.next = currY.next\n\t\tcurrY.next = temp\n\n\t# Function to add Node at beginning of list.\n\tdef push(self, new_data):\n\n\t\t# 1. alloc the Node and put the data\n\t\tnew_Node = self.Node(new_data)\n\n\t\t# 2. Make next of new Node as head\n\t\tnew_Node.next = self.head\n\n\t\t# 3. Move the head to point to new Node\n\t\tself.head = new_Node\n\n\t# This function prints contents of linked list starting\n\t# from the given Node\n\tdef printList(self):\n\t\ttNode = self.head\n\t\twhile tNode != None:\n\t\t\tprint tNode.data,\n\t\t\ttNode = tNode.next\n\n\n# Driver program to test above function\nllist = LinkedList()\n\n# The constructed linked list is:\n# 1->2->3->4->5->6->7\nllist.push(7)\nllist.push(6)\nllist.push(5)\nllist.push(4)\nllist.push(3)\nllist.push(2)\nllist.push(1)\nprint \"Linked list before calling swapNodes() \"\nllist.printList()\nllist.swapNodes(4, 3)\nprint \"\\nLinked list after calling swapNodes() \"\nllist.printList()\n\n# This code is contributed by BHAVYA JAIN\n"}
{"nl": "Count the number of words whose length is greater than 5", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Read the above file using the read() function(get the content) and store it in a variable\n  filetext = givenfilecontent.read()\n# Take a variable(which gives the count of words with length>5 in a file) and initialize its value with zero.\ncnt = 0\n# Split the above file text lines into list of words using the split() function and \n# iterate in that list using the for loop\nfor wrd in filetext.split():\n  # Get the length of each word is using the len() function and check if the length of\n  # each word is greater than 5 using the if conditional statement.\n  if len(wrd) > 5:\n  # If it is true, then increment the above count value by 1.\n  cnt += 1\n# Print the count of words with length greater than 5 in a given file.\nprint(\"The count of words with length greater than 5 in a given file = \", cnt)"}
{"nl": "Python Program to Read Two Numbers and Print Their Quotient and Remainder", "code": "# scanning the given two numbers using int(input()) function\n# first number\nnumb1 = int(input(\"Enter some random number = \"))\n# second number\nnumb2 = int(input(\"Enter some random number = \"))\n# Calculate the quotient by using the syntax first number /second number\n# and store it in a variable.\nquotie = numb1/numb2\n# Calculate the remainder by using the syntax first number %second number\n# and store it in a variable.\nremain = numb1 % numb2\n# Print the above two variables which are the result of the program\nprint(\"The value of quotient after dividing\", numb1, \"/\", numb2, \" = \", quotie)\nprint(\"The value of remainder after dividing\",\n      numb1, \"/\", numb2, \" = \", remain)"}
{"nl": "Return the sum of divisors of the integers in that array that have exactly four divisors", "code": "class Solution:\n  def sumFourDivisors(self, nums: List[int]) -> int:\n  res = 0\n  for num in nums:\n  divisor = set() \n  for i in range(1, floor(sqrt(num)) + 1):\n  if num % i == 0:\n  divisor.add(num//i)\n  divisor.add(i)\n  if len(divisor) > 4:  \n  break\n  \n  if len(divisor) == 4:\n  res += sum(divisor)\n  return res"}
{"nl": "Convert a given Binary Tree to Doubly Linked List", "code": "# Python3 program to convert a given Binary Tree to Doubly Linked List\nclass Node:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\nclass BinaryTree:\n\t# A simple recursive function to convert a given\n\t# Binary tree to Doubly Linked List\n\t# root --> Root of Binary Tree\n\t# head --> Pointer to head node of created doubly linked list\n\troot, head = None, None\n\t\n\tdef BToDll(self, root: Node):\n\t\tif root is None:\n\t\t\treturn\n\n\t\t# Recursively convert right subtree\n\t\tself.BToDll(root.right)\n\n\t\t# Insert root into doubly linked list\n\t\troot.right = self.head\n\n\t\t# Change left pointer of previous head\n\t\tif self.head is not None:\n\t\t\tself.head.left = root\n\n\t\t# Change head of doubly linked list\n\t\tself.head = root\n\n\t\t# Recursively convert left subtree\n\t\tself.BToDll(root.left)\n\n\t@staticmethod\n\tdef print_list(head: Node):\n\t\tprint('Extracted Double Linked list is:')\n\t\twhile head is not None:\n\t\t\tprint(head.data, end = ' ')\n\t\t\thead = head.right\n\n# Driver program to test above function\nif __name__ == '__main__':\n\t\n\t\"\"\"\n\tConstructing below tree\n\t\t\t5\n\t\t// \\\\\n\t\t3 6\n\t\t// \\\\ \\\\\n\t\t1 4 8\n\t// \\\\ // \\\\\n\t0 2 7 9\n\t\"\"\"\n\ttree = BinaryTree()\n\ttree.root = Node(5)\n\ttree.root.left = Node(3)\n\ttree.root.right = Node(6)\n\ttree.root.left.left = Node(1)\n\ttree.root.left.right = Node(4)\n\ttree.root.right.right = Node(8)\n\ttree.root.left.left.left = Node(0)\n\ttree.root.left.left.right = Node(2)\n\ttree.root.right.right.left = Node(7)\n\ttree.root.right.right.right = Node(9)\n\n\ttree.BToDll(tree.root)\n\ttree.print_list(tree.head)\n\n# This code is contributed by Rajat Srivastava\n"}
{"nl": "Implement Bellman-Ford Algorithm", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def __len__(self):\n        return len(self.vertices)\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef bellman_ford(g, source):\n    \"\"\"Return distance where distance[v] is min distance from source to v.\n\u00a0\n    This will return a dictionary distance.\n\u00a0\n    g is a Graph object which can have negative edge weights.\n    source is a Vertex object in g.\n    \"\"\"\n    distance = dict.fromkeys(g, float('inf'))\n    distance[source] = 0\n\u00a0\n    for _ in range(len(g) - 1):\n        for v in g:\n            for n in v.get_neighbours():\n                distance[n] = min(distance[n], distance[v] + v.get_weight(n))\n\u00a0\n    return distance\n\u00a0\n\u00a0\ng = Graph()\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('bellman-ford <source vertex key>')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'bellman-ford':\n        key = int(do[1])\n        source = g.get_vertex(key)\n        distance = bellman_ford(g, source)\n        print('Distances from {}: '.format(key))\n        for v in distance:\n            print('Distance to {}: {}'.format(v.get_key(), distance[v]))\n        print()\n\u00a0\n    elif operation == 'display':\n        print('Vertices: ', end='')\n        for v in g:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in g:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Matrix Multiplication", "code": "import numpy as np\ndef multiply_matrix(m1, m2):\n  try:\n    return np.dot(m1, m2).tolist()\n  except:\n    return \"ERROR\""}
{"nl": "Find largest subtree sum in a tree", "code": "# Python3 program to find largest subtree\n# sum in a given binary tree.\n\n# Function to create new tree node.\nclass newNode:\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = self.right = None\n\n# Helper function to find largest\n# subtree sum recursively.\ndef findLargestSubtreeSumUtil(root, ans):\n\t\n\t# If current node is None then\n\t# return 0 to parent node.\n\tif (root == None):\n\t\treturn 0\n\t\n\t# Subtree sum rooted at current node.\n\tcurrSum = (root.key +\n\t\t\tfindLargestSubtreeSumUtil(root.left, ans) +\n\t\t\tfindLargestSubtreeSumUtil(root.right, ans))\n\n\t# Update answer if current subtree\n\t# sum is greater than answer so far.\n\tans[0] = max(ans[0], currSum)\n\n\t# Return current subtree sum to\n\t# its parent node.\n\treturn currSum\n\n# Function to find largest subtree sum.\ndef findLargestSubtreeSum(root):\n\t\n\t# If tree does not exist,\n\t# then answer is 0.\n\tif (root == None):\t\n\t\treturn 0\n\t\n\t# Variable to store maximum subtree sum.\n\tans = [-999999999999]\n\n\t# Call to recursive function to\n\t# find maximum subtree sum.\n\tfindLargestSubtreeSumUtil(root, ans)\n\n\treturn ans[0]\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t#\n\t#\t\t 1\n\t#\t\t / \\\n\t#\t /\t \\\n\t#\t -2\t 3\n\t#\t / \\\t / \\\n\t#\t / \\ / \\\n\t# 4\t 5 -6\t 2\n\troot = newNode(1)\n\troot.left = newNode(-2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(-6)\n\troot.right.right = newNode(2)\n\n\tprint(findLargestSubtreeSum(root))\n\n# This code is contributed by PranchalK\n"}
{"nl": "Triangular Matchstick Number", "code": "# Create a function to say count_MatchSticks() which takes the given number as an\r\n# argument and returns the count of the number of matchsticks needed to form a\r\n# pyramid of matchsticks for a given number of floors.\r\n\r\n\r\ndef count_MatchSticks(no_floors):\r\n    # Inside the function, calculate the number of matchsticks needed using the above\r\n    # given mathematical formula and store it in a variable.\r\n    no_sticks = (3 * no_floors * (no_floors + 1)) / 2\r\n    # Return the above result.\r\n    return no_sticks\r\n\r\n\r\n# Give the number as static input and store it in a variable.\r\nno_floors = 3\r\nprint(\"The Number of matchsticks needed to form a pyramid of matchsticks :\")\r\n# Pass the given number as an argument to the count_MatchSticks() function, convert\r\n# it into an integer using the int() function and print it.\r\nprint(int(count_MatchSticks(no_floors)))"}
{"nl": "Possible Palindrome", "code": "def possible_palindrome(txt):\n  return sum(txt.count(i)%2 for i in set(txt)) <= 1"}
{"nl": "Sum of both diagonals of a spiral odd-order square matrix", "code": "# Python3 program to find sum of\n# diagonals of spiral matrix\n\u00a0\n# function returns sum of diagonals\ndef spiralDiaSum(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if n == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# as order should be only odd\n\u00a0\u00a0\u00a0\u00a0# we should pass only odd\n\u00a0\u00a0\u00a0\u00a0# integers\n\u00a0\u00a0\u00a0\u00a0return (4 * n*n - 6 * n + 6 +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spiralDiaSum(n-2))\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver program\nn = 7;\nprint(spiralDiaSum(n))\n\u00a0\n# This code is contributed by Anant Agarwal.\n"}
{"nl": "Print BST keys in the given range", "code": "# Python program to find BST keys in given range\n\u00a0\n# A binary tree node\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# The function prints all the keys in the given range\n# [k1..k2]. Assumes that k1 < k2\ndef Print(root, k1, k2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Since the desired o/p is sorted, recurse for left\n\u00a0\u00a0\u00a0\u00a0# subtree first. If root.data is greater than k1, then\n\u00a0\u00a0\u00a0\u00a0# only we can get o/p keys in left subtree\n\u00a0\u00a0\u00a0\u00a0if k1 < root.data :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Print(root.left, k1, k2)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If root's data lies in range, then prints root's data\n\u00a0\u00a0\u00a0\u00a0if k1 <= root.data and k2 >= root.data:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (root.data,end=' ')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# recursively call the right subtree\n\u00a0\u00a0\u00a0\u00a0Print(root.right, k1, k2)\n\u00a0\n# Driver function to test above function\nk1 = 10 ; k2 = 25 ;\nroot = Node(20)\nroot.left = Node(8)\nroot.right = Node(22)\nroot.left.left = Node(4)\nroot.left.right = Node(12)\n\u00a0\nPrint(root, k1, k2)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Averages of Levels in Binary Tree", "code": "# Python3 program to find averages of\r\n# all levels in a binary tree.\r\n\r\n# Importing Queue\r\nfrom queue import Queue\r\n\r\n# Helper class that allocates a\r\n# new node with the given data and\r\n# None left and right pointers.\r\nclass newNode:\r\n\tdef __init__(self, data):\r\n\t\tself.val = data\r\n\t\tself.left = self.right = None\r\n\t\r\n# Function to print the average value\r\n# of the nodes on each level\r\ndef averageOfLevels(root):\r\n\r\n\t# Traversing level by level\r\n\tq = Queue()\r\n\tq.put(root)\r\n\twhile (not q.empty()):\r\n\r\n\t\t# Compute Sum of nodes and\r\n\t\t# count of nodes in current\r\n\t\t# level.\r\n\t\tSum = 0\r\n\t\tcount = 0\r\n\t\ttemp = Queue()\r\n\t\twhile (not q.empty()):\r\n\t\t\tn = q.queue[0]\r\n\t\t\tq.get()\r\n\t\t\tSum += n.val\r\n\t\t\tcount += 1\r\n\t\t\tif (n.left != None):\r\n\t\t\t\ttemp.put(n.left)\r\n\t\t\tif (n.right != None):\r\n\t\t\t\ttemp.put(n.right)\r\n\t\tq = temp\r\n\t\tprint((Sum * 1.0 / count), end = \" \")\r\n\r\n# Driver code\r\nif __name__ == '__main__':\r\n\r\n\t# Let us construct a Binary Tree\r\n\t#\t 4\r\n\t# / \\\r\n\t# 2 9\r\n\t# / \\ \\\r\n\t# 3 5 7\r\n\troot = None\r\n\troot = newNode(4)\r\n\troot.left = newNode(2)\r\n\troot.right = newNode(9)\r\n\troot.left.left = newNode(3)\r\n\troot.left.right = newNode(8)\r\n\troot.right.right = newNode(7)\r\n\taverageOfLevels(root)\r\n\r\n# This code is contributed by PranchalK\r"}
{"nl": "Find whether an array is subset of another array", "code": "# Python 3 program to find whether an array\n# is subset of another array\n\n# Return 1 if arr2[] is a subset of\n# arr1[]\ndef isSubset(arr1, arr2, m, n):\n\ti = 0\n\tj = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif(arr2[i] == arr1[j]):\n\t\t\t\tbreak\n\t\t\n\t\t# If the above inner loop was\n\t\t# not broken at all then arr2[i]\n\t\t# is not present in arr1[]\n\t\tif (j == m):\n\t\t\treturn 0\n\t\n\t# If we reach here then all\n\t# elements of arr2[] are present\n\t# in arr1[]\n\treturn 1\n\n# Driver code\nif __name__ == \"__main__\":\n\t\n\tarr1 = [11, 1, 13, 21, 3, 7]\n\tarr2 = [11, 3, 7, 1]\n\n\tm = len(arr1)\n\tn = len(arr2)\n\n\tif(isSubset(arr1, arr2, m, n)):\n\t\tprint(\"arr2[] is subset of arr1[] \")\n\telse:\n\t\tprint(\"arr2[] is not a subset of arr1[]\")\n\n# This code is contributed by ita_c"}
{"nl": "Remove all nodes which don\u2019t lie in any path with sum>= k", "code": "# A class to create a new Binary Tree\n# node with given data\nclass newNode:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = None\n\n# print the tree in LVR (Inorder traversal) way.\ndef Print(root):\n\tif (root != None):\n\t\tPrint(root.left)\n\t\tprint(root.data, end = \" \")\n\t\tPrint(root.right)\n\n# Main function which truncates\n# the binary tree.\ndef pruneUtil(root, k, Sum):\n\t\n\t# Base Case\n\tif (root == None):\n\t\treturn None\n\n\t# Initialize left and right Sums as\n\t# Sum from root to this node\n\t# (including this node)\n\tlSum = [Sum[0] + (root.data)]\n\trSum = [lSum[0]]\n\n\t# Recursively prune left and right\n\t# subtrees\n\troot.left = pruneUtil(root.left, k, lSum)\n\troot.right = pruneUtil(root.right, k, rSum)\n\n\t# Get the maximum of left and right Sums\n\tSum[0] = max(lSum[0], rSum[0])\n\n\t# If maximum is smaller than k,\n\t# then this node must be deleted\n\tif (Sum[0] < k[0]):\n\t\troot = None\n\treturn root\n\n# A wrapper over pruneUtil()\ndef prune(root, k):\n\tSum = [0]\n\treturn pruneUtil(root, k, Sum)\n\n# Driver Code\nif __name__ == '__main__':\n\tk = [45]\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(6)\n\troot.right.right = newNode(7)\n\troot.left.left.left = newNode(8)\n\troot.left.left.right = newNode(9)\n\troot.left.right.left = newNode(12)\n\troot.right.right.left = newNode(10)\n\troot.right.right.left.right = newNode(11)\n\troot.left.left.right.left = newNode(13)\n\troot.left.left.right.right = newNode(14)\n\troot.left.left.right.right.left = newNode(15)\n\n\tprint(\"Tree before truncation\")\n\tPrint(root)\n\tprint()\n\troot = prune(root, k) # k is 45\n\n\tprint(\"Tree after truncation\")\n\tPrint(root)\n\n# This code is contributed by PranchalK\n"}
{"nl": "given number of rooms, find the label of the first day where all rooms have been visited", "code": "class Solution:\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\n        time_taken = 0\n        n = len(nextVisit)\n        arrival_time = [0]*n\n        MOD = 10**9 + 7\n        \n        for i, next_room in enumerate(nextVisit):\n            if i != 0:\n                arrival_time[i] = 1 + arrival_time[i-1] + time_taken\n            time_taken = (arrival_time[i] - arrival_time[next_room])+1\n        \n        return (arrival_time[-1])%MOD"}
{"nl": "Barabasi Albert Graph (for Scale Free Models)", "code": "def barabasi_albert_graph(n, m, seed=None):\n    \"\"\"Returns a random graph according to the Barab\u00e1si\u2013Albert preferential\n    Attachment model.\n  \n    A graph of ``n`` nodes is grown by attaching new nodes each with ``m``\n    Edges that are preferentially attached to existing nodes with high degree.\n  \n    Parameters\n    ----------\n    n : int\n        Number of nodes\n    m : int\n        Number of edges to attach from a new node to existing nodes\n    seed : int, optional\n        Seed for random number generator (default=None).\n  \n    Returns\n    -------\n    G : Graph\n  \n    Raises\n    ------\n    NetworkXError\n        If ``m`` does not satisfy ``1 <= m < n``.\n  \n      \n    if m < 1 or  m >=n:\n        raise nx.NetworkXError(\"Barab\u00e1si\u2013Albert network must have m >= 1\"\n                               \" and m < n, m = %d, n = %d\" % (m, n))\n    if seed is not None:\n        random.seed(seed)\n  \n    # Add m initial nodes (m0 in barabasi-speak)\n    G=empty_graph(m)\n    G.name=\"barabasi_albert_graph(%s,%s)\"%(n,m)\n    # Target nodes for new edges\n    targets=list(range(m))\n    # List of existing nodes, with nodes repeated once for each adjacent edge\n    repeated_nodes=[]\n    # Start adding the other n-m nodes. The first node is m.\n    source=m\n    while source<n:\n        # Add edges to m nodes from the source.\n        G.add_edges_from(zip(*m,targets))\n        # Add one node to the list for each new edge just created.\n        repeated_nodes.extend(targets)\n        # And the new node \"source\" has m edges to add to the list.\n        repeated_nodes.extend(*m)\n        # Now choose m unique nodes from the existing nodes\n        # Pick uniformly from repeated_nodes (preferential attachement)\n        targets = _random_subset(repeated_nodes,m)\n        source += 1\n    return G"}
{"nl": "Softmax Regression using TensorFlow", "code": "import tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tensorflow.examples.tutorials.mnist import input_data\nmnist = input_data.read_data_sets(\"MNIST_data/\", one_hot=True)\nprint(\"Shape of feature matrix:\", mnist.train.images.shape)\nprint(\"Shape of target matrix:\", mnist.train.labels.shape)\nprint(\"One-hot encoding for 1st observation:\\n\", mnist.train.labels[0])\n\n# visualize data by plotting images\nfig,ax = plt.subplots(10,10)\nk = 0\nfor i in range(10):\n\tfor j in range(10):\n\t\tax[i][j].imshow(mnist.train.images[k].reshape(28,28), aspect='auto')\n\t\tk += 1\nplt.show()\n# number of features\nnum_features = 784\n# number of target labels\nnum_labels = 10\n# learning rate (alpha)\nlearning_rate = 0.05\n# batch size\nbatch_size = 128\n# number of epochs\nnum_steps = 5001\n\n# input data\ntrain_dataset = mnist.train.images\ntrain_labels = mnist.train.labels\ntest_dataset = mnist.test.images\ntest_labels = mnist.test.labels\nvalid_dataset = mnist.validation.images\nvalid_labels = mnist.validation.labels\n\n# initialize a tensorflow graph\ngraph = tf.Graph()\n\nwith graph.as_default():\n\t\"\"\"\n\tdefining all the nodes\n\t\"\"\"\n\n\t# Inputs\n\ttf_train_dataset = tf.placeholder(tf.float32, shape=(batch_size, num_features))\n\ttf_train_labels = tf.placeholder(tf.float32, shape=(batch_size, num_labels))\n\ttf_valid_dataset = tf.constant(valid_dataset)\n\ttf_test_dataset = tf.constant(test_dataset)\n\n\t# Variables.\n\tweights = tf.Variable(tf.truncated_normal([num_features, num_labels]))\n\tbiases = tf.Variable(tf.zeros([num_labels]))\n\n\t# Training computation.\n\tlogits = tf.matmul(tf_train_dataset, weights) + biases\n\tloss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(\n\t\t\t\t\t\tlabels=tf_train_labels, logits=logits))\n\n\t# Optimizer.\n\toptimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)\n\n\t# Predictions for the training, validation, and test data.\n\ttrain_prediction = tf.nn.softmax(logits)\n\tvalid_prediction = tf.nn.softmax(tf.matmul(tf_valid_dataset, weights) + biases)\n\ttest_prediction = tf.nn.softmax(tf.matmul(tf_test_dataset, weights) + biases)\n# utility function to calculate accuracy\ndef accuracy(predictions, labels):\n\tcorrectly_predicted = np.sum(np.argmax(predictions, 1) == np.argmax(labels, 1))\n\taccu = (100.0 * correctly_predicted) / predictions.shape[0]\n\treturn accu\n\nwith tf.Session(graph=graph) as session:\n\t# initialize weights and biases\n\ttf.global_variables_initializer().run()\n\tprint(\"Initialized\")\n\n\tfor step in range(num_steps):\n\t\t# pick a randomized offset\n\t\toffset = np.random.randint(0, train_labels.shape[0] - batch_size - 1)\n\n\t\t# Generate a minibatch.\n\t\tbatch_data = train_dataset[offset:(offset + batch_size), :]\n\t\tbatch_labels = train_labels[offset:(offset + batch_size), :]\n\n\t\t# Prepare the feed dict\n\t\tfeed_dict = {tf_train_dataset : batch_data,\n\t\t\t\t\ttf_train_labels : batch_labels}\n\n\t\t# run one step of computation\n\t\t_, l, predictions = session.run([optimizer, loss, train_prediction],\n\t\t\t\t\t\t\t\t\t\tfeed_dict=feed_dict)\n\n\t\tif (step % 500 == 0):\n\t\t\tprint(\"Minibatch loss at step {0}: {1}\".format(step, l))\n\t\t\tprint(\"Minibatch accuracy: {:.1f}%\".format(\n\t\t\t\taccuracy(predictions, batch_labels)))\n\t\t\tprint(\"Validation accuracy: {:.1f}%\".format(\n\t\t\t\taccuracy(valid_prediction.eval(), valid_labels)))\n\n\tprint(\"\\nTest accuracy: {:.1f}%\".format(\n\t\taccuracy(test_prediction.eval(), test_labels)))\n"}
{"nl": "Same on Both Ends", "code": "import re\ndef count_same_ends(txt):\n  return len(re.findall(r'\\b(\\w)\\w*\\1\\b', txt.lower()))"}
{"nl": "Layers in a Rug", "code": "def count_layers(rug):\n  return len(set(rug))"}
{"nl": "Find the previous Armstrong number", "code": "# Import the count from the itertools module using the import and from keyword.\n from itertools import count\n # Give the number n as static input and store it in a variable.\n gvnnumb = 67\n # Loop till the given number in decreasing order using the For loop\n # and the count() function.\n for m in count(gvnnumb, -1):\n  # Convert the given number to the string using the str() function\n  # and store it in a variable say strngnumb.\n  strngnumb = str(m)\n  # Take a variable say cuntsum and initialize its value to 0.\n  cuntsum = 0\n  # Calculate the length of the string using the len() function\n  # and store it in a variable to say\n  strnglengt = len(strngnumb)\n  # Loop in the strngnumb using the nested For loop(Inner For loop).\n  for dgtval in strngnumb:\n  # Convert the inner loop iterator value to an integer using the int() function\n  # and store it as a new variable say intitr.\n  intitr = int(dgtval)\n  # Inside the for loop, increment the value of cuntsum with intitr**strnglengt(where ** is power operator).\n  cuntsum += intitr**strnglengt\n  # After the end of For loop check if cuntsum is equal to the iterator value\n  # of the inner for loop using the if conditional statement.\n  if(cuntsum == m):\n  # If it is true then print the value of cuntsum.\n  print('The previous armstrong number of {', gvnnumb, '} is :', cuntsum)\n  # Break the parent for loop using the break keyword.\n  break"}
{"nl": "Print array elements that are divisible by at-least one other", "code": "# Python3 program to find special numbers\n# in an array\nimport math as mt\n\n# Function to find special numbers\ndef divisibilityCheck(arr, n):\n\n        # Storing all array elements in a hash\n        # and finding maximum element in array\n        s = dict()\n        max_ele = -10**9\n        for i in range(n):\n                s[arr[i]] = 1\n\n                # finding maximum element of array\n                max_ele = max(max_ele, arr[i])\n        \n        # traversing array element and storing\n        # the array multiples that are present\n        # in s in res.\n        res = dict()\n        for i in range(n):\n\n                # Check for non-zero values only\n                if (arr[i] != 0):\n\n                        # checking the factor of current element\n                        for j in range(arr[i] * 2,\n                                                max_ele + 1, arr[i]):\n                                \n                                # if factor is already part of\n                                # array element then store it\n                                if (j in s.keys()):\n                                        res[j] = 1\n                        \n        # displaying elements that are divisible\n        # by at least one other in array\n        for x in res:\n                print(x, end = \" \")\n\n# Driver code\narr = [ 2, 3, 8, 6, 9, 10]\nn = len(arr)\ndivisibilityCheck(arr, n)\n\n# This code is contributed by\n# Mohit Kumar 29\n"}
{"nl": "Find top k (or most frequent) numbers in a stream", "code": "# Python program to find top k elements in a stream\n\n# Function to print top k numbers\ndef kTop(a, n, k):\n\n\t# list of size k + 1 to store elements\n\ttop = [0 for i in range(k + 1)]\n\n\t# dictionary to keep track of frequency\n\tfreq = {i:0 for i in range(k + 1)}\n\n\t# iterate till the end of stream\n\tfor m in range(n):\n\n\t\t# increase the frequency\n\t\tif a[m] in freq.keys():\n\t\t\tfreq[a[m]] += 1\n\t\telse:\n\t\t\tfreq[a[m]] = 1\n\n\t\t# store that element in top vector\n\t\ttop[k] = a[m]\n\n\t\ti = top.index(a[m])\n\t\ti -= 1\n\t\t\n\t\twhile i >= 0:\n\n\t\t\t# compare the frequency and swap if higher\n\t\t\t# frequency element is stored next to it\n\t\t\tif (freq[top[i]] < freq[top[i + 1]]):\n\t\t\t\tt = top[i]\n\t\t\t\ttop[i] = top[i + 1]\n\t\t\t\ttop[i + 1] = t\n\t\t\t\n\t\t\t# if frequency is same compare the elements\n\t\t\t# and swap if next element is high\n\t\t\telse if ((freq[top[i]] == freq[top[i + 1]]) and (top[i] > top[i + 1])):\n\t\t\t\tt = top[i]\n\t\t\t\ttop[i] = top[i + 1]\n\t\t\t\ttop[i + 1] = t\n\t\t\telse:\n\t\t\t\tbreak\n\t\t\ti -= 1\n\t\t\n\t\t# print top k elements\n\t\ti = 0\n\t\twhile i < k and top[i] != 0:\n\t\t\tprint(top[i],end=\" \")\n\t\t\ti += 1\n\tprint()\n\n# Driver program to test above function\nk = 4\narr = [ 5, 2, 1, 3, 2 ]\nn = len(arr)\nkTop(arr, n, k)\n\n# This code is contributed by Sachin Bisht"}
{"nl": "Prim\u2019s MST for Adjacency List Representation", "code": "# A Python program for Prims's MST for\n# adjacency list representation of graph\n\nfrom collections import defaultdict\nimport sys\n\nclass Heap():\n\n        def __init__(self):\n                self.array = []\n                self.size = 0\n                self.pos = []\n\n        def newMinHeapNode(self, v, dist):\n                minHeapNode = [v, dist]\n                return minHeapNode\n\n        # A utility function to swap two nodes of\n        # min heap. Needed for min heapify\n        def swapMinHeapNode(self, a, b):\n                t = self.array[a]\n                self.array[a] = self.array[b]\n                self.array[b] = t\n\n        # A standard function to heapify at given idx\n        # This function also updates position of nodes\n        # when they are swapped. Position is needed\n        # for decreaseKey()\n        def minHeapify(self, idx):\n                smallest = idx\n                left = 2 * idx + 1\n                right = 2 * idx + 2\n\n                if left < self.size and self.array[left][1] < \\\n                                                                self.array[smallest][1]:\n                        smallest = left\n\n                if right < self.size and self.array[right][1] < \\\n                                                                self.array[smallest][1]:\n                        smallest = right\n\n                # The nodes to be swapped in min heap\n                # if idx is not smallest\n                if smallest != idx:\n\n                        # Swap positions\n                        self.pos[ self.array[smallest][0] ] = idx\n                        self.pos[ self.array[idx][0] ] = smallest\n\n                        # Swap nodes\n                        self.swapMinHeapNode(smallest, idx)\n\n                        self.minHeapify(smallest)\n\n        # Standard function to extract minimum node from heap\n        def extractMin(self):\n\n                # Return NULL wif heap is empty\n                if self.isEmpty() == True:\n                        return\n\n                # Store the root node\n                root = self.array[0]\n\n                # Replace root node with last node\n                lastNode = self.array[self.size - 1]\n                self.array[0] = lastNode\n\n                # Update position of last node\n                self.pos[lastNode[0]] = 0\n                self.pos[root[0]] = self.size - 1\n\n                # Reduce heap size and heapify root\n                self.size -= 1\n                self.minHeapify(0)\n\n                return root\n\n        def isEmpty(self):\n                return True if self.size == 0 else False\n\n        def decreaseKey(self, v, dist):\n\n                # Get the index of v in heap array\n\n                i = self.pos[v]\n\n                # Get the node and update its dist value\n                self.array[i][1] = dist\n\n                # Travel up while the complete tree is not\n                # hepified. This is a O(Logn) loop\n                while i > 0 and self.array[i][1] < \\\n                                        self.array[(i - 1) // 2][1]:\n\n                        # Swap this node with its parent\n                        self.pos[ self.array[i][0] ] = (i-1)/2\n                        self.pos[ self.array[(i-1)//2][0] ] = i\n                        self.swapMinHeapNode(i, (i - 1)//2 )\n\n                        # move to parent index\n                        i = (i - 1) // 2;\n\n        # A utility function to check if a given vertex\n        # 'v' is in min heap or not\n        def isInMinHeap(self, v):\n\n                if self.pos[v] < self.size:\n                        return True\n                return False\n\n\ndef printArr(parent, n):\n        for i in range(1, n):\n                print(\"% d - % d\" % (parent[i], i))\n\n\nclass Graph():\n\n        def __init__(self, V):\n                self.V = V\n                self.graph = defaultdict(list)\n\n        # Adds an edge to an undirected graph\n        def addEdge(self, src, dest, weight):\n\n                # Add an edge from src to dest. A new node is\n                # added to the adjacency list of src. The node\n                # is added at the beginning. The first element of\n                # the node has the destination and the second\n                # elements has the weight\n                newNode = [dest, weight]\n                self.graph[src].insert(0, newNode)\n\n                # Since graph is undirected, add an edge from\n                # dest to src also\n                newNode = [src, weight]\n                self.graph[dest].insert(0, newNode)\n\n        # The main function that prints the Minimum\n        # Spanning Tree(MST) using the Prim's Algorithm.\n        # It is a O(ELogV) function\n        def PrimMST(self):\n                # Get the number of vertices in graph\n                V = self.V\n                \n                # key values used to pick minimum weight edge in cut\n                key = []\n                \n                # List to store constructed MST\n                parent = []\n\n                # minHeap represents set E\n                minHeap = Heap()\n\n                # Initialize min heap with all vertices. Key values of all\n                # vertices (except the 0th vertex) is is initially infinite\n                for v in range(V):\n                        parent.append(-1)\n                        key.append(1e7)\n                        minHeap.array.append( minHeap.newMinHeapNode(v, key[v]) )\n                        minHeap.pos.append(v)\n\n                # Make key value of 0th vertex as 0 so\n                # that it is extracted first\n                minHeap.pos[0] = 0\n                key[0] = 0\n                minHeap.decreaseKey(0, key[0])\n\n                # Initially size of min heap is equal to V\n                minHeap.size = V;\n\n                # In the following loop, min heap contains all nodes\n                # not yet added in the MST.\n                while minHeap.isEmpty() == False:\n\n                        # Extract the vertex with minimum distance value\n                        newHeapNode = minHeap.extractMin()\n                        u = newHeapNode[0]\n\n                        # Traverse through all adjacent vertices of u\n                        # (the extracted vertex) and update their\n                        # distance values\n                        for pCrawl in self.graph[u]:\n\n                                v = pCrawl[0]\n\n                                # If shortest distance to v is not finalized\n                                # yet, and distance to v through u is less than\n                                # its previously calculated distance\n                                if minHeap.isInMinHeap(v) and pCrawl[1] < key[v]:\n                                        key[v] = pCrawl[1]\n                                        parent[v] = u\n\n                                        # update distance value in min heap also\n                                        minHeap.decreaseKey(v, key[v])\n\n                printArr(parent, V)\n\n\n# Driver program to test the above functions\ngraph = Graph(9)\ngraph.addEdge(0, 1, 4)\ngraph.addEdge(0, 7, 8)\ngraph.addEdge(1, 2, 8)\ngraph.addEdge(1, 7, 11)\ngraph.addEdge(2, 3, 7)\ngraph.addEdge(2, 8, 2)\ngraph.addEdge(2, 5, 4)\ngraph.addEdge(3, 4, 9)\ngraph.addEdge(3, 5, 14)\ngraph.addEdge(4, 5, 10)\ngraph.addEdge(5, 6, 2)\ngraph.addEdge(6, 7, 1)\ngraph.addEdge(6, 8, 6)\ngraph.addEdge(7, 8, 7)\ngraph.PrimMST()\n\n# This code is contributed by Divyanshu Mehta\n"}
{"nl": "check if a given point lies inside or outside a polygon", "code": "# A Python3 program to check if a given point\n# lies inside a given polygon\n# Refer https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# for explanation of functions onSegment(),\n# orientation() and doIntersect()\n\n# Define Infinite (Using INT_MAX\n# caused overflow problems)\nINT_MAX = 10000\n\n# Given three collinear points p, q, r,\n# the function checks if point q lies\n# on line segment 'pr'\ndef onSegment(p:tuple, q:tuple, r:tuple) -> bool:\n\t\n\tif ((q[0] <= max(p[0], r[0])) &\n\t\t(q[0] >= min(p[0], r[0])) &\n\t\t(q[1] <= max(p[1], r[1])) &\n\t\t(q[1] >= min(p[1], r[1]))):\n\t\treturn True\n\t\t\n\treturn False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are collinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p:tuple, q:tuple, r:tuple) -> int:\n\t\n\tval = (((q[1] - p[1]) *\n\t\t\t(r[0] - q[0])) -\n\t\t((q[0] - p[0]) *\n\t\t\t(r[1] - q[1])))\n\t\t\t\n\tif val == 0:\n\t\treturn 0\n\tif val > 0:\n\t\treturn 1 # Collinear\n\telse:\n\t\treturn 2 # Clock or counterclock\n\ndef doIntersect(p1, q1, p2, q2):\n\t\n\t# Find the four orientations needed for\n\t# general and special cases\n\to1 = orientation(p1, q1, p2)\n\to2 = orientation(p1, q1, q2)\n\to3 = orientation(p2, q2, p1)\n\to4 = orientation(p2, q2, q1)\n\n\t# General case\n\tif (o1 != o2) and (o3 != o4):\n\t\treturn True\n\t\n\t# Special Cases\n\t# p1, q1 and p2 are collinear and\n\t# p2 lies on segment p1q1\n\tif (o1 == 0) and (onSegment(p1, p2, q1)):\n\t\treturn True\n\n\t# p1, q1 and p2 are collinear and\n\t# q2 lies on segment p1q1\n\tif (o2 == 0) and (onSegment(p1, q2, q1)):\n\t\treturn True\n\n\t# p2, q2 and p1 are collinear and\n\t# p1 lies on segment p2q2\n\tif (o3 == 0) and (onSegment(p2, p1, q2)):\n\t\treturn True\n\n\t# p2, q2 and q1 are collinear and\n\t# q1 lies on segment p2q2\n\tif (o4 == 0) and (onSegment(p2, q1, q2)):\n\t\treturn True\n\n\treturn False\n\n# Returns true if the point p lies\n# inside the polygon[] with n vertices\ndef is_inside_polygon(points:list, p:tuple) -> bool:\n\t\n\tn = len(points)\n\t\n\t# There must be at least 3 vertices\n\t# in polygon\n\tif n < 3:\n\t\treturn False\n\t\t\n\t# Create a point for line segment\n\t# from p to infinite\n\textreme = (INT_MAX, p[1])\n\tcount = i = 0\n\t\n\twhile True:\n\t\tnext = (i + 1) % n\n\t\t\n\t\t# Check if the line segment from 'p' to\n\t\t# 'extreme' intersects with the line\n\t\t# segment from 'polygon[i]' to 'polygon[next]'\n\t\tif (doIntersect(points[i],\n\t\t\t\t\t\tpoints[next],\n\t\t\t\t\t\tp, extreme)):\n\t\t\t\t\t\t\t\n\t\t\t# If the point 'p' is collinear with line\n\t\t\t# segment 'i-next', then check if it lies\n\t\t\t# on segment. If it lies, return true, otherwise false\n\t\t\tif orientation(points[i], p,\n\t\t\t\t\t\tpoints[next]) == 0:\n\t\t\t\treturn onSegment(points[i], p,\n\t\t\t\t\t\t\t\tpoints[next])\n\t\t\t\t\t\t\t\t\n\t\t\tcount += 1\n\t\t\t\n\t\ti = next\n\t\t\n\t\tif (i == 0):\n\t\t\tbreak\n\t\t\n\t# Return true if count is odd, false otherwise\n\treturn (count % 2 == 1)\n\n# Driver code\nif __name__ == '__main__':\n\t\n\tpolygon1 = [ (0, 0), (10, 0), (10, 10), (0, 10) ]\n\t\n\tp = (20, 20)\n\tif (is_inside_polygon(points = polygon1, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tp = (5, 5)\n\tif (is_inside_polygon(points = polygon1, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\n\tpolygon2 = [ (0, 0), (5, 0), (5, 5), (3, 3) ]\n\t\n\tp = (3, 3)\n\tif (is_inside_polygon(points = polygon2, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tp = (5, 1)\n\tif (is_inside_polygon(points = polygon2, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tp = (8, 1)\n\tif (is_inside_polygon(points = polygon2, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n\tpolygon3 = [ (0, 0), (10, 0), (10, 10), (0, 10) ]\n\t\n\tp = (-1, 10)\n\tif (is_inside_polygon(points = polygon3, p = p)):\n\tprint ('Yes')\n\telse:\n\tprint ('No')\n\t\n# This code is contributed by Vikas Chitturi"}
{"nl": "The DECIMATOR", "code": "def DECIMATOR(txt):\n  return txt[:-((len(txt)+9)//10)]"}
{"nl": "Count the occurrences of a word in a text file", "code": "# Take a variable say wordCount that stores the calculate the\n# count of given word in a given file and initialize it to 0.\nwordCount = 0\n# Scan the given word by user input using the int(input()) function and store it in a variable.\ngivenword = input('Enter the given word = ')\n# Enter the file's name into the input() function and save it to a variable.\nfilename = input(\"Enter the file name = \")\n# Open the file with the entered file name in read mode.\nwith open(filename, 'r') as givenfile:\n  # Traverse the lines in the file using a For loop.\n  for fileline in givenfile:\n  # Using the split() method, split the line into words.\n  wordslist = fileline.split()\n  # To traverse the words in the list, use a For loop.\n  for words in wordslist:\n  # If the iterator value is equal to the given word then increase the wordCount by 1.\n  if(words == givenword):\n  wordCount = wordCount+1\n# Print the wordCount.\nprint('The total count of the given word {',\n  givenword, '} in the given file = ', wordCount)"}
{"nl": "Copy contents of one file into another", "code": "# In read mode, open the first file say  samplefile1.txt.\nwith open(\"samplefile1.txt\") as file1:\n  # In write mode, open the second file say  samplefile2.txt.\n    with open(\"samplefile2.txt\", \"w\") as file2:\n      # Using for loop, go over the lines in the first file.\n        for iline in file1:\n          # Copy the ith line of the first file to the second file using the write function.\n            file2.write(iline)"}
{"nl": "Copy odd lines of text file to another file", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nreading_file = open(givenFilename, \"r\") \n# Make another variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"oddlinesfile.txt\"\n# Open another file in write mode. In this case, we're writing the contents into the file.\nwriting_file = open(givenFilename, \"w\") \n# Get the lines of the reading file using the readlines() function and store it in a variable\nfilelines = reading_file.readlines() \n# Iterate in the length of the file lines using the for loop\nfor line_indx in range(0, len(filelines)): \n  # Check if the index of the file lines is odd using the if conditional statement\n  if(line_indx % 2 != 0): \n  # If it is true, then write the file line using the write() function into the \n  # writing file\n  writing_file.write(filelines[line_indx]) \n# Close the writing file using the close() function\nwriting_file.close()\n# Close the reading file using the close() function\nreading_file.close()"}
{"nl": "Python Program to Check if two Lines are Parallel or Not", "code": "#Create a function checkParallel() which accepts the 6 parameters\n#(First and second line x,y,z coordinates)\n#We can Check if the slopes of the given two lines are equal by formula (a1/b1 == a2/b2).\ndef checkParallel(a1,b1,c1,a2,b2,c2):\n    #Inside the checkParallel() function.\n    #Check if both lines y coordinates are not equal to 0 \n    #using the If conditional Statement.\n    if(b1!=0 and b2!=0):\n        #If it is true then check a1/b1 is equal to a2/b2 \n        #using another Nested If conditional Statement.\n        if(a1/b1==a2/b2):\n            #If it is true then return True\n            return True\n        else:\n            #Else return False.\n            return False\n    #If parent If conditional statement is false then inside the else statement \n    \n    else:\n      #check if first line and second line x and y coordinates are equal\n      #or not using the nested If conditional statement.\n      if(a1==a2 and b1==b2):\n          #If it is true then return True else return False.\n          return True\n      else:\n          return False\n#Give the values of a1,b1,c1 as user input using map(),int(),split() functions \n#and store it in three separate variables.\na1,b1,c1=map(int,input('Enter some random x y z coordinates separated by spaces = ').split())                    \n#Give the values of a2,b2,c2 as user input using map(),int(),split() functions \n#and store it in three separate variables.\na2,b2,c2=map(int,input('Enter some random x y z coordinates separated by spaces = ').split())\n#Pass the a1,b1,c1,a2,b2,c2 as the arguments to checkParallel() function\n#inside the if Conditional statement.\nif(checkParallel(a1,b1,c1,a2,b2,c2)):\n  #If it is true then print those lines are parallel.\n  print('The given lines are parallel to each other')\nelse:\n  #Else they are not parallel.\n  print('The given lines are not parallel to each other')"}
{"nl": "Print K\u2019th element in spiral form of matrix", "code": "R = 3\nC = 6\n\u00a0\ndef spiralPrint(m, n, a, c):\n\u00a0\u00a0\u00a0\u00a0k = 0\n\u00a0\u00a0\u00a0\u00a0l = 0\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0\"\"\" k - starting row index\n\u00a0\u00a0\u00a0\u00a0m - ending row index\n\u00a0\u00a0\u00a0\u00a0l - starting column index\n\u00a0\u00a0\u00a0\u00a0n - ending column index\n\u00a0\u00a0\u00a0\u00a0i - iterator\n\u00a0\u00a0\u00a0\u00a0\"\"\"\n\u00a0\u00a0\u00a0\u00a0while (k < m and l < n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(l,n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[k][i] , end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\"\" check the last column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0from the remaining columns \"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(k,m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[i][n - 1],end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n-=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\"\" check the last row from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the remaining rows \"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k < m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(n - 1,l-1,-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[m - 1][i],end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m-=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\"\" check the first column from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the remaining columns \"\"\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (l < n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(m - 1,k-1,-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count+=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count == c):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(a[i][l],end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0l+=1\n\u00a0\n\"\"\" Driver program to test above functions \"\"\"\n\u00a0\na = [[1, 2, 3, 4, 5, 6 ],[ 7, 8, 9, 10, 11, 12 ],[ 13, 14, 15, 16, 17, 18]]\nk = 17\nspiralPrint(R, C, a, k)\n\u00a0\n# This code is contributed by shivanisingh\n"}
{"nl": "Return the minimum time to remove all the cars containing illegal goods", "code": "class Solution:\n    def minimumTime(self, s: str) -> int:\n        s = [int(c) for c in s]\n        for i in range(1, len(s)):\n            s[i] += s[i-1]\n        s = [2*x - i - 1 for i, x in enumerate(s)]\n        \n        curMax = ret = 0\n        for i, x in enumerate(s):\n            ret = min(ret, x - curMax)\n            curMax = max(x, curMax)\n        \n        return ret + len(s)\n"}
{"nl": "Solve Rod Cutting Problem using Dynamic Programming with Bottom-Up Approach", "code": "def cut_rod(p, n):\n    \"\"\"Take a list p of prices and the rod length n and return lists r and s.\n    r[i] is the maximum revenue that you can get and s[i] is the length of the\n    first piece to cut from a rod of length i.\"\"\"\n    # r[i] is the maximum revenue for rod length i\n    # r[i] = -1 means that r[i] has not been calculated yet\n    r = [-1]*(n + 1)\n    r[0] = 0\n\u00a0\n    # s[i] is the length of the initial cut needed for rod length i\n    # s[0] is not needed\n    s = [-1]*(n + 1)\n\u00a0\n    for i in range(1, n + 1):\n        q = -1\n        for j in range(1, i + 1):\n            temp = p[j] + r[i - j]\n            if q < temp:\n                q = temp\n                s[i] = j\n        r[i] = q\n\u00a0\n    return r, s\n\u00a0\n\u00a0\nn = int(input('Enter the length of the rod in inches: '))\n\u00a0\n# p[i] is the price of a rod of length i\n# p[0] is not needed, so it is set to None\np = [None]\nfor i in range(1, n + 1):\n    price = input('Enter the price of a rod of length {} in: '.format(i))\n    p.append(int(price))\n\u00a0\nr, s = cut_rod(p, n)\nprint('The maximum revenue that can be obtained:', r[n])\nprint('The rod needs to be cut into length(s) of ', end='')\nwhile n > 0:\n    print(s[n], end=' ')\n    n -= s[n]"}
{"nl": "Print nodes that are at 'K' distance from the root", "code": "# Python program to find the nodes at k distance from root\n\n# A Binary tree node\nclass Node:\n\t\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\ndef printKDistant(root, k):\n\t\n\tif root is None:\n\t\treturn\n\tif k == 0:\n\t\tprint (root.data,end=' ')\n\telse:\n\t\tprintKDistant(root.left, k-1)\n\t\tprintKDistant(root.right, k-1)\n\n# Driver program to test above function\n\"\"\"\nConstructed binary tree is\n\t\t\t1\n\t\t/ \\\n\t\t2\t 3\n\t/ \\ /\n\t4\t 5 8\n\"\"\"\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(8)\n\nprintKDistant(root, 2)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Check if the given two lines are parallel", "code": "#Create a function checkParallel() which accepts the 6 parameters\n #(First and second line x,y,z coordinates)\n #We can Check if the slopes of the given two lines are equal by formula (a1/b1 == a2/b2).\n def checkParallel(a1,b1,c1,a2,b2,c2):\n  #Inside the checkParallel() function.\n  #Check if both lines y coordinates are not equal to 0 \n  #using the If conditional Statement.\n  if(b1!=0 and b2!=0):\n  #If it is true then check a1/b1 is equal to a2/b2 \n  #using another Nested If conditional Statement.\n  if(a1/b1==a2/b2):\n  #If it is true then return True\n  return True\n  else:\n  #Else return False.\n  return False\n  #If parent If conditional statement is false then inside the else statement \n  else:\n  #check if first line and second line x and y coordinates are equal\n  #or not using the nested If conditional statement.\n  if(a1==a2 and b1==b2):\n  #If it is true then return True else return False.\n  return True\n  else:\n  return False\n #Give the values of a1,b1,c1 as static input \n #and store it in three separate variables.\n a1,b1,c1=4,8,13\n #Give the values of a2,b2,c2 as static input \n #and store it in three separate variables.\n a2,b2,c2=2,4,7\n #Pass the a1,b1,c1,a2,b2,c2 as the arguments to checkParallel() function\n #inside the if Conditional statement.\n if(checkParallel(a1,b1,c1,a2,b2,c2)):\n  #If it is true then print those lines are parallel.\n  print('The given lines are parallel to each other')\n else:\n  #Else they are not parallel.\n  print('The given lines are not parallel to each other')"}
{"nl": "Find the sum of the elements of the upper triangular matrix, given a matrix.", "code": "# Give the matrix as static input and store it in a variable.\r\nmtrx = [[6, 2, 1], [1, 5, 0], [2, 8, 3]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\nprint(\"The sum of Upper Triangular matrix of the given matrix is :\")\r\n# Take a variable say uppr_sum and initialize its value to 0.\r\nuppr_sum = 0\r\n# To print all the elements of the given matrix.\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n      # Check if the condition n is greater than m using the if conditional statement where n\r\n      # is the iterator value of the parent For loop and m is the iterator value of the\r\n      # inner For loop.\r\n        if n > m:\r\n          # If the statement is true, add the gvnmatrix[n][m] to the above-initialized\r\n          # uppr_sum and store it in the same variable uppr_sum.\r\n            uppr_sum += mtrx[n][m]\r\n# Print the variable uppr_sum to get the sum of an upper triangular matrix of the\r\n# given matrix.\r\nprint(uppr_sum)"}
{"nl": "Exercise working with string manipulation and conditional code to implement a Extract-Transform-Load process's Transform step, given an old format of stored information of the Scrabble game, transform it to a new format which only stores scores per letter", "code": "def transform(in_dict: {}) -> {}:\r\n    return {m.lower(): n for n in in_dict for m in in_dict[n]}"}
{"nl": "Sort a List of String Tuples using sorted()", "code": "def lastEle(ele):\r\n  # returning the last element\r\n    return ele[-1]\r\n\r\n\r\ndef sortlastElementTuple(listTuple):\r\n  # using sorted function with first parameter as given list of tuples and\r\n  # key as last element\r\n  # To get last element we create a function which returns the last element\r\n  # returning the sorted list of tuples\r\n    return sorted(listTuple, key=lastEle)\r\n\r\n\r\nlistofTuples = [('hello', 'this'), ('BTechGeeks', 'online',\r\n                                    'platform'), ('for', 'students')]\r\n# printing the sorted list of tuples by last element\r\nprint(\"Printing the sorted list of tuples : \")\r\n# Passing the given list of tuples to sortlastElementTuple function\r\nprint(sortlastElementTuple(listofTuples))"}
{"nl": "You FAILEDPASSED the Exam", "code": "def grade_percentage(user_score, pass_score):\n  return 'You {} the Exam'.format('PASSED' if user_score >= pass_score else 'FAILED')"}
{"nl": "Exercise to implement a binary search algorithm.", "code": "def find(search_list, value):\r\n    if value in search_list:\r\n        return search_list.index(value)\r\n    else:\r\n        raise ValueError(\"value not in array\")"}
{"nl": "minimum path sum from top to bottom for a triangle array", "code": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        for row in range(1, len(triangle)):\n            for col in range(row + 1):\n                smallest_above = math.inf\n                if col > 0:\n                    smallest_above = triangle[row - 1][col - 1]\n                if col < row:\n                    smallest_above = min(smallest_above, triangle[row - 1][col])\n                triangle[row][col] += smallest_above\n        return min(triangle[-1])"}
{"nl": "The Alternating Numbers", "code": "def is_alternating(num):\n  s = str(num)\n  return num>0 and all((int(a)+int(b))%2 for a,b in zip(s,s[1:]))"}
{"nl": "Check if Array can be Sorted with One Swap", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n#Store it in a variable.\r\ngven_lst = list(map(int, input(\r\n   'Enter some random List Elements separated by spaces = ').split()))\r\n# Copy the given list in a variable say \"new_lst\" using the copy() function.\r\nnew_lst = gven_lst.copy()\r\n# Take a variable say 'c' and initialize its value with 0.\r\nc = 0\r\n# Sort the above obtained \"new_lst\".\r\nnew_lst.sort()\r\n# Loop until the length of the \"new_lst\" using the for loop.\r\nfor i in range(len(new_lst)):\r\n # Check if the given list element is not equal to the new_lst element using the\r\n    # if conditional statement.\r\n    if(gven_lst[i] != new_lst[i]):\r\n     # If the statement is true then increment the count value of 'c' by 1 and\r\n        # store it in the same variable 'c'.\r\n        c += 1\r\n# Check if the value of 'c' is equal to 0 or true using the if conditional statement\r\n# and 'or ' keyword.\r\nif(c == 0 or c == 2):\r\n  # If the statement is true, print \"The given list can be sorted with a single swap\".\r\n    print(\"The given list\", gven_lst, \"can be sorted with a single swap\")\r\n # If it is false, then print \"The given list cannot be sorted with a single swap\".\r\nelse:\r\n    print(\"The given list\", gven_lst, \"cannot be sorted with a single swap\")"}
{"nl": "Create a child class Bus that inherits from Vehicle class", "code": "class Vehicle:\r\n\r\n    def __init__(self, name, max_speed, mileage):\r\n        self.name = name\r\n        self.max_speed = max_speed\r\n        self.mileage = mileage\r\n\r\nclass Bus(Vehicle):\r\n    pass\r\n\r\nSchool_bus = Bus(\"School Volvo\", 180, 12)\r\nprint(\"Vehicle Name:\", School_bus.name, \"Speed:\", School_bus.max_speed, \"Mileage:\", School_bus.mileage)"}
{"nl": "Can You Make the Numbers?", "code": "def can_build(digits, lst):\n  nums = ''.join(str(i) for i in lst)\n  return all(nums.count(j)<= digits[int(j)] for j in set(nums))"}
{"nl": "The maximum score that a player can obtain", "code": "def stoneGameV(self, A):\n  n = len(A)\n  prefix = [0] * (n + 1)\n  for i, a in enumerate(A):\n  prefix[i + 1] = prefix[i] + A[i]\n\n  @functools.lru_cache(None)\n  def dp(i, j):\n  if i == j: return 0\n  res = 0\n  for m in range(i, j):\n  left = prefix[m + 1] - prefix[i]\n  right = prefix[j + 1] - prefix[m + 1]\n  if left <= right:\n  res = max(res, dp(i, m) + left)\n  if left >= right:\n  res = max(res, dp(m + 1, j) + right)\n  return res\n  return dp(0, n - 1)"}
{"nl": "Find Sum of all unique sub-array sum for a given array.\r\n", "code": "\r\n# Python3 for finding sum of all\r\n# unique subarray sum\r\n \r\n# function for finding grandSum\r\ndef findSubarraySum(arr, n):\r\n \r\n    res = 0\r\n \r\n    # Go through all subarrays, compute sums\r\n    # and count occurrences of sums.\r\n    m = dict()\r\n    for i in range(n):\r\n        Sum = 0\r\n        for j in range(i, n):\r\n            Sum += arr[j]\r\n            m[Sum] = m.get(Sum, 0) + 1\r\n         \r\n    # Print all those Sums that appear\r\n    # once.\r\n    for x in m:\r\n        if m[x] == 1:\r\n            res += x\r\n \r\n    return res\r\n \r\n# Driver code\r\narr = [3, 2, 3, 1, 4]\r\nn = len(arr)\r\nprint(findSubarraySum(arr, n))\r\n \r\n# This code is contributed by mohit kumar"}
{"nl": "Python math.log10() Method", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the base-10 logarithm of different numbers\r\nprint(math.log10(2.7183))\r\nprint(math.log10(2))\r\nprint(math.log10(1))"}
{"nl": "Find k-th smallest element in BST", "code": "# A simple inorder traversal based Python3\r\n# program to find k-th smallest element in a BST.\r\n \r\n# A BST node\r\nclass newNode:\r\n     \r\n    def __init__(self, x):\r\n         \r\n        self.data = x\r\n        self.left = None\r\n        self.right = None\r\n        self.lCount = 0\r\n \r\n# Recursive function to insert\r\n# an key into BST\r\ndef insert(root, x):\r\n     \r\n    if (root == None):\r\n        return newNode(x)\r\n \r\n    # If a node is inserted in left subtree,\r\n    # then lCount of this node is increased.\r\n    # For simplicity, we are assuming that\r\n    # all keys (tried to be inserted) are\r\n    # distinct.\r\n    if (x < root.data):\r\n        root.left = insert(root.left, x)\r\n        root.lCount += 1\r\n \r\n    elif (x > root.data):\r\n        root.right = insert(root.right, x);\r\n         \r\n    return root\r\n \r\n# Function to find k'th largest element\r\n# in BST. Here count denotes the number\r\n# of nodes processed so far\r\ndef kthSmallest(root, k):\r\n     \r\n    # Base case\r\n    if (root == None):\r\n        return None\r\n         \r\n    count = root.lCount + 1\r\n     \r\n    if (count == k):\r\n        return root\r\n \r\n    if (count > k):\r\n        return kthSmallest(root.left, k)\r\n \r\n    # Else search in right subtree\r\n    return kthSmallest(root.right, k - count)\r\n \r\n# Driver code\r\nif __name__ == '__main__':\r\n     \r\n    root = None\r\n    keys = [ 20, 8, 22, 4, 12, 10, 14 ]\r\n \r\n    for x in keys:\r\n        root = insert(root, x)\r\n \r\n    k = 4\r\n    res = kthSmallest(root, k)\r\n     \r\n    if (res == None):\r\n        print(\"There are less than k nodes in the BST\")\r\n    else:\r\n        print(\"K-th Smallest Element is\", res.data)\r\n         \r\n# This code is contributed by bgangwar59"}
{"nl": "Check if each internal node of a BST has exactly one child", "code": "# Check if each internal\n# node of BST has only one child\n\u00a0\ndef hasOnlyOneChild (pre, size):\n\u00a0\u00a0\u00a0\u00a0nextDiff=0; lastDiff=0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(size-1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nextDiff = pre[i] - pre[i+1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastDiff = pre[i] - pre[size-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if nextDiff*lastDiff < 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\n# driver program to\n# test above function\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0pre = [8, 3, 5, 7, 6]\n\u00a0\u00a0\u00a0\u00a0size= len(pre)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (hasOnlyOneChild(pre,size) == True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\n# This code is contributed by\n# Harshit Saini\n"}
{"nl": "Turn off the rightmost set bit", "code": "# unsets the rightmost set bit\n# of n and returns the result\ndef fun(n):\n\n\treturn n & (n-1)\n\n# Driver code\n\nn = 7\nprint(\"The number after unsetting the rightmost set bit\", fun(n))\n\n# This code is contributed\n# by Anant Agarwal.\n"}
{"nl": "Shuffle the Name", "code": "def nameShuffle(str):\n  return ' '.join(reversed(str.split(' ')))"}
{"nl": "Queue Introduction and Array Implementation", "code": "# Python3 program for array implementation of queue\n\u00a0\n# Class Queue to represent a queue\nclass Queue:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# __init__ function\n\u00a0\u00a0\u00a0\u00a0def __init__(self, capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = self.size = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = capacity -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.Q = [None]*capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.capacity = capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Queue is full when size becomes\n\u00a0\u00a0\u00a0\u00a0# equal to the capacity\n\u00a0\u00a0\u00a0\u00a0def isFull(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.size == self.capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Queue is empty when size is 0\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.size == 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to add an item to the queue.\n\u00a0\u00a0\u00a0\u00a0# It changes rear and size\n\u00a0\u00a0\u00a0\u00a0def EnQueue(self, item):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isFull():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Full\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = (self.rear + 1) % (self.capacity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.Q[self.rear] = item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size = self.size + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"% s enqueued to queue\"\u00a0 % str(item))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to remove an item from queue.\n\u00a0\u00a0\u00a0\u00a0# It changes front and size\n\u00a0\u00a0\u00a0\u00a0def DeQueue(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Empty\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"% s dequeued from queue\" % str(self.Q[self.front]))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = (self.front + 1) % (self.capacity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.size = self.size -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to get front of queue\n\u00a0\u00a0\u00a0\u00a0def que_front(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue is empty\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Front item is\", self.Q[self.front])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to get rear of queue\n\u00a0\u00a0\u00a0\u00a0def que_rear(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue is empty\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Rear item is\",\u00a0 self.Q[self.rear])\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0queue = Queue(30)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(10)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(20)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(30)\n\u00a0\u00a0\u00a0\u00a0queue.EnQueue(40)\n\u00a0\u00a0\u00a0\u00a0queue.DeQueue()\n\u00a0\u00a0\u00a0\u00a0queue.que_front()\n\u00a0\u00a0\u00a0\u00a0queue.que_rear()\n"}
{"nl": "Find Super Factorial of a Number", "code": "# Import math module using the import keyword.\r\nimport math\r\n# Give the number as User input and store it in a variable.\r\ngvn_numbr = int(input(\"Enter some Random Number =\"))\r\n# Take a variable and initialize it's value with '1'.\r\nsupr_factrl = 1\r\n# Loop from '1 ' to above given number using For loop.\r\nfor iteror in range(gvn_numbr+1):\r\n  # Calculate the factorial of the iterator value using built-in factorial method\r\n  # and multiply it with above initialized superfactorial value.\r\n # Store it in another variable.\r\n    supr_factrl = supr_factrl * math.factorial(iteror)\r\n# Print the superfactorial value of the above given number.\r\nprint(\"The super Factorial value of above given number = \", supr_factrl)"}
{"nl": "Create a Vehicle class without any variables and methods", "code": "class Vehicle:\r\n    pass"}
{"nl": "Print a reverse number pattern pyramid given the number of rows.", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumbrrows = 10\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numbrrows):\r\n    # Loop from the parent loop iterator value to 0 in decreasing order\r\n    # using another For loop(Nested For Loop).\r\n    for n in range(m, 0, -1):\r\n        # Print the iterator value of the inner for loop.\r\n        print(n, end=' ')\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "Python Program to Move all Negative Elements to End in Order with Extra Space Allowed", "code": "# Give the list as static input and store it in a variable.\n gvnlst = [1, 9, -3, 6, 8, 11, 35, -5, -7, 10, -1, -2, -3]\n # Using list comprehension and if conditional statements\n # separate the positive numbers from the list\n # and store it in a variable to say the positive list.\n pstivelist = [elemn for elemn in gvnlst if elemn &gt;= 0]\n # Using list comprehension and if conditional statements\n # separate the negative numbers from the list and store it\n # in a variable to say the negative list.\n ngtivelist = [elemn for elemn in gvnlst if elemn &lt; 0]\n # Add the positive list and negative list using the + operator\n # and store it in another variable to say result list\n # (This operation moves all the negative list).\n resltlist = pstivelist+ngtivelist\n # Print the result list.\n print('The given list after moving negative elements to the end is', resltlist)"}
{"nl": "All x such that given a % x = b", "code": "# Import the math module using the import keyword.\n import math\n # Create a function to say a_mod_xisb which takes the given two numbers as the arguments\n # and returns all the values of x such that given a % x = b.\n def a_mod_xisb(gvn_a_val, gvn_b_val):\n  # Check if the given number a is less than the given b value using the if conditional\n  # statement.\n  if (gvn_a_val < gvn_b_val):\n  # If it is true then print \"There are no solutions possible\".\n  print(\"There are no solutions possible\")\n  # Return.\n  return\n  # Check if the given a value is equal to the given b value using the if conditional\n  # statement.\n  if (gvn_a_val == gvn_b_val):\n  # If it is true then print \"Infinite Solutions are possible for the equation\".\n  # Return.\n  print(\"Infinite Solutions are possible for the equation\")\n  return\n  # Take a variable say cnt and initialize its value to 0.\n  cnt = 0\n  # Subtract the given b value from the given a value and store it in another variable\n  # say rslt.\n  rslt = gvn_a_val - gvn_b_val\n  # Calculate the value of square root of (gvn_a_val - gvn_b_val) using the math.sqrt()\n  # function and convert result to an integer using the int() function.\n  # Store it in another variable say k.\n  k = (int)(math.sqrt(gvn_a_val - gvn_b_val))\n  # Loop from 1 to the above result k using the for loop.\n  for itr in range(1, k+1):\n  # Inside the loop, check if the above value of rslt modulus iterator value is equal\n  # to 0 using the if conditional statement.\n  if (rslt % itr == 0):\n  # Again check if the rslt divided by the iterator value greater than the given b value\n  # using the if conditional statement.\n  if (rslt / itr > gvn_b_val):\n  # If it is true, increment the count value by 1 and store it in the same variable.\n  cnt = cnt + 1\n  # Check if the iterator value is greater than the given b value using the if\n  # conditional statement.\n  if (itr > gvn_b_val):\n  # If it is true, increment the count value by 1 and store it in the same variable.\n  cnt = cnt + 1\n  # Check if the k multiplied with itself is equal to the rslt and k greater than the\n  # given b value using the if conditional statement.\n  if (k * k == rslt and k > gvn_b_val):\n  # If it is true, decrement the count value by 1 and store it in the same variable.\n  cnt = cnt - 1\n  # Print the value of x such that given a%x==b.\n  print(\n  \"The value of x such that given a%x==b {a,b =\", gvn_a_val, gvn_b_val, \"} = \", cnt)\n # Give the number as static input and store it in a variable.\n gvn_a_val = 15\n # Give the other number as static input and store it in another variable.\n gvn_b_val = 2\n # Pass the given number two numbers as the arguments to the a_mod_xisb function.\n a_mod_xisb(gvn_a_val, gvn_b_val)"}
{"nl": "Highest Index (With a Twist)", "code": "alphabet='abcdefghijklmnopqrstuvwxyz'\nalphabet_index=lambda a,s:'%s%s'%next((a.find(x)+1,x)for x in a[::-1]if x in s.lower())"}
{"nl": "implement prefix tree", "code": "class TrieNode:\n# Initialize your data structure here.\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n\nclass Trie:\n\ndef __init__(self):\n    self.root = TrieNode()\n\ndef insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True\n\ndef search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word\n\ndef startsWith(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True"}
{"nl": "Letters Formed from the Longest Word", "code": "def can_form(lst):\n  longest = max(lst, key=len)\n  return all(longest.count(i) >= word.count(i) for word in lst for i in set(word))"}
{"nl": "The minimum operations needed make s alternating", "code": "def minOperations(self, s):\n  res = sum(i % 2 == int(c) for i, c in enumerate(s))\n  return min(res, len(s) - res)"}
{"nl": "K\u2019th Smallest/Largest Element in Unsorted Array ", "code": "# Python3 program to find k'th smallest\n# element\n\n# Function to return k'th smallest\n# element in a given array\ndef kthSmallest(arr, n, k):\n\n        # Sort the given array\n        arr.sort()\n\n        # Return k'th element in the\n        # sorted array\n        return arr[k-1]\n\n# Driver code\nif __name__=='__main__':\n        arr = [12, 3, 5, 7, 19]\n        n = len(arr)\n        k = 2\n        print(\"K'th smallest element is\",\n                kthSmallest(arr, n, k))\n\n# This code is contributed by\n# Shrikant13"}
{"nl": "Product of All Odd Integers", "code": "import numpy\ndef odd_product(lst):\n    return numpy.prod([i for i in lst if i % 2 != 0])"}
{"nl": "What's Hiding Amongst the Crowd?", "code": "def detect_word(txt):\n  return \"\".join(c for c in txt if c.islower())"}
{"nl": "Find LCA in Binary Tree using RMQ", "code": "# Python3 program to find LCA of u and v by\n# reducing the problem to RMQ\nfrom math import log2, floor\nfrom typing import List\n\u00a0\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, val: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.val, self.left, self.right = val, None, None\n\u00a0\nclass BinaryTree:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, root: Node):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.root = root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.val_max = self._get_max_val()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler = [0] * (2 * self.val_max - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level = [0] * (2 * self.val_max - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.f_occur = [-1] * (self.val_max + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def _get_max_val(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack = [self.root]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_val = -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while stack:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x = stack.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if x.val > max_val:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_val = x.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if x.left:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(x.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if x.right:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.append(x.right)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return max_val\n\u00a0\u00a0\u00a0\u00a0''' A recursive function to get the minimum value in a given range\n\u00a0\u00a0\u00a0\u00a0\u00a0of array indexes. The following are parameters for this function.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0st\u00a0\u00a0\u00a0 --> Pointer to segment tree\n\u00a0\u00a0\u00a0\u00a0index --> Index of current node in the segment tree. Initially\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 is passed as root is always at index 0\n\u00a0\u00a0\u00a0\u00a0ss & se\u00a0 --> Starting and ending indexes of the segment represented\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0by current node, i.e., st[index]\n\u00a0\u00a0\u00a0\u00a0qs & qe\u00a0 --> Starting and ending indexes of query range '''\n\u00a0\u00a0\u00a0\u00a0def rmq_util(self, index, ss, se, qs, qe) -> int:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If segment of this node is part of given range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then return the min of the segment\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if qs <= ss and qe >= se:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.segment_tree[index]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If segment of this node is outside\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the given range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif se < qs or ss > qe:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If part of this segment overlaps with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# given range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mid = (ss + se) // 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1 = self.rmq_util(2 * index + 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ss, mid, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q2 = self.rmq_util(2 * index + 2, mid + 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0se, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if q1 == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return q2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if q2 == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return q1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (q1 if self.level[q1] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[q2] else q2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return minimum of elements in range from\n\u00a0\u00a0\u00a0\u00a0# index qs (query start) to\u00a0 qe (query end).\u00a0\n\u00a0\u00a0\u00a0\u00a0# It mainly uses rmq_util()\n\u00a0\u00a0\u00a0\u00a0def rmq(self, n: int, qs: int, qe: int) -> int:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if qs < 0 or qe > n - 1 or qs > qe:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print('invalid input')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.rmq_util(0, 0, n - 1, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# A recursive function that constructs Segment\n\u00a0\u00a0\u00a0\u00a0# Tree for array[ss..se]. si is index of\n\u00a0\u00a0\u00a0\u00a0# current node in segment tree st\n\u00a0\u00a0\u00a0\u00a0def construct_segment_tree_util(self, si, ss,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0se, arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If\u00a0 there is one element in array,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# store it in current node of segment tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ss == se:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree[si] = ss\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If there are more than one elements,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then recur for left and right subtrees and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# store the min of two values in this node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mid = (ss + se) // 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index_left, index_right = si * 2 + 1, si * 2 + 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree_util(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index_left, ss, mid, arr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree_util(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index_right, mid+1, se, arr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[self.segment_tree[index_left]] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[self.segment_tree[index_right]]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree[si] = self.segment_tree[index_left]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree[si] = self.segment_tree[index_right]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to construct segment tree from given\n\u00a0\u00a0\u00a0\u00a0# array. This function allocates memory for segment\n\u00a0\u00a0\u00a0\u00a0# tree and calls construct_segment_tree_util()\n\u00a0\u00a0\u00a0\u00a0# to fill the allocated memory\n\u00a0\u00a0\u00a0\u00a0def construct_segment_tree(self, arr: List, n: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Height of segment tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x = floor(log2(n) + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Maximum size of segment tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max_size = 2 * (1 << x) - 1\u00a0\u00a0\u00a0\u00a0\u00a0 # 2*pow(2,x) -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.segment_tree = [0] * max_size\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Fill the allocated memory st\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree_util(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00, 0, n - 1, arr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recursive version of the Euler tour of T\n\u00a0\u00a0\u00a0\u00a0def euler_tour(self, node: Node, lev: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the passed node exists\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if node is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler[self.fill] = node.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[self.fill] = lev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If unvisited, mark first occurence\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.f_occur[node.val] == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.f_occur[node.val] = self.fill - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Tour left subtree if exists and remark\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# euler and level arrays for parent on\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if node.left is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler_tour(node.left, lev + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler[self.fill] = node.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[self.fill] = lev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Tour right subtree if exists and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# remark euler and level arrays for\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# parent on return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if node.right is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler_tour(node.right, lev + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler[self.fill] = node.val\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level[self.fill] = lev\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.fill += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns LCA of nodes n1, n2 (assuming they are\n\u00a0\u00a0\u00a0\u00a0# present in the tree)\n\u00a0\u00a0\u00a0\u00a0def find_lca(self, u: int, v: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Start euler tour with root node on level 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.euler_tour(self.root, 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Construct segment tree on level array\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.construct_segment_tree(self.level,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 * self.val_max - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# For rmq to work, u must be smaller than v\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.f_occur[u] > self.f_occur[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u, v = v, u\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Start and end of query range\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qs = self.f_occur[u]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qe = self.f_occur[v]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Query for index of lca in tour\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index = self.rmq(2 * self.val_max - 1, qs, qe)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Return lca node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.euler[index]\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = Node(1)\n\u00a0\u00a0\u00a0\u00a0root.left = Node(2)\n\u00a0\u00a0\u00a0\u00a0root.right = Node(3)\n\u00a0\u00a0\u00a0\u00a0root.left.left = Node(4)\n\u00a0\u00a0\u00a0\u00a0root.left.right = Node(5)\n\u00a0\u00a0\u00a0\u00a0root.right.left = Node(6)\n\u00a0\u00a0\u00a0\u00a0root.right.right = Node(7)\n\u00a0\u00a0\u00a0\u00a0root.left.right.left = Node(8)\n\u00a0\u00a0\u00a0\u00a0root.left.right.right = Node(9)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0tree = BinaryTree(root)\n\u00a0\u00a0\u00a0\u00a0u, v = 4, 9\n\u00a0\u00a0\u00a0\u00a0print('The lca of node {} and {} is node {}'.format(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u, v, tree.find_lca(u, v)))\n\u00a0\n# This code is contributed by Rajat Srivastava\n"}
{"nl": "Python Program to Find Volume and Surface Area of a Cone", "code": "# Import math module using the import keyword.\nimport math\n# Give the radius of a cone user input using the float(input()) function and store it in a variable.\ngvn_rad = float(input(\"Enter some random number = \"))\n# Give the height of a cone user input using the float(input()) function and store it in another variable.\ngvn_heigt = float(input(\"Enter some random number = \"))\n# Calculate the Slant height of a given cone using the above given mathematical formula\n# and math.sqrt() function and store it in another variable.\nslant_l = math.sqrt(gvn_rad * gvn_rad + gvn_heigt * gvn_heigt)\n# Calculate the surface area of a given cone using the above given mathematical formula and math.pi function\n# Store it in another variable.\nsurf_area = math.pi * gvn_rad * (gvn_rad + slant_l)\n# Calculate the volume of a given cone using the above given mathematical formula and\n# math.pi function\n# Store it in another variable.\nVol = (1.0/3) * math.pi * gvn_rad * gvn_rad * gvn_heigt\n# Calculate the lateral surface area of a given cone using the above given mathematical\n# formula and math.pi function.\n# Store it in another variable.\nLaterl_surfcarea = math.pi * gvn_rad * slant_l\n# Print the slant height of a given cone.\nprint(\"The given cone's slant height = %.3f\" % slant_l)\n# Print the surface area of a given cone.\nprint(\n    \"The given surface Area of a cone with given radius,height[\", gvn_rad, gvn_heigt, \"]= %.3f\" % surf_area)\n# Print the volume of a given cone.\nprint(\n    \"The given volume of a cone with given radius,height[\", gvn_rad, gvn_heigt, \"]= %.3f\" % Vol)\n# Print the lateral surface area of a given cone.\nprint(\n    \"The given lateral surface Area of a cone with given radius,height[\", gvn_rad, gvn_heigt, \"]= %.3f \" % Laterl_surfcarea)"}
{"nl": "The strongest k values in the array", "code": "class Solution:\n  def getStrongest(self, arr: List[int], k: int) -> List[int]:\n  arr.sort()\n  i, j = 0, len(arr) - 1\n  median = arr[(len(arr) - 1) // 2]\n  while len(arr) + i - j <= k:\n  if median - arr[i] > arr[j] - median:\n  i = i + 1\n  else:\n  j = j - 1\n  return arr[:i] + arr[j + 1:]"}
{"nl": "Neighboring Letters", "code": "def neighboring(txt):\n  return all(abs(ord(a)-ord(b)) == 1 for a, b in zip(txt, txt[1:]))"}
{"nl": "Print all paths from a given source to a destination", "code": "# Python program to print all paths from a source to destination.\n\u00a0\u00a0\nfrom collections import defaultdict\n\u00a0\u00a0\n# This class represents a directed graph\n# using adjacency list representation\nclass Graph:\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, vertices):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# No. of vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# default dictionary to store graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# function to add an edge to graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self, u, v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[u].append(v)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0'''A recursive function to print all paths from 'u' to 'd'.\n\u00a0\u00a0\u00a0\u00a0visited[] keeps track of vertices in current path.\n\u00a0\u00a0\u00a0\u00a0path[] stores actual vertices and path_index is current\n\u00a0\u00a0\u00a0\u00a0index in path[]'''\n\u00a0\u00a0\u00a0\u00a0def printAllPathsUtil(self, u, d, visited, path):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark the current node as visited and store in path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[u]= True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append(u)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current vertex is same as destination, then print\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# current path[]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if u == d:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current vertex is not destination\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Recur for all the vertices adjacent to this vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in self.graph[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[i]== False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.printAllPathsUtil(i, d, visited, path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove current vertex from path[] and mark it as unvisited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[u]= False\n\u00a0\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Prints all paths from 's' to 'd'\n\u00a0\u00a0\u00a0\u00a0def printAllPaths(self, s, d):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark all the vertices as not visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited =[False]*(self.V)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create an array to store paths\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Call the recursive helper function to print all paths\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.printAllPathsUtil(s, d, visited, path)\n\u00a0\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\n# Create a graph given in the above diagram\ng = Graph(4)\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(0, 3)\ng.addEdge(2, 0)\ng.addEdge(2, 1)\ng.addEdge(1, 3)\n\u00a0\u00a0\ns = 2 ; d = 3\nprint (\"Following are all different paths from % d to % d :\" %(s, d))\ng.printAllPaths(s, d)\n# This code is contributed by Neelam Yadav\n"}
{"nl": "Python Program to Remove String Elements that Appear Strictly Less than k Times", "code": "# Take a dictionary and initialize it to empty\n \n # using the {} or dict() say freqncyDictionary.\n \n freqncyDictionary = {}\n \n # Give the string as static input and store it in a variable\n \n gvnstrng = \"hellobtechgeekssss\"\n \n # Loop in the given string using the For loop.\n \n for i in gvnstrng:\n \n  # Inside the For loop,\n \n  # Check if the string character is present in the dictionary\n \n  # or not using the if conditional statement and 'in' keyword.\n \n  if i in freqncyDictionary.keys():\n \n  # If it is true then increment the count of the string character\n \n  # in the dictionary by 1.\n \n  freqncyDictionary[i] = freqncyDictionary[i]+1\n \n  # Else initialize the dictionary with the string character as key and value as 1.\n \n  else:\n \n  freqncyDictionary[i] = 1\n \n # Give the k value as static input and store it in a variable.\n \n k = 2\n \n # Take a string which stores all the characters which are not occuring even number\n \n # of times and initialize it to null string using \"\" or str()\n \n modifd_string = \"\"\n \n # loop in the given string using the for loop\n \n for charac in gvnstrng:\n \n \n \n  # check if the character has frequency greater than or equal to k by checking value of that character in frequency dictionary\n \n  # we check using the if conditional statement\n \n  if(freqncyDictionary[charac] >= k):\n \n  # if it is true then concatenate this character to modifd_string using string concatenation\n \n  modifd_string = modifd_string+charac\n \n \n \n # print the modifd_string string\n \n print('The given string {', gvnstrng,\n \n  '} after removal of all characters that appears more than k{', k, '} times :', modifd_string)"}
{"nl": "Form minimum number from given sequence", "code": "# Python3 program to print minimum number that\n# can be formed from a given sequence of Is and Ds\n\u00a0\n# Prints the minimum number that can be formed from\n# input sequence of I's and D's\ndef PrintMinNumberForPattern(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize current_max (to make sure that\n\u00a0\u00a0\u00a0\u00a0# we don't use repeated character\n\u00a0\u00a0\u00a0\u00a0curr_max = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize last_entry (Keeps track for\n\u00a0\u00a0\u00a0\u00a0# last printed digit)\n\u00a0\u00a0\u00a0\u00a0last_entry = 0\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Iterate over input array\n\u00a0\u00a0\u00a0\u00a0while i < len(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Initialize 'noOfNextD' to get count of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next D's available\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0noOfNextD = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr[i] == \"I\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If letter is 'I'\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate number of next consecutive D's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# available\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while j < len(arr) and arr[j] == \"D\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0noOfNextD += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr_max = noOfNextD + 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If 'I' is first letter, print incremented\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# sequence from 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry, end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", curr_max, end = \"\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Set max digit reached\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry = curr_max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If not first letter\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get next digit to print\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr_max += noOfNextD + 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print digit for I\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry = curr_max\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry, end = \"\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# For all next consecutive 'D' print\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# decremented sequence\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(noOfNextD):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry, end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If letter is 'D'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif arr[i] == \"D\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If 'D' is first letter in sequence\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Find number of Next D's available\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while j < len(arr) and arr[j] == \"D\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0noOfNextD += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Calculate first digit to print based on\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# number of consecutive D's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0curr_max = noOfNextD + 2\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print twice for the first time\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", curr_max, curr_max - 1, end = \"\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Store last entry\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry = curr_max - 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If current 'D' is not first letter\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Decrement last_entry\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"\", last_entry - 1, end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0last_entry -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"IDID\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"I\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"DD\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"II\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"DIDI\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"IIDDD\")\n\u00a0\u00a0\u00a0\u00a0PrintMinNumberForPattern(\"DDIDDIID\")\n\u00a0\n# This code is contributed by\n# sanjeev2552\n"}
{"nl": "Python Program to Find the Gravitational Force Acting Between Two Objects", "code": "# scanning  first mass as float\nmass1 = float(input(\"Enter the first mass of the object =\"))\n# given second mass as float\nmass2 = float(input(\"Enter the second mass of the object =\"))\n# enter the radius as float\nradius = float(input(\"Enter the distance/radius between the objects =\"))\n# Given value of Gravitational Constant Gval\nGval = 6.673*(10**(-11))\n# Calculating the value of the gravitational force Gforce\nGforce = (Gval*mass1*mass2)/(radius**2)\n# printing the value of gravitational force\nprint(\"The gravitational force of objects with masses\", str(mass1) +\n      \" kg \"+str(mass2)+\" kg \", \"of radius=\", radius, \"=\", Gforce)"}
{"nl": "Implementation of Deque using circular array", "code": "# Python implementation of De-queue using circular\n# array\n\n# A structure to represent a Deque\nMAX = 100;\n\nclass Deque:\n\tdef __init__(self, size):\n\t\tself.arr = [0] * MAX\n\t\tself.front = -1;\n\t\tself.rear = 0;\n\t\tself.size = size;\n\t\n\t\n\t''' Operations on Deque:\n\tvoid insertfront(int key);\n\tvoid insertrear(int key);\n\tvoid deletefront();\n\tvoid deleterear();\n\tbool isFull();\n\tbool isEmpty();\n\tint getFront();\n\tint getRear(); '''\n\n\t# Checks whether Deque is full or not.\n\tdef isFull(self):\n\t\treturn ((self.front == 0 and self.rear == self.size-1) or self.front == self.rear + 1)\n\t\n\t\n\t# Checks whether Deque is empty or not.\n\tdef isEmpty (self):\n\t\treturn (self.front == -1);\n\t\n\t# Inserts an element at front\n\tdef insertfront(self, key):\n\n\t\t# check whether Deque if full or not\n\t\tif (self.isFull()):\n\t\t\tprint(\"Overflow\");\n\t\t\treturn;\n\t\t\n\n\t\t# If queue is initially empty\n\t\tif (self.front == -1):\n\t\t\tself.front = 0;\n\t\t\tself.rear = 0;\n\t\t\n\t\t\n\t\t# front is at first position of queue\n\t\telif (self.front == 0):\n\t\t\tself.front = self.size - 1 ;\n\n\t\telse: # decrement front end by '1'\n\t\t\tself.front = self.front-1;\n\n\t\t# insert current element into Deque\n\t\tself.arr[self.front] = key ;\n\t\n\t\n\t# function to inset element at rear end\n\t# of Deque.\n\tdef insertrear(self, key):\n\t\tif (self.isFull()):\n\t\t\tprint(\" Overflow\");\n\t\t\treturn;\n\t\t\n\n\t\t# If queue is initially empty\n\t\tif (self.front == -1):\n\t\t\tself.front = 0;\n\t\t\tself.rear = 0;\n\t\t\n\n\t\t# rear is at last position of queue\n\t\telif (self.rear == self.size-1):\n\t\t\tself.rear = 0;\n\n\t\t# increment rear end by '1'\n\t\telse:\n\t\t\tself.rear = self.rear+1;\n\t\t\n\t\t# insert current element into Deque\n\t\tself.arr[self.rear] = key ;\n\t\n\t\n\t# Deletes element at front end of Deque\n\tdef deletefront(self):\n\t\t# check whether Deque is empty or not\n\t\tif (self.isEmpty()):\n\t\t\tprint(\"Queue Underflow\");\n\t\t\treturn ;\n\t\t\n\n\t\t# Deque has only one element\n\t\tif (self.front == self.rear):\n\t\t\tself.front = -1;\n\t\t\tself.rear = -1;\n\t\t\n\t\telse:\n\t\t\t# back to initial position\n\t\t\tif (self.front == self.size -1):\n\t\t\t\tself.front = 0;\n\n\t\t\telse: # increment front by '1' to remove current\n\t\t\t\t# front value from Deque\n\t\t\t\tself.front = self.front+1;\n\t\n\t\n\t# Delete element at rear end of Deque\n\tdef deleterear(self):\n\t\tif (self.isEmpty()):\n\t\t\tprint(\" Underflow\");\n\t\t\treturn ;\n\t\t\n\n\t\t# Deque has only one element\n\t\tif (self.front == self.rear):\n\t\t\tself.front = -1;\n\t\t\tself.rear = -1;\n\t\t\n\t\telif (self.rear == 0):\n\t\t\tself.rear = self.size-1;\n\t\telse:\n\t\t\tself.rear = self.rear-1;\n\t\n\t\n\t# Returns front element of Deque\n\tdef getFront(self):\n\t\t# check whether Deque is empty or not\n\t\tif (self.isEmpty()):\n\t\t\tprint(\" Underflow\");\n\t\t\treturn -1 ;\n\t\t\n\t\treturn self.arr[self.front];\n\t\n\t\n\t# function return rear element of Deque\n\tdef getRear(self):\n\t\t# check whether Deque is empty or not\n\t\tif(self.isEmpty() or self.rear < 0):\n\t\t\tprint(\" Underflow\");\n\t\t\treturn -1 ;\n\t\t\n\t\treturn self.arr[self.rear];\n\t\n\t\n\n\n# Driver program to test above function\ndq = Deque(5);\n\t\t\nprint(\"Insert element at rear end : 5 \");\ndq.insertrear(5);\n\nprint(\"insert element at rear end : 10 \");\ndq.insertrear(10);\n\nprint(f\"get rear element : {dq.getRear()}\");\n\ndq.deleterear();\nprint(f\"After delete rear element new rear become : {dq.getRear()}\");\n\nprint(\"inserting element at front end\");\ndq.insertfront(15);\n\nprint(f\"get front element: {dq.getFront()}\");\n\ndq.deletefront();\n\nprint(f\"After delete front element new front become : {dq.getFront()}\");\n\n# This code is contributed by _saurabh_jaiswal\n"}
{"nl": "Count Numbers that don\u2019t Contain 3", "code": "# Give the list as user input using list(),map(),input(),and split() functions.\r\n# Store it in a variable.\r\nlstnmbs = list(map(int, input(\r\n    'Enter some random List Elements separated by spaces = ').split()))\r\n# Take a variable that stores the count of numbers\r\n# that doesn't contain digit 3 in them(say cunt)\r\ncunt = 0\r\n# Traverse the given list using For loop.\r\nfor numbr in lstnmbs:\r\n    # Convert the list element to a string and store it in a variable.\r\n    strnumbr = str(numbr)\r\n    # Check if this string contains digit 3 in it using not in operator and If statement.\r\n    if '3' not in strnumbr:\r\n        # If it is true then increment the cunt by 1.\r\n        cunt = cunt+1\r\n# Print the cunt value.\r\nprint('The Count of numbers that doesnt contain three in the given list',\r\n      lstnmbs, 'is [', cunt, ']')"}
{"nl": "Python Program to Find the LCM of Two Numbers Using Recursion", "code": "# function which accepts the given two numbers as arguments\n# and return the lcm of the given two numbers.\n\n\ndef lcmRecursion(numb1, numb2):\n    # Set the multiple variable to the highest value between the given two numbers.\n    lcmRecursion.multiple = lcmRecursion.multiple+numb2\n    # Check to see if the multiple variable  divides both given numbers perfectly.\n    if((lcmRecursion.multiple % numb1 == 0) and (lcmRecursion.multiple % numb2 == 0)):\n      # If it does, the process is terminated and the multiple variable is returned as the LCM.\n        return lcmRecursion.multiple\n    else:\n      # If the multiple does not divide both given numbers perfectly, then it is increased by the maximum value\n      # among both given numbers using the max() function.\n        lcmRecursion(numb1, numb2)\n    # The recursive function returns the multiple variable\n    # which is the result(lcm of the given two numbers)\n    return lcmRecursion.multiple\n\n\n# set multiplee variable value to 0\nlcmRecursion.multiple = 0\n# Give two numbers as static input and store them in two variables.\nnumbe1 = 10\nnumbe2 = 16\n# if the first number is greater than second number then swap the arguments\nif(numbe1 > numbe2):\n    LcmVal = lcmRecursion(numbe2, numbe1)\n# else pass the original numbers as arguments\nelse:\n    LcmVal = lcmRecursion(numbe1, numbe2)\nprint('The value of lcm of the given two numbers', numbe1, numbe2, ' = ', LcmVal)"}
{"nl": "Replace each node in binary tree with the sum of its inorder predecessor and successor", "code": "# Python3 implementation to replace each\n# node in binary tree with the sum of its\n# inorder predecessor and successor\n\n# class to get a new node of a\n# binary tree\nclass getNode:\n\tdef __init__(self, data):\n\t\t\n\t\t# put in the data\n\t\tself.data = data\n\t\tself.left = self.right = None\n\t\n# function to store the inorder traversal\n# of the binary tree in 'arr'\ndef storeInorderTraversal(root, arr):\n\t\n\t# if root is None\n\tif (not root):\n\t\treturn\n\n\t# first recur on left child\n\tstoreInorderTraversal(root.left, arr)\n\n\t# then store the root's data in 'arr'\n\tarr.append(root.data)\n\n\t# now recur on right child\n\tstoreInorderTraversal(root.right, arr)\n\n# function to replace each node with the\n# sum of its inorder predecessor and successor\ndef replaceNodeWithSum(root, arr, i):\n\t\n\t# if root is None\n\tif (not root):\n\t\treturn\n\n\t# first recur on left child\n\treplaceNodeWithSum(root.left, arr, i)\n\n\t# replace node's data with the sum of its\n\t# inorder predecessor and successor\n\troot.data = arr[i[0] - 1] + arr[i[0] + 1]\n\n\t# move 'i' to point to the next 'arr' element\n\ti[0] += 1\n\n\t# now recur on right child\n\treplaceNodeWithSum(root.right, arr, i)\n\n# Utility function to replace each node in\n# binary tree with the sum of its inorder\n# predecessor and successor\ndef replaceNodeWithSumUtil(root):\n\t\n\t# if tree is empty\n\tif (not root):\n\t\treturn\n\n\tarr = []\n\n\t# store the value of inorder predecessor\n\t# for the leftmost leaf\n\tarr.append(0)\n\n\t# store the inorder traversal of the\n\t# tree in 'arr'\n\tstoreInorderTraversal(root, arr)\n\n\t# store the value of inorder successor\n\t# for the rightmost leaf\n\tarr.append(0)\n\n\t# replace each node with the required sum\n\ti = [1]\n\treplaceNodeWithSum(root, arr, i)\n\n# function to print the preorder traversal\n# of a binary tree\ndef preorderTraversal(root):\n\t\n\t# if root is None\n\tif (not root):\n\t\treturn\n\n\t# first print the data of node\n\tprint(root.data, end = \" \")\n\n\t# then recur on left subtree\n\tpreorderTraversal(root.left)\n\n\t# now recur on right subtree\n\tpreorderTraversal(root.right)\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# binary tree formation\n\troot = getNode(1) #\t\t 1\t\n\troot.left = getNode(2)\t #\t / \\\t\n\troot.right = getNode(3)\t #\t 2\t 3\t\n\troot.left.left = getNode(4) # / \\ / \\\n\troot.left.right = getNode(5) # 4 5 6 7\n\troot.right.left = getNode(6)\n\troot.right.right = getNode(7)\n\n\tprint(\"Preorder Traversal before\",\n\t\t\t\t\"tree modification:\")\n\tpreorderTraversal(root)\n\n\treplaceNodeWithSumUtil(root)\n\tprint()\n\tprint(\"Preorder Traversal after\",\n\t\t\t\t\"tree modification:\")\n\tpreorderTraversal(root)\n\n# This code is contributed by PranchalK\n"}
{"nl": "Uno (Part 2)", "code": "def decision(hand, face):\n  match = any(i in ''.join(hand) for i in face.split())\n  outcomes = {(1, True): 'You won!', (2, True): 'Uno!', (1, False): 'Uno!'}\n  return outcomes.get((len(hand), match), 'Keep going...')"}
{"nl": "an algorithm to detect squares", "code": "class DetectSquares:\n\ndef __init__(self):\n    self.dic={}\n\ndef add(self, point: List[int]) -> None:\n    key=(point[0],point[1])\n    self.dic[key]=self.dic.get(key,0)+1\n\ndef count(self, point: List[int]) -> int:\n    res=0\n    x1,y1=point\n    \n    for x2,y2 in self.dic:\n        if(x1!=x2 and y1!=y2 and abs(x1-x2)==abs(y1-y2) and (x1,y2) in self.dic and (x2,y1) in self.dic):\n            res+=self.dic[(x2,y2)]*self.dic[(x1,y2)]*self.dic[(x2,y1)]\n    return res"}
{"nl": "How to Get the First Digit of a Number in Python", "code": "# Python Program to get the first digit of number # take input num = int(input('Enter any Number: ')) # get the first digit while (num >= 10): num = num // 10 # printing first digit of number print('The first digit of number:', num)"}
{"nl": "find maximum beauty by returning an array answer of the same length as queries where answer[j] is the answer to the jth query", "code": "class Solution:\n    def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\n        arr_price, arr_beauty, res, max_ = [], [], [], -inf\n        items.sort()\n        \n        for i in range(len(items)):\n            if i == len(items) - 1 or items[i][0] != items[i + 1][0]:\n                arr_price.append(items[i][0])\n                max_ = max(max_, items[i][1])\n                arr_beauty.append(max_)\n\n        for q in queries:\n            ind = bisect.bisect(arr_price, q)\n            if ind == 0: res.append(0)\n            else: res.append(arr_beauty[ind - 1])\n            \n        return res"}
{"nl": "Count quadruples from four sorted arrays whose sum is equal to a given value x", "code": "# A Python3 implementation to count\n# quadruples from four sorted arrays\n# whose sum is equal to a given value x\n\n# function to count all quadruples\n# from four sorted arrays whose sum\n# is equal to a given value x\ndef countQuuadruples(arr1, arr2,\n\t\t\t\t\tarr3, arr4, n, x):\n\tcount = 0\n\n\t# generate all possible\n\t# quadruples from the four\n\t# sorted arrays\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tfor k in range(n):\n\t\t\t\tfor l in range(n):\n\n\t\t\t\t\t# check whether elements of\n\t\t\t\t\t# quadruple sum up to x or not\n\t\t\t\t\tif (arr1[i] + arr2[j] +\n\t\t\t\t\t\tarr3[k] + arr4[l] == x):\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\t\n\t# required count of quadruples\n\treturn count\n\n# Driver Code\narr1 = [1, 4, 5, 6]\narr2 = [2, 3, 7, 8]\narr3 = [1, 4, 6, 10]\narr4 = [2, 4, 7, 8 ]\nn = len(arr1)\nx = 30\nprint(\"Count = \", countQuuadruples(arr1, arr2,\n\t\t\t\t\t\t\t\tarr3, arr4, n, x))\n\n# This code is contributed\n# by Shrikant13"}
{"nl": "Construct tree from ancestor matrix", "code": "# key structure to store a binary tree node\r\nclass Node:\r\n\tdef __init__(self, key, left = None, right = None):\r\n\t\tself.key = key\r\n\t\tself.left = left\r\n\t\tself.right = right\r\n\r\n# Utility function to print binary tree nodes in-order fashion\r\ndef inorder(node):\r\n\tif node:\r\n\t\tinorder(node.left)\r\n\t\tprint(node.key, end = ' ')\r\n\t\tinorder(node.right)\r\n\r\n# Function to construct a binary tree\r\n# from specified ancestor matrix\r\ndef constructBT(mat):\r\n\r\n\t# get number of rows in the matrix\r\n\tN = len(mat)\r\n\r\n\t# create an empty multi-dict\r\n\tdict = {}\r\n\r\n\t# Use sum as key and row numbers as values in the multi-dict\r\n\tfor i in range(N):\r\n\r\n\t\t# find the sum of the current row\r\n\t\ttotal = sum(mat[i])\r\n\r\n\t\t# insert the sum and row number into the dict\r\n\t\tdict.setdefault(total, []).append(i)\r\n\r\n\t# node[i] will store node for i in constructed tree\r\n\tnode = [Node(-1)] * N\r\n\tlast = 0\r\n\r\n\t# the value of parent[i] is true if parent is set for i'th node\r\n\tparent = [False] * N\r\n\r\n\t# Traverse the dictionary in sorted order (default behavior)\r\n\tfor key in dict.keys():\r\n\t\tfor row in dict.get(key):\r\n\t\t\tlast = row\r\n\t\t\t\r\n\t\t\t# create a new node\r\n\t\t\tnode[row] = Node(row)\r\n\r\n\t\t\t# if leaf node, do nothing\r\n\t\t\tif key == 0:\r\n\t\t\t\tcontinue\r\n\r\n\t\t\t# traverse row\r\n\t\t\tfor i in range(N):\r\n\t\t\t\r\n\t\t\t\t# do if parent is not set and ancestor exits\r\n\t\t\t\tif not parent[i] and mat[row][i] == 1:\r\n\t\t\t\t\r\n\t\t\t\t\t# check for the unoccupied node\r\n\t\t\t\t\tif node[row].left is None:\r\n\t\t\t\t\t\tnode[row].left = node[i]\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tnode[row].right = node[i]\r\n\r\n\t\t\t\t\t# set parent for i'th node\r\n\t\t\t\t\tparent[i] = True\r\n\r\n\t# last processed node is the root\r\n\treturn node[last]\r\n\r\n# Construct a Binary Tree from Ancestor Matrix\r\nif __name__ == '__main__':\r\n\r\n\tmat = [[0, 0, 0, 0, 0, 0],\r\n\t\t[1, 0, 0, 0, 1, 0],\r\n\t\t[0, 0, 0, 1, 0, 0],\r\n\t\t[0, 0, 0, 0, 0, 0],\r\n\t\t[0, 0, 0, 0, 0, 0],\r\n\t\t[1, 1, 1, 1, 0, 0]]\r\n\r\n\troot = constructBT(mat)\r\n\tinorder(root)\r\n\r\n# This code is contributed by Priyadarshini Kumari\r"}
{"nl": "Print multiplication tables in python", "code": "# Python program to print multiplication table # take inputs num = int(input('Display multiplication table of: ')) # print multiplication table for i in range(1, 11): print (\"%d * %d = %d\" % (num, i, num * i))"}
{"nl": "Find a Mother Vertex in a Graph\r\n", "code": "\r\n# program to find a mother vertex in O(V+E) time\r\nfrom collections import defaultdict\r\n \r\n# This class represents a directed graph using adjacency list\r\n# representation\r\nclass Graph:\r\n \r\n    def __init__(self,vertices):\r\n        self.V = vertices #No. of vertices\r\n        self.graph = defaultdict(list) # default dictionary\r\n \r\n    # A recursive function to print DFS starting from v\r\n    def DFSUtil(self, v, visited):\r\n \r\n        # Mark the current node as visited and print it\r\n        visited[v] = True\r\n \r\n        # Recur for all the vertices adjacent to this vertex\r\n        for i in self.graph[v]:\r\n            if visited[i] == False:\r\n                self.DFSUtil(i, visited)\r\n \r\n    # Add w to the list of v\r\n    def addEdge(self, v, w):\r\n        self.graph[v].append(w)\r\n \r\n    # Returns a mother vertex if exists. Otherwise returns -1\r\n    def findMother(self):\r\n \r\n        # visited[] is used for DFS. Initially all are\r\n        # initialized as not visited\r\n        visited =[False]*(self.V)\r\n \r\n        # To store last finished vertex (or mother vertex)\r\n        v=0\r\n \r\n        # Do a DFS traversal and find the last finished\r\n        # vertex\r\n        for i in range(self.V):\r\n            if visited[i]==False:\r\n                self.DFSUtil(i,visited)\r\n                v = i\r\n \r\n        # If there exist mother vertex (or vertices) in given\r\n        # graph, then v must be one (or one of them)\r\n \r\n        # Now check if v is actually a mother vertex (or graph\r\n        # has a mother vertex). We basically check if every vertex\r\n        # is reachable from v or not.\r\n \r\n        # Reset all values in visited[] as false and do\r\n        # DFS beginning from v to check if all vertices are\r\n        # reachable from it or not.\r\n        visited = [False]*(self.V)\r\n        self.DFSUtil(v, visited)\r\n        if any(i == False for i in visited):\r\n            return -1\r\n        else:\r\n            return v\r\n \r\n# Create a graph given in the above diagram\r\ng = Graph(7)\r\ng.addEdge(0, 1)\r\ng.addEdge(0, 2)\r\ng.addEdge(1, 3)\r\ng.addEdge(4, 1)\r\ng.addEdge(6, 4)\r\ng.addEdge(5, 6)\r\ng.addEdge(5, 2)\r\ng.addEdge(6, 0)\r\nprint (\"A mother vertex is \" + str(g.findMother()))\r\n \r\n# This code is contributed by Neelam Yadav"}
{"nl": "Compare Diagonal", "code": "def compare_diagonal(m):\n  return max([[l[len(m)-1-i] for i,l in enumerate(m)],[l[i] for i,l in enumerate()]] ,key = sum)"}
{"nl": "string to integer", "code": "class StateMachine:\n    def __init__(self):\n        self.State = { \"q0\": 1, \"q1\": 2, \"q2\": 3, \"qd\": 4 }\n        self.INT_MAX, self.INT_MIN = pow(2, 31) - 1, -pow(2, 31)\n        \n        # Store current state value.\n        self.__current_state = self.State[\"q0\"]\n        # Store result formed and its sign.\n        self.__result = 0\n        self.__sign = 1\n\n    def to_state_q1(self, ch: chr) -> None:\n        \"\"\"Transition to state q1.\"\"\"\n        self.__sign = -1 if (ch == '-') else 1\n        self.__current_state = self.State[\"q1\"]\n    \n    def to_state_q2(self, digit: int) -> None:\n        \"\"\"Transition to state q2.\"\"\"\n        self.__current_state = self.State[\"q2\"]\n        self.append_digit(digit)\n    \n    def to_state_qd(self) -> None:\n        \"\"\"Transition to dead state qd.\"\"\"\n        self.__current_state = self.State[\"qd\"]\n    \n    def append_digit(self, digit: int) -> None:\n        \"\"\"Append digit to result, if out of range return clamped value.\"\"\"\n        if ((self.__result > self.INT_MAX // 10) or \n            (self.__result == self.INT_MAX // 10 and digit > self.INT_MAX % 10)):\n            if self.__sign == 1:\n                # If sign is 1, clamp result to INT_MAX.\n                self.__result = self.INT_MAX\n            else:\n                # If sign is -1, clamp result to INT_MIN.\n                self.__result = self.INT_MIN\n                self.__sign = 1\n            \n            # When the 32-bit int range is exceeded, a dead state is reached.\n            self.to_state_qd()\n        else:\n            # Append current digit to the result. \n            self.__result = (self.__result * 10) + digit\n\n    def transition(self, ch: chr) -> None:\n        \"\"\"Change state based on current input character.\"\"\"\n        if self.__current_state == self.State[\"q0\"]:\n            # Beginning state of the string (or some whitespaces are skipped).\n            if ch == ' ':\n                # Current character is a whitespaces.\n                # We stay in same state. \n                return\n            elif ch == '-' or ch == '+':\n                # Current character is a sign.\n                self.to_state_q1(ch)\n            elif ch.isdigit():\n                # Current character is a digit.\n                self.to_state_q2(int(ch))\n            else:\n                # Current character is not a space/sign/digit.\n                # Reached a dead state.\n                self.to_state_qd()\n        \n        elif self.__current_state == self.State[\"q1\"] or self.__current_state == self.State[\"q2\"]:\n            # Previous character was a sign or digit.\n            if ch.isdigit():\n                # Current character is a digit.\n                self.to_state_q2(int(ch))\n            else:\n                # Current character is not a digit.\n                # Reached a dead state.\n                self.to_state_qd()\n    \n    def get_integer(self) -> None:\n        \"\"\"Return the final result formed with it's sign.\"\"\"\n        return self.__sign * self.__result\n    \n    def get_state(self) -> None:\n        \"\"\"Get current state.\"\"\"\n        return self.__current_state\n\nclass Solution:\n    def myAtoi(self, input: str) -> int:\n        q = StateMachine()\n        \n        for ch in input:\n            q.transition(ch)\n            if q.get_state() == q.State[\"qd\"]:\n                break\n\n        return q.get_integer()"}
{"nl": "Python Program to Find Sum of Even Numbers Using Recursion in a List/Array", "code": "# Create a recursive function to say evenelemt_sum which takes the given list and length\n# of the given list as the arguments and returns the sum of even numbers in a given list\n# using recursion.\n\n\ndef evenelemt_sum(gven_lst, len_lst):\n    # Make the rslt_sum a global declaration.\n    global rslt_sum\n    # Check if the length of the given list is greater than 0 using the if conditional\n    # statement.\n    if(len_lst > 0):\n        # If the statement is true, then subtract 1 from the length of the given list and\n        # store it in a variable k.\n        k = len_lst-1\n   # Check if the element present at the index k of the given list is even using modulus\n   # operator and if conditional statement.\n        if(gven_lst[k] % 2 == 0):\n            # If the statement is true, add the element present at the index k of the\n            # given list to the above-initialized rslt_sum.\n            # Store it in the same variable.\n            rslt_sum = rslt_sum+gven_lst[k]\n           # Pass the given list and k value as the arguments to the evenelemt_sum function\n           # {Recursive Logic}.\n        evenelemt_sum(gven_lst, k)\n       # Return rslt_sum.\n    return rslt_sum\n\n\n# Give the list as static input and store it in a variable.\ngven_lst = [1, 6, 3, 7, 8, 4]\n# Calculate the length of the given list and store it in another variable.\nlen_lst = len(gven_lst)\n# Take a variable say rslt_sum and initialize its value to 0.\nrslt_sum = 0\n# Pass the given list and length of the given list as the arguments to the evenelemt_sum\n# function.\n# Print the sum of even numbers in the above-given list.\nprint(\"The Sum of Even Elements in a given list\",\n      gven_lst, \"=\", evenelemt_sum(gven_lst, len_lst))"}
{"nl": "String Expansion", "code": "def string_expansion(txt):\n    m,n = '',1\n    for j in txt:\n        if j.isdigit():\n            n = int(j)\n        else:\n            m += j*n\n    return m"}
{"nl": "Max Adjacent Product", "code": "def adjacent_product(lst):\n  return max(a*b for a, b in zip(lst, lst[1:]))"}
{"nl": "Boolean Chain", "code": "boolean_and=all\nboolean_or=any  \nboolean_xor=lambda l:sum(l)%2"}
{"nl": "FSA: Individual Instructions", "code": "def combine(lst):\n  return {a[0]: [a[2], b[2]] for a, b in zip(lst[::2], lst[1::2])}"}
{"nl": "The number of ways the n people wear different hats to each other", "code": "class Solution:\n  def numberWays(self, hats: List[List[int]]) -> int:\n  htop = [[] for i in range(41)] # htop: hat to people list\n  for p, prefer_hats in enumerate(hats):\n  for h in prefer_hats:\n  htop[h].append(p)\n  htop = list(filter(lambda h: h, htop)) # filter out hats no one wants\n  \n  num_hats, num_people = len(htop), len(hats)\n  if num_hats < num_people:\n  return 0\n  \n  MOD = 10**9+7\n  @functools.lru_cache(None)\n  def dp(i, mask):\n  if bin(mask).count('1') == num_people:\n  return 1\n  if i == num_hats:\n  return 0\n  res = dp(i+1, mask) # not using the current hat\n  for p in htop[i]:\n  if mask & (1<<p) == 0:\n  mask |= 1<<p\n  res += dp(i+1, mask)\n  mask ^= 1<<p\n  return res%MOD\n  return dp(0, 0)"}
{"nl": "Python File seekable() Method", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.seekable())"}
{"nl": "Sum of all the numbers that are formed from root to leaf paths", "code": "# Python program to find sum of all paths from root to leaves\n\n# A Binary tree node\nclass Node:\n\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Returns sums of all root to leaf paths. The first parameter is root\n# of current subtree, the second paramete\"r is value of the number\n# formed by nodes from root to this node\ndef treePathsSumUtil(root, val):\n\n\t# Base Case\n\tif root is None:\n\t\treturn 0\n\n\t# Update val\n\tval = (val*10 + root.data)\n\n\t# If current node is leaf, return the current value of val\n\tif root.left is None and root.right is None:\n\t\treturn val\n\n\t# Recur sum of values for left and right subtree\n\treturn (treePathsSumUtil(root.left, val) +\n\t\t\ttreePathsSumUtil(root.right, val))\n\n# A wrapper function over treePathSumUtil()\ndef treePathsSum(root):\n\t\n\t# Pass the initial value as 0 as ther is nothing above root\n\treturn treePathsSumUtil(root, 0)\n\n# Driver function to test above function\nroot = Node(6)\nroot.left = Node(3)\nroot.right = Node(5)\nroot.left.left = Node(2)\nroot.left.right = Node(5)\nroot.right.right = Node(4)\nroot.left.right.left = Node(7)\nroot.left.right.right = Node(4)\nprint (\"Sum of all paths is\", treePathsSum(root))\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Solve Rod Cutting Problem using Dynamic Programming with Memoization", "code": "def cut_rod(p, n):\n    \"\"\"Take a list p of prices and the rod length n and return lists r and s.\n    r[i] is the maximum revenue that you can get and s[i] is the length of the\n    first piece to cut from a rod of length i.\"\"\"\n    # r[i] is the maximum revenue for rod length i\n    # r[i] = -1 means that r[i] has not been calculated yet\n    r = [-1]*(n + 1)\n\u00a0\n    # s[i] is the length of the initial cut needed for rod length i\n    # s[0] is not needed\n    s = [-1]*(n + 1)\n\u00a0\n    cut_rod_helper(p, n, r, s)\n\u00a0\n    return r, s\n\u00a0\n\u00a0\ndef cut_rod_helper(p, n, r, s):\n    \"\"\"Take a list p of prices, the rod length n, a list r of maximum revenues\n    and a list s of initial cuts and return the maximum revenue that you can get\n    from a rod of length n.\n\u00a0\n    Also, populate r and s based on which subproblems need to be solved.\n    \"\"\"\n    if r[n] >= 0:\n        return r[n]\n\u00a0\n    if n == 0:\n        q = 0\n    else:\n        q = -1\n        for i in range(1, n + 1):\n            temp = p[i] + cut_rod_helper(p, n - i, r, s)\n            if q < temp:\n                q = temp\n                s[n] = i\n    r[n] = q\n\u00a0\n    return q\n\u00a0\n\u00a0\nn = int(input('Enter the length of the rod in inches: '))\n\u00a0\n# p[i] is the price of a rod of length i\n# p[0] is not needed, so it is set to None\np = [None]\nfor i in range(1, n + 1):\n    price = input('Enter the price of a rod of length {} in: '.format(i))\n    p.append(int(price))\n\u00a0\nr, s = cut_rod(p, n)\nprint('The maximum revenue that can be obtained:', r[n])\nprint('The rod needs to be cut into length(s) of ', end='')\nwhile n > 0:\n    print(s[n], end=' ')\n    n -= s[n]"}
{"nl": "Unlucky Years", "code": "from datetime import date\ndef how_unlucky(y):\n  return sum(date(y, m, 13).strftime('%A') == 'Friday' for m in range(1, 13))"}
{"nl": "Rearrange the Letters of Multiple strings separated by spaces in Alphabetical Order", "code": "# Give the string as user input using the input() function and store it in a variable.\r\ngvnstrng = input('Enter some random string = ')\r\n# Reorder the letters of a string alphabetically using\r\n# the sorted function(This method returns a list of letters in alphabetical order).\r\nsortdstrng = sorted(gvnstrng)\r\n# Join this using the join() function.\r\n# Use the strip() function to remove spaces between the strings.\r\nfinalstrng = ''.join(sortdstrng).strip()\r\n# Print the modified string after reordering the letters of a string alphabetically.\r\nprint('The original string is [', gvnstrng, ']')\r\nprint(\r\n    'The modified string after reordering the letters of a string alphabetically is [', finalstrng, ']')"}
{"nl": "Python List insert() Method\r\n\r\n", "code": "fruits = ['apple', 'banana', 'cherry']\r\n\r\nfruits.insert(1, \"orange\")"}
{"nl": "Generate a graph using Dictionary in Python", "code": "# Python program for\n# validation of a graph\n\u00a0\n# import dictionary for graph\nfrom collections import defaultdict\n\u00a0\n# function for adding edge to graph\ngraph = defaultdict(list)\ndef addEdge(graph,u,v):\n\u00a0\u00a0\u00a0\u00a0graph[u].append(v)\n\u00a0\n# definition of function\ndef generate_edges(graph):\n\u00a0\u00a0\u00a0\u00a0edges = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# for each node in graph\n\u00a0\u00a0\u00a0\u00a0for node in graph:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for each neighbour node of a single node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for neighbour in graph[node]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if edge exists then append\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0edges.append((node, neighbour))\n\u00a0\u00a0\u00a0\u00a0return edges\n\u00a0\n# declaration of graph as dictionary\naddEdge(graph,'a','c')\naddEdge(graph,'b','c')\naddEdge(graph,'b','e')\naddEdge(graph,'c','d')\naddEdge(graph,'c','e')\naddEdge(graph,'c','a')\naddEdge(graph,'c','b')\naddEdge(graph,'e','b')\naddEdge(graph,'d','c')\naddEdge(graph,'e','c')\n\u00a0\n# Driver Function call\n# to print generated graph\nprint(generate_edges(graph))\n"}
{"nl": "Score a Bowling", "code": "class Frame(object):\n    \"\"\"Frame\"\"\"\n    def __init__(self, ID):\n        self.id = ID\n        self.throws = []\n    @property\n    def is_done(self):\n        return sum(self.throws) == 10 or len(self.throws) == 2\n    @property\n    def is_strike(self):\n        return sum(self.throws) == 10 and len(self.throws) == 1\n    @property\n    def is_spare(self):\n        return sum(self.throws) == 10 and len(self.throws) == 2\n    def score(self, next_throws):\n        res = sum(self.throws)\n        if self.is_strike:\n            res += sum(next_throws[:2])\n        elif self.is_spare:\n            res += sum(next_throws[:1])\n        return res\n    def roll(self, pins):\n        if pins < 0:\n            raise ValueError(f'pins cannot be negative but received \"{pins}\".')\n        if pins > 10:\n            raise ValueError(f'pins cannot be greater than 10 but received \"{pins}\".')  # noqa\n        if sum(self.throws) + pins > 10:\n            raise ValueError(f'A frame\\'s rolls cannot exceed 10 pins.')\n        self.throws.append(pins)\nclass BowlingGame(object):\n    \"\"\"BowlingGame\"\"\"\n    def __init__(self):\n        self.bonus_throws = []\n        self.frames = [Frame(i) for i in range(10)]\n        self.frame_num = 0\n    @property\n    def crnt_frame(self):\n        return self.get_frame(self.frame_num)\n    def get_frame(self, frame_num):\n        return self.frames[frame_num]\n    def next_throws(self, frameID):\n        next_throws = []\n        next_frameID = frameID + 1\n        while next_frameID < 10:\n            next_throws += self.get_frame(next_frameID).throws\n            next_frameID += 1\n        next_throws += self.bonus_throws\n        return next_throws\n    def handle_bonus_throw(self, pins):\n        if self.get_frame(9).is_spare:\n            if len(self.bonus_throws) == 1:\n                raise IndexError(f'Game over. Please insert quarter.')\n            self.bonus_throws += [pins]  # TODO guard against bad input\n        elif self.get_frame(9).is_strike:\n            if len(self.bonus_throws) == 2:\n                raise IndexError(f'Game over. Please insert quarter.')\n            if sum(self.bonus_throws + [pins]) > 10:\n                if len(self.bonus_throws) == 1 and self.bonus_throws[0] == 10:\n                    pass\n                else:\n                    raise ValueError(f'You lie!')\n            self.bonus_throws += [pins]\n        else:\n            raise IndexError(f'Game over. Please insert quarter.')\n    def roll(self, pins):\n        if pins > 10:\n            raise ValueError(f'You lie!')\n        if self.frame_num == 10:\n            self.handle_bonus_throw(pins)\n        else:\n            self.crnt_frame.roll(pins)\n            if self.crnt_frame.is_done:\n                self.frame_num += 1\n    def score(self):\n        if self.frame_num < 10:\n            raise IndexError(f'All frames must be complete before scoring.')\n        if self.get_frame(9).is_spare:\n            if len(self.bonus_throws) != 1:\n                raise IndexError(f'If the final frame is a spare, then one bonus roll must be taken.')  # noqa\n        if self.get_frame(9).is_strike:\n            if len(self.bonus_throws) != 2:\n                raise IndexError(f'If the final frame is a strike, then two bonus rolls must be taken.')  # noqa\n        return sum(frame.score(self.next_throws(frame.id))\n                   for frame in self.frames)"}
{"nl": "jump to the last index", "code": "def canJump(self, nums):\n    m = 0\n    for i, n in enumerate(nums):\n        if i > m:\n            return False\n        m = max(m, i+n)\n    return True"}
{"nl": "Check if an array can be divided into pairs whose sum is divisible by k", "code": "# Python3 program to check if\n# arr[0..n-1] can be divided\n# in pairs such that every\n# pair is divisible by k.\nfrom collections import defaultdict\n\n# Returns true if arr[0..n-1] can be\n# divided into pairs with sum\n# divisible by k.\n\n\ndef canPairs(arr, n, k):\n\n        # An odd length array cannot\n        # be divided into pairs\n        if (n & 1):\n                return 0\n\n        # Create a frequency array to\n        # count occurrences of all\n        # remainders when divided by k.\n        freq = defaultdict(lambda: 0)\n\n        # Count occurrences of all remainders\n        for i in range(0, n):\n                freq[((arr[i] % k) + k) % k] += 1\n\n        # Traverse input array and use\n        # freq[] to decide if given array\n        # can be divided in pairs\n        for i in range(0, n):\n\n                # Remainder of current element\n                rem = ((arr[i] % k) + k) % k\n\n                # If remainder with current element\n                # divides k into two halves.\n                if (2 * rem == k):\n\n                        # Then there must be even occurrences\n                        # of such remainder\n                        if (freq[rem] % 2 != 0):\n                                return 0\n\n                # If remainder is 0, then there\n                # must be two elements with 0 remainder\n                else if (rem == 0):\n                        if (freq[rem] & 1):\n                                return 0\n\n                        # Else number of occurrences of\n                        # remainder must be equal to\n                        # number of occurrences of\n                        # k - remainder\n                else if (freq[rem] != freq[k - rem]):\n                        return 0\n\n        return 1\n\n\n# Driver code\narr = [92, 75, 65, 48, 45, 35]\nk = 10\nn = len(arr)\n\n# Function call\nif (canPairs(arr, n, k)):\n        print(\"True\")\nelse:\n        print(\"False\")\n\n# This code is contributed by Stream_Cipher\n"}
{"nl": "Python Program to Flatten a Nested List using Recursion", "code": "# function which takes the nested list as argument and\n# returns the flattened list using recursion\n\n\ndef flattenListRecursion(given_NestedList):\n    # If the list is empty, the function returns the list.\n    if given_NestedList == []:\n        return given_NestedList\n     # Otherwise, use the function with the sublists as parameters\n     # recursively until the entire list is flattened.\n    if isinstance(given_NestedList[0], list):\n        return flattenListRecursion(given_NestedList[0]) + flattenListRecursion(given_NestedList[1:])\n    return given_NestedList[:1] + flattenListRecursion(given_NestedList[1:])\n\n\n# Give the nested list as static input and store it in a variable.\ngivenNestedList = [[7, 8, 2], [11, 19, 29, 63, 91], [12, 52, 98], [11, 19, 18],\n                   [11, 28, 34, 39, 35, 56, 87, 46, 1, 2], [5], [9, 23], [3, 23, 124]]\n# printing the given nested list\nprint('Printing the given nested list : \\n', givenNestedList)\n# passing the given nested list as an argument to the recursive function flattenListRecursion\n# which returns the flattened lsit\nprint(\"Printing the flattened list : \\n\",\n      flattenListRecursion(givenNestedList))"}
{"nl": "Implement Stack using Queues", "code": "''' Python3 Program to implement a stack\nthat supports findMiddle()\nand deleteMiddle in O(1) time '''\n\u00a0\n''' A Doubly Linked List Node '''\n\u00a0\n\u00a0\nclass DLLNode:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, d):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.prev = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = d\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next = None\n\u00a0\n\u00a0\n''' Representation of the stack\ndata structure that supports\nfindMiddle() in O(1) time. The\nStack is implemented using\nDoubly Linked List. It maintains\npointer to head node, pointer\nto middle node and count of\nnodes '''\n\u00a0\n\u00a0\nclass myStack:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.head = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.mid = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.count = 0\n\u00a0\n\u00a0\n''' Function to create the stack data structure '''\n\u00a0\n\u00a0\ndef createMyStack():\n\u00a0\u00a0\u00a0\u00a0ms = myStack()\n\u00a0\u00a0\u00a0\u00a0ms.count = 0\n\u00a0\u00a0\u00a0\u00a0return ms\n\u00a0\n\u00a0\n''' Function to push an element to the stack '''\n\u00a0\n\u00a0\ndef push(ms, new_data):\n\u00a0\u00a0\u00a0\u00a0''' allocate DLLNode and put in data '''\n\u00a0\u00a0\u00a0\u00a0new_DLLNode = DLLNode(new_data)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' Since we are adding at the beginning,\n\u00a0\u00a0\u00a0\u00a0prev is always NULL '''\n\u00a0\u00a0\u00a0\u00a0new_DLLNode.prev = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' link the old list off the new DLLNode '''\n\u00a0\u00a0\u00a0\u00a0new_DLLNode.next = ms.head\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' Increment count of items in stack '''\n\u00a0\u00a0\u00a0\u00a0ms.count += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' Change mid pointer in two cases\n\u00a0\u00a0\u00a0\u00a01) Linked List is empty\n\u00a0\u00a0\u00a0\u00a02) Number of nodes in linked list is odd '''\n\u00a0\u00a0\u00a0\u00a0if(ms.count == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.mid = new_DLLNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.head.prev = new_DLLNode\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update mid if ms->count is odd\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if((ms.count % 2) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.mid = ms.mid.prev\n\u00a0\n\u00a0\u00a0\u00a0\u00a0''' move head to point to the new DLLNode '''\n\u00a0\u00a0\u00a0\u00a0ms.head = new_DLLNode\n\u00a0\n\u00a0\n''' Function to pop an element from stack '''\n\u00a0\n\u00a0\ndef pop(ms):\n\u00a0\u00a0\u00a0\u00a0''' Stack underflow '''\n\u00a0\u00a0\u00a0\u00a0if(ms.count == 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack is empty\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0head = ms.head\n\u00a0\u00a0\u00a0\u00a0item = head.data\n\u00a0\u00a0\u00a0\u00a0ms.head = head.next\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If linked list doesn't become empty,\n\u00a0\u00a0\u00a0\u00a0# update prev of new head as NULL\n\u00a0\u00a0\u00a0\u00a0if(ms.head != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.head.prev = None\n\u00a0\u00a0\u00a0\u00a0ms.count -= 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# update the mid pointer when\n\u00a0\u00a0\u00a0\u00a0# we have even number of elements\n\u00a0\u00a0\u00a0\u00a0# in the stack, i,e move down\n\u00a0\u00a0\u00a0\u00a0# the mid pointer.\n\u00a0\u00a0\u00a0\u00a0if(ms.count % 2 == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ms.mid = ms.mid.next\n\u00a0\u00a0\u00a0\u00a0return item\n\u00a0\n# Function for finding middle of the stack\n\u00a0\n\u00a0\ndef findMiddle(ms):\n\u00a0\u00a0\u00a0\u00a0if(ms.count == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Stack is empty now\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\u00a0\u00a0return ms.mid.data\n\u00a0\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ms = createMyStack()\n\u00a0\u00a0\u00a0\u00a0push(ms, 11)\n\u00a0\u00a0\u00a0\u00a0push(ms, 22)\n\u00a0\u00a0\u00a0\u00a0push(ms, 33)\n\u00a0\u00a0\u00a0\u00a0push(ms, 44)\n\u00a0\u00a0\u00a0\u00a0push(ms, 55)\n\u00a0\u00a0\u00a0\u00a0push(ms, 66)\n\u00a0\u00a0\u00a0\u00a0push(ms, 77)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Item popped is \" +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str(pop(ms)))\n\u00a0\u00a0\u00a0\u00a0print(\"Item popped is \" +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str(pop(ms)))\n\u00a0\u00a0\u00a0\u00a0print(\"Middle Element is \" +\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str(findMiddle(ms)))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by rutvik_56.\n"}
{"nl": "Human, Cat and Dog Years \ud83e\uddd1\ud83c\udffb\ud83d\udc31\ud83d\udc36", "code": "def calculate_years(years):\n  return [\n    years,\n    15 + 9 * (years > 1) + 4 * (years > 2) * (years - 2),\n    15 + 9 * (years > 1) + 5 * (years > 2) * (years - 2),\n  ]"}
{"nl": "Threaded Binary Search Tree | Deletion", "code": "# Here 'par' is pointer to parent Node and 'ptr' is\n# pointer to current Node.\ndef caseB(root, par, ptr):\n\tchild = None;\n\n\t# Initialize child Node to be deleted has\n\t# left child.\n\tif (ptr.lthread == False):\n\t\tchild = ptr.left;\n\n\t# Node to be deleted has right child.\n\telse:\n\t\tchild = ptr.right;\n\n\t# Node to be deleted is root Node.\n\tif (par == None):\n\t\troot = child;\n\n\t# Node is left child of its parent.\n\telif(ptr == par.left):\n\t\tpar.left = child;\n\telse:\n\t\tpar.right = child;\n\n\t# Find successor and predecessor\n\ts = inSucc(ptr);\n\tp = inPred(ptr);\n\n\t# If ptr has left subtree.\n\tif (ptr.lthread == False):\n\t\tp.right = s;\n\n\t# If ptr has right subtree.\n\telse:\n\t\tif (ptr.rthread == False):\n\t\t\ts.left = p;\n\t\n\treturn root;\n\n# This code is contributed by umadevi9616"}
{"nl": "Summation of the First n Terms", "code": "def summation(exp, i):\n  return round(sum(eval(exp) for n in range(1,i+1)),1)"}
{"nl": "Minimum product of k integers in an array of positive Integers", "code": "# Python3 program to find minimum\n# product of k elements in an array\nimport math\nimport heapq\n\ndef minProduct(arr, n, k):\n\n\theapq.heapify(arr)\n\tcount = 0\n\tans = 1\n\n\t# One by one extract\n\t# items from min heap\n\twhile ( arr ) and count < k:\n\t\tx = heapq.heappop(arr)\n\t\tans = ans * x\n\t\tcount = count + 1\n\t\n\treturn ans;\n\n# Driver method\narr = [198, 76, 544, 123, 154, 675]\nk = 2\nn = len(arr)\nprint (\"Minimum product is\",\n\tminProduct(arr, n, k))"}
{"nl": "search in integer array sorted in non-decreasing order with duplicates", "code": "def search(self, nums, target):\n    l, r = 0, len(nums)-1\n    while l <= r:\n        mid = l + (r-l)//2\n        if nums[mid] == target:\n            return True\n        while l < mid and nums[l] == nums[mid]: # tricky part\n            l += 1\n        # the first half is ordered\n        if nums[l] <= nums[mid]:\n            # target is in the first half\n            if nums[l] <= target < nums[mid]:\n                r = mid - 1\n            else:\n                l = mid + 1\n        # the second half is ordered\n        else:\n            # target is in the second half\n            if nums[mid] < target <= nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n    return False"}
{"nl": "Exercise working with loops: given an input integer N, find all Pythagorean triplets for which a + b + c = N.", "code": "def triplets_with_sum(number):\r\n    output_list = []\r\n    for a in range(1, 2 * number // 7 + 1):\r\n        denominator = 2 * (number - a)\r\n        numerator = 2 * a**2 - 2 * number * a + number**2\r\n        if denominator > 0 and numerator % denominator == 0:\r\n          c = numerator // denominator\r\n          output_list.append([a, number - a - c, c])\r\n    return output_list"}
{"nl": "Mubashir's Mystery Challenge", "code": "def mubashir_function(a, b):\n\treturn sum(map(int, str(a))) * sum(map(int, str(b)))"}
{"nl": "Python Program to Find Sum of Series 5^2 + 10^2 + 15^2 +\u2026..N^2", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the number N(limit) as static input and store it in a variable.\n \n gvn_numb = 25\n \n # Take a variable to say itr and initialize its value to 5.\n \n itr = 5\n \n # Take a variable to say rsltseries_summ and initialize its value to 0.\n \n rsltseries_summ = 0\n \n # Loop until the above-declared variable itr value is less than or equal to the\n \n # given number using the while loop.\n \n while(itr &lt;= gvn_numb):\n \n  # Calculate the value of itr raised to the power 2 (square) using the pow() function\n \n  # and store it in another variable.\n \n  k = pow(itr, 2)\n \n  # Add the above result to the rsltseries_summ and store it in the\n \n  # same variable.\n \n  rsltseries_summ += k\n \n  # Increment the above itr value by 5.\n \n  itr += 5\n \n print(\"The above given series sum = \", rsltseries_summ)\n \n </pre>"}
{"nl": "Sort an array containing two types of elements", "code": "# Python3 program to sort an array with\r\n# two types of values in one traversal.\r\n\r\n# Method for segregation 0 and\r\n# 1 given input array\r\ndef segregate0and1(arr, n):\r\n\r\n\ttype0 = 0; type1 = n - 1\r\n\r\n\twhile (type0 < type1):\r\n\t\tif (arr[type0] == 1):\r\n\t\t\tarr[type0], arr[type1] = arr[type1], arr[type0]\r\n\t\t\ttype1 -= 1\r\n\t\t\r\n\t\telse:\r\n\t\t\ttype0 += 1\r\n\t\t\r\n# Driver Code\r\narr = [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1]\r\nn = len(arr)\r\nsegregate0and1(arr, n)\r\nfor i in range(0, n):\r\n\tprint(arr[i], end = \" \")\r\n\r\n# This code is contributed by Smitha Dinesh Semwal\r"}
{"nl": "Python Program to Find Even Digits Sum and Odd Digits Sum Divisible by 4 and 3 Respectively", "code": "# Give the number as static input and store it in a variable.\nnumb = 123452\n# Convert the given number to string using the str() function.\nstringnum = str(numb)\n# Create a list of digits say \"digtslst\" using map(),list(),int functions.\ndigtslst = list(map(int, stringnum))\n# Take a variable say \"evn_sum\" and initialize it with 0.\nevn_sum = 0\n# Take another variable say \"od_sum\" and initialize it with 0.\nod_sum = 0\n# Loop in the above list of digits until the length of the \"digtslst\" using the for loop.\nfor itr in range(len(digtslst)):\n    # Check if the element of the \"digtslst\" is even or not using the if conditional statement.\n    if(digtslst[itr] % 2 == 0):\n     # If the statement is true, then add the element of the \"digtslst\" to the \"evn_sum\"\n        # and store it in the same variable evn_sum.\n        evn_sum += digtslst[itr]\n    else:\n        # If the statement is false, then add the element of the \"digtslst\" to the \"od_sum\"\n        # and store it in the same variable od_sum.\n        od_sum += digtslst[itr]\n# Check if the evn_sum modulus 4 is equal to 0 and od_sum modulus 3 is equal to 0\n# using the if conditional statement.\nif(evn_sum % 4 == 0 and od_sum % 3 == 0):\n  # If the statement is true, print \"yes, the even digits sum and odd digits sum of a\n    # given number are divisible by 4 and 3 respectively.\n    print(\n        \"yes, the even digits sum and odd digits sum of a given number{\", numb, \"} is divisible by 4 and 3 respectively.\")\nelse:\n # If the statement is false, print \"No, the even digits sum and odd digits sum\n    # of a given number are not divisible by 4 and 3 respectively.\n    print(\n        \"No, the even digits sum and odd digits sum of a given number{\", numb, \"} is not divisible by 4 and 3 respectively.\")"}
{"nl": "Read file word by word", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  print('The words in the given file : ')\n  for gvnfileline in givenfilecontent:\n  # Split the words of the line using the split() function and store them in a variable(it is of type list).\n  gvnfilewords = gvnfileline.split()\n  # Loop in the above list using another Nested For loop\n  # and print all the contents of the list using the print() function.\n  for words in gvnfilewords:\n  print(words)"}
{"nl": "Python Lists\r\n", "code": "thislist = [\"apple\", \"banana\", \"cherry\"]\r\nprint(thislist)"}
{"nl": "Which One Is Your Type?", "code": "def convert(data1, data2):\n  return type(data1)(data2)"}
{"nl": "Valid Hex Code", "code": "import re\ndef is_valid_hex_code(txt):\n  return bool(re.match(r'#[A-Fa-f0-9]{6}$', txt))"}
{"nl": "Print all the numbers present in the text file", "code": "filename = input('Enter the name of the given file : ')\n# In read mode, open the given file with the name 'filename'\nwith open(filename, 'r') as file:\n  # Using for loop, go over the lines in the sample file.\n  for line in file:\n  # Split the line into words using the split() function.\n  words = line.split()\n  # Traverse through the words using for loop.\n  for i in words:\n  # Traverse through all the characters of the word using another for loop.\n  for letter in i:\n  # Check to see if the letter is a digit, and if so, print it.\n  if(letter.isdigit()):\n  print(letter)"}
{"nl": "Reverse Words Starting With a Particular Letter", "code": "def special_reverse(s, c):\n  return ' '.join(i[::-1] if i[0]==c else i for i in s.split())"}
{"nl": "Print Floyd's Triangle", "code": "# Give the number of rows of the triangle as static input and store it in a variable.\ntriRows = 10\n# Take a variable and initialize it with 1 say sampNum.\nsampNum = 1\n# Loop from 1 to the number of rows of the triangle using For loop.\nfor m in range(1, triRows+1):\n  # Using another For loop, loop from 1 to the parent loop iterator value (Nested For loop).\n    for n in range(1, m+1):\n        # Inside the inner for loop print the sampNum with a space character.\n        print(sampNum, end=' ')\n        # Increase the value of sampNum by 1.\n        sampNum = sampNum+1\n    # Print the Newline Character after the end of the inner for loop.\n    print()"}
{"nl": "Reverse a String in Python", "code": "# given string\ngiven_string = \"vikram\"\n# calculating the length of string\nlength = len(given_string)\n# Reversing the string using slicing\nreverse_string = given_string[len(given_string)::-1]\n# print the reversed string\nprint(\"The reversed string of\", given_string, \"=\", reverse_string)"}
{"nl": "Find largest subtree sum in a tree", "code": "# Python3 program to find largest subtree\n# sum in a given binary tree.\n\n# Function to create new tree node.\nclass newNode:\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = self.right = None\n\n# Helper function to find largest\n# subtree sum recursively.\ndef findLargestSubtreeSumUtil(root, ans):\n\t\n\t# If current node is None then\n\t# return 0 to parent node.\n\tif (root == None):\n\t\treturn 0\n\t\n\t# Subtree sum rooted at current node.\n\tcurrSum = (root.key +\n\t\t\tfindLargestSubtreeSumUtil(root.left, ans) +\n\t\t\tfindLargestSubtreeSumUtil(root.right, ans))\n\n\t# Update answer if current subtree\n\t# sum is greater than answer so far.\n\tans[0] = max(ans[0], currSum)\n\n\t# Return current subtree sum to\n\t# its parent node.\n\treturn currSum\n\n# Function to find largest subtree sum.\ndef findLargestSubtreeSum(root):\n\t\n\t# If tree does not exist,\n\t# then answer is 0.\n\tif (root == None):\t\n\t\treturn 0\n\t\n\t# Variable to store maximum subtree sum.\n\tans = [-999999999999]\n\n\t# Call to recursive function to\n\t# find maximum subtree sum.\n\tfindLargestSubtreeSumUtil(root, ans)\n\n\treturn ans[0]\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t#\n\t#\t\t 1\n\t#\t\t / \\\n\t#\t /\t \\\n\t#\t -2\t 3\n\t#\t / \\\t / \\\n\t#\t / \\ / \\\n\t# 4\t 5 -6\t 2\n\troot = newNode(1)\n\troot.left = newNode(-2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.left.right = newNode(5)\n\troot.right.left = newNode(-6)\n\troot.right.right = newNode(2)\n\n\tprint(findLargestSubtreeSum(root))\n\n# This code is contributed by PranchalK"}
{"nl": "Types of Regression Techniques", "code": "\r\n# importing libraries\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom sklearn.linear_model import LinearRegression\r\n \r\nx = 11 * np.random.random((10, 1))\r\n \r\n# y = a * x + b\r\ny = 1.0 * x + 3.0\r\n \r\n# create a linear regression model\r\nmodel = LinearRegression()\r\nmodel.fit(x, y)\r\n \r\n# predict y from the data where the x is predicted from the x\r\nx_pred = np.linspace(0, 11, 100)\r\ny_pred = model.predict(x_pred[:, np.newaxis])\r\n \r\n# plot the results\r\nplt.figure(figsize =(3, 5))\r\nax = plt.axes()\r\nax.scatter(x, y)\r\n \r\nax.plot(x_pred, y_pred)\r\nax.set_xlabel('predictors')\r\nax.set_ylabel('criterion')\r\nax.axis('tight')\r\n \r\nplt.show()"}
{"nl": "the node at which the two lists intersect", "code": "class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pA = headA\n        pB = headB\n\n        while pA != pB:\n            pA = headB if pA is None else pA.next\n            pB = headA if pB is None else pB.next\n\n        return pA\n        # Note: In the case lists do not intersect, the pointers for A and B\n        # will still line up in the 2nd iteration, just that here won't be\n        # a common node down the list and both will reach their respective ends\n        # at the same time. So pA will be NULL in that case."}
{"nl": "The minimum positive deci-binary numbers to sum up to n", "code": "def minPartitions(self, x):\n  return int(max(x))"}
{"nl": "Check Factors", "code": "def check_factors(factors, num):\n  return all([num%i == 0 for i in factors])"}
{"nl": "Check if it is possible to form the array from pieces", "code": "class Solution:\n  def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n  mp = {x[0]: x for x in pieces}\n  res = []\n  \n  for num in arr:\n  res += mp.get(num, [])\n  \n  return res == arr"}
{"nl": "Decimal to Binary in Python", "code": "# Python program to convert decimal to binary # take input num = int(input('Enter any decimal number: ')) # display result print('Binary value:', bin(num))"}
{"nl": "Find k-th smallest element in BST (Order Statistics in BST)", "code": "# A simple inorder traversal based Python3\n# program to find k-th smallest element\n# in a BST.\n\u00a0\n# A BST node\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n# Recursive function to insert an key into BST\ndef insert(root, x):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(x)\n\u00a0\u00a0\u00a0\u00a0if (x < root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, x)\n\u00a0\u00a0\u00a0\u00a0elif (x > root.data):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, x)\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# Function to find k'th largest element\n# in BST. Here count denotes the number\n# of nodes processed so far\ndef kthSmallest(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0global k\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case\n\u00a0\u00a0\u00a0\u00a0if (root == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Search in left subtree\n\u00a0\u00a0\u00a0\u00a0left = kthSmallest(root.left)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If k'th smallest is found in\n\u00a0\u00a0\u00a0\u00a0# left subtree, return it\n\u00a0\u00a0\u00a0\u00a0if (left != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If current element is k'th\n\u00a0\u00a0\u00a0\u00a0# smallest, return it\n\u00a0\u00a0\u00a0\u00a0k -= 1\n\u00a0\u00a0\u00a0\u00a0if (k == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Else search in right subtree\n\u00a0\u00a0\u00a0\u00a0return kthSmallest(root.right)\n\u00a0\n# Function to find k'th largest element in BST\ndef printKthSmallest(root):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Maintain index to count number\n\u00a0\u00a0\u00a0\u00a0# of nodes processed so far\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0res = kthSmallest(root)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (res == None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"There are less than k nodes in the BST\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"K-th Smallest Element is \", res.data)\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0keys = [ 20, 8, 22, 4, 12, 10, 14 ]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for x in keys:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = insert(root, x)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0k = 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0printKthSmallest(root)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Solve the zebra puzzle", "code": "import itertools\nppl = 'Norwegian Englishman Ukrainian Spaniard Japanese'.split()\ndef drinks_water():\n    x,_ = solve()\n    return ppl[x]\ndef owns_zebra():\n    _,x = solve()\n    return ppl[x]\ndef solve():\n    g = ((water, zebra)\n        for (red, green, ivory, yellow, blue) in itertools.permutations(range(5))\n        if green - ivory == 1\n        for (norway, english, ukraine, spain, japan) in itertools.permutations(range(5))\n        if norway == 0\n        if english == red\n        for (dog, fox, snails, horse, zebra) in itertools.permutations(range(5))\n        if spain == dog\n        for (coffee, tea, milk, orange, water) in itertools.permutations(range(5))\n        if coffee == green\n        if ukraine == tea\n        if milk == 2\n        for (oldgold, kools, chesterfields, luckystrike, parliaments) in itertools.permutations(range(5))\n        if oldgold == snails\n        if kools == yellow\n        if abs(chesterfields - fox) == 1\n        if abs(kools - horse) == 1\n        if luckystrike == orange\n        if parliaments == japan\n        if abs(norway - blue) == 1\n        )\n    return next(g)"}
{"nl": "implement a robot class to simulate a robot moving", "code": "class Robot:\n\n    def __init__(self, width: int, height: int):\n        self.direction = \"East\"  # Faces East at the start\n        self.position = [0, 0]  # Is at position (0,0) on the board at the start\n        self.moved = False # Had to add this so if we're at 0,0 and we moved, we're facing south and not East\n        \n    def step(self, num: int) -> None:\n\n        dictio = {\n            \"South\": (-1, 0),\n            \"East\": (0, 1),\n            \"North\": (1, 0),\n            \"West\": (0, -1)\n        }\n\n        horizontal = len(self.board[0]) # Width of the board\n        vertical = len(self.board) # Height of the board\n\n        steps = num % (horizontal * 2 + vertical * 2 - 4) # 1 complete lap is 2 times the width + 2 times the height - 4 (-4 because we don't wanna count every corners twice for one lap)\n        self.moved = True\n        while steps > 0: # We'll now do the steps that will actually move the robot from its position\n            if 0 <= self.position[0] + dictio.get(self.direction)[0] < vertical and 0 <= self.position[1] + dictio.get(self.direction)[1] < horizontal:\n                self.position[0] += dictio.get(self.direction)[0]\n                self.position[1] += dictio.get(self.direction)[1]\n                steps -= 1\n\n                if steps == 0:\n                    break\n            else:\n                # Change direction of the robot since we can't move anymore in that direction (out of bounds)\n                if self.direction != \"West\": # If it's not west, we just wanna get the next one\n                    new_direction = list(dictio.keys())[list(dictio.keys()).index(self.direction) + 1]  # Get the following direction from the dict\n                else: # If it's West, just change our direction to South\n                    new_direction = \"South\"\n                self.direction = new_direction\n\n\n\n\n    def getPos(self):\n        return self.position[::-1]\n\n    def getDir(self):\n        if self.moved and self.position[0] == 0 and self.position[1] == 0:\n            self.direction = \"South\"\n            return self.direction\n        else:\n            return self.direction"}
{"nl": "Temperature Converter", "code": "def convert(deg):\n    try:\n      temp, unit = deg.split('*')\n    except:\n      return 'Error'\n        if unit == 'F':\n      return str(round((int(temp) - 32) / 1.8)) + '*' + 'C'\n          if unit == 'C':\n      return str(round((int(temp) * 1.8) + 32)) + '*' + 'F'"}
{"nl": "The maxmium total we can get obatain from choosing optimally top coins from coin piles", "code": "class Solution:\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\n        \n        @functools.lru_cache(None)\n        def dp(i, k):\n            if k == 0 or i == 0:\n                return 0\n            \n            max_value, curr_pile, curr_sum = dp(i - 1, k), piles[i - 1], 0\n            for j in range(min(len(curr_pile), k)):\n                curr_sum += curr_pile[j]\n                max_value = max(max_value, curr_sum + dp(i - 1, k - j - 1))\n            return max_value\n\n        # dp(i, k) means max value for first i piles with k coins\n        return dp(len(piles), k)"}
{"nl": "Check if a Binary Tree (not BST) has duplicate values", "code": "\"\"\" Program to check duplicates\n# in Binary Tree \"\"\"\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pointers.\t\t\t\t\t\t\t\t\nclass newNode:\n\n\t# Construct to create a new node\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\ndef checkDupUtil( root, s) :\n\n\t# If tree is empty, there are no\n\t# duplicates.\n\tif (root == None) :\n\t\treturn False\n\n\t# If current node's data is already present.\n\tif root.data in s:\n\t\treturn True\n\n\t# Insert current node\n\ts.add(root.data)\n\t\n\t# Recursively check in left and right\n\t# subtrees.\n\treturn checkDupUtil(root.left, s) or checkDupUtil(root.right, s)\n\n\n# To check if tree has duplicates\ndef checkDup( root) :\n\n\ts=set()\n\treturn checkDupUtil(root, s)\n\n\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(2)\n\troot.left.left = newNode(3)\n\tif (checkDup(root)):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Exercise working with loops: determine if a word is an isogram, if all letters in the word are unique", "code": "def is_isogram(string: str) -> bool:\r\n    letters = set()\r\n    for c in (c.lower() for c in string if c.isalpha()):\r\n        if c in letters:\r\n            return False\r\n        letters.add(c)\r\n    return True"}
{"nl": "Python Program to Print All Co-binary Palindromic Numbers in a Range", "code": "# Create a function checkpalindromicNumb() which accepts the string as an argument and\n \n # returns true if the string is palindrome else it returns False.\n \n def checkpalindromicNumb(val):\n \n  return val == val[::-1]\n \n # Create a function convertBinar() which converts the given number to binary and returns it.\n \n def convertBinar(orinumb):\n \n  return bin(orinumb)[2:]\n \n # Give the lower limit range as static input and store it in a variable.\n \n lowlimrange = 11\n \n # Give the upper limit range as static input and store it in another variable.\n \n upplimrange = 2426\n \n print('The Co-binary palindrome numbers in the given range',\n \n  lowlimrange, 'and', upplimrange, 'are:')\n \n # Loop from lower limit range to upper limit range using For loop.\n \n for itervalu in range(lowlimrange, upplimrange+1):\n \n  # Convert this iterator value to binary by passing it as an argument\n \n  # to convertBinar() function and store it in a variable say binarystrng.\n \n  binarystrng = convertBinar(itervalu)\n \n  # Convert this iterator value to a string\n \n  # using the str() function say strngnumb.\n \n  strngnumb = str(itervalu)\n \n  # Check if the strngnumb is palindrome or not by giving the given strngnumb\n \n  # as an argument to checkpalindromicNumb().\n \n  # Check if the binarystrng is palindrome or not by giving the given binarystrng\n \n  # as an argument to checkpalindromicNumb().\n \n  # Check if both statements are true using the and operator and If conditional Statement.\n \n  if(checkpalindromicNumb(binarystrng) and checkpalindromicNumb(strngnumb)):\n \n  # If it is true then print it.\n \n  print(strngnumb, end=' ')\n \n </pre>"}
{"nl": "Subset of a Cartasian Product", "code": "def relation_lst(lst):\n    return sorted([(x,y) for x in lst for y in lst if x <= y])"}
{"nl": "Temperature Converter", "code": "def converter(a, b):\n    a, t = a\n    d = {('celsius', 'kelvin'): t + 273.15, \n         ('celsius', 'fahrenheit'): t * 9/5 + 32, \n         ('fahrenheit', 'celsius'): (t - 32) * 5/9, \n         ('fahrenheit', 'kelvin'): (t + 459.67) * 5/9, \n         ('kelvin', 'celsius'): t - 273.15, \n         ('kelvin', 'fahrenheit'): t * 9/5 - 459.67}\n    return round(d[(a, b)], 1)"}
{"nl": "Calculate GST", "code": "# Give the original price as static input and store it in a variable.\n gvn_Orignl_amt = 520\n # Give the net price as static input and store it in another variable.\n gvn_Net_amt = 650\n # Calculate the GST amount by using the above given formula and store it in\n # another variable.\n GST_amnt = gvn_Net_amt - gvn_Orignl_amt\n # Calculate the given GST percentage by using the above given formula and\n # store it in another variable.\n gvn_GST_percnt = ((GST_amnt * 100) / gvn_Orignl_amt)\n # Print the given GST value for the above given original and net prices.\n print(\"The GST percent for the above given input net and original prices = \",\n  gvn_GST_percnt, end='')\n print(\"%\")"}
{"nl": "Python File isatty() Method", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.isatty())"}
{"nl": "find maximum points you can get on an exam given an array pf questions with their points and brainpower required", "code": "class Solution:\n    def mostPoints(self, questions: List[List[int]]) -> int:\n        dp = {}\n        \n        def helper(i):\n            if i >= len(questions):\n                return 0\n            \n            if i in dp:\n                return dp[i]\n            \n            points, power = questions[i]\n            dp[i] = max(helper(i + 1), helper(i + 1 + power) + points)\n            return dp[i]\n        \n        return helper(0)"}
{"nl": "Smallest of three integers without comparison operators", "code": "# Python3 program to find Smallest\n# of three integers without\n# comparison operators\n\ndef smallest(x, y, z):\n\tc = 0\n\t\n\twhile ( x and y and z ):\n\t\tx = x-1\n\t\ty = y-1\n\t\tz = z-1\n\t\tc = c + 1\n\n\treturn c\n\n# Driver Code\nx = 12\ny = 15\nz = 5\nprint(\"Minimum of 3 numbers is\",\n\tsmallest(x, y, z))\n\n# This code is contributed by Anshika Goyal\n"}
{"nl": "Happy Birthday! \ud83c\udf69", "code": "def happy_birthday(age):\n  return \"Mubashir is just {}, in base {}!\".format(20 + age%2, age//2)"}
{"nl": "Python Program to Print Downward Triangle Mirrored Alphabets Pattern\n", "code": "rows = int(input(\"Enter Downward Triangle Mirrored Alphabets Rows = \"))\n\nprint(\"====Downward Triangle of Mirrored Alphabets Pattern====\")\nalphabet = 65\n\nfor i in range(rows):\n    for j in range(i, rows):\n        print('%c' %(alphabet + j), end = ' ')\n    for k in range(rows - 2, i - 1, -1):\n        print('%c' %(alphabet + k), end = ' ')       \n    print()"}
{"nl": "Less or Equal", "code": "def less_or_equal(lst, k):\n    r = [1] + sorted(lst)    \n    return r[k] if len(lst) == k or r[k] != r[k + 1] else None"}
{"nl": "Find all sub square in a square matrix", "code": "# A simple Python 3 program to find sum\n# of all subsquares of size k x k\n \n# Size of given matrix\nn = 5\n \n# A simple function to find sum of all\n# sub-squares of size k x k in a given\n# square matrix of size n x n\ndef printSumSimple(mat, k):\n \n    # k must be smaller than or equal to n\n    if (k > n):\n        return\n \n    # row number of first cell in current\n    # sub-square of size k x k\n    for i in range(n - k + 1):\n     \n        # column of first cell in current\n        # sub-square of size k x k\n        for j in range(n - k + 1):\n             \n            # Calculate and print sum of\n            # current sub-square\n            sum = 0\n            for p in range(i, k + i):\n                for q in range(j, k + j):\n                    sum += mat[p][q]\n            print(sum, end = \" \")\n     \n        # Line separator for sub-squares\n        # starting with next row\n        print()\n \n# Driver Code\nif __name__ == \"__main__\":\n \n    mat = [[1, 1, 1, 1, 1],\n           [2, 2, 2, 2, 2],\n           [3, 3, 3, 3, 3],\n           [4, 4, 4, 4, 4],\n           [5, 5, 5, 5, 5]]\n    k = 3\n    printSumSimple(mat, k)\n \n# This code is contributed by ita_c"}
{"nl": "Genetic Algorithm for reinforcement learning", "code": "\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n  \r\n# specifying the size for each and \r\n# every matplotlib plot globally\r\nplt.rcParams['figure.figsize'] = [8, 6] \r\n  \r\n# defining list objects with range of the graph\r\nx1_range = [-100, 100]\r\nx2_range = [-100, 100]\r\n  \r\n# empty list object to store the population\r\npopulation = []\r\n  \r\n# this function is used to generate the population\r\n# and appending it to the population list defined above\r\n# it takes the attributes as no. of features in a \r\n# population and size that we have in it\r\ndef populate(features, size = 1000):\r\n      \r\n    # here we are defining the coordinate \r\n    # for each entity in a population\r\n    initial = [] \r\n      \r\n    for _ in range(size):\r\n        entity = []\r\n        for feature in features:\r\n              \r\n            # this * feature variable unpacks a list \r\n            # or tuple into position arguments.\r\n            val = np.random.randint(*feature)\r\n            entity.append(val)\r\n        initial.append(entity)\r\n      \r\n    return np.array(initial)\r\n  \r\n# defining the virus in the form of numpy array\r\nvirus = np.array([5, 5])\r\n  \r\n# only the 100 fit ones will survive in this one\r\ndef fitness(population, virus, size = 100):\r\n      \r\n    scores = []\r\n      \r\n    # enumerate also provides the index as for the iterator\r\n    for index, entity in enumerate(population): \r\n        score = np.sum((entity-virus)**2)\r\n        scores.append((score, index))\r\n      \r\n    scores = sorted(scores)[:size]\r\n      \r\n    return np.array(scores)[:, 1]\r\n  \r\n# this function is used to plot the graph\r\ndef draw(population, virus):\r\n    plt.xlim((-100, 100))\r\n    plt.ylim((-100, 100))\r\n    plt.scatter(population[:, 0], population[:, 1], c ='green', s = 12)\r\n    plt.scatter(virus[0], virus[1], c ='red', s = 60) \r\n      \r\n      \r\ndef reduction(population, virus, size = 100):\r\n      \r\n    # only the index of the fittest ones\r\n    # is returned in sorted format\r\n    fittest = fitness(population, virus, size) \r\n  \r\n    new_pop = []\r\n      \r\n    for item in fittest:\r\n        new_pop.append(population[item])\r\n          \r\n    return np.array(new_pop)\r\n  \r\n# cross mutation in order to generate the next generation\r\n# of the population which will be more immune to virus than previous\r\ndef cross(population, size = 1000):\r\n      \r\n    new_pop = []\r\n      \r\n    for _ in range(size):\r\n        p = population[np.random.randint(0, len(population))]\r\n        m = population[np.random.randint(0, len(population))]\r\n      \r\n        # we are only considering half of each \r\n        # without considering random selection\r\n        entity = []\r\n        entity.append(*p[:len(p)//2])\r\n        entity.append(*m[len(m)//2:])\r\n          \r\n        new_pop.append(entity)\r\n      \r\n    return np.array(new_pop)\r\n  \r\n# generating and adding the random features to\r\n# the entity so that it looks more distributed\r\ndef mutate(population):\r\n      \r\n    return population + np.random.randint(-10, 10, 2000).reshape(1000, 2)\r\n  \r\n  \r\n# the complete cycle of the above steps\r\npopulation = populate([x1_range, x2_range], 1000)\r\n  \r\n# gens is the number of generation\r\ndef cycle(population, virus, gens = 1): \r\n      \r\n    # if we change the value of gens, we'll get \r\n    # next and genetically more powerful generation\r\n    # of the population\r\n    for _ in range(gens):\r\n        population = reduction(population, virus, 100)\r\n        population = cross(population, 1000)\r\n        population = mutate(population)\r\n          \r\n    return population\r\n  \r\npopulation = cycle(population, virus)\r\n  \r\ndraw(population, virus)"}
{"nl": "Adjacency list representation of graph", "code": "\"\"\"\r\nA Python program to demonstrate the adjacency\r\nlist representation of the graph\r\n\"\"\"\r\n \r\n# A class to represent the adjacency list of the node\r\n \r\n \r\nclass AdjNode:\r\n    def __init__(self, data):\r\n        self.vertex = data\r\n        self.next = None\r\n \r\n \r\n# A class to represent a graph. A graph\r\n# is the list of the adjacency lists.\r\n# Size of the array will be the no. of the\r\n# vertices \"V\"\r\nclass Graph:\r\n    def __init__(self, vertices):\r\n        self.V = vertices\r\n        self.graph = [None] * self.V\r\n \r\n    # Function to add an edge in an undirected graph\r\n    def add_edge(self, src, dest):\r\n        # Adding the node to the source node\r\n        node = AdjNode(dest)\r\n        node.next = self.graph[src]\r\n        self.graph[src] = node\r\n \r\n        # Adding the source node to the destination as\r\n        # it is the undirected graph\r\n        node = AdjNode(src)\r\n        node.next = self.graph[dest]\r\n        self.graph[dest] = node\r\n \r\n    # Function to print the graph\r\n    def print_graph(self):\r\n        for i in range(self.V):\r\n            print(\"Adjacency list of vertex {}\\n head\".format(i), end=\"\")\r\n            temp = self.graph[i]\r\n            while temp:\r\n                print(\" -> {}\".format(temp.vertex), end=\"\")\r\n                temp = temp.next\r\n            print(\" \\n\")\r\n \r\n \r\n# Driver program to the above graph class\r\nif __name__ == \"__main__\":\r\n    V = 5\r\n    graph = Graph(V)\r\n    graph.add_edge(0, 1)\r\n    graph.add_edge(0, 4)\r\n    graph.add_edge(1, 2)\r\n    graph.add_edge(1, 3)\r\n    graph.add_edge(1, 4)\r\n    graph.add_edge(2, 3)\r\n    graph.add_edge(3, 4)\r\n \r\n    graph.print_graph()\r\n \r\n# This code is contributed by Kanav Malhotra\r"}
{"nl": "build an array to process tasks using servers", "code": "class Solution:\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\n        time=0\n        heap=[(weight,index) for index,weight in enumerate(servers)]\n        heapq.heapify(heap)\n        task_pointer=0\n        processing=[]\n        assingment=[-1 for task in tasks]\n        last_task=len(tasks)-1\n        \n        while task_pointer<=last_task:\n            while processing and processing[0][0]<=time:\n                time_freed,weight,server_index=heapq.heappop(processing)\n                heapq.heappush(heap,(weight,server_index))\n            while heap and task_pointer<=min(time,last_task):\n                weight,server_index=heapq.heappop(heap)\n                assingment[task_pointer]=server_index\n                heapq.heappush(processing,(time+tasks[task_pointer],weight,server_index))\n                task_pointer+=1\n            if heap:\n                time+=1\n            else:\n                time=processing[0][0]\n        \n        return assingment"}
{"nl": "Program for Set clear() Method in Python", "code": "# Give the set as static input and initialize it with some random values.\n# Store it in a variable.\ngven_set = {'hello', 'this', 'is', 'btechgeeks'}\n# Print the above-given set.\nprint(\"The given set is :\")\nprint(gven_set)\n# Clear the values of the given set by applying clear() function to the given set.\ngven_set.clear()\n# Print the above-given set after clearing all the values.\nprint(\"The given set after clearing all the values :\")\nprint(gven_set)"}
{"nl": "List of Prime Factors", "code": "def prime_factorization(n):\n  i, fact = 2, []\n  while n>1:\n    while n%i==0:\n      fact+= [i]\n      n//= i\n    i+= 1\n  return fact"}
{"nl": "Reformat the phone number", "code": "def reformatNumber(self, number: str) -> str:\n  return re.sub('(...?(?=..))', r'\\1-', re.sub('\\D', '', number))"}
{"nl": "Index Filtering", "code": "index_filter=lambda i,s:''.join(s[x].lower()for x in i)"}
{"nl": "Find the first circular tour that visits all petrol pumps", "code": "# Python program to find circular tour for a truck\n# In this approach we will start the tour from the first petrol pump\n# then while moving to the next pumps in the loop we will store the cumulative\n# information that whether we have a deficit of petrol at the current pump or not\n# If there is a deficit then we will add it to the deficit value calculated\n# till the previous petrol pump and then update the starting point to the next pump\n# and reset the petrol available in the truck as 0\n\n# This function return starting point if there is a possible\n# solution otherwise returns -1\ndef printTour(arr,n):\n\t\n\t# Consider first petrol pump as starting point\n\tstart = 0\n\t# These two variable will keep tracking if there is\n\t# surplus(s) or deficit(d) of petrol in the truck\n\ts = 0\t\t # petrol available the truck till now\n\td = 0\t # deficit of petrol till visiting this petrol pump\n\t\n\t# Start from the first petrol pump and complete one loop\n\t# of visiting all the petrol pumps and keep updating s and d at each pump\n\tfor i in range(n):\n\ts += arr[i][0] - arr[i][1]\n\tif s < 0:\t\t # the truck has a deficit of petrol\n\t\tstart = i+1\t # change the starting point\n\t\td += s\t\t # storing the deficit of petrol till current petrol pump\n\t\ts = 0\t\t # starting again from new station\n\t\n\t# when we reach first petrol pump again and sum of the petrol available at the truck\n\t# and the petrol deficit till now is 0 or more petrol then return the starting point\n\t# else return -1\n\treturn start if (s+d)>=0 else -1\n\n\n# Driver program to test above function\narr = [[6,4], [3,6], [7,3]]\nstart = printTour(arr,3)\nif start == -1:\nprint(\"No Solution Possible !!!\")\nelse:\nprint(\"start = {}\".format(start))\n\n# This code is contributed by Antara Das(anny)"}
{"nl": "Python Program to Transpose a Matrix", "code": "# Define a matrix A  \nA = [[5, 4, 3],  \n         [2, 4, 6],  \n         [4, 7, 9],  \n         [8, 1, 3]]  \n# Define an empty matrix of reverse order  \ntransResult = [[0, 0, 0, 0],    \n                             [0, 0, 0, 0],  \n                             [0, 0, 0, 0]]  \n# Use nested for loop on matrix A  \nfor a in range(len(A)):    \n   for b in range(len(A[0])):    \n          transResult[b][a] = A[a][b] # store transpose result on empty matrix          \n# Printing result in the output  \nprint(\"The transpose of matrix A is: \")  \nfor res in transResult:    \n   print(res)  "}
{"nl": "Sort a String by Its Last Character", "code": "def sort_by_last(txt):\n  return ' '.join(sorted(txt.split(), key=lambda x: x[-1]))"}
{"nl": "Check if String Ending Matches Second String", "code": "def check_ending(str1, str2):\n  return str1.endswith(str2)"}
{"nl": "Python math.erf() Method", "code": "# Import math Library\r\nimport math\r\n\r\n# Print error function for different numbers\r\nprint (math.erf(0.67))\r\nprint (math.erf(1.34))\r\nprint (math.erf(-6))"}
{"nl": "Matrix Multiplication Program in Python", "code": "# Python program to multiply two matrices using numpy # import NumPy library import numpy # take inputs m1 = [[1, 7], [4, 5]] m2 = [[5, 3], [4, 2]] res = [[0, 0], [0, 0]] # multiply matrix print(\"Matrix Multiplication: \") result = numpy.dot(m1, m2) for row in result: print(row)"}
{"nl": "Using a Trie to implement Reverse DNS Look Up Cache", "code": "# Trie Node\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.child = [None] * 11\r\n        self.url = None\r\n        self.is_end = False\r\n \r\nclass Trie:\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n     \r\n    def getIndex(self, c):\r\n        # For the . (dot) in IP address, we'll use the 10th index in child list\r\n        return 10 if c == '.' else int(c)\r\n     \r\n    def insert(self, ip, domain):\r\n        cur = self.root\r\n        n = len(ip)\r\n         \r\n        for level in range(n):\r\n            # We'll use the digits of IP address to form the trie structure\r\n            idx = self.getIndex(ip[level])\r\n             \r\n            if cur.child[idx] is None:\r\n                # Create a new trie node if not available for a particular digit\r\n                # and assign to the respective index\r\n                cur.child[idx] = TrieNode()\r\n                 \r\n            cur = cur.child[idx]\r\n         \r\n        # At the end, we'll map the domain name and mark the end node\r\n        cur.url = domain\r\n        cur.is_end = True\r\n     \r\n    def search_domain(self, ip):\r\n        cur = self.root\r\n        n = len(ip)\r\n         \r\n        # Traverse through the trie structure with all digits in ip address\r\n        for level in range(n):\r\n            idx = self.getIndex(ip[level])\r\n            if cur.child[idx] is None:\r\n                return \"Domain name not found\"\r\n             \r\n            cur = cur.child[idx]\r\n         \r\n        # Returns the url when all the digits in ip found\r\n        if cur and cur.url:\r\n            return cur.url\r\n         \r\n        return \"Domain name not found\"\r\n \r\n# Driver Code\r\nip = [\"107.108.11.123\", \"107.109.123.255\", \"74.125.200.106\"]\r\ndomain = [\"www.samsung.com\", \"www.samsung.net\", \"www.google.co.in\"]\r\n \r\ntrie = Trie()\r\nfor idx in range(len(ip)):\r\n    trie.insert(ip[idx], domain[idx])\r\n \r\nprint(trie.search_domain(\"107.109.123.255\"))\r\nprint(trie.search_domain(\"107.109.123.245\"))\r\n \r\n# This code is contributed by Abhilash Pujari"}
{"nl": "Update set1 by adding items from set2", "code": "set1 = {10, 20, 30, 40, 50}\r\nset2 = {30, 40, 50, 60, 70}\r\n\r\nset1.symmetric_difference_update(set2)\r\nprint(set1)"}
{"nl": "Beginning and End Pairs", "code": "def pairs(lst):\n  return [[lst[i], lst[-(i+1)]] for i in range((len(lst)+1) //  2)]"}
{"nl": "Return a random number from a given list, with the exception of a given number n", "code": "# Import the random module using the import statement.\r\nimport random\r\n# Give the list as static input and store it in a variable.\r\ngvnlst = [12, 42, 48, 19, 24, 29, 23, 11, 19, 5, 7, 31, 39, 45, 47, 49]\r\n# Give the number as static input and store it in a variable.\r\nnumbr = 24\r\n# Using List Comprehension create a new list that does not contain the given number.\r\nnwlist = [elmnt for elmnt in gvnlst if elmnt != numbr]\r\n# Using the random. choice() function generates some random element in the given list.\r\nrndm_numbrr = random.choice(nwlist)\r\n# Print the random element in the given list.\r\nprint('The Random Element in the given list', gvnlst, 'is [', rndm_numbrr, ']'"}
{"nl": "Pi to N Decimal Places", "code": "from math import pi\ndef my_pi(n):\n  return round(pi, n)"}
{"nl": "Node insertion in Circular Linked List", "code": "prev = current"}
{"nl": "Function that outputs an encrypted letter string of a decrypted Mmorse code.", "code": "def morse(txt):\r\n    encrypt = {'A':'.-', 'B':'-...', 'C':'-.-.', 'D':'-..', 'E':'.', 'F':'..-.', \r\n                'G':'--.', 'H':'....', 'I':'..', 'J':'.---', 'K':'-.-', 'L':'.-..', \r\n                'M':'--', 'N':'-.', 'O':'---', 'P':'.--.', 'Q':'--.-', 'R':'.-.', \r\n                'S':'...', 'T':'-', 'U':'..-', 'V':'...-', 'W':'.--', 'X':'-..-', \r\n                'Y':'-.--', 'Z':'--..', ' ':'.....'}\r\n    decrypt = {v: k for k, v in encrypt.items()}\r\n    \r\n    if '-' in txt:\r\n        return ''.join(decrypt[i] for i in txt.split())\r\n    return ' '.join(encrypt[i] for i in txt.upper())"}
{"nl": "Change the array into a permutation of numbers from 1 to n", "code": "# Python3 code to make a permutation\n# of numbers from 1 to n using\n# minimum changes.\n\ndef makePermutation (a, n):\n\n\t# Store counts of all elements.\n\tcount = dict()\n\tfor i in range(n):\n\t\tif count.get(a[i]):\n\t\t\tcount[a[i]] += 1\n\t\telse:\n\t\t\tcount[a[i]] = 1;\n\t\t\n\tnext_missing = 1\n\tfor i in range(n):\n\t\tif count[a[i]] != 1 or a[i] > n or a[i] < 1:\n\t\t\tcount[a[i]] -= 1\n\t\t\t\n\t\t\t# Find next missing element to put\n\t\t\t# in place of current element.\n\t\t\twhile count.get(next_missing):\n\t\t\t\tnext_missing+=1\n\t\t\t\n\t\t\t# Replace with next missing and\n\t\t\t# insert the missing element in hash.\n\t\t\ta[i] = next_missing\n\t\t\tcount[next_missing] = 1\n\n# Driver Code\nA = [ 2, 2, 3, 3 ]\nn = len(A)\nmakePermutation(A, n)\n\nfor i in range(n):\n\tprint(A[i], end = \" \")\n\t\n# This code is contributed by \"Sharad_Bhardwaj\"."}
{"nl": "Python statistics.harmonic_mean() Method\r\n\r\n", "code": "# Import statistics Library\r\nimport statistics\r\n\r\n# Calculate harmonic mean\r\nprint(statistics.harmonic_mean([40, 60, 80]))\r\nprint(statistics.harmonic_mean([10, 30, 50, 70, 90]))"}
{"nl": "Function that calculates the nth Fibonacci number.", "code": "def fib(n):\r\n    return fib(n - 1) + fib(n - 2) if n > 1 else n"}
{"nl": "Connecting Nodes at the same Level", "code": "# Python3 program to connect nodes at same\n# level using extended pre-order traversal\n\nclass newnode:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = self.right = self.nextRight = None\n\t\t\n# Sets the nextRight of root and calls\n# connectRecur() for other nodes\ndef connect (p):\n\t\n\t# Set the nextRight for root\n\tp.nextRight = None\n\n\t# Set the next right for rest of\n\t# the nodes (other than root)\n\tconnectRecur(p)\n\n# Set next right of all descendants of p.\n# Assumption: p is a complete binary tree\ndef connectRecur(p):\n\t\n\t# Base case\n\tif (not p):\n\t\treturn\n\t\n\t# Set the nextRight pointer for p's\n\t# left child\n\tif (p.left):\n\t\tp.left.nextRight = p.right\n\t\n\t# Set the nextRight pointer for p's right\n\t# child p.nextRight will be None if p is\n\t# the right most child at its level\n\tif (p.right):\n\t\tif p.nextRight:\n\t\t\tp.right.nextRight = p.nextRight.left\n\t\telse:\n\t\t\tp.right.nextRight = None\n\t\n\t# Set nextRight for other nodes in\n\t# pre order fashion\n\tconnectRecur(p.left)\n\tconnectRecur(p.right)\n\n# Driver Code\nif __name__ == '__main__':\n\n\t# Constructed binary tree is\n\t# 10\n\t#\t / \\\n\t# 8\t 2\n\t# /\n\t# 3\n\troot = newnode(10)\n\troot.left = newnode(8)\n\troot.right = newnode(2)\n\troot.left.left = newnode(3)\n\n\t# Populates nextRight pointer in all nodes\n\tconnect(root)\n\n\t# Let us check the values of nextRight pointers\n\tprint(\"Following are populated nextRight\",\n\t\t\"pointers in the tree (-1 is printed\",\n\t\t\t\t\t\"if there is no nextRight)\")\n\tprint(\"nextRight of\", root.data, \"is \", end = \"\")\n\tif root.nextRight:\n\t\tprint(root.nextRight.data)\n\telse:\n\t\tprint(-1)\n\tprint(\"nextRight of\", root.left.data, \"is \", end = \"\")\n\tif root.left.nextRight:\n\t\tprint(root.left.nextRight.data)\n\telse:\n\t\tprint(-1)\n\tprint(\"nextRight of\", root.right.data, \"is \", end = \"\")\n\tif root.right.nextRight:\n\t\tprint(root.right.nextRight.data)\n\telse:\n\t\tprint(-1)\n\tprint(\"nextRight of\", root.left.left.data, \"is \", end = \"\")\n\tif root.left.left.nextRight:\n\t\tprint(root.left.left.nextRight.data)\n\telse:\n\t\tprint(-1)\n\n# This code is contributed by PranchalK\n"}
{"nl": "Minimize Cash Flow among a given set of friends who have borrowed money from each other", "code": "# Python3 program to find maximum\n# cash flow among a set of persons\n\u00a0\n# Number of persons(or vertices in graph)\nN = 3\n\u00a0\n# A utility function that returns\n# index of minimum value in arr[]\ndef getMin(arr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0minInd = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i] < arr[minInd]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minInd = i\n\u00a0\u00a0\u00a0\u00a0return minInd\n\u00a0\n# A utility function that returns\n# index of maximum value in arr[]\ndef getMax(arr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0maxInd = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arr[i] > arr[maxInd]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxInd = i\n\u00a0\u00a0\u00a0\u00a0return maxInd\n\u00a0\n# A utility function to\n# return minimum of 2 values\ndef minOf2(x, y):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return x if x < y else y\n\u00a0\n# amount[p] indicates the net amount to\n# be credited/debited to/from person 'p'\n# If amount[p] is positive, then i'th\n# person will amount[i]\n# If amount[p] is negative, then i'th\n# person will give -amount[i]\ndef minCashFlowRec(amount):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find the indexes of minimum\n\u00a0\u00a0\u00a0\u00a0# and maximum values in amount[]\n\u00a0\u00a0\u00a0\u00a0# amount[mxCredit] indicates the maximum\n\u00a0\u00a0\u00a0\u00a0# amount to be given(or credited) to any person.\n\u00a0\u00a0\u00a0\u00a0# And amount[mxDebit] indicates the maximum amount\n\u00a0\u00a0\u00a0\u00a0# to be taken (or debited) from any person.\n\u00a0\u00a0\u00a0\u00a0# So if there is a positive value in amount[],\n\u00a0\u00a0\u00a0\u00a0# then there must be a negative value\n\u00a0\u00a0\u00a0\u00a0mxCredit = getMax(amount)\n\u00a0\u00a0\u00a0\u00a0mxDebit = getMin(amount)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If both amounts are 0,\n\u00a0\u00a0\u00a0\u00a0# then all amounts are settled\n\u00a0\u00a0\u00a0\u00a0if (amount[mxCredit] == 0 and amount[mxDebit] == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find the minimum of two amounts\n\u00a0\u00a0\u00a0\u00a0min = minOf2(-amount[mxDebit], amount[mxCredit])\n\u00a0\u00a0\u00a0\u00a0amount[mxCredit] -=min\n\u00a0\u00a0\u00a0\u00a0amount[mxDebit] += min\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If minimum is the maximum amount to be\n\u00a0\u00a0\u00a0\u00a0print(\"Person \" , mxDebit , \" pays \" , min\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0, \" to \" , \"Person \" , mxCredit)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for the amount array. Note that\n\u00a0\u00a0\u00a0\u00a0# it is guaranteed that the recursion\n\u00a0\u00a0\u00a0\u00a0# would terminate as either amount[mxCredit]\n\u00a0\u00a0\u00a0\u00a0# or amount[mxDebit] becomes 0\n\u00a0\u00a0\u00a0\u00a0minCashFlowRec(amount)\n\u00a0\n# Given a set of persons as graph[] where\n# graph[i][j] indicates the amount that\n# person i needs to pay person j, this\n# function finds and prints the minimum\n# cash flow to settle all debts.\ndef minCashFlow(graph):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an array amount[],\n\u00a0\u00a0\u00a0\u00a0# initialize all value in it as 0.\n\u00a0\u00a0\u00a0\u00a0amount = [0 for i in range(N)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Calculate the net amount to be paid\n\u00a0\u00a0\u00a0\u00a0# to person 'p', and stores it in amount[p].\n\u00a0\u00a0\u00a0\u00a0# The value of amount[p] can be calculated by\n\u00a0\u00a0\u00a0\u00a0# subtracting debts of 'p' from credits of 'p'\n\u00a0\u00a0\u00a0\u00a0for p in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0amount[p] += (graph[i][p] - graph[p][i])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0minCashFlowRec(amount)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver code\n\u00a0\n# graph[i][j] indicates the amount\n# that person i needs to pay person j\ngraph = [ [0, 1000, 2000],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 0, 5000],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 0, 0] ]\n\u00a0\nminCashFlow(graph)\n\u00a0\n# This code is contributed by Anant Agarwal.\n"}
{"nl": "Python Program for Exponential Squaring (Fast Modulo Multiplication)", "code": "# Take a variable to say numb and initialize its value with 1000000007(10^9+7).\nnumb = 1000000007\n\n# Create a function to say exponentl_squaring() which takes the given two base and\n# exponential values as the arguments and returns the value of the power of base and\n# exponent modular 10^9+7.\n\n\ndef exponentl_squaring(gvn_baseval, gvn_exponentlval):\n  # Inside the function, take a variable say p, and initialize its value to 1.\n    p = 1\n    # Loop until the given exponential value is greater than 0 using the while loop.\n    while(gvn_exponentlval > 0):\n           # Check if the given exponential value is odd using the if conditional statement.\n        if (gvn_exponentlval % 2 != 0):\n            # If it is true, multiply p with the given base value and store it in another\n            # variable.\n            k = p * gvn_baseval\n            # Calculate the value of the above result modulus numb(10^9+7) and store it in the\n            # same variable p.\n            p = k % numb\n      # Multiply the given base value with itself and apply the modulus operator with\n      # 10^9+7(numb).\n      # Store it in the same variable given base value.\n        gvn_baseval = (gvn_baseval * gvn_baseval) % numb\n        # Divide the given exponential value by 2 and convert it to an integer using the\n        # int() function.\n        # Store it in the same variable given exponential value.\n        gvn_exponentlval = int(gvn_exponentlval / 2)\n   # Return the value of p modulus 10^9+7.\n    return p % numb\n\n# Give the base value as user input using the int(input()) function and store it in a variable.\ngvn_baseval = int(input(\"Enter some random number = \"))\n# Give the exponential value as user input using the int(input()) function and \n# store it in another variable.\ngvn_exponentlval = int(input(\"Enter some random number = \"))\n# Pass the given base and exponential values as the arguments to the exponentl_squaring()\n# function and store it in a variable.\nrslt = exponentl_squaring(gvn_baseval, gvn_exponentlval)\n# Print the value of the power of base and exponent modular 10^9+7.\nprint(\"The value of the power of base and exponent modular 10^9+7 = \", rslt)"}
{"nl": "Deletion in Unsorted Array", "code": "# Python program to delete an element\r\n# from an unsorted array\r\n\r\n# Declaring array and key to delete\r\narr = [10, 50, 30, 40, 20]\r\nkey = 30\r\n\r\nprint(\"Array before deletion:\")\r\nprint (arr)\r\n\r\n# deletes key if found in the array\r\n# otherwise shows error not in list\r\narr.remove(key)\r\nprint(\"Array after deletion\")\r\nprint(arr)\r\n\r\n# This code is contributed by Aditi Sharma.\r"}
{"nl": "Refactor a ledger printer", "code": "import datetime\nclass LedgerEntry(object):\n    def __init__(self, date, description, change):\n        self.date = datetime.datetime.strptime(date, '%Y-%m-%d')\n        self.description = description\n        self.change = change\n    def __eq__(self, other):\n        return (self.date == other.date\n                or self.change == other.change\n                or self.description == other.description)\n    def __lt__(self, other):\n        return (self.date < other.date\n                or self.change < other.change\n                or self.description < other.description)\ncreate_entry = LedgerEntry\ndef format_entries(currency, locale, entries):\n    return \"\\n\".join(format_iter(currency, locale, entries))\ndef format_iter(currency, locale, entries):\n    header = {\n        \"en_US\": \"Date|Description|Change\",\n        \"nl_NL\": \"Datum|Omschrijving|Verandering\"\n    }[locale].split(\"|\")\n    yield TableFormat().header(*header)\n    for entry in sorted(entries):\n        date = DateFormatter().format(entry.date, locale)\n        change = CurrencyFormatter().format(entry.change / 100.0, currency, locale)\n        yield TableFormat().row(date, entry.description, change)\ndef wrap(field, width):\n    # NOTE: normally, I use `textwrap.wrap` but it is aware of word-breaking,\n    # but the tests aren't...\n    return f\"{field[:width-3]}...\" if len(field) > width else field\nclass TableFormat:\n    def header(self, date, desc, change):\n        return f\"{wrap(date, 10):<10} | {wrap(desc, 25):<25} | {wrap(change, 13):<13}\"\n    def row(self, date, desc, change):\n        return f\"{wrap(date, 10):<10} | {wrap(desc, 25):<25} | {wrap(change, 13):>13}\"\nclass CurrencyFormatter:\n    def format(self, value, currency, locale):\n        # NOTE: normally I should use `locale` module to do this, but the tests\n        # provided don't follow international currency representation rules...\n        symbol = {\"USD\": \"$\", \"EUR\": \"\u20ac\"}[currency]\n        return getattr(self, f\"_polish_{locale[:2]}\")(f\"{value:,.2f}\", symbol)\n    def _polish_en(self, text, symbol):\n        if text.startswith(\"-\"):\n            return f\"({symbol}{text[1:]})\"\n        return f\" {symbol}{text} \"\n    def _polish_nl(self, text, symbol):\n        swap_symbols = dict(zip(\",.\", \".,\"))\n        text = \"\".join(swap_symbols.get(s, s) for s in text)\n        return f\"{symbol} {text} \"\nclass DateFormatter:\n    def format(self, date, locale):\n        snowflake_formats = { \"en_US\": \"%m/%d/%Y\" }\n        sane_person_format = \"%d-%m-%Y\"\n        return date.strftime(snowflake_formats.get(locale, sane_person_format))"}
{"nl": "Check Validity of Triangle Given Three Angles", "code": "# Validity of Triangle given angles\r\n\r\n# Function definition to check validity\r\ndef is_valid_triangle(a,b,c):\r\n    if a+b+c==180 and a!=0 and b!=0 and c!=0:\r\n        return True\r\n    else:\r\n        return False\r\n\r\n# Reading Three Angles\r\nangle_a = float(input('Enter angle a: '))\r\nangle_b = float(input('Enter angle b: '))\r\nangle_c = float(input('Enter angle c: '))\r\n\r\n# Function call & making decision\r\nif is_valid_triangle(angle_a, angle_b, angle_c):\r\n    print('Triangle is Valid.')\r\nelse:\r\n    print('Triangle is Invalid.')"}
{"nl": "Find common elemen in row sorted matrix", "code": "\n# Python 3 program to find a common element\n# in all rows of a row wise sorted array\n \n# Specify number of rows\n# and columns\nM = 4\nN = 5\n \n# Returns common element in all rows\n# of mat[M][N]. If there is no common\n# element, then -1 is returned\ndef findCommon(mat):\n \n    # An array to store indexes of\n    # current last column\n    column = [N - 1] * M\n \n    min_row = 0 # Initialize min_row as first row\n \n    # Keep finding min_row in current last\n    # column, till either all elements of\n    # last column become same or we hit first column.\n    while (column[min_row] >= 0):\n     \n        # Find minimum in current last column\n        for i in range(M):\n            if (mat[i][column[i]] <\n                mat[min_row][column[min_row]]):\n                min_row = i\n     \n        # eq_count is count of elements equal\n        # to minimum in current last column.\n        eq_count = 0\n \n        # Traverse current last column elements\n        # again to update it\n        for i in range(M):\n             \n            # Decrease last column index of a row\n            # whose value is more than minimum.\n            if (mat[i][column[i]] >\n                mat[min_row][column[min_row]]):\n                if (column[i] == 0):\n                    return -1\n \n                column[i] -= 1 # Reduce last column\n                               # index by 1\n         \n            else:\n                eq_count += 1\n \n        # If equal count becomes M, return the value\n        if (eq_count == M):\n            return mat[min_row][column[min_row]]\n    return -1\n \n# Driver Code\nif __name__ == \"__main__\":\n     \n    mat = [[1, 2, 3, 4, 5],\n           [2, 4, 5, 8, 10],\n           [3, 5, 7, 9, 11],\n           [1, 3, 5, 7, 9]]\n \n    result = findCommon(mat)\n    if (result == -1):\n        print(\"No common element\")\n    else:\n        print(\"Common element is\", result)\n \n# This code is contributed by ita_c"}
{"nl": "Find max possible profit by buying and selling a share at most twice", "code": "import sys\r\n \r\ndef maxtwobuysell(arr, size):\r\n    first_buy = -sys.maxsize;\r\n    first_sell = 0;\r\n    second_buy = -sys.maxsize;\r\n    second_sell = 0;\r\n \r\n    for i in range(size):\r\n \r\n        first_buy = max(first_buy, -arr[i]);\r\n        first_sell = max(first_sell, first_buy + arr[i]);\r\n        second_buy = max(second_buy, first_sell - arr[i]);\r\n        second_sell = max(second_sell, second_buy + arr[i]);\r\n \r\n     \r\n    return second_sell;\r\n \r\nif __name__ == '__main__':\r\n    arr = [ 2, 30, 15, 10, 8, 25, 80 ];\r\n    size = len(arr);\r\n    print(maxtwobuysell(arr, size));\r\n \r\n# This code is contributed by gauravrajput1"}
{"nl": "Calculate Area & Volume of Sphere", "code": "# Finding area and volume of sphere\r\n\r\n# importing math module for PI\r\nimport math\r\n\r\n# Reading temperature in Celsius\r\nradius = float(input('Enter radius of circle: '))\r\n\r\n# Calculating area and volume\r\narea = 4 * math.pi * radius ** 2\r\nvolume = (4/3) * math.pi * radius**3\r\n\r\n# Displaying output\r\nprint('Area = %0.4f.' % (area))\r\nprint('Volume = %0.4f.' % (volume))"}
{"nl": "Recursion: Length of a String", "code": "def length(s):\n  if s: return length(s[:-1]) + 1\n  return 0"}
{"nl": "Efficient Method to Check if a Number is Multiple of 3", "code": "# Python program to check if n is a multiple of 3\n\n# Function to check if n is a multiple of 3\ndef isMultipleOf3(n):\n\n\todd_count = 0\n\teven_count = 0\n\n\t# Make no positive if + n is multiple of 3\n\t# then is -n. We are doing this to avoid\n\t# stack overflow in recursion\n\tif(n < 0):\n\t\tn = -n\n\tif(n == 0):\n\t\treturn 1\n\tif(n == 1):\n\t\treturn 0\n\n\twhile(n):\n\t\t\n\t\t# If odd bit is set then\n\t\t# increment odd counter\n\t\tif(n & 1):\n\t\t\todd_count += 1\n\n\t\t# If even bit is set then\n\t\t# increment even counter\n\t\tif(n & 2):\n\t\t\teven_count += 1\n\t\tn = n >> 2\n\n\treturn isMultipleOf3(abs(odd_count - even_count))\n\n# Program to test function isMultipleOf3\nnum = 24\nif (isMultipleOf3(num)):\n\tprint(num, 'is multiple of 3')\nelse:\n\tprint(num, 'is not a multiple of 3')\n\n# This code is contributed by Danish Raza"}
{"nl": "Python Program to Remove a String from a List of Strings", "code": "# Give the list of strings as user input using list(), split(),\n# and input() functions and store it in a variable.\ngvnstrnlists = list(input('Enter some random list of strings = ').split())\n# Give the string as user input using input() and store it in another variable.\ngvnstrng = input('enter some random string which you want to remove = ')\nprint(\n    'The given list of strings before removing the string [', gvnstrng, '] is', gvnstrnlists)\n\n# Remove the given strings from the list of strings using List Comprehension.\nmodilststrngs = [elemen for elemen in gvnstrnlists if elemen != gvnstrng]\n# Print the modified list of strings.\nprint(\n    'The given list of strings after removing the string [', gvnstrng, '] is', modilststrngs)"}
{"nl": "Minimum number of subsets with distinct elements", "code": "# A sorting based solution to find the\n# minimum number of subsets of a set\n# such that every subset contains distinct\n# elements.\n\n# function to count subsets such that all\n# subsets have distinct elements.\ndef subset(ar, n):\n\n\t# take input and initialize res = 0\n\tres = 0\n\n\t# sort the array\n\tar.sort()\n\n\t# traverse the input array and\n\t# find maximum frequency\n\tfor i in range(0, n) :\n\t\tcount = 1\n\n\t\t# for each number find its repetition / frequency\n\t\tfor i in range(n - 1):\n\t\t\tif ar[i] == ar[i + 1]:\n\t\t\t\tcount+=1\n\t\t\telse:\n\t\t\t\tbreak\n\t\t\t\n\t\t# update res\n\t\tres = max(res, count)\n\t\n\treturn res\n\n\n# Driver code\nar = [ 5, 6, 9, 3, 4, 3, 4 ]\nn = len(ar)\nprint(subset(ar, n))\n\n# This code is contributed by\n# Smitha Dinesh Semwal"}
{"nl": "Python return Keyword", "code": "def myfunction():\r\n  return 3+3\r\n\r\nprint(myfunction())"}
{"nl": "Toggle Bits of a Number Except First and Last bits", "code": "# Create a  function to say setallmidlebits which takes the given number as an\r\n# argument.\r\n\r\n\r\ndef setallmidlebits(gven_numb):\r\n    # Apply the or(|) operator to the given number and given_numb >> 1(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 1\r\n    # Apply the or(|) operator to the given number and given_numb >> 2(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 2\r\n    # Apply the or(|) operator to the given number and given_numb >> 4(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 4\r\n    # Apply the or(|) operator to the given number and given_numb >> 8(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 8\r\n    # Apply the or(|) operator to the given number and given_numb >> 16(Right Shift) and\r\n    # store it in the same variable.\r\n    gven_numb = gven_numb | gven_numb >> 16\r\n    # Right shift the given number by 1 and store it in another variable.\r\n    p = (gven_numb >> 1)\r\n    # Return the Xor value of the above result and 1.\r\n    return (p ^ 1)\r\n\r\n# Create a  function to say toglemidlebits which takes the given number as an\r\n# argument and returns the number after toggling all the bits of a given number except the\r\n# first and last bits.\r\n\r\n\r\ndef toglemidlebits(gven_numb):\r\n  # Check if the given number is equal to 1 using the if conditional statement.\r\n    if (gven_numb == 1):\r\n      # If the statement is true, then return 1.\r\n        return 1\r\n    # Return the Xor result of the given number and setallmidlebits(gven_numb).\r\n    return gven_numb ^ setallmidlebits(gven_numb)\r\n\r\n\r\n# Give the number as user input using the int(input()) function and store it in a variable.\r\ngven_numb = int(input(\"Enter some random number = \"))\r\n# Pass the given number as an argument to the setallmidlebits function.\r\n# Pass the given number as an argument to the toglemidlebits function.\r\n# Print the number after toggling all the bits of a given number except the\r\n# first and last bits.\r\nprint(\"The Number after toggling all the bits of a given number{\", gven_numb,\r\n      \"} except the first and last bits = \", toglemidlebits(gven_numb))"}
{"nl": "find original array from doubled array", "code": "class Solution:\n    def findOriginalArray(self, changed: List[int]) -> List[int]:\n        dct=collections.Counter(changed)\n        if dct[0]%2!=0: return []\n        res=[]\n        for el in sorted(dct):\n            while dct[el]>0 and dct[el*2]>0:\n                res.append(el)\n                dct[el]-=1\n                dct[el*2]-=1\n        return res if sum(dct.values())==0 else []"}
{"nl": "Exercise to refactor the markdown parser: a given string is parsed with Markdown syntax and the associated HTML is returned.", "code": "import re\ndef parse(markdown):\n    s = markdown\n    s = re.sub(r'__([^\\n]+?)__', r'<strong>\\1</strong>', s)\n    s = re.sub(r'_([^\\n]+?)_', r'<em>\\1</em>', s)\n    s = re.sub(r'^\\* (.*?$)', r'<li>\\1</li>', s, flags=re.M)\n    s = re.sub(r'(<li>.*</li>)', r'<ul>\\1</ul>', s, flags=re.S)\n    for i in range(6, 0, -1):\n        s = re.sub(r'^{} (.*?$)'.format('#' * i), r'<h{0}>\\1</h{0}>'.format(i), s, flags=re.M)\n    s = re.sub(r'^(?!<[hlu])(.*?$)', r'<p>\\1</p>', s, flags=re.M)\n    s = re.sub(r'\\n', '', s)\n    return s\n"}
{"nl": "Python Program to Calculate EMI (Estimated Monthly Installment)", "code": "# Give the Principle as user input using float(input()) and store it in a variable.\ngvn_princpl = float(input(\"Enter some random number = \"))\n# Give the Rate as user input using float(input()) and store it in another variable.\ngvn_rate = float(input(\"Enter some random number = \"))\n# Give the Time as user input using float(input()) and store it in another variable.\ngvn_time = float(input(\"Enter some random number = \"))\n# Calculate the given rate using given rate formula( given rate/(12*100))and\n# store it in a same variable.\ngvn_rate = gvn_rate/(12*100)\n# Calculate the given time using given time formula (given time *12) and\n# store it in a same variable.\ngvn_time = gvn_time*12\n# Calculate the EMI Value using the above given mathematical formula and\n# store it in another variable.\nfnl_Emi = (gvn_princpl*gvn_rate*pow(1+gvn_rate, gvn_time)) / \\\n    (pow(1+gvn_rate, gvn_time)-1)\n# Print the given EMI value for the above given values of Principle,Rate,Time.\nprint(\"The EMI for the above given values of P,T,R = \", fnl_Emi)"}
{"nl": "Get Student Names", "code": "def get_student_names(students):\n  return sorted(students.values())"}
{"nl": "in a 4 by 3 grid excluding the bottom most right and left cells, return the number of distinct n moves possible starting from any cell. you may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically", "code": "def knightDialer(self, N):\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\n    neighbors = {\n        0:(4,6),\n        1:(6,8),\n        2:(7,9),\n        3:(4,8),\n        4:(0,3,9),\n        5:(),\n        6:(0,1,7),\n        7:(2,6),\n        8:(1,3),\n        9:(2,4)\n    }\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    for _ in range(N-1):\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        for src_key in range(10):\n            for dst_key in neighbors[src_key]:\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\n        current_counts = next_counts\n    return sum(current_counts) % (10**9 + 7)"}
{"nl": "Triple + Double = So Much Trouble", "code": "def trouble(num1, num2):\n  for i in \"0123456789\":\n    if i*3 in str(num1) and i*2 in str(num2):\n      return True\n  return False"}
{"nl": "Find Number of Digits in Number", "code": "def num_of_digits(n):\n  return next(i for i in range(1, 100) if abs(n) < 10**i)"}
{"nl": "Python Dictionary values() Method\n\n", "code": "car = {\r\n  \"brand\": \"Ford\",\r\n  \"model\": \"Mustang\",\r\n  \"year\": 1964\r\n}\r\n\r\nx = car.values()\r\n\r\nprint(x)\r\n"}
{"nl": "Program for scalar multiplication of a matrix", "code": "# Python 3 program to find the scalar\n# product of a matrix\n\u00a0\n# Size of given matrix\nN = 3\n\u00a0\ndef scalarProductMat( mat, k):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# scalar element is multiplied\n\u00a0\u00a0\u00a0\u00a0# by the matrix\n\u00a0\u00a0\u00a0\u00a0for i in range( N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range( N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = mat[i][j] * k\u00a0\u00a0\u00a0\u00a0\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[ 1, 2, 3 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 4, 5, 6 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 7, 8, 9 ]]\n\u00a0\u00a0\u00a0\u00a0k = 4\n\u00a0\n\u00a0\u00a0\u00a0\u00a0scalarProductMat(mat, k)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# to display the resultant matrix\n\u00a0\u00a0\u00a0\u00a0print(\"Scalar Product Matrix is : \")\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(mat[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": "Python Program to Solve Quadratic Equation", "code": "# importing cmath\nimport cmath\n# given a,b,c values\na = 2\nb = -7\nc = 6\ndiscriminant = (b**2) - (4*a*c)\n# checking if the value of discriminant is greater than 0\nif(discriminant > 0):\n    # here exist the two distinct roots and we print them\n    # calculating the roots\n    root1 = (-b+discriminant) / (2 * a)\n    root2 = (-b-discriminant) / (2 * a)\n    # printing the roots\n\n    print(\"The two distinct roots are : \")\n    print(root1)\n    print(root2)\n# checking if the value of discriminant is equal to 0\nelif(discriminant == 0):\n    # here exist the two equal roots\n    # calculating single root here discriminant is 0 so we dont need to write full formulae\n    root = (-b)/(2*a)\n    # printing the root\n    print(\"The two equal roots are : \")\n    print(root, root)\n# else there exists complex roots\nelse:\n    # here exist the two complex roots\n    # calculating complex roots\n    realpart = -b/(2*a)\n    complexpart = discriminant/(2*a)*(-1)\n    # printing the roots\n    print(\"There exists two complex roots:\")\n    print(realpart, \"+\", complexpart, \"i\")\n    print(realpart, \"-\", complexpart, \"i\")"}
{"nl": "number of strings that appear as substrings in a word", "code": "class Solution:\n    def numOfStrings(self, patterns: List[str], word: str) -> int:\n        count=0\n        for i in patterns:\n            if i in word:\n                count+=1\n        return count"}
{"nl": "Implement Merge Sort", "code": "def merge_sort(alist, start, end):\n    '''Sorts the list from indexes start to end - 1 inclusive.'''\n    if end - start > 1:\n        mid = (start + end)//2\n        merge_sort(alist, start, mid)\n        merge_sort(alist, mid, end)\n        merge_list(alist, start, mid, end)\n\u00a0\ndef merge_list(alist, start, mid, end):\n    left = alist[start:mid]\n    right = alist[mid:end]\n    k = start\n    i = 0\n    j = 0\n    while (start + i < mid and mid + j < end):\n        if (left[i] <= right[j]):\n            alist[k] = left[i]\n            i = i + 1\n        else:\n            alist[k] = right[j]\n            j = j + 1\n        k = k + 1\n    if start + i < mid:\n        while k < end:\n            alist[k] = left[i]\n            i = i + 1\n            k = k + 1\n    else:\n        while k < end:\n            alist[k] = right[j]\n            j = j + 1\n            k = k + 1\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\nmerge_sort(alist, 0, len(alist))\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "Find Minimum Spanning Tree using Prim\u2019s Algorithm", "code": "class Graph:\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n\u00a0\n    def add_vertex(self, key):\n        \"\"\"Add a vertex with the given key to the graph.\"\"\"\n        vertex = Vertex(key)\n        self.vertices[key] = vertex\n\u00a0\n    def get_vertex(self, key):\n        \"\"\"Return vertex object with the corresponding key.\"\"\"\n        return self.vertices[key]\n\u00a0\n    def __contains__(self, key):\n        return key in self.vertices\n\u00a0\n    def add_edge(self, src_key, dest_key, weight=1):\n        \"\"\"Add edge from src_key to dest_key with given weight.\"\"\"\n        self.vertices[src_key].add_neighbour(self.vertices[dest_key], weight)\n\u00a0\n    def does_edge_exist(self, src_key, dest_key):\n        \"\"\"Return True if there is an edge from src_key to dest_key.\"\"\"\n        return self.vertices[src_key].does_it_point_to(self.vertices[dest_key])\n\u00a0\n    def display(self):\n        print('Vertices: ', end='')\n        for v in self:\n            print(v.get_key(), end=' ')\n        print()\n\u00a0\n        print('Edges: ')\n        for v in self:\n            for dest in v.get_neighbours():\n                w = v.get_weight(dest)\n                print('(src={}, dest={}, weight={}) '.format(v.get_key(),\n                                                             dest.get_key(), w))\n\u00a0\n    def __len__(self):\n        return len(self.vertices)\n\u00a0\n    def __iter__(self):\n        return iter(self.vertices.values())\n\u00a0\n\u00a0\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.points_to = {}\n\u00a0\n    def get_key(self):\n        \"\"\"Return key corresponding to this vertex object.\"\"\"\n        return self.key\n\u00a0\n    def add_neighbour(self, dest, weight):\n        \"\"\"Make this vertex point to dest with given edge weight.\"\"\"\n        self.points_to[dest] = weight\n\u00a0\n    def get_neighbours(self):\n        \"\"\"Return all vertices pointed to by this vertex.\"\"\"\n        return self.points_to.keys()\n\u00a0\n    def get_weight(self, dest):\n        \"\"\"Get weight of edge from this vertex to dest.\"\"\"\n        return self.points_to[dest]\n\u00a0\n    def does_it_point_to(self, dest):\n        \"\"\"Return True if this vertex points to dest.\"\"\"\n        return dest in self.points_to\n\u00a0\n\u00a0\ndef mst_prim(g):\n    \"\"\"Return a minimum cost spanning tree of the connected graph g.\"\"\"\n    mst = Graph() # create new Graph object to hold the MST\n\u00a0\n    # if graph is empty\n    if not g:\n        return mst\n\u00a0\n    # nearest_neighbour[v] is the nearest neighbour of v that is in the MST\n    # (v is a vertex outside the MST and has at least one neighbour in the MST)\n    nearest_neighbour = {}\n    # smallest_distance[v] is the distance of v to its nearest neighbour in the MST\n    # (v is a vertex outside the MST and has at least one neighbour in the MST)\n    smallest_distance = {}\n    # v is in unvisited iff v has not been added to the MST\n    unvisited = set(g)\n\u00a0\n    u = next(iter(g)) # select any one vertex from g\n    mst.add_vertex(u.get_key()) # add a copy of it to the MST\n    unvisited.remove(u)\n\u00a0\n    # for each neighbour of vertex u\n    for n in u.get_neighbours():\n        if n is u:\n            # avoid self-loops\n            continue\n        # update dictionaries\n        nearest_neighbour[n] = mst.get_vertex(u.get_key())\n        smallest_distance[n] = u.get_weight(n)\n\u00a0\n    # loop until smallest_distance becomes empty\n    while (smallest_distance):\n        # get nearest vertex outside the MST\n        outside_mst = min(smallest_distance, key=smallest_distance.get)\n        # get the nearest neighbour inside the MST\n        inside_mst = nearest_neighbour[outside_mst]\n\u00a0\n        # add a copy of the outside vertex to the MST\n        mst.add_vertex(outside_mst.get_key())\n        # add the edge to the MST\n        mst.add_edge(outside_mst.get_key(), inside_mst.get_key(),\n                     smallest_distance[outside_mst])\n        mst.add_edge(inside_mst.get_key(), outside_mst.get_key(),\n                     smallest_distance[outside_mst])\n\u00a0\n        # now that outside_mst has been added to the MST, remove it from our\n        # dictionaries and the set unvisited\n        unvisited.remove(outside_mst)\n        del smallest_distance[outside_mst]\n        del nearest_neighbour[outside_mst]\n\u00a0\n        # update dictionaries\n        for n in outside_mst.get_neighbours():\n            if n in unvisited:\n                if n not in smallest_distance:\n                    smallest_distance[n] = outside_mst.get_weight(n)\n                    nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())\n                else:\n                    if smallest_distance[n] > outside_mst.get_weight(n):\n                        smallest_distance[n] = outside_mst.get_weight(n)\n                        nearest_neighbour[n] = mst.get_vertex(outside_mst.get_key())\n\u00a0\n    return mst\n\u00a0\n\u00a0\ng = Graph()\nprint('Undirected Graph')\nprint('Menu')\nprint('add vertex <key>')\nprint('add edge <src> <dest> <weight>')\nprint('mst')\nprint('display')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0]\n    if operation == 'add':\n        suboperation = do[1]\n        if suboperation == 'vertex':\n            key = int(do[2])\n            if key not in g:\n                g.add_vertex(key)\n            else:\n                print('Vertex already exists.')\n        elif suboperation == 'edge':\n            src = int(do[2])\n            dest = int(do[3])\n            weight = int(do[4])\n            if src not in g:\n                print('Vertex {} does not exist.'.format(src))\n            elif dest not in g:\n                print('Vertex {} does not exist.'.format(dest))\n            else:\n                if not g.does_edge_exist(src, dest):\n                    g.add_edge(src, dest, weight)\n                    g.add_edge(dest, src, weight)\n                else:\n                    print('Edge already exists.')\n\u00a0\n    elif operation == 'mst':\n        mst = mst_prim(g)\n        print('Minimum Spanning Tree:')\n        mst.display()\n        print()\n\u00a0\n    elif operation == 'display':\n        g.display()\n        print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Alternating between Numbers Two and Eight with a Catch", "code": "def f(n):\n    return 3*(-1)**n + 5"}
{"nl": "First Class Function", "code": "def factory(n):\n  return lambda lst: [i // n for i in lst]"}
{"nl": "Replacing Letters with Hashes", "code": "def replace(txt, r):\n  return ''.join('#' if r[0] <= i <= r[2] else i for i in txt)"}
{"nl": "in a matrix, start at any element in the first row and find the minimum sum of elements by going down one row and to the right or left one or zero columns", "code": "def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n    for i in range(1, len(matrix)):\n        for j in range(len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][max(0, j - 1):j + 2])\n    return min(matrix[-1])"}
{"nl": "The maximum length of a subarray with positive product", "code": "def getMaxLen(self, nums: List[int]) -> int:\n  n = len(nums)\n  pos, neg = 0, 0\n  if nums[0] > 0: pos = 1\n  if nums[0] < 0: neg = 1\n  ans = pos\n  for i in range(1, n):\n  if nums[i] > 0:\n  pos = 1 + pos\n  neg = 1 + neg if neg > 0 else 0\n  elif nums[i] < 0:\n  pos, neg = 1 + neg if neg > 0 else 0, 1 + pos\n  else:\n  pos, neg = 0, 0\n  ans = max(ans, pos)\n  return ans"}
{"nl": "Bit Masking", "code": "def bit_mask(n, b):\n  return (n >> b) & 1"}
{"nl": "Detect Cycle in a Directed Graph", "code": "# Python program to detect cycle\n# in a graph\n\u00a0\nfrom collections import defaultdict\n\u00a0\nclass Graph():\n\u00a0\u00a0\u00a0\u00a0def __init__(self,vertices):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = vertices\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u,v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[u].append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0def isCyclicUtil(self, v, visited, recStack):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark current node as visited and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# adds to recursion stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[v] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recStack[v] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Recur for all neighbours\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if any neighbour is visited and in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recStack then graph is cyclic\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for neighbour in self.graph[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[neighbour] == False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isCyclicUtil(neighbour, visited, recStack) == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif recStack[neighbour] == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# The node needs to be poped from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursion stack before function ends\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recStack[v] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if graph is cyclic else false\n\u00a0\u00a0\u00a0\u00a0def isCyclic(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited = [False] * (self.V + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recStack = [False] * (self.V + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for node in range(self.V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[node] == False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.isCyclicUtil(node,visited,recStack) == True:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\ng = Graph(4)\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\nif g.isCyclic() == 1:\n\u00a0\u00a0\u00a0\u00a0print \"Graph has a cycle\"\nelse:\n\u00a0\u00a0\u00a0\u00a0print \"Graph has no cycle\"\n\u00a0\n# Thanks to Divyanshu Mehta for contributing this code\n"}
{"nl": "Water Jug problem using BFS", "code": "from collections import deque\n\u00a0\ndef BFS(a, b, target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Map is used to store the states, every\n\u00a0\u00a0\u00a0\u00a0# state is hashed to binary value to\n\u00a0\u00a0\u00a0\u00a0# indicate either that state is visited\n\u00a0\u00a0\u00a0\u00a0# before or not\n\u00a0\u00a0\u00a0\u00a0m = {}\n\u00a0\u00a0\u00a0\u00a0isSolvable = False\n\u00a0\u00a0\u00a0\u00a0path = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Queue to maintain states\n\u00a0\u00a0\u00a0\u00a0q = deque()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialing with initial state\n\u00a0\u00a0\u00a0\u00a0q.append((0, 0))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while (len(q) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Current state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = q.popleft()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#q.pop() #pop off used state\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this state is already visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((u[0], u[1]) in m):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Doesn't met jug constraints\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((u[0] > a or u[1] > b or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u[0] < 0 or u[1] < 0)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Filling the vector for constructing\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the solution path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append([u[0], u[1]])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Marking current state as visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m[(u[0], u[1])] = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we reach solution state, put ans=1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[0] == target or u[1] == target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0isSolvable = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[0] == target):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[1] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Fill final state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append([u[0], 0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (u[0] != 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Fill final state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.append([0, u[1]])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print the solution path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sz = len(path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(sz):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"(\", path[i][0], \",\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[i][1], \")\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we have not reached final state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then, start developing intermediate\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# states to reach solution state\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([u[0], b]) # Fill Jug2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([a, u[1]]) # Fill Jug1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for ap in range(max(a, b) + 1):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pour amount ap from Jug2 to Jug1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c = u[0] + ap\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d = u[1] - ap\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if this state is possible or not\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (c == a or (d == 0 and d >= 0)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([c, d])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pour amount ap from Jug 1 to Jug2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c = u[0] - ap\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d = u[1] + ap\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if this state is possible or not\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((c == 0 and c >= 0) or d == b):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([c, d])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Empty Jug2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([a, 0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Empty Jug1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append([0, b])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# No, solution exists if ans=0\n\u00a0\u00a0\u00a0\u00a0if (not isSolvable):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (\"No solution\")\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Jug1, Jug2, target = 4, 3, 2\n\u00a0\u00a0\u00a0\u00a0print(\"Path from initial state \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"to solution state ::\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0BFS(Jug1, Jug2, target)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "String Slice-athon", "code": "def challenge1(s):\n  return s[:5]\n  def challenge2(s):\n  return s[-5:]\n  def challenge3(s):\n  return s[::-1]\n  def challenge4(s):\n  return s[5::-1]\n  def challenge5(s):\n  return s[-7::2]"}
{"nl": "Display the Nodes of a Tree using BFS Traversal", "code": "class Tree:\n    def __init__(self, data=None):\n        self.key = data\n        self.children = []\n\u00a0\n    def set_root(self, data):\n        self.key = data\n\u00a0\n    def add(self, node):\n        self.children.append(node)\n\u00a0\n    def search(self, key):\n        if self.key == key:\n            return self\n        for child in self.children:\n            temp = child.search(key)\n            if temp is not None:\n                return temp\n        return None\n\u00a0\n    def bfs(self):\n        queue = [self]\n        while queue != []:\n            popped = queue.pop(0)\n            for child in popped.children:\n                queue.append(child)\n            print(popped.key, end=' ')\n\u00a0\n\u00a0\ntree = None\n\u00a0\nprint('Menu (this assumes no duplicate keys)')\nprint('add <data> at root')\nprint('add <data> below <data>')\nprint('bfs')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'add':\n        data = int(do[1])\n        new_node = Tree(data)\n        suboperation = do[2].strip().lower() \n        if suboperation == 'at':\n            tree = new_node\n        elif suboperation == 'below':\n            position = do[3].strip().lower()\n            key = int(position)\n            ref_node = None\n            if tree is not None:\n                ref_node = tree.search(key)\n            if ref_node is None:\n                print('No such key.')\n                continue\n            ref_node.add(new_node)\n\u00a0\n    elif operation == 'bfs':\n        if tree is None:\n            print('Tree is empty.')\n        else:\n            print('BFS traversal: ', end='')\n            tree.bfs()\n            print()\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Python Accessing Dictionary Items\r\n", "code": "x = thisdict[\"model\"]"}
{"nl": "find the sum of the given series (3+7+13+21\u2026..+N) for the given number in Python.", "code": "# Give the number N as static input and store it in a variable.\r\ngvn_numb = 9\r\n# Take a variable say resltsum which gives the sum of the given series till N and\r\n# initialize its value to 0.\r\nresltsum = 0\r\n# Loop from 2 to the given number+1 using the for loop.\r\nfor itr in range(2, gvn_numb+2):\r\n  # Inside the loop, subtract 1 from the iterator value and multiply it with the\r\n  # iterator and add 1 to this result.\r\n  # Store it in another variable say p.\r\n    p = 1+(itr*(itr-1))\r\n  # Add the value of above p to the above-initialized resltsum and store it in the same\r\n  # variable resltsum.\r\n    resltsum += p\r\n# Print the resltsum value which is the result of the series till the given Number N.\r\nprint(\r\n    \"The total sum of the series till the given number {\", gvn_numb, \"} = \", resltsum)"}
{"nl": "Find postorder traversal of BST from preorder traversal", "code": "\"\"\"Python3 program for finding postorder\r\ntraversal of BST from preorder traversal\"\"\"\r\n\r\nINT_MIN = -2**31\r\nINT_MAX = 2**31\r\n\r\n# Function to find postorder traversal\r\n# from preorder traversal.\r\n\r\n\r\ndef findPostOrderUtil(pre, n, minval,\r\n\t\t\t\t\tmaxval, preIndex):\r\n\r\n\t# If entire preorder array is traversed\r\n\t# then return as no more element is left\r\n\t# to be added to post order array.\r\n\tif (preIndex[0] == n):\r\n\t\treturn\r\n\r\n\t# If array element does not lie in\r\n\t# range specified, then it is not\r\n\t# part of current subtree.\r\n\tif (pre[preIndex[0]] < minval or\r\n\t\t\tpre[preIndex[0]] > maxval):\r\n\t\treturn\r\n\r\n\t# Store current value, to be printed later,\r\n\t# after printing left and right subtrees.\r\n\t# Increment preIndex to find left and right\r\n\t# subtrees, and pass this updated value to\r\n\t# recursive calls.\r\n\tval = pre[preIndex[0]]\r\n\tpreIndex[0] += 1\r\n\r\n\t# All elements with value between minval\r\n\t# and val lie in left subtree.\r\n\tfindPostOrderUtil(pre, n, minval,\r\n\t\t\t\t\tval, preIndex)\r\n\r\n\t# All elements with value between val\r\n\t# and maxval lie in right subtree.\r\n\tfindPostOrderUtil(pre, n, val,\r\n\t\t\t\t\tmaxval, preIndex)\r\n\r\n\tprint(val, end=\" \")\r\n\r\n# Function to find postorder traversal.\r\n\r\n\r\ndef findPostOrder(pre, n):\r\n\r\n\t# To store index of element to be\r\n\t# traversed next in preorder array.\r\n\t# This is passed by reference to\r\n\t# utility function.\r\n\tpreIndex = [0]\r\n\r\n\tfindPostOrderUtil(pre, n, INT_MIN,\r\n\t\t\t\t\tINT_MAX, preIndex)\r\n\r\n\r\n# Driver Code\r\nif __name__ == '__main__':\r\n\tpre = [40, 30, 35, 80, 100]\r\n\r\n\tn = len(pre)\r\n\r\n\t# Calling function\r\n\tfindPostOrder(pre, n)\r\n\r\n# This code is contributed by\r\n# SHUBHAMSINGH10\r"}
{"nl": "Find the Odd Integer", "code": "def find_odd(lst):\n  for num in lst:\n    if lst.count(num) % 2:\n      return num"}
{"nl": "Finding the Center and Radius of a Circle", "code": "def circle(a, b, c):\r\n\treturn [(-a/2, -b/2), (-c + (a/2)**2 + (b/2)**2)**0.5]"}
{"nl": "Find index of closing bracket for a given opening bracket in an expression", "code": "# Python program to find index of closing\n# bracket for a given opening bracket.\nfrom collections import deque\n\u00a0\u00a0\ndef getIndex(s, i):\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If input is invalid.\n\u00a0\u00a0\u00a0\u00a0if s[i] != '[':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a deque to use it as a stack.\n\u00a0\u00a0\u00a0\u00a0d = deque()\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse through all elements\n\u00a0\u00a0\u00a0\u00a0# starting from i.\n\u00a0\u00a0\u00a0\u00a0for k in range(i, len(s)):\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pop a starting bracket\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# for every closing bracket\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if s[k] == ']':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d.popleft()\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push all starting brackets\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif s[k] == '[':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0d.append(s[i])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If deque becomes empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not d:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return k\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\u00a0\n# Driver code to test above method.\ndef test(s, i):\n\u00a0\u00a0\u00a0\u00a0matching_index = getIndex(s, i)\n\u00a0\u00a0\u00a0\u00a0print(s + \", \" + str(i) + \": \" + str(matching_index))\n\u00a0\u00a0\ndef main():\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 0) # should be 8\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 4) # should be 7\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 9) # should be 12\n\u00a0\u00a0\u00a0\u00a0test(\"[ABC[23]][89]\", 1) # No matching bracket\n\u00a0\u00a0\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0main()\n"}
{"nl": "Subtract Without Subtract", "code": "def my_sub(a, b):\n    return len(range(a,b))"}
{"nl": "divide two integers", "code": "def divide(self, dividend: int, divisor: int) -> int:\n\n    # Constants.\n    MAX_INT = 2147483647        # 2**31 - 1\n    MIN_INT = -2147483648       # -2**31\n    HALF_MIN_INT = -1073741824  # MIN_INT // 2\n\n    # Special case: overflow.\n    if dividend == MIN_INT and divisor == -1:\n        return MAX_INT\n\n    # We need to convert both numbers to negatives.\n    # Also, we count the number of negatives signs.\n    negatives = 2\n    if dividend > 0:\n        negatives -= 1\n        dividend = -dividend\n    if divisor > 0:\n        negatives -= 1\n        divisor = -divisor\n\n    quotient = 0\n    # Once the divisor is bigger than the current dividend,\n    # we can't fit any more copies of the divisor into it anymore */\n    while divisor >= dividend:\n        # We know it'll fit at least once as divivend >= divisor.\n        # Note: We use a negative powerOfTwo as it's possible we might have\n        # the case divide(INT_MIN, -1). */\n        powerOfTwo = -1\n        value = divisor\n        # Check if double the current value is too big. If not, continue doubling.\n        # If it is too big, stop doubling and continue with the next step */\n        while value >= HALF_MIN_INT and value + value >= dividend:\n            value += value;\n            powerOfTwo += powerOfTwo\n        # We have been able to subtract divisor another powerOfTwo times.\n        quotient += powerOfTwo\n        # Remove value so far so that we can continue the process with remainder.\n        dividend -= value\n\n    # If there was originally one negative sign, then\n    # the quotient remains negative. Otherwise, switch\n    # it to positive.\n    return -quotient if negatives != 1 else quotient"}
{"nl": "find the earliest possible day full bloom given planttime and growtime arrays", "code": "class Solution:\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\n        time_line = sorted(range(len(plantTime)), key=growTime.__getitem__, reverse=True)\n        line = 0\n        for x in time_line:\n            line = max(line - plantTime[x], growTime[x])\n        return sum(plantTime) + line"}
{"nl": "Reverse Each Word in a String Python", "code": "# Python program to reverse each word in a string # take inputs string = 'Know Program' # splitting the string into list of words words = string.split(' ') # reversing each word and creating a new list of words reverseWords = [word[::-1] for word in words] # joining the new list of words to for a new string reverseString = \" \".join(reverseWords) # print reverse of each word in a string print('The reverse is', reverseString)"}
{"nl": "Python Program to Perform XOR on Two Lists", "code": "# Give the first list as static input and store it in a variable.\n \n lstt1 = [4, 19, 11, 5, 3, 9, 7]\n \n # Give the second list as static input and store it in another variable.\n \n lstt2 = [10, 3, 7, 2, 9, 8, 6, 5]\n \n print('The given First list elements are =', lstt1)\n \n print('The given Second list elements are =', lstt2)\n \n # Calculate the length of the first list using the len()\n \n # function(as both lists have same length) and store it in a variable.\n \n lenlst = len(lstt1)\n \n # Loop till the above length using the For loop.\n \n for p in range(lenlst):\n \n  # Inside the for loop initialize the list 1 element as xor operation\n \n  # between list1 and list2 using xor operator i.e lst1[p]=lst1[p]^lst2[p]\n \n  # where p is the iterator value of the For loop.\n \n  lstt1[p] = lstt1[p] ^ lstt2[p]\n \n # Print the list1 which is the result.\n \n print('The result after applying xor operation on both lists is', lstt1)\n \n </pre>"}
{"nl": "Alternate Sort", "code": "def alternate_sort(lst):\n    nums, chars, res = [], [], []\n    for i in lst:\n        nums.append(i) if type(i) == int else chars.append(i) \n    for i in zip(sorted(nums), sorted(chars)):\n        res += i\n    return res"}
{"nl": "Python Program to Find Digital Root of Large Integers using Recursion", "code": "# Create a function digitalRootRecursion which accepts the given number as an argument\n \n # and returns the digital root of the given number.\n \n \n \n \n \n def digitalRootRecursion(largenumbr):\n \n  # Then determine whether the integer is greater than or less than 10.\n \n  # If the integer is less than 10, return the number immediately\n \n  # and terminate the function\n \n  if(largenumbr < 10):\n \n  return largenumbr\n \n  # If the number is higher than 10, use the above function to recursively\n \n  # compute the sum of the digits of the given integer.\n \n  largenumbr = largenumbr % 10+digitalRootRecursion(largenumbr//10)\n \n  return digitalRootRecursion(largenumbr)\n \n \n \n \n \n # Give the number(Very Large) as static input and store it in a variable.\n \n lrgenumbr = 64829048194591378492648546725\n \n # Pass the given number as an argument to digitalRootRecursion() function.\n \n rsdigitalroot = digitalRootRecursion(lrgenumbr)\n \n # print the result digital root\n \n print('The Digital root of the given number',\n \n  lrgenumbr, 'is [', rsdigitalroot, ']')"}
{"nl": "Print Grid", "code": "def printgrid(rows, cols):\n  return [[c*rows+r for c in range(cols)] for r in range(1, rows+1)]"}
{"nl": "Generate a Countdown of Numbers in a List", "code": "def countdown(start):\n  return [i for i in range(start,-1,-1)]"}
{"nl": "Recursion: Sum", "code": "def sum_numbers(n):\n  return n + sum_numbers(n-1) if n else 0"}
{"nl": "Collect maximum points in a grid using two traversals", "code": "# A Memoization based program to find maximum collection\n# using two traversals of a grid\n\u00a0\nR=5\nC=4\nintmin=-10000000\nintmax=10000000\n\u00a0\n# checks whether a given input is valid or not\ndef isValid(x,y1,y2):\n\u00a0\u00a0\u00a0\u00a0return ((x >= 0 and x < R and y1 >=0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0and y1 < C and y2 >=0 and y2 < C))\n\u00a0\n# Driver function to collect max value\ndef getMaxUtil(arr,mem,x,y1,y2):\n\u00a0\u00a0\u00a0\u00a0# ---------- BASE CASES -----------\n\u00a0\u00a0\u00a0\u00a0if isValid(x, y1, y2)==False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return intmin\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if both traversals reach their destinations\n\u00a0\u00a0\u00a0\u00a0if x == R-1 and y1 == 0 and y2 == C-1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if y1==y2:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return arr[x][y1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return arr[x][y1]+arr[x][y2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If both traversals are at last row\n\u00a0\u00a0\u00a0\u00a0# but not at their destination\n\u00a0\u00a0\u00a0\u00a0if x==R-1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return intmin\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If subproblem is already solved\n\u00a0\u00a0\u00a0\u00a0if mem[x][y1][y2] != -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return mem[x][y1][y2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize answer for this subproblem\n\u00a0\u00a0\u00a0\u00a0ans=intmin\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# this variable is used to store gain of current cell(s)\n\u00a0\u00a0\u00a0\u00a0temp=0\n\u00a0\u00a0\u00a0\u00a0if y1==y2:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp=arr[x][y1]\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp=arr[x][y1]+arr[x][y2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for all possible cases, then store and return the\n\u00a0\u00a0\u00a0\u00a0# one with max value\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1, y2-1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1, y2+1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1, y2))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1-1, y2))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1-1, y2-1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1-1, y2+1))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1+1, y2))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1+1, y2-1))\n\u00a0\u00a0\u00a0\u00a0ans = max(ans, temp + getMaxUtil(arr, mem, x+1, y1+1, y2+1))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mem[x][y1][y2] = ans\n\u00a0\u00a0\u00a0\u00a0return ans\n\u00a0\n# This is mainly a wrapper over recursive\n# function getMaxUtil().\n# This function creates a table for memoization and calls\n# getMaxUtil()\n\u00a0\ndef geMaxCollection(arr):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a memoization table and\n\u00a0\u00a0\u00a0\u00a0# initialize all entries as -1\n\u00a0\u00a0\u00a0\u00a0mem=[[[-1 for i in range(C)] for i in range(C)] for i in range(R)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Calculation maximum value using\n\u00a0\u00a0\u00a0\u00a0# memoization based function\n\u00a0\u00a0\u00a0\u00a0# getMaxUtil()\n\u00a0\u00a0\u00a0\u00a0return getMaxUtil(arr, mem, 0, 0, C-1)\n\u00a0\n# Driver program to test above functions\nif __name__=='__main__':\n\u00a0\u00a0\u00a0\u00a0arr=[[3, 6, 8, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[5, 2, 4, 3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 20, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 20, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 1, 20, 10],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0]\n\u00a0\u00a0\u00a0\u00a0print('Maximum collection is ', geMaxCollection(arr))\n\u00a0\u00a0\u00a0\u00a0\u00a0\n#this code is contributed by sahilshelangia\n"}
{"nl": "Check if One List is a Subset of Another", "code": "def subset(lst1, lst2):\n    return set(lst1).issubset(set(lst2))"}
{"nl": "Boggle (Find all possible words in a board of characters)", "code": "# Python3 program for Boggle game\r\n# Let the given dictionary be following\r\n \r\ndictionary = [\"GEEKS\", \"FOR\", \"QUIZ\", \"GO\"]\r\nn = len(dictionary)\r\nM = 3\r\nN = 3\r\n \r\n# A given function to check if a given string\r\n# is present in dictionary. The implementation is\r\n# naive for simplicity. As per the question\r\n# dictionary is given to us.\r\ndef isWord(Str):\r\n   \r\n    # Linearly search all words\r\n    for i in range(n):\r\n        if (Str == dictionary[i]):\r\n            return True\r\n    return False\r\n \r\n# A recursive function to print all words present on boggle\r\ndef findWordsUtil(boggle, visited, i, j, Str):\r\n    # Mark current cell as visited and\r\n    # append current character to str\r\n    visited[i][j] = True\r\n    Str = Str + boggle[i][j]\r\n     \r\n    # If str is present in dictionary,\r\n    # then print it\r\n    if (isWord(Str)):\r\n        print(Str)\r\n     \r\n    # Traverse 8 adjacent cells of boggle[i,j]\r\n    row = i - 1\r\n    while row <= i + 1 and row < M:\r\n        col = j - 1\r\n        while col <= j + 1 and col < N:\r\n            if (row >= 0 and col >= 0 and not visited[row][col]):\r\n                findWordsUtil(boggle, visited, row, col, Str)\r\n            col+=1\r\n        row+=1\r\n     \r\n    # Erase current character from string and\r\n    # mark visited of current cell as false\r\n    Str = \"\" + Str[-1]\r\n    visited[i][j] = False\r\n \r\n# Prints all words present in dictionary.\r\ndef findWords(boggle):\r\n   \r\n    # Mark all characters as not visited\r\n    visited = [[False for i in range(N)] for j in range(M)]\r\n     \r\n    # Initialize current string\r\n    Str = \"\"\r\n     \r\n    # Consider every character and look for all words\r\n    # starting with this character\r\n    for i in range(M):\r\n      for j in range(N):\r\n        findWordsUtil(boggle, visited, i, j, Str)\r\n \r\n# Driver Code\r\nboggle = [[\"G\", \"I\", \"Z\"], [\"U\", \"E\", \"K\"], [\"Q\", \"S\", \"E\"]]\r\n \r\nprint(\"Following words of\", \"dictionary are present\")\r\nfindWords(boggle)\r\n \r\n#  This code is contributed by divyesh072019."}
{"nl": "Python List Length\r\n", "code": "thislist = [\"apple\", \"banana\", \"cherry\"]\r\nprint(len(thislist))"}
{"nl": "Identify continuous sub-array with highest sum", "code": "def findKadane(givnList, listleng):\n    # Set both of the variablesto the value at the first index, i.e., givnList[0].\n    cur_maxi = givnList[0]\n    maxi_so_far = givnList[0]\n\n    for i in range(1, listleng):\n      # Store the maximum of givnList[i] and cur_maxi + givnList[i]\n      # in the cur_maxi for the following index i.\n        cur_maxi = max(givnList[i], cur_maxi + givnList[i])\n        # maxi_so_far stores the maximum of maxi_so_far and cur_maxi.\n        maxi_so_far = max(maxi_so_far, cur_maxi)\n    # return the maxi_so_far\n    return maxi_so_far\n\n\n# Give the array/list as user input using list(),map(),split() and input() functions.\n# Here the given numbers will get divided by space using the split() function.\n# The string numbers get converted to integer using map and int functions.\ngivnList = list(\n    map(int, input('Enter some random list numbers separated by spaces = ').split()))\n# Calculate the length of the given list\n# using the len() function and store it in a variable.\nlistleng = len(givnList)\n# Pass the given list and length of the given\n# list as an arguments to the findKadane function which implements the kadane's algorithm.\nresltsum = findKadane(givnList, listleng)\n# Print the maximum sum.\nprint('The maximum subarray sum of the given list', givnList, ':')\nprint(resltsum)"}
{"nl": "Python Program to Convert Octal to Decimal using While Loop", "code": "# Give the octal number as user input using the int(input()) function and\n# store it in a variable.\ngvn_octl_numb = int(input(\"Enter some Random Number = \"))\n# Take a variable say 'a 'and initialize its value with 0.\na = 0\n# Take another variable say deciml_numb and initialize its value with 0.\ndeciml_numb = 0\n# Loop till the given octal number is not equal to zero using the while loop.\nprint(\"The Decimal value of the given Octal number {\", gvn_octl_numb, \"} is: \")\nwhile(gvn_octl_numb != 0):\n  # Inside the loop, calculate the value of the given octal number modulus 10\n  # (to get the last digit) and store it in a variable say 'b'.\n    b = (gvn_octl_numb % 10)\n# Calculate the value of 8 raised to the power 'a' using the pow() function and multiply\n# it with the above-obtained 'b'.\n# Store it in another variable 'c'.\n    c = b*pow(8, a)\n  # Add the above variable 'c' with the deciml_numb and store it in the same variable\n  # deciml_numb.\n    deciml_numb = deciml_numb+c\n  # Increment the value a by 1 and store it in the same variable 'a'.\n    a += 1\n# Divide the given octal number by 10 (to remove the last digit) and store it in the\n# same variable gvn_octl_numb.\n    gvn_octl_numb = gvn_octl_numb // 10\n# Print the deciml_num to get the decimal value of the given Octal number.\nprint(deciml_numb)"}
{"nl": "Python Program to Display Calendar", "code": "# Program to display calendar of the given month and year\n\n# importing calendar module\nimport calendar\n\nyy = 2014  # year\nmm = 11    # month\n\n# To take month and year input from the user\n# yy = int(input(\"Enter year: \"))\n# mm = int(input(\"Enter month: \"))\n\n# display the calendar\nprint(calendar.month(yy, mm))"}
{"nl": "The Gravitational Force acting between the given two particles", "code": "# given first mass\n mass1 = 1300012.67\n # given second mass\n mass2 = 303213455.953\n # enter the radius\n radius = 45.4\n # Given value of Gravitational Constant Gval\n Gval = 6.673*(10**(-11))\n # Calculating the value of the gravitational force Gforce\n Gforce = (Gval*mass1*mass2)/(radius**2)\n # printing the value of gravitational force\n print(\"The gravitational force of objects with masses\", str(mass1) +\n  \" kg \"+str(mass2)+\" kg \", \"of radius=\", radius, \"=\", Gforce)"}
{"nl": "Return a set of elements present in Set A or B, but not both", "code": "set1 = {10, 20, 30, 40, 50}\r\nset2 = {30, 40, 50, 60, 70}\r\n\r\nprint(set1.symmetric_difference(set2))"}
{"nl": "Check if two arrays are equal or not", "code": "# Python3 program to find given\n# two array are equal or not\n\n# Returns true if arr1[0..n-1] and\n# arr2[0..m-1] contain same elements.\n\n\ndef areEqual(arr1, arr2, n, m):\n\n\t# If lengths of array are not\n\t# equal means array are not equal\n\tif (n != m):\n\t\treturn False\n\n\t# Sort both arrays\n\tarr1.sort()\n\tarr2.sort()\n\n\t# Linearly compare elements\n\tfor i in range(0, n):\n\t\tif (arr1[i] != arr2[i]):\n\t\t\treturn False\n\n\t# If all elements were same.\n\treturn True\n\n\n# Driver Code\narr1 = [3, 5, 2, 5, 2]\narr2 = [2, 3, 5, 5, 2]\nn = len(arr1)\nm = len(arr2)\n\nif (areEqual(arr1, arr2, n, m)):\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n\n# This code is contributed\n# by Shivi_Aggarwal."}
{"nl": "check if all the integers in a range are covered", "code": "class Solution:\n\ndef isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:\n    # loop throught the range from left and right, inclusively\n    for i in range(left, right + 1):\n        # check if the number is between any interval\n        # put this variable to see if the number is found in any range\n        in_range = False\n        for interval in ranges:\n            # if the number is found, we set the boolean true\n            if i >= interval[0] and i <= interval[1]:\n                in_range = True\n                break\n        if not in_range:\n            return False\n    \n    return True"}
{"nl": "Balanced expression with replacement", "code": "# Python3 program to determine whether\n# given expression is balanced/ parenthesis\n# expression or not.\n\u00a0\n# Function to check if two brackets are\n# matching or not.\ndef isMatching(a, b):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if ((a == '{' and b == '}') or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a == '[' and b == ']') or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a == '(' and b == ')') or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a == 'X'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n# Recursive function to check if given\n# expression is balanced or not.\ndef isBalanced(s, ele, ind):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base case.\n\u00a0\u00a0\u00a0\u00a0# If the string is balanced then all the\n\u00a0\u00a0\u00a0\u00a0# opening brackets had been popped and\n\u00a0\u00a0\u00a0\u00a0# stack should be empty after string is\n\u00a0\u00a0\u00a0\u00a0# traversed completely.\n\u00a0\u00a0\u00a0\u00a0if (ind == len(s)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if len(ele) == 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Variable to store element at the top\n\u00a0\u00a0\u00a0\u00a0# of the stack.\n\u00a0\u00a0\u00a0\u00a0# char topEle;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Variable to store result of\n\u00a0\u00a0\u00a0\u00a0# recursive call.\n\u00a0\u00a0\u00a0\u00a0# int res;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Case 1: When current element is an\n\u00a0\u00a0\u00a0\u00a0# opening bracket then push that\n\u00a0\u00a0\u00a0\u00a0# element in the stack.\n\u00a0\u00a0\u00a0\u00a0if (s[ind] == '{' or s[ind] == '(' or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s[ind] == '['):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ele.append(s[ind])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return isBalanced(s, ele, ind + 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Case 2: When current element is a closing\n\u00a0\u00a0\u00a0\u00a0# bracket then check for matching bracket\n\u00a0\u00a0\u00a0\u00a0# at the top of the stack.\n\u00a0\u00a0\u00a0\u00a0elif (s[ind] == '}' or s[ind] == ')' or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s[ind] == ']'):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If stack is empty then there is no matching\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# opening bracket for current closing bracket\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and the expression is not balanced.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(ele) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0topEle = ele[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ele.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check bracket is matching or not.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (isMatching(topEle, s[ind]) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return isBalanced(s, ele, ind + 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Case 3: If current element is 'X' then check\n\u00a0\u00a0\u00a0\u00a0# for both the cases when 'X' could be opening\n\u00a0\u00a0\u00a0\u00a0# or closing bracket.\n\u00a0\u00a0\u00a0\u00a0elif (s[ind] == 'X'):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmp = ele\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmp.append(s[ind])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = isBalanced(s, tmp, ind + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (res):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(ele) == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ele.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return isBalanced(s, ele, ind + 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver Code\ns = \"{(X}[]\"\nele = []\n\u00a0\nif (isBalanced(s, ele, 0)):\n\u00a0\u00a0\u00a0\u00a0print(\"Balanced\")\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"Not Balanced\")\n\u00a0\n# This code is contributed by divyeshrabadiya07\n"}
{"nl": "Join Two Portions of a Path", "code": "def join_path(portion1, portion2):\n  return '/'.join((portion1.rstrip('/'), portion2.lstrip('/')))"}
{"nl": "Python Program to Display Fibonacci Sequence Using Recursion", "code": "def recur_fibo(n):  \n   if n <= 1:  \n       return n  \n   else:  \n       return(recur_fibo(n-1) + recur_fibo(n-2))  \n# take input from the user  \nnterms = int(input(\"How many terms? \"))  \n# check if the number of terms is valid  \nif nterms <= 0:  \n   print(\"Plese enter a positive integer\")  \nelse:  \n   print(\"Fibonacci sequence:\")  \n   for i in range(nterms):  \n       print(recur_fibo(i))  "}
{"nl": "best time to sell a stock including the same day", "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        profit = 0\n        for i in range(1, len(prices)):\n            profit += max(prices[i]-prices[i-1], 0)\n        return profit"}
{"nl": "Print rectangle star pattern", "code": "# Give the length and breadth as static input and store them in two variables.\nlengthnum = 8\nbreadthnum = 11\n# Loop till the length of the rectangle using For loop.\nfor m in range(lengthnum):\n  # Loop till the breadth of the rectangle using another nested For loop.\n  for n in range(breadthnum):\n  # Print the * character inside the nested For loop.\n  print('* ', end=' ')\n  print()"}
{"nl": "Exercise to practice arithmetic calculations: calculating prime factors", "code": "def factors(value):\r\n    prime = []\r\n    factor = 2\r\n    while value > 1:\r\n        if value % factor == 0:\r\n            prime.append(factor)\r\n            value /= factor\r\n        else:\r\n            factor += 1\r\n    return prime"}
{"nl": "Bug: Regular Expression", "code": "import re\ndef assignment(date):\n    return bool(re.match('^\\d{4}/\\d{2}/\\d{2}$', date))"}
{"nl": "Python List copy() Method\r\n\r\n", "code": "fruits = ['apple', 'banana', 'cherry', 'orange']\r\n\r\nx = fruits.copy()"}
{"nl": "DFS for a n-ary tree (acyclic graph) represented as adjacency list", "code": "# Python3 code to perform DFS of given tree :\n\u00a0\n# DFS on tree\ndef dfs(List, node, arrival):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Printing traversed node\n\u00a0\u00a0\u00a0\u00a0print(node)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traversing adjacent edges\n\u00a0\u00a0\u00a0\u00a0for i in range(len(List[node])):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Not traversing the parent node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (List[node][i] != arrival):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dfs(List, List[node][i], node)\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Number of nodes\n\u00a0\u00a0\u00a0\u00a0nodes = 5\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Adjacency List\n\u00a0\u00a0\u00a0\u00a0List = [[] for i in range(10000)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Designing the tree\n\u00a0\u00a0\u00a0\u00a0List[1].append(2)\n\u00a0\u00a0\u00a0\u00a0List[2].append(1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0List[1].append(3)\n\u00a0\u00a0\u00a0\u00a0List[3].append(1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0List[2].append(4)\n\u00a0\u00a0\u00a0\u00a0List[4].append(2)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0List[3].append(5)\n\u00a0\u00a0\u00a0\u00a0List[5].append(3)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call\n\u00a0\u00a0\u00a0\u00a0dfs(List, 1, 0)\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Python Program to check Armstrong Number", "code": "def power_1(A, B):  \n        \n    if B == 0:  \n        return 1  \n    if B % 2 == 0:  \n        return power_1(A, B // 2) * power(A, B // 2)  \n            \n    return A * power(A, B // 2) * power(A, B // 2)  \n    \n# Function for calculating \"order of the number\"  \ndef order_1(A):  \n    \n    # Variable for storing the number  \n    N = 0  \n    while (A != 0):  \n        N = N + 1  \n        A = A // 10  \n            \n    return N  \n    \n# Function for checking if the given number is Armstrong number or not  \ndef is_Armstrong(A):  \n        \n    N = order_1(A)  \n    temp_1 = A  \n    sum_1 = 0  \n        \n    while (temp_1 != 0):  \n        R_1 = temp_1 % 10  \n        sum_1 = sum_1 + power_1(R_1, N)  \n        temp_1 = temp_1 // 10  \n    \n    # If the above condition is satisfied, it will return the result  \n    return (sum_1 == A)  \n    \n# Driver code  \nA = int(input(\"Please enter the number to be checked: \"))  \nprint(is_Armstrong(A))  \n"}
{"nl": "Reversing a part of a linked list", "code": "\n# Python program to reverse a\n# linked list in group of given size\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    def reverse(self, head, k):\n       \n        if head == None:\n          return None\n        current = head\n        next = None\n        prev = None\n        count = 0\n \n        # Reverse first k nodes of the linked list\n        while(current is not None and count < k):\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n            count += 1\n \n        # next is now a pointer to (k+1)th node\n        # recursively call for the list starting\n        # from current. And make rest of the list as\n        # next of first node\n        if next is not None:\n            head.next = self.reverse(next, k)\n \n        # prev is new head of the input list\n        return prev\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the linked LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data,end=' ')\n            temp = temp.next\n "}
{"nl": "Rearrange characters in a string such that no two adjacent are same", "code": "# Python program for rearranging characters in a string such\n# that no two adjacent are same\n\n# Function to find the char with maximum frequency in the given\n# string\ndef getMaxCountChar(count):\nmaxCount = 0\nfor i in range(26):\n\tif count[i] > maxCount:\n\t\tmaxCount = count[i]\n\t\tmaxChar = chr(i + ord('a'))\n\nreturn maxCount, maxChar\n\n# Main function for rearranging the characters\ndef rearrangeString(S):\nn = len(S)\n\n# if length of string is None return False\nif not n:\n\treturn False\n\t\n# create a hashmap for the alphabets\ncount = [0] * 26\nfor char in S:\n\tcount[ord(char) - ord('a')] += 1\n\n\nmaxCount, maxChar = getMaxCountChar(count)\n\n# if the char with maximum frequency is more than the half of the\n# total length of the string than return False\nif maxCount > (n + 1) // 2:\n\treturn False\n\n# create a list for storing the result\nres = [None] * n\n\nind = 0\n\n# place all occurrences of the char with maximum frequency in\n# even positions\nwhile maxCount:\n\tres[ind] = maxChar\n\tind += 2\n\tmaxCount -= 1\n\t\n# replace the count of the char with maximum frequency to zero\n# as all the maxChar are already placed in the result\ncount[ord(maxChar) - ord('a')] = 0\n\n# place all other char in the result starting from remaining even\n# positions and then place in the odd positions\nfor i in range(26):\n\twhile count[i] > 0:\n\t\tif ind >= n:\n\t\t\tind = 1\n\t\tres[ind] = chr(i + ord('a') )\n\t\tind += 2\n\t\tcount[i] -= 1\n\n\n# convert the result list to string and return\nreturn ''.join(res)\n\n# Driver Code\nstr = 'bbbaa'\nres = rearrangeString(str)\nif res:\nprint(res)\nelse:\nprint('Not valid string')\n\n# This code is contributed by Manish Thapa"}
{"nl": "Parseltongue", "code": "def is_parsel_tongue(sentence):\n  return all('ss' in word or 's' not in word for word in sentence.lower().split())"}
{"nl": "Deploy Machine Learning Model using Flask\r", "code": "# importing the dataset\r\nimport pandas\r\nimport numpy\r\nfrom sklearn import preprocessing\r\n \r\ndf = pandas.read_csv('adult.csv')   \r\ndf.head()\r\ndf = df.drop(['fnlwgt', 'educational-num'], axis = 1)\r\n \r\ncol_names = df.columns\r\n \r\nfor c in col_names:\r\n    df = df.replace(\"?\", numpy.NaN)\r\ndf = df.apply(lambda x:x.fillna(x.value_counts().index[0]))\r\ndf.replace(['Divorced', 'Married-AF-spouse',\r\n              'Married-civ-spouse', 'Married-spouse-absent',\r\n              'Never-married', 'Separated', 'Widowed'],\r\n             ['divorced', 'married', 'married', 'married',\r\n              'not married', 'not married', 'not married'], inplace = True)\r\n \r\ncategory_col =['workclass', 'race', 'education', 'marital-status', 'occupation',\r\n               'relationship', 'gender', 'native-country', 'income']\r\nlabelEncoder = preprocessing.LabelEncoder()\r\n \r\nmapping_dict ={}\r\nfor col in category_col:\r\n    df[col] = labelEncoder.fit_transform(df[col])\r\n \r\n    le_name_mapping = dict(zip(labelEncoder.classes_,\r\n                        labelEncoder.transform(labelEncoder.classes_)))\r\n \r\n    mapping_dict[col]= le_name_mapping\r\nprint(mapping_dict)\r\nfrom sklearn.model_selection import train_test_split\r\nfrom sklearn.tree import DecisionTreeClassifier\r\nfrom sklearn.metrics import accuracy_score\r\n \r\nX = df.values[:, 0:12]\r\nY = df.values[:, 12]\r\nX_train, X_test, y_train, y_test = train_test_split(\r\n           X, Y, test_size = 0.3, random_state = 100)\r\n \r\ndt_clf_gini = DecisionTreeClassifier(criterion = \"gini\",\r\n                                     random_state = 100,\r\n                                     max_depth = 5,\r\n                                     min_samples_leaf = 5)\r\n \r\ndt_clf_gini.fit(X_train, y_train)\r\ny_pred_gini = dt_clf_gini.predict(X_test)\r\n \r\nprint (\"Decision Tree using Gini Index\\nAccuracy is \",\r\n             accuracy_score(y_test, y_pred_gini)*100 )\r\n# prediction function\r\ndef ValuePredictor(to_predict_list):\r\n    to_predict = np.array(to_predict_list).reshape(1, 12)\r\n    loaded_model = pickle.load(open(\"model.pkl\", \"rb\"))\r\n    result = loaded_model.predict(to_predict)\r\n    return result[0]\r\n \r\n@app.route('/result', methods = ['POST'])\r\ndef result():\r\n    if request.method == 'POST':\r\n        to_predict_list = request.form.to_dict()\r\n        to_predict_list = list(to_predict_list.values())\r\n        to_predict_list = list(map(int, to_predict_list))\r\n        result = ValuePredictor(to_predict_list)       \r\n        if int(result)== 1:\r\n            prediction ='Income more than 50K'\r\n        else:\r\n            prediction ='Income less that 50K'           \r\n        return render_template(\"result.html\", prediction = prediction)"}
{"nl": "Century Crisis", "code": "def future_people(P, nP):\n  return P+360*nP"}
{"nl": "Check Whether Number is Even or Odd Using Conditional Operator", "code": "# Check Even or Odd Using Conditional Operator\r\n\r\nnumber = int(input(\"Enter number: \"))\r\n\r\nprint(\"ODD\") if number%2 else print(\"EVEN\")"}
{"nl": "Nuts & Bolts Problem (Lock & Key problem)", "code": "# Python program to solve nut and bolt\r\n# problem using Quick Sort.\r\nfrom typing import List\r\n \r\n# Method to print the array\r\ndef printArray(arr: List[str]) -> None:\r\n    for i in range(6):\r\n        print(\" {}\".format(arr[i]), end=\" \")\r\n    print()\r\n \r\n# Similar to standard partition method.\r\n# Here we pass the pivot element too\r\n# instead of choosing it inside the method.\r\ndef partition(arr: List[str], low: int, high: int, pivot: str) -> int:\r\n    i = low\r\n    j = low\r\n    while j < high:\r\n        if (arr[j] < pivot):\r\n            arr[i], arr[j] = arr[j], arr[i]\r\n            i += 1\r\n        elif (arr[j] == pivot):\r\n            arr[j], arr[high] = arr[high], arr[j]\r\n            j -= 1\r\n        j += 1\r\n    arr[i], arr[high] = arr[high], arr[i]\r\n \r\n    # Return the partition index of\r\n    # an array based on the pivot\r\n    # element of other array.\r\n    return i\r\n \r\n# Function which works just like quick sort\r\ndef matchPairs(nuts: List[str], bolts: List[str], low: int, high: int) -> None:\r\n    if (low < high):\r\n \r\n        # Choose last character of bolts\r\n        # array for nuts partition.\r\n        pivot = partition(nuts, low, high, bolts[high])\r\n \r\n        # Now using the partition of nuts\r\n        # choose that for bolts partition.\r\n        partition(bolts, low, high, nuts[pivot])\r\n \r\n        # Recur for [low...pivot-1] &\r\n        # [pivot+1...high] for nuts and\r\n        # bolts array.\r\n        matchPairs(nuts, bolts, low, pivot - 1)\r\n        matchPairs(nuts, bolts, pivot + 1, high)\r\n \r\n# Driver code\r\nif __name__ == \"__main__\":\r\n \r\n    # Nuts and bolts are represented\r\n    # as array of characters\r\n    nuts = ['@', '#', '$', '%', '^', '&']\r\n    bolts = ['$', '%', '&', '^', '@', '#']\r\n \r\n    # Method based on quick sort which\r\n    # matches nuts and bolts\r\n    matchPairs(nuts, bolts, 0, 5)\r\n    print(\"Matched nuts and bolts are : \")\r\n    printArray(nuts)\r\n    printArray(bolts)\r\n \r\n# This code is contributed by sanjeev2552"}
{"nl": "Cycles of length n in an undirected and connected graph", "code": "# Python Program to count\n# cycles of length n\n# in a given graph.\n\u00a0\u00a0\n# Number of vertices\nV = 5\n\u00a0\ndef DFS(graph, marked, n, vert, start, count):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# mark the vertex vert as visited\n\u00a0\u00a0\u00a0\u00a0marked[vert] = True\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# if the path of length (n-1) is found\n\u00a0\u00a0\u00a0\u00a0if n == 0:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark vert as un-visited to make\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# it usable again.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0marked[vert] = False\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if vertex vert can end with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# vertex start\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if graph[vert][start] == 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = count + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# For searching every possible path of\n\u00a0\u00a0\u00a0\u00a0# length (n-1)\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if marked[i] == False and graph[vert][i] == 1:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# DFS for searching path by decreasing\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# length by 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = DFS(graph, marked, n-1, i, start, count)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# marking vert as unvisited to make it\n\u00a0\u00a0\u00a0\u00a0# usable again.\n\u00a0\u00a0\u00a0\u00a0marked[vert] = False\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\u00a0\n# Counts cycles of length\n# N in an undirected\n# and connected graph.\ndef countCycles( graph, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# all vertex are marked un-visited initially.\n\u00a0\u00a0\u00a0\u00a0marked = [False] * V\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Searching for cycle by using v-n+1 vertices\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(V-(n-1)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = DFS(graph, marked, n-1, i, i, count)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# ith vertex is marked as visited and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# will not be visited again.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0marked[i] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return int(count/2)\n\u00a0\u00a0\n# main :\ngraph = [[0, 1, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1 ,0 ,1 ,0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 0, 1, 0],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 0, 1, 0, 1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 0, 1, 0]]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nn = 4\nprint(\"Total cycles of length \",n,\" are \",countCycles(graph, n))\n\u00a0\n# this code is contributed by Shivani Ghughtyal\n"}
{"nl": "Solving Exponential Equations With Logarithms", "code": "from math import log\ndef solve_for_exp(a, b):\n  return round(log(b,a))"}
{"nl": "Python Program to Generate first N numbers of Pell Series", "code": "# Give the number N as static input and store it in a variable.\n \n numb = 21\n \n # Take a variable temp1 and initialize it to 1.\n \n temp1 = 1\n \n # Take another variable temp2 and initialize it to 2.\n \n temp2 = 2\n \n # Take the third variable temp3 and initialize it to 0.\n \n temp3 = 0\n \n # Now, print the first two numbers in the series,\n \n # and we'll print the other generated numbers in the order they were generated.\n \n print('The first', numb, 'numbers of the pell series are :')\n \n print(temp1, temp2, end=' ')\n \n # Loop till number -2 using For loop.\n \n for i in range(numb-2):\n \n  # Add the value of temp1 and twice the temp2 value\n \n  # and initialize the temp3 with this value.\n \n  temp3 = temp1+2*temp2\n \n  # Swap the previous number for the previous number's predecessor (temp1 =temp2).\n \n  temp1 = temp2\n \n  # Swap the generated and previously generated numbers (temp2 = temp3)\n \n  temp2 = temp3\n \n  # Print the value of temp3.\n \n  print(temp3, end=' ')\n \n </pre>"}
{"nl": "Python math.cos() Method", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the cosine of different numbers\r\nprint (math.cos(0.00))\r\nprint (math.cos(-1.23))\r\nprint (math.cos(10))\r\nprint (math.cos(3.14159265359))"}
{"nl": "Python nonlocal Keyword", "code": "def myfunc1():\r\n  x = \"John\"\r\n  def myfunc2():\r\n    nonlocal x\r\n    x = \"hello\"\r\n  myfunc2()\r\n  return x\r\n\r\nprint(myfunc1())"}
{"nl": "Python Set difference_update() Method", "code": "x = {\"apple\", \"banana\", \"cherry\"}\r\ny = {\"google\", \"microsoft\", \"apple\"}\r\n\r\nx.difference_update(y)\r\n\r\nprint(x)"}
{"nl": "Python program to print the elements of an array", "code": "#Initialize array     \narr = [1, 2, 3, 4, 5];     \n     \nprint(\"Elements of given array: \");    \n#Loop through the array by incrementing the value of i     \n    \nfor i in range(0, len(arr)):    \n    print(arr[i]),    "}
{"nl": "Find sum of Even Factors of a Number", "code": "# Give the number as static input and store it in a variable.\r\ngvn_numb = 24\r\n# Take an empty list and store it in another variable.\r\nall_factors = []\r\n# Loop from '1' to above given number range using For loop.\r\nfor itr in range(1, gvn_numb+1):\r\n    # Check whether the given number modulus iterator value is equal to '0' or not\r\n    # using if conditional statement.\r\n    if gvn_numb % itr == 0:\r\n# If the statement is True, Check if the iterator modulus 2 is equal to 0 using the\r\n# if conditional statement.\r\n        if itr % 2 == 0:\r\n            # If the statement is True ,append the iterator value to the above declared list .\r\n            all_factors.append(itr)\r\n      # Get the sum of all the even factors of above got list using built-in sum() function\r\n      # and store it in another variable.\r\nreslt = sum(all_factors)\r\n# Print the sum of all even factors of a given number.\r\nprint(\"The Sum of all even factors of {\", gvn_numb, \"}  = \", reslt)"}
{"nl": "Linked List implementation of Queue", "code": "# Python3 program to demonstrate linked list\n# based implementation of queue\n\n# A linked list (LL) node\n# to store a queue entry\nclass Node:\n\t\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\n# A class to represent a queue\n\n# The queue, front stores the front node\n# of LL and rear stores the last node of LL\nclass Queue:\n\t\n\tdef __init__(self):\n\t\tself.front = self.rear = None\n\n\tdef isEmpty(self):\n\t\treturn self.front == None\n\t\n\t# Method to add an item to the queue\n\tdef EnQueue(self, item):\n\t\ttemp = Node(item)\n\t\t\n\t\tif self.rear == None:\n\t\t\tself.front = self.rear = temp\n\t\t\treturn\n\t\tself.rear.next = temp\n\t\tself.rear = temp\n\n\t# Method to remove an item from queue\n\tdef DeQueue(self):\n\t\t\n\t\tif self.isEmpty():\n\t\t\treturn\n\t\ttemp = self.front\n\t\tself.front = temp.next\n\n\t\tif(self.front == None):\n\t\t\tself.rear = None\n\n# Driver Code\nif __name__== '__main__':\n\tq = Queue()\n\tq.EnQueue(10)\n\tq.EnQueue(20)\n\tq.DeQueue()\n\tq.DeQueue()\n\tq.EnQueue(30)\n\tq.EnQueue(40)\n\tq.EnQueue(50)\n\tq.DeQueue()\n\tprint(\"Queue Front \" + str(q.front.data))\n\tprint(\"Queue Rear \" + str(q.rear.data))\n\t"}
{"nl": "rearrange an array by partition according to a given pivot", "code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        left = []\n        mid = []\n        right = []\n        for n in nums:\n            if n < pivot:\n                left.append(n)\n            elif n == pivot:\n                mid.append(n)\n            elif n > pivot:\n                right.append(n)\n        return left + mid + right"}
{"nl": "count the number of integers less than n and consisting of the given non-decreasing digit array", "code": "class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        sn = str(n)\n        ln = len(sn)\n        res = 0\n        digits = tuple(digits)\n        for l in range(1,ln+1):\n            part = self.dfs(sn,l,digits)\n            res += part\n        return res\n    def dfs(self,sn,l,digits):\n        # return the number of numbers 1) whose length is l 2) constructed only using numbers from digits 3) smaller than sn \n        if l < len(sn):\n            return len(digits) ** l\n        elif l > len(sn):\n            return 0\n        else:\n            res = 0\n            for d in digits:\n                d = int(d)\n                if d == int(sn[0]):\n                    res += self.dfs(sn[1:],l-1,digits) if l-1 > 0 else 1\n                    break\n                elif d > int(sn[0]):\n                    res += 0\n                    break\n                else:  # d < int(sn[0])\n                    res += len(digits) ** (len(sn) - 1)\n            return res"}
{"nl": "Grade Point Average", "code": "def gpa_calculator(student):\n    pts = {'A':4, 'B':3, 'C':2, 'D':1, 'F':0}\n    qp = []\n    hr = []\n    for c in student['courses']:\n        qp.append(pts[c['grade']])\n        hr.append(c['credit_hours'])\n    num = sum([qp[i]*hr[i] for i in range(len(qp))])\n    den = sum(hr)\n    av = \"% 4.2f\" % (num / den)\n    return student['name'] + ' GPA for ' + student['semester'] + ' is' + av"}
{"nl": "Check if a given Binary Tree is Heap", "code": "# To check if a binary tree\n# is a MAX Heap or not\n\n\nclass GFG:\n\tdef __init__(self, value):\n\t\tself.key = value\n\t\tself.left = None\n\t\tself.right = None\n\n\tdef count_nodes(self, root):\n\t\tif root is None:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn (1 + self.count_nodes(root.left) +\n\t\t\t\t\tself.count_nodes(root.right))\n\n\tdef heap_property_util(self, root):\n\n\t\tif (root.left is None and\n\t\t\t\troot.right is None):\n\t\t\treturn True\n\n\t\tif root.right is None:\n\t\t\treturn root.key >= root.left.key\n\t\telse:\n\t\t\tif (root.key >= root.left.key and\n\t\t\t\t\troot.key >= root.right.key):\n\t\t\t\treturn (self.heap_property_util(root.left) and\n\t\t\t\t\t\tself.heap_property_util(root.right))\n\t\t\telse:\n\t\t\t\treturn False\n\n\tdef complete_tree_util(self, root,\n\t\t\t\t\t\tindex, node_count):\n\t\tif root is None:\n\t\t\treturn True\n\t\tif index >= node_count:\n\t\t\treturn False\n\t\treturn (self.complete_tree_util(root.left, 2 *\n\t\t\t\t\t\t\t\t\t\tindex + 1, node_count) and\n\t\t\t\tself.complete_tree_util(root.right, 2 *\n\t\t\t\t\t\t\t\t\t\tindex + 2, node_count))\n\n\tdef check_if_heap(self):\n\t\tnode_count = self.count_nodes(self)\n\t\tif (self.complete_tree_util(self, 0, node_count) and\n\t\t\t\tself.heap_property_util(self)):\n\t\t\treturn True\n\t\telse:\n\t\t\treturn False\n\n\n# Driver Code\nroot = GFG(5)\nroot.left = GFG(2)\nroot.right = GFG(3)\nroot.left.left = GFG(1)\n\nif root.check_if_heap():\n\tprint(\"Given binary tree is a heap\")\nelse:\n\tprint(\"Given binary tree is not a Heap\")\n\n# This code has been\n# contributed by Yash Agrawal"}
{"nl": "Count Number of Identical Lists", "code": "def count_identical_lists(lst1, lst2, lst3, lst4):\n  thicboi = [lst1, lst2, lst3, lst4]\n  res =  max(thicboi.count(x) for x in thicboi)\n  return res if res > 1 else 0"}
{"nl": "Print all Happy Numbers within a given Range", "code": "# Create a function digitSquareSum() that accepts the given number\r\n# as an argument and returns the sum of squares of digits.\r\n\r\n\r\ndef digitSquareSum(resltnumber):\r\n    # Inside the digitSquareSum() function.\r\n    # Convert the given argument to string using the str() function.\r\n    strnumbe = str(resltnumber)\r\n    # Convert the given argument into list of digits using list(),map(),int() functions.\r\n    # Store it in a variable.\r\n    numbrlistdigits = list(map(int, strnumbe))\r\n    # Take a variable sumsquaredigits and initialize its value to 0.\r\n    sumsquaredigits = 0\r\n    # Loop in this digits list using For loop.\r\n    for digitvalu in numbrlistdigits:\r\n        # Increment the value of sumsquaredigits by the square\r\n        # of the digit(iterator value).\r\n        sumsquaredigits = sumsquaredigits+(digitvalu**2)\r\n    # Return the sumsquaredigits value\r\n    return sumsquaredigits\r\n\r\n# Create a function checkhapppynumb() which accepts the number as an argument\r\n# and returns true if it is happy number else returns False.\r\n\r\n\r\ndef checkhapppynumb(numb):\r\n    # Take a variable rest and initialize its value to the given argument.\r\n    rest = numb\r\n    # Loop till the rest is not equal to 1 or 4 using while loop.\r\n    while(rest != 1 and rest != 4):\r\n        # Inside the loop pass the reslt value to digitSquareSum()\r\n        # and store it in the same variable reslt.\r\n        rest = digitSquareSum(rest)\r\n    # After the end of the while loop,\r\n    # Check whether rest value is 1 or not using the If statement.\r\n    if(rest == 1):\r\n        # If it is true then the given number is a happy number so return True\r\n        return True\r\n    else:\r\n        # Else it is not a happy number so return False.\r\n        return False\r\n\r\n\r\n# Give the lower limit range and upper limit range as\r\n# user input using map(),int(),split() functions.\r\n# Store them in two separate variables.\r\nlowlimrange, upplimrange = map(int, input(\r\n    'Enter lower limit range and upper limit range separate bt spaces = ').split())\r\nprint('The Harshad numbers in the given range',\r\n      lowlimrange, 'and', upplimrange, 'are:')\r\nprint('The happy numbers in the given range',\r\n      lowlimrange, 'and', upplimrange, 'are:')\r\n# Loop from lower limit range to upper limit range using For loop.\r\nfor l in range(lowlimrange, upplimrange+1):\r\n        # IInside the for loop pass the iterator value to checkhapppynumb() function.\r\n    if(checkhapppynumb(l)):\r\n        # If it returns true then print the iterator value.\r\n        print(l, end=' ')"}
{"nl": "Remove items or elements from the list using the pop() method", "code": "# Python program to remove element from list by index # take list my_list = ['C', 'Java', 'Python', 'HTML', 'Javascript'] # printing original list print('List:', my_list) # removed index 3 item from the list my_list.pop(3) # print list after item deletion print('New list:', my_list)"}
{"nl": "Find the First Non-Repeated Character", "code": "def first_non_repeated_character(txt):\n  for c in txt:\n    if txt.count(c) == 1:\n      return c\n  return False"}
{"nl": "Reverse a Doubly Linked List", "code": "# Program to reverse a doubly linked list\n\n# A node of the doubly linked list\n\n\nclass Node:\n\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\t\tself.prev = None\n\n\nclass DoublyLinkedList:\n\t# Constructor for empty Doubly Linked List\n\tdef __init__(self):\n\t\tself.head = None\n\n\t# Function reverse a Doubly Linked List\n\tdef reverse(self):\n\t\ttemp = None\n\t\tcurrent = self.head\n\n\t\t# Swap next and prev for all nodes of\n\t\t# doubly linked list\n\t\twhile current is not None:\n\t\t\ttemp = current.prev\n\t\t\tcurrent.prev = current.next\n\t\t\tcurrent.next = temp\n\t\t\tcurrent = current.prev\n\n\t\t# Before changing head, check for the cases like\n\t\t# empty list and list with only one node\n\t\tif temp is not None:\n\t\t\tself.head = temp.prev\n\n\t# Given a reference to the head of a list and an\n\t# integer,inserts a new node on the front of list\n\tdef push(self, new_data):\n\n\t\t# 1. Allocates node\n\t\t# 2. Put the data in it\n\t\tnew_node = Node(new_data)\n\n\t\t# 3. Make next of new node as head and\n\t\t# previous as None (already None)\n\t\tnew_node.next = self.head\n\n\t\t# 4. change prev of head node to new_node\n\t\tif self.head is not None:\n\t\t\tself.head.prev = new_node\n\n\t\t# 5. move the head to point to the new node\n\t\tself.head = new_node\n\n\tdef printList(self, node):\n\t\twhile(node is not None):\n\t\t\tprint(node.data,end=' ')\n\t\t\tnode = node.next\n\n\n# Driver code\ndll = DoublyLinkedList()\ndll.push(2)\ndll.push(4)\ndll.push(8)\ndll.push(10)\n\nprint (\"\\nOriginal Linked List\")\ndll.printList(dll.head)\n\n# Reverse doubly linked list\ndll.reverse()\n\nprint (\"\\nReversed Linked List\")\ndll.printList(dll.head)\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Depth First Search", "code": "# Python3 program to print DFS traversal\n# from a given given graph\nfrom collections import defaultdict\n\n# This class represents a directed graph using\n# adjacency list representation\n\n\nclass Graph:\n\n\t# Constructor\n\tdef __init__(self):\n\n\t\t# default dictionary to store graph\n\t\tself.graph = defaultdict(list)\n\n\t# function to add an edge to graph\n\tdef addEdge(self, u, v):\n\t\tself.graph[u].append(v)\n\n\t# A function used by DFS\n\tdef DFSUtil(self, v, visited):\n\n\t\t# Mark the current node as visited\n\t\t# and print it\n\t\tvisited.add(v)\n\t\tprint(v, end=' ')\n\n\t\t# Recur for all the vertices\n\t\t# adjacent to this vertex\n\t\tfor neighbour in self.graph[v]:\n\t\t\tif neighbour not in visited:\n\t\t\t\tself.DFSUtil(neighbour, visited)\n\n\t# The function to do DFS traversal. It uses\n\t# recursive DFSUtil()\n\tdef DFS(self, v):\n\n\t\t# Create a set to store visited vertices\n\t\tvisited = set()\n\n\t\t# Call the recursive helper function\n\t\t# to print DFS traversal\n\t\tself.DFSUtil(v, visited)\n\n# Driver code\n\n\n# Create a graph given\n# in the above diagram\ng = Graph()\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n\nprint(\"Following is DFS from (starting from vertex 2)\")\ng.DFS(2)\n\n# This code is contributed by Neelam Yadav"}
{"nl": "Find a number in minimum steps", "code": "from collections import deque\n\u00a0\n# Python program to find a number in minimum steps\nInF = 99999\n\u00a0\n# To represent data of a node in tree\nclass number:\n\u00a0\u00a0\u00a0\u00a0def __init__(self,n,l):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.no = n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.level = l\n\u00a0\n# Prints level of node n\ndef findnthnumber(n):\n\u00a0\u00a0\u00a0\u00a0# Create a queue and insert root\n\u00a0\u00a0\u00a0\u00a0q = deque()\n\u00a0\u00a0\u00a0\u00a0r = number(0, 1)\n\u00a0\u00a0\u00a0\u00a0q.append(r)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Do level order traversal\n\u00a0\u00a0\u00a0\u00a0while (len(q) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove a node from queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = q.popleft()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# q.pop()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# To avoid infinite loop\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.no >= InF or temp.no <= -InF):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if dequeued number is same as n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.no == n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Found number n at level\", temp.level - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Insert children of dequeued node to queue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append(number(temp.no + temp.level, temp.level + 1))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q.append(number(temp.no - temp.level, temp.level + 1))\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0findnthnumber(13)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Python Program to Find Factorial of Number Using Recursion", "code": "# Factorial of a number using recursion\n\ndef recur_factorial(n):\n   if n == 1:\n       return n\n   else:\n       return n*recur_factorial(n-1)\n\nnum = 7\n\n# check if the number is negative\nif num < 0:\n   print(\"Sorry, factorial does not exist for negative numbers\")\nelif num == 0:\n   print(\"The factorial of 0 is 1\")\nelse:\n   print(\"The factorial of\", num, \"is\", recur_factorial(num))"}
{"nl": "Sorted Linked List to Balanced BST", "code": "# Python3 implementation of above approach\n\u00a0\n# Link list node\nclass LNode :\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next = None\n\u00a0\n# A Binary Tree node\nclass TNode :\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\nhead = None\n\u00a0\n# This function counts the number of\n# nodes in Linked List and then calls\n# sortedListToBSTRecur() to construct BST\ndef sortedListToBST():\n\u00a0\u00a0\u00a0\u00a0global head\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Count the number of nodes in Linked List\n\u00a0\u00a0\u00a0\u00a0n = countLNodes(head)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Construct BST\n\u00a0\u00a0\u00a0\u00a0return sortedListToBSTRecur(n)\n\u00a0\n# The main function that constructs\n# balanced BST and returns root of it.\n# head -. Pointer to pointer to\n# head node of linked list n -. No.\n# of nodes in Linked List\ndef sortedListToBSTRecur( n) :\n\u00a0\u00a0\u00a0\u00a0global head\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if (n <= 0) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recursively construct the left subtree\n\u00a0\u00a0\u00a0\u00a0left = sortedListToBSTRecur( int(n/2))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Allocate memory for root, and\n\u00a0\u00a0\u00a0\u00a0# link the above constructed left\n\u00a0\u00a0\u00a0\u00a0# subtree with root\n\u00a0\u00a0\u00a0\u00a0root = newNode((head).data)\n\u00a0\u00a0\u00a0\u00a0root.left = left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Change head pointer of Linked List\n\u00a0\u00a0\u00a0\u00a0# for parent recursive calls\n\u00a0\u00a0\u00a0\u00a0head = (head).next\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recursively construct the right\n\u00a0\u00a0\u00a0\u00a0# subtree and link it with root\n\u00a0\u00a0\u00a0\u00a0# The number of nodes in right subtree\n\u00a0\u00a0\u00a0\u00a0# is total nodes - nodes in\n\u00a0\u00a0\u00a0\u00a0# left subtree - 1 (for root) which is n-n/2-1\n\u00a0\u00a0\u00a0\u00a0root.right = sortedListToBSTRecur( n - int(n/2) - 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# UTILITY FUNCTIONS\n\u00a0\n# A utility function that returns\n# count of nodes in a given Linked List\ndef countLNodes(head) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0count = 0\n\u00a0\u00a0\u00a0\u00a0temp = head\n\u00a0\u00a0\u00a0\u00a0while(temp != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = temp.next\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count = count + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return count\n\u00a0\n# Function to insert a node\n#at the beginning of the linked list\ndef push(head, new_data) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# allocate node\n\u00a0\u00a0\u00a0\u00a0new_node = LNode()\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# put in the data\n\u00a0\u00a0\u00a0\u00a0new_node.data = new_data\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# link the old list off the new node\n\u00a0\u00a0\u00a0\u00a0new_node.next = (head)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# move the head to point to the new node\n\u00a0\u00a0\u00a0\u00a0(head) = new_node\n\u00a0\u00a0\u00a0\u00a0return head\n\u00a0\n\u00a0\n# Function to print nodes in a given linked list\ndef printList(node):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while(node != None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print( node.data ,end= \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.next\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# Helper function that allocates a new node with the\n# given data and None left and right pointers.\ndef newNode(data) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0node = TNode()\n\u00a0\u00a0\u00a0\u00a0node.data = data\n\u00a0\u00a0\u00a0\u00a0node.left = None\n\u00a0\u00a0\u00a0\u00a0node.right = None\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\n# A utility function to\n# print preorder traversal of BST\ndef preOrder( node) :\n\u00a0\n\u00a0\u00a0\u00a0\u00a0if (node == None) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0print(node.data, end = \" \" )\n\u00a0\u00a0\u00a0\u00a0preOrder(node.left)\n\u00a0\u00a0\u00a0\u00a0preOrder(node.right)\n\u00a0\n# Driver code\n\u00a0\n# Start with the empty list\nhead = None\n\u00a0\n# Let us create a sorted linked list to test the functions\n# Created linked list will be 1.2.3.4.5.6.7\nhead = push(head, 7)\nhead = push(head, 6)\nhead = push(head, 5)\nhead = push(head, 4)\nhead = push(head, 3)\nhead = push(head, 2)\nhead = push(head, 1)\n\u00a0\nprint(\"Given Linked List \" )\nprintList(head)\n\u00a0\n# Convert List to BST\nroot = sortedListToBST()\nprint(\"\\nPreOrder Traversal of constructed BST \")\npreOrder(root)\n\u00a0\n# This code is contributed by Arnab Kundu\n"}
{"nl": "Find ASCII Value Of Given Character", "code": "# ASCII value of given character\r\n\r\ncharacter = input(\"Enter character: \")\r\n\r\nprint(\"ASCII value is: \", ord(character))"}
{"nl": "Print a Calendar in Python", "code": "import calendar yy = 2022 mm = 10 print(calendar.month(yy, mm))"}
{"nl": "Python Program to Sort digits of a Number in Ascending Order", "code": "# Give the number as static input and store it in a variable.\n \n numb = 4561230008\n \n # Convert the given number into a string number using the str() function and\n \n # store it in another variable.\n \n strng_numbr = str(numb)\n \n # Sort the above-obtained string number using the sorted() function and store\n \n # it in another variable.\n \n sortdlst_num = sorted(strng_numbr)\n \n # Convert this sorted list of numbers into a string using the join function and\n \n # store it in another variable.\n \n sortd_str = ''.join(sortdlst_num)\n \n # Convert the above obtained sorted string to an integer using the int() function\n \n # (This removes the leading zeros) and store it in another variable.\n \n rslt = int(sortd_str)\n \n # Print the sorted digits in ascending order of a given number after removal of\n \n # leading zeros.\n \n print(\"The sorted digits in ascending order of a given number\",\n \n  numb, \"after removal of leading zeros =\")\n \n print(rslt)\n \n </pre>"}
{"nl": "Calculate the number of words and the number of characters present in a string", "code": "# Give the string as static input and store it in a variable.\ngiven_string = 'Hello this is btechgeeks'\n# Take a variable to say stringchars that store the total characters in the given string.\n# Initialize the stringchars to 0.\nstringchars = 0\n# Take a variable to say stringwords that stores the total words in the given string.\n# Initialize the stringwords to 1.\nstringwords = 1\n# To traverse the characters in the string, use a For loop.\nfor charact in given_string:\n  # If a space character is encountered then increment the stringwords by 1.\n  if(charact == ' '):\n  stringwords = stringwords+1\n  # increment the stringchars variable each time by 1.\n  stringchars = stringchars+1\n# Print the total words and character present in the given string\nprint('Total characters present in given string {', given_string, '} =', stringchars)\nprint('Total words present in given string {', given_string, '} =', stringwords)"}
{"nl": "Check if a String Contains Special Characters in Python", "code": "# Python program to check special character # import required package import re # take inputs string = input('Enter any string: ') # special characters special_char = re.compile('[@_!#$%^&*()<>?/\\|}{~:]') # check string contains special characters or not if(special_char.search(string) == None): print('String does not contain any special characters.') else: print('The string contains special characters.')"}
{"nl": "recover the original array given the addition operations done on it", "code": "class Solution:\n    def recoverArray(self, nums: List[int]) -> List[int]:\n        counter = Counter(nums)  # counter\n        nums = sorted(counter)   # sorted unique numbers\n\n        hm = nums[-1]            # the max number must be the max in the \"higher\" group\n        for num in nums[:-1]:    # test the corresponding number in the \"lower\" group. Not necessarily the min.\n            k, m = divmod(hm - num, 2)  # derived \"k\"\n            if m:                       # there is a remainder, so they are partners\n                continue\n            ans = []                    # to store the answer in case this will succeed\n            cnt = counter.copy()        # not sure if there is a better way than this\n            for n in nums:              # validation starts now.  start with the smallest value\n                c = cnt.pop(n)          # its number\n                if c == 0:              # this value must have been fully considered in the \"higher\" group\n                    continue\n                o = n + k                # derived origin\n                p = o + k                # derived partner\n                if cnt[p] >= c:          # \"p\" should have enough number. If it has more, the remaining join \"lower\".\n                    cnt[p] -= c          # reduce the count\n                    ans.extend([o] * c)  # add them into \"ans\"\n                else:                    # validation failed\n                    break\n            else:\n                return ans"}
{"nl": "Count number of binary strings without consecutive 1\u2019s for given String Length N", "code": "# Python program to count\n# all distinct binary strings\n# without two consecutive 1's\n \ndef countStrings(n):\n \n    a=[0 for i in range(n)]\n    b=[0 for i in range(n)]\n    a[0] = b[0] = 1\n    for i in range(1,n):\n        a[i] = a[i-1] + b[i-1]\n        b[i] = a[i-1]\n     \n    return a[n-1] + b[n-1]\n \n# Driver program to test\n# above functions\n \nprint(countStrings(3))\n \n# This code is contributed\n# by Anant Agarwal."}
{"nl": "Level Order Binary Tree Traversal", "code": "# Python program to print level\r\n# order traversal using Queue\r\n\r\n# A node structure\r\n\r\n\r\nclass Node:\r\n\t# A utility function to create a new node\r\n\tdef __init__(self, key):\r\n\t\tself.data = key\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# Iterative Method to print the\r\n# height of a binary tree\r\n\r\n\r\ndef printLevelOrder(root):\r\n\t# Base Case\r\n\tif root is None:\r\n\t\treturn\r\n\r\n\t# Create an empty queue\r\n\t# for level order traversal\r\n\tqueue = []\r\n\r\n\t# Enqueue Root and initialize height\r\n\tqueue.append(root)\r\n\r\n\twhile(len(queue) > 0):\r\n\r\n\t\t# Print front of queue and\r\n\t\t# remove it from queue\r\n\t\tprint(queue[0].data)\r\n\t\tnode = queue.pop(0)\r\n\r\n\t\t# Enqueue left child\r\n\t\tif node.left is not None:\r\n\t\t\tqueue.append(node.left)\r\n\r\n\t\t# Enqueue right child\r\n\t\tif node.right is not None:\r\n\t\t\tqueue.append(node.right)\r\n\r\n\r\n# Driver Program to test above function\r\nroot = Node(1)\r\nroot.left = Node(2)\r\nroot.right = Node(3)\r\nroot.left.left = Node(4)\r\nroot.left.right = Node(5)\r\n\r\nprint(\"Level Order Traversal of binary tree is -\")\r\nprintLevelOrder(root)\r\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\r"}
{"nl": "Binary Search function", "code": "# A recursive binary search function. It returns location of x in\n# given array arr[l..r] is present, otherwise -1\ndef binarySearch(arr, l, r, x):\nif (r >= l):\n\t\tmid = l + (r - l)/2;\n\t\t\n# If the element is present at the middle itself\nif (arr[mid] == x):\n\t\treturn mid;\n\t\n# If element is smaller than mid, then it can only be present\n# in left subarray\n\tif (arr[mid] > x):\n\treturn binarySearch(arr, l, mid-1, x);\n\n\t# Else the element can only be present in right subarray\n\treturn binarySearch(arr, mid+1, r, x);\n\t\n# We reach here when element is not present in array\nreturn -1;\n\n# This code is contributed by umadevi9616"}
{"nl": "Python Program to Remove the last Word from the String/Sentence", "code": "# Give the string/sentence as static input and store it in a variable.\n \n gven_strng = 'Hello this is btechgeeks'\n \n # Convert the given string into a list of words using the list() and split() functions\n \n # and store it in another variable.\n \n str_lst = list(gven_strng.split())\n \n # Apply pop() function on the above list of words.\n \n str_lst.pop()\n \n # Convert the list of words into the string using the join() function and store it in\n \n # another variable.\n \n modified_str = ' '.join(str_lst)\n \n # Print the String after removal of the last word from the above-given string.\n \n print(\"The given string{\", gven_strng,\n \n  \"} after removal of last word = \", modified_str)\n \n </pre>"}
{"nl": "maximum product subarray", "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n\n        result = nums[0]\n\n        for i in range(len(nums)):\n            accu = 1\n            for j in range(i, len(nums)):\n                accu *= nums[j]\n                result = max(result, accu)\n\n        return result"}
{"nl": "The maximum sum of a constrained subsequence", "code": "def constrainedSubsetSum(self, A, k):\n  deque = collections.deque()\n  for i in xrange(len(A)):\n  A[i] += deque[0] if deque else 0\n  while len(deque) and A[i] > deque[-1]:\n  deque.pop()\n  if A[i] > 0:\n  deque.append(A[i])\n  if i >= k and deque and deque[0] == A[i - k]:\n  deque.popleft()\n  return max(A)"}
{"nl": "Density based clustering machine learnng DBSCAN", "code": "import matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom sklearn.cluster import DBSCAN\r\nfrom sklearn import metrics\r\nfrom sklearn.datasets.samples_generator import make_blobs\r\nfrom sklearn.preprocessing import StandardScaler\r\nfrom sklearn import datasets\r\n  \r\n# Load data in X\r\nX, y_true = make_blobs(n_samples=300, centers=4,\r\n                       cluster_std=0.50, random_state=0)\r\ndb = DBSCAN(eps=0.3, min_samples=10).fit(X)\r\ncore_samples_mask = np.zeros_like(db.labels_, dtype=bool)\r\ncore_samples_mask[db.core_sample_indices_] = True\r\nlabels = db.labels_\r\n  \r\n# Number of clusters in labels, ignoring noise if present.\r\nn_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\r\n  \r\nprint(labels)\r\n  \r\n# Plot result\r\n  \r\n# Black removed and is used for noise instead.\r\nunique_labels = set(labels)\r\ncolors = ['y', 'b', 'g', 'r']\r\nprint(colors)\r\nfor k, col in zip(unique_labels, colors):\r\n    if k == -1:\r\n        # Black used for noise.\r\n        col = 'k'\r\n  \r\n    class_member_mask = (labels == k)\r\n  \r\n    xy = X[class_member_mask & core_samples_mask]\r\n    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=col,\r\n             markeredgecolor='k',\r\n             markersize=6)\r\n  \r\n    xy = X[class_member_mask & ~core_samples_mask]\r\n    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=col,\r\n             markeredgecolor='k',\r\n             markersize=6)\r\n  \r\nplt.title('number of clusters: %d' % n_clusters_)\r\nplt.show()"}
{"nl": "Print all elements in sorted order from row and column wise sorted matrix", "code": "# Python 3 program to Print all elements\n# in sorted order from row and column\n# wise sorted matrix\nimport sys\n\u00a0\nINF = sys.maxsize\nN = 4\n\u00a0\n# A utility function to youngify a Young\n# Tableau. This is different from standard\n# youngify. It assumes that the value at\n# mat[0][0] is infinite.\ndef youngify(mat, i, j):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Find the values at down and\n\u00a0\u00a0\u00a0\u00a0# right sides of mat[i][j]\n\u00a0\u00a0\u00a0\u00a0downVal = mat[i + 1][j] if (i + 1 < N) else INF\n\u00a0\u00a0\u00a0\u00a0rightVal = mat[i][j + 1] if (j + 1 < N) else INF\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If mat[i][j] is the down right\n\u00a0\u00a0\u00a0\u00a0# corner element, return\n\u00a0\u00a0\u00a0\u00a0if (downVal == INF and rightVal == INF):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Move the smaller of two values\n\u00a0\u00a0\u00a0\u00a0# (downVal and rightVal) to mat[i][j]\n\u00a0\u00a0\u00a0\u00a0# and recur for smaller value\n\u00a0\u00a0\u00a0\u00a0if (downVal < rightVal):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = downVal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i + 1][j] = INF\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0youngify(mat, i + 1, j)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j] = rightVal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat[i][j + 1] = INF\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0youngify(mat, i, j + 1)\n\u00a0\n# A utility function to extract minimum\n# element from Young tableau\ndef extractMin(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0ret = mat[0][0]\n\u00a0\u00a0\u00a0\u00a0mat[0][0] = INF\n\u00a0\u00a0\u00a0\u00a0youngify(mat, 0, 0)\n\u00a0\u00a0\u00a0\u00a0return ret\n\u00a0\n# This function uses extractMin() to\n# print elements in sorted order\ndef printSorted(mat):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Elements of matrix in sorted order n\")\n\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0while i < N * N:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(extractMin(mat), end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[10, 20, 30, 40],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[15, 25, 35, 45],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[27, 29, 37, 48],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[32, 33, 39, 50]]\n\u00a0\u00a0\u00a0\u00a0printSorted(mat)\n\u00a0\n# This code is contributed by ita_c\n"}
{"nl": "Check if a binary tree is subtree of another binary tree", "code": "# Python program to check binary tree is a subtree of\n# another tree\n\n# A binary tree node\nclass Node:\n\n        # Constructor to create a new node\n        def __init__(self, data):\n                self.data = data\n                self.left = None\n                self.right = None\n\n# A utility function to check whether trees with roots\n# as root 1 and root2 are indetical or not\ndef areIdentical(root1, root2):\n        \n        # Base Case\n        if root1 is None and root2 is None:\n                return True\n        if root1 is None or root2 is None:\n                return False\n\n        # Check fi the data of both roots is same and data of\n        # left and right subtrees are also same\n        return (root1.data == root2.data and\n                        areIdentical(root1.left , root2.left)and\n                        areIdentical(root1.right, root2.right)\n                        )\n\n# This function returns True if S is a subtree of T,\n# otherwise False\ndef isSubtree(T, S):\n        \n        # Base Case\n        if S is None:\n                return True\n\n        if T is None:\n                return False\n\n        # Check the tree with root as current node\n        if (areIdentical(T, S)):\n                return True\n\n        # IF the tree with root as current node doesn't match\n        # then try left and right subtreee one by one\n        return isSubtree(T.left, S) or isSubtree(T.right, S)\n\n\n# Driver program to test above function\n\n\"\"\" TREE 1\n        Construct the following tree\n                        26\n                        / \\\n                10         3\n                / \\         \\\n        4         6         3\n        \\\n                30\n        \"\"\"\n\nT = Node(26)\nT.right = Node(3)\nT.right.right = Node(3)\nT.left = Node(10)\nT.left.left = Node(4)\nT.left.left.right = Node(30)\nT.left.right = Node(6)\n\n\"\"\" TREE 2\n        Construct the following tree\n                10\n                / \\\n        4         6\n        \\\n                30\n        \"\"\"\nS = Node(10)\nS.right = Node(6)\nS.left = Node(4)\nS.left.right = Node(30)\n\nif isSubtree(T, S):\n        print (\"Tree 2 is subtree of Tree 1\")\nelse :\n        print (\"Tree 2 is not a subtree of Tree 1\")\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Print the longest leaf to leaf path in a Binary tree", "code": "# Python3 program to print the longest\n# leaf to leaf path\n\n# Tree node structure used in the program\nclass Node:\n\t\n\tdef __init__(self, x):\n\t\t\n\t\tself.data = x\n\t\tself.left = None\n\t\tself.right = None\n\n# Function to find height of a tree\ndef height(root):\n\t\n\tglobal ans, k, lh, rh, f\n\t\n\tif (root == None):\n\t\treturn 0\n\n\tleft_height = height(root.left)\n\n\tright_height = height(root.right)\n\n\t# Update the answer, because diameter of a\n\t# tree is nothing but maximum value of\n\t# (left_height + right_height + 1) for each node\n\tif (ans < 1 + left_height + right_height):\n\t\tans = 1 + left_height + right_height\n\n\t\t# Save the root, this will help us finding the\n\t\t# left and the right part of the diameter\n\t\tk = root\n\n\t\t# Save the height of left & right\n\t\t# subtree as well.\n\t\tlh = left_height\n\t\trh = right_height\n\n\treturn 1 + max(left_height, right_height)\n\n# Prints the root to leaf path\ndef printArray(ints, lenn, f):\n\t\n\t# Print left part of the path\n\t# in reverse order\n\tif (f == 0):\n\t\tfor i in range(lenn - 1, -1, -1):\n\t\t\tprint(ints[i], end = \" \")\n\n\t# Print right part of the path\n\telif (f == 1):\n\t\tfor i in range(lenn):\n\t\t\tprint(ints[i], end = \" \")\n\n# This function finds out all the\n# root to leaf paths\ndef printPathsRecur(node, path, maxm, pathlen):\n\t\n\tglobal f\n\n\tif (node == None):\n\t\treturn\n\n\t# Append this node to the path array\n\tpath[pathlen] = node.data\n\tpathlen += 1\n\n\t# If it's a leaf, so print the\n\t# path that led to here\n\tif (node.left == None and node.right == None):\n\t\t\n\t\t# Print only one path which is equal to the\n\t\t# height of the tree.\n\t\t# print(pathlen,\"---\",maxm)\n\t\tif (pathlen == maxm and (f == 0 or f == 1)):\n\t\t\t\n\t\t\t# print(\"innn\")\n\t\t\tprintArray(path, pathlen,f)\n\t\t\tf = 2\n\n\telse:\n\t\t\n\t\t# Otherwise try both subtrees\n\t\tprintPathsRecur(node.left, path, maxm, pathlen)\n\t\tprintPathsRecur(node.right, path, maxm, pathlen)\n\n# Computes the diameter of a binary\n# tree with given root.\ndef diameter(root):\n\t\n\tglobal ans, lh, rh, f, k, pathLen\n\n\tif (root == None):\n\t\treturn\n\t\n\t# f is a flag whose value helps in printing\n\t# left & right part of the diameter only once\n\theight_of_tree = height(root)\n\tlPath = [0 for i in range(100)]\n\n\t# print(lh,\"--\",rh)\n\n\t# Print the left part of the diameter\n\tprintPathsRecur(k.left, lPath, lh, 0);\n\tprint(k.data, end = \" \")\n\trPath = [0 for i in range(100)]\n\tf = 1\n\n\t# Print the right part of the diameter\n\tprintPathsRecur(k.right, rPath, rh, 0)\n\t\n# Driver code\nif __name__ == '__main__':\n\t\n\tk, lh, rh, f, ans, pathLen = None, 0, 0, 0, 0 - 10 ** 19, 0\n\t\n\t# Enter the binary tree ...\n\t#\t\t 1\n\t#\t / \\\n\t#\t 2\t 3\n\t#\t / \\\n\t# 4\t 5\n\t#\t \\ / \\\n\t#\t 8 6 7\n\t#\t /\n\t# 9\n\troot = Node(1)\n\troot.left = Node(2)\n\troot.right = Node(3)\n\troot.left.left = Node(4)\n\troot.left.right = Node(5)\n\troot.left.right.left = Node(6)\n\troot.left.right.right = Node(7)\n\troot.left.left.right = Node(8)\n\troot.left.left.right.left = Node(9)\n\n\tdiameter(root)\n\t\n# This code is contributed by mohit kumar 29"}
{"nl": "Find maximum sum sub 2d array", "code": "# Python3 program to find maximum sum\n# subarray in a given 2D array\n \n# Implementation of Kadane's algorithm\n# for 1D array. The function returns the\n# maximum sum and stores starting and\n# ending indexes of the maximum sum subarray\n# at addresses pointed by start and finish\n# pointers respectively.\n \n \ndef kadane(arr, start, finish, n):\n \n    # initialize sum, maxSum and\n    Sum = 0\n    maxSum = -999999999999\n    i = None\n \n    # Just some initial value to check\n    # for all negative values case\n    finish[0] = -1\n \n    # local variable\n    local_start = 0\n \n    for i in range(n):\n        Sum += arr[i]\n        if Sum < 0:\n            Sum = 0\n            local_start = i + 1\n        elif Sum > maxSum:\n            maxSum = Sum\n            start[0] = local_start\n            finish[0] = i\n \n    # There is at-least one\n    # non-negative number\n    if finish[0] != -1:\n        return maxSum\n \n    # Special Case: When all numbers\n    # in arr[] are negative\n    maxSum = arr[0]\n    start[0] = finish[0] = 0\n \n    # Find the maximum element in array\n    for i in range(1, n):\n        if arr[i] > maxSum:\n            maxSum = arr[i]\n            start[0] = finish[0] = i\n    return maxSum\n \n# The main function that finds maximum\n# sum rectangle in M[][]\n \n \ndef findMaxSum(M):\n    global ROW, COL\n \n    # Variables to store the final output\n    maxSum, finalLeft = -999999999999, None\n    finalRight, finalTop, finalBottom = None, None, None\n    left, right, i = None, None, None\n \n    temp = [None] * ROW\n    Sum = 0\n    start = [0]\n    finish = [0]\n \n    # Set the left column\n    for left in range(COL):\n \n        # Initialize all elements of temp as 0\n        temp = [0] * ROW\n \n        # Set the right column for the left\n        # column set by outer loop\n        for right in range(left, COL):\n \n            # Calculate sum between current left\n            # and right for every row 'i'\n            for i in range(ROW):\n                temp[i] += M[i][right]\n \n            # Find the maximum sum subarray in\n            # temp[]. The kadane() function also\n            # sets values of start and finish.\n            # So 'sum' is sum of rectangle between\n            # (start, left) and (finish, right) which\n            # is the maximum sum with boundary columns\n            # strictly as left and right.\n            Sum = kadane(temp, start, finish, ROW)\n \n            # Compare sum with maximum sum so far.\n            # If sum is more, then update maxSum\n            # and other output values\n            if Sum > maxSum:\n                maxSum = Sum\n                finalLeft = left\n                finalRight = right\n                finalTop = start[0]\n                finalBottom = finish[0]\n \n    # Prfinal values\n    print(\"(Top, Left)\", \"(\", finalTop,\n          finalLeft, \")\")\n    print(\"(Bottom, Right)\", \"(\", finalBottom,\n          finalRight, \")\")\n    print(\"Max sum is:\", maxSum)\n \n \n# Driver Code\nROW = 4\nCOL = 5\nM = [[1, 2, -1, -4, -20],\n     [-8, -3, 4, 2, 1],\n     [3, 8, 10, 1, 3],\n     [-4, -1, 1, 7, -6]]\n \n# Function call\nfindMaxSum(M)\n \n# This code is contributed by PranchalK"}
{"nl": "Python math.hypot() Method", "code": "#Import math Library\r\nimport math\r\n\r\n#set perpendicular and base\r\nparendicular = 10\r\nbase = 5\r\n\r\n#print the hypotenuse of a right-angled triangle\r\nprint(math.hypot(parendicular, base))"}
{"nl": "Detect a cycle of the same value in a 2D grid", "code": "class Solution:\n  def containsCycle(self, grid: List[List[str]]) -> bool:\n  def dfs(node, parent):\n  if node in visited: return True\n  visited.add(node)\n  nx,ny = node\n  childs = [(cx,cy) for cx,cy in [[nx+1,ny],[nx-1, ny],[nx,ny+1],[nx,ny-1]] \n  if 0 <= cx < m and 0 <= cy < n \n  and grid[cx][cy] == grid[nx][ny] and (cx,cy) != parent]\n  for x in childs:\n  if dfs(x, node): return True \n  return False  \n  \n  m, n = len(grid), len(grid[0])\n  visited = set()\n  for i in range(m):\n  for j in range(n):\n  if (i,j) in visited: continue \n  if dfs((i,j), None): return True\n  return False"}
{"nl": "Find the closest two integers whose product equals num + 1 or num + 2", "code": "def closestDivisors(self, num: int) -> List[int]:\n  for i in reversed(range(1, int((num + 2) ** 0.5) + 1)):\n  if not (num + 1) % i:\n  return [i, (num + 1) // i]\n  if not (num + 2) % i:\n  return [i, (num + 2) // i]"}
{"nl": "Check if a given array can represent Preorder Traversal of Binary Search Tree", "code": "# Python program for an efficient solution to check if\n# a given array can represent Preorder traversal of\n# a Binary Search Tree\n\u00a0\nINT_MIN = -2**32\n\u00a0\ndef canRepresentBST(pre):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create an empty stack\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize current root as minimum possible value\n\u00a0\u00a0\u00a0\u00a0root = INT_MIN\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse given array\n\u00a0\u00a0\u00a0\u00a0for value in pre:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#NOTE:value is equal to pre[i] according to the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#given algo\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If we find a node who is on the right side\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and smaller than root, return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if value < root :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If value(pre[i]) is in right subtree of stack top,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Keep removing items smaller than value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and make the last removed items as new root\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while(len(s) > 0 and s[-1] < value) :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = s.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# At this point either stack is empty or value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is smaller than root, push value\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(value)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n# Driver Program\npre1 = [40 , 30 , 35 , 80 , 100]\nprint (\"true\" if canRepresentBST(pre1) == True else \"false\")\npre2 = [40 , 30 , 35 , 20 ,\u00a0 80 , 100]\nprint (\"true\" if canRepresentBST(pre2) == True else \"false\")\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": " \u201cin\u201d Operator in Python", "code": "# given list\r\ngiven_list = [\"hello\", \"this\", \"is\", \"BTechGeeks\", \"Python\"]\r\n# given element\r\nelement = \"BTechGeeks\"\r\n# checking if the given element is present in given list or not using in opertor\r\n# it returns true if is present else it returns false\r\nprint(element in given_list)"}
{"nl": "The minimum number of function calls to make target array", "code": "def minOperations(self, A):\n  return sum(bin(a).count('1') for a in A) + len(bin(max(A))) - 3"}
{"nl": "Lemmatization machine learning textblob", "code": "# from textblob lib import Word method\r\nfrom textblob import Word\r\n \r\n# create a Word object.\r\nu = Word(\"rocks\")\r\n \r\n# apply lemmatization.\r\nprint(\"rocks :\", u.lemmatize())\r\n \r\n# create a Word object.\r\nv = Word(\"corpora\")\r\n \r\n# apply lemmatization.\r\nprint(\"corpora :\", v.lemmatize())\r\n \r\n# create a Word object.\r\nw = Word(\"better\")\r\n  \r\n# apply lemmatization with\r\n# parameter \"a\", \"a\" denotes adjective.\r\nprint(\"better :\", w.lemmatize(\"a\"))"}
{"nl": "Count Ones in a 2D Array", "code": "def count_ones(matrix):\n  return sum([row.count(1) for row in matrix])"}
{"nl": "Reformatting the Date", "code": "import dateutil.parser\r\ndef convert_date(date):\r\n\tdate = dateutil.parser.parse(date)\r\n\treturn [date.month, date.day, date.year]"}
{"nl": "Fix the Error: Filtering out Empty Arrays", "code": "def remove_empty_arrays(arr):\n    return [x for x in arr if x != []]"}
{"nl": "Matrix Addition Program in Python", "code": "import numpy as np m1 = np.array([[3, 4], [5, 6]]) m2 = np.array([[8, 9], [0, 6]]) result = np.add(m1, m2) print(result)"}
{"nl": "Calculate the Median", "code": "def median(lst):\n  lst.sort()\n  n = len(lst)\n  m = n // 2\n  if n % 2 == 0:\n    return (lst[m - 1] + lst[m]) / 2\n  else:\n    return lst[m]"}
{"nl": "Filtering by Star Rating", "code": "def filter_by_rating(d, rating):\n\treturn {k:v for k,v in d.items() if d[k]==rating} or 'No results found'"}
{"nl": "Range sum of sorted subarray sums", "code": "class Solution:\n  def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n  h = [(x, i) for i, x in enumerate(nums)] #min-heap \n  heapify(h)\n  \n  ans = 0\n  for k in range(1, right+1): #1-indexed\n  x, i = heappop(h)\n  if k >= left: ans += x\n  if i+1 < len(nums): \n  heappush(h, (x + nums[i+1], i+1))\n  \n  return ans % 1_000_000_007"}
{"nl": "given an integer n and a 2D integer array with the path of friends, find the longest common subpath that is shared by every friend's path", "code": "class Solution:\n        def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n                def helper(mid):\n                        base = 10**5+1\n                        mod = 2**128\n                        a = pow(base,mid,mod)\n                        hashSet = set()\n\n                        for i,path in enumerate(paths):\n                                hashset2 = set()\n                                curHash = 0\n\n                                for j in range(len(path)):\n                                        curHash = curHash*base+path[j]\n                                        if j >= mid:\n                                                curHash -= path[j-mid] * a\n\n                                        curHash %= mod\n                                        if j >= mid-1:\n                                                hashset2.add(curHash)\n\n                                if i == 0:\n                                        hashSet = hashset2\n                                else:\n                                        hashSet = hashSet.intersection(hashset2)\n\n                                if i > 0 and not hashSet:\n                                        break\n\n                        return len(hashSet) > 0\n\n                l = 0\n                r = min(len(path) for path in paths)\n\n                while l < r:\n                        mid = l +(r-l+1) // 2\n                        if helper(mid):\n                                l = mid\n                        else:\n                                r = mid-1\n\n                return l"}
{"nl": "Phrase or Word Inverse", "code": "def inverter(txt, T):\n  if T == 'P':\n    return ' '.join(txt.split()[::-1]).capitalize()\n  else:\n    return ' '.join(w[::-1] for w in txt.split()).capitalize()"}
{"nl": "Clear nth Bit of a Number", "code": "# Give the number as static input and store it in a variable.\r\ngvn_numb = 60\r\n# Give the bit position as static input and store it in another variable.\r\nbitpositin = 3\r\n# Apply the left shift operator to 1 and the above-given bit position and\r\n# store it in another variable.\r\nnumbr_bit = (1 << bitpositin)\r\n# Apply the complement operator (which converts 0 to 1 and vice-versa) to the above result\r\n# and store it in another variable.\r\ncomplemt = (~numbr_bit)\r\n# Apply bitwise & operation for the given number and the above result and store it in\r\n# another variable say rslt_numb.\r\nrslt_numb = gvn_numb & complemt\r\n# Print the number after clearing the bit at the given position for a given number.\r\nprint(\"The Number after clearing the bit at the given position{\",\r\n      bitpositin, \"} for a given number{\", gvn_numb, \"} =\", rslt_numb)"}
{"nl": "Python Program to Check Whether Product of Digits at Even places of a Number is Divisible by K", "code": "# Give the number as static input and store it in a variable.\ngvn_numb = 123456\n# Give the other number k as static input and store it in another variable.\ngvn_k = 5\n# Convert the given number to a string using the str() function and store it in\n# another variable.\nstringnum = str(gvn_numb)\n# Create a list of digits say \"digtslst\" using map(),list(),int functions.\ndigtslst = list(map(int, stringnum))\n# Take another variable say \"evn_prodt\" and initialize it with 1.\nevn_prodt = 1\n# Loop in the above list of digits until the length of the \"digtslst\" using the for loop.\nfor itr in range(len(digtslst)):\n    # Check if the iterator value is even or not using\n    # the if conditional statement.\n    if(itr % 2 == 0):\n        # If the statement is true, then multiply the element of digits list at iterator value to\n        # the \"evn_prodt\" and store it in the same variable evn_prodt.\n        evn_prodt *= digtslst[itr]\n# Check if the evn_prodt modulus given number k is equal to 0 or not using the if conditional\n# statement.\nif(evn_prodt % gvn_k == 0):\n    # If the statement is true, then print \"The product of digits at even places of the given\n    # number is divisible by the another given number k.\n    print(\"The Product of digits at even places of the given number{\", gvn_numb,\n          \"} is divisible by the another given number k{\", gvn_k, \"}\")\nelse:\n    # If the statement is false, then print \"The product of digits at even places of the given\n    # number is Not divisible by the another given number k.\n    print(\"The Product of digits at even places of the given number{\", gvn_numb,\n          \"} is not divisible by the another given number k{\", gvn_k, \"}\")"}
{"nl": "Sort Odds Keeping Evens in Place", "code": "def odd_sort(lst): \n  odds = iter(sorted(i for i in lst if i%2))\n  return [next(odds) if n%2 else n for n in lst]"}
{"nl": "Minimum Number of Platforms Required for a Railway/Bus Station", "code": "\r\n# Program to find minimum\r\n# number of platforms\r\n# required on a railway\r\n# station\r\n \r\n# Returns minimum number\r\n# of platforms required\r\n \r\n \r\ndef findPlatform(arr, dep, n):\r\n \r\n    # Sort arrival and\r\n    # departure arrays\r\n    arr.sort()\r\n    dep.sort()\r\n \r\n    # plat_needed indicates\r\n    # number of platforms\r\n    # needed at a time\r\n    plat_needed = 1\r\n    result = 1\r\n    i = 1\r\n    j = 0\r\n \r\n    # Similar to merge in\r\n    # merge sort to process\r\n    # all events in sorted order\r\n    while (i < n and j < n):\r\n \r\n        # If next event in sorted\r\n        # order is arrival,\r\n        # increment count of\r\n        # platforms needed\r\n        if (arr[i] <= dep[j]):\r\n \r\n            plat_needed += 1\r\n            i += 1\r\n \r\n        # Else decrement count\r\n        # of platforms needed\r\n        elif (arr[i] > dep[j]):\r\n \r\n            plat_needed -= 1\r\n            j += 1\r\n \r\n        # Update result if needed\r\n        if (plat_needed > result):\r\n            result = plat_needed\r\n \r\n    return result\r\n \r\n# Driver code\r\n \r\n \r\narr = [900, 940, 950, 1100, 1500, 1800]\r\ndep = [910, 1200, 1120, 1130, 1900, 2000]\r\nn = len(arr)\r\n \r\nprint(\"Minimum Number of Platforms Required = \",\r\n      findPlatform(arr, dep, n))\r\n \r\n# This code is contributed\r\n# by Anant Agarwal."}
{"nl": "The sum of vowels", "code": "def sum_of_vowels(sentence):\n  v = {'a':4, 'e':3, 'i':1}\n  return sum(v[ch] for ch in sentence.lower() if ch in v)"}
{"nl": "find the biggest three sums of elements that form the border of a regular rhombus shape in a grid", "code": "class Solution:\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n        n, m = len(grid), len(grid[0])\n        sumD1 = [[grid[i][j] for j in range(m)] for i in range(n)]\n        sumD2 = [[grid[i][j] for j in range(m)] for i in range(n)]\n        \n        ans = set([grid[i][j] for i in range(n) for j in range(m)])\n        ans = list(ans)\n        ans.sort(reverse = True)\n        ans = ans[:3]\n        \n        for i in range(1, n):\n            for j in range(1, m):\n                sumD1[i][j] += sumD1[i - 1][j - 1]\n        \n        for i in range(1, n):\n            for j in range(m - 1):\n                sumD2[i][j] += sumD2[i - 1][j + 1]\n        \n        for i in range(1, n - 1):\n            for j in range(1, m - 1):                \n                d = 1\n                while 0 <= i - d and i + d < n and 0 <= j - d and j + d < m: \n                    TR = sumD1[i][j + d]\n                    TR -= sumD1[i - d - 1][j - 1] if j - 1 >= 0 and i - d - 1 >= 0 else 0 \n                    \n                    BL = sumD1[i + d][j]\n                    BL -= sumD1[i - 1][j - d - 1] if i - 1 >= 0 and j - d - 1 >= 0 else 0\n                    \n                    TL = sumD2[i - 1][j - d + 1] - sumD2[i - d][j] \n                    \n                    BR = sumD2[i + d - 1][j + 1] - sumD2[i][j + d]\n                    \n                    perimeter = TR + BL + TL + BR\n                    \n                    if perimeter not in ans: \n                        ans.append(perimeter)\n                        ans.sort(reverse = True)\n                        ans = ans[:3]\n                    d += 1\n               \n        return ans\n                    "}
{"nl": "Showcasing Segment Tree Operations using Sum of given range problem", "code": "# Python3 program to show segment tree operations like\r\n# construction, query and update\r\nfrom math import ceil, log2;\r\n \r\n# A utility function to get the\r\n# middle index from corner indexes.\r\ndef getMid(s, e) :\r\n    return s + (e -s) // 2;\r\n \r\n\"\"\" A recursive function to get the sum of values\r\n    in the given range of the array. The following\r\n    are parameters for this function.\r\n \r\n    st --> Pointer to segment tree\r\n    si --> Index of current node in the segment tree.\r\n           Initially 0 is passed as root is always at index 0\r\n    ss & se --> Starting and ending indexes of the segment\r\n                represented by current node, i.e., st[si]\r\n    qs & qe --> Starting and ending indexes of query range \"\"\"\r\ndef getSumUtil(st, ss, se, qs, qe, si) :\r\n \r\n    # If segment of this node is a part of given range,\r\n    # then return the sum of the segment\r\n    if (qs <= ss and qe >= se) :\r\n        return st[si];\r\n \r\n    # If segment of this node is\r\n    # outside the given range\r\n    if (se < qs or ss > qe) :\r\n        return 0;\r\n \r\n    # If a part of this segment overlaps\r\n    # with the given range\r\n    mid = getMid(ss, se);\r\n     \r\n    return getSumUtil(st, ss, mid, qs, qe, 2 * si + 1) +\r\n           getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2);\r\n \r\n\"\"\" A recursive function to update the nodes\r\nwhich have the given index in their range.\r\nThe following are parameters st, si, ss and se\r\nare same as getSumUtil()\r\ni --> index of the element to be updated.\r\n      This index is in the input array.\r\ndiff --> Value to be added to all nodes\r\nwhich have i in range \"\"\"\r\ndef updateValueUtil(st, ss, se, i, diff, si) :\r\n \r\n    # Base Case: If the input index lies\r\n    # outside the range of this segment\r\n    if (i < ss or i > se) :\r\n        return;\r\n \r\n    # If the input index is in range of this node,\r\n    # then update the value of the node and its children\r\n    st[si] = st[si] + diff;\r\n     \r\n    if (se != ss) :\r\n     \r\n        mid = getMid(ss, se);\r\n        updateValueUtil(st, ss, mid, i,\r\n                        diff, 2 * si + 1);\r\n        updateValueUtil(st, mid + 1, se, i,\r\n                         diff, 2 * si + 2);\r\n \r\n# The function to update a value in input array\r\n# and segment tree. It uses updateValueUtil()\r\n# to update the value in segment tree\r\ndef updateValue(arr, st, n, i, new_val) :\r\n \r\n    # Check for erroneous input index\r\n    if (i < 0 or i > n - 1) :\r\n         \r\n        print(\"Invalid Input\", end = \"\");\r\n        return;\r\n \r\n    # Get the difference between\r\n    # new value and old value\r\n    diff = new_val - arr[i];\r\n \r\n    # Update the value in array\r\n    arr[i] = new_val;\r\n \r\n    # Update the values of nodes in segment tree\r\n    updateValueUtil(st, 0, n - 1, i, diff, 0);\r\n \r\n# Return sum of elements in range from\r\n# index qs (query start) to qe (query end).\r\n# It mainly uses getSumUtil()\r\ndef getSum(st, n, qs, qe) :\r\n \r\n    # Check for erroneous input values\r\n    if (qs < 0 or qe > n - 1 or qs > qe) :\r\n \r\n        print(\"Invalid Input\", end = \"\");\r\n        return -1;\r\n     \r\n    return getSumUtil(st, 0, n - 1, qs, qe, 0);\r\n \r\n# A recursive function that constructs\r\n# Segment Tree for array[ss..se].\r\n# si is index of current node in segment tree st\r\ndef constructSTUtil(arr, ss, se, st, si) :\r\n \r\n    # If there is one element in array,\r\n    # store it in current node of\r\n    # segment tree and return\r\n    if (ss == se) :\r\n     \r\n        st[si] = arr[ss];\r\n        return arr[ss];\r\n     \r\n    # If there are more than one elements,\r\n    # then recur for left and right subtrees\r\n    # and store the sum of values in this node\r\n    mid = getMid(ss, se);\r\n     \r\n    st[si] = constructSTUtil(arr, ss, mid, st, si * 2 + 1) +\r\n             constructSTUtil(arr, mid + 1, se, st, si * 2 + 2);\r\n     \r\n    return st[si];\r\n \r\n\"\"\" Function to construct segment tree\r\nfrom given array. This function allocates memory\r\nfor segment tree and calls constructSTUtil() to\r\nfill the allocated memory \"\"\"\r\ndef constructST(arr, n) :\r\n \r\n    # Allocate memory for the segment tree\r\n \r\n    # Height of segment tree\r\n    x = (int)(ceil(log2(n)));\r\n \r\n    # Maximum size of segment tree\r\n    max_size = 2 * (int)(2**x) - 1;\r\n     \r\n    # Allocate memory\r\n    st = [0] * max_size;\r\n \r\n    # Fill the allocated memory st\r\n    constructSTUtil(arr, 0, n - 1, st, 0);\r\n \r\n    # Return the constructed segment tree\r\n    return st;\r\n \r\n# Driver Code\r\nif __name__ == \"__main__\" :\r\n \r\n    arr = [1, 3, 5, 7, 9, 11];\r\n    n = len(arr);\r\n \r\n    # Build segment tree from given array\r\n    st = constructST(arr, n);\r\n \r\n    # Print sum of values in array from index 1 to 3\r\n    print(\"Sum of values in given range = \",\r\n                       getSum(st, n, 1, 3));\r\n \r\n    # Update: set arr[1] = 10 and update\r\n    # corresponding segment tree nodes\r\n    updateValue(arr, st, n, 1, 10);\r\n \r\n    # Find sum after the value is updated\r\n    print(\"Updated sum of values in given range = \",\r\n                     getSum(st, n, 1, 3), end = \"\");\r\n     \r\n# This code is contributed by AnkitRai01"}
{"nl": "minimum number of flips to make a binary string alternating", "code": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        diff1,diff2 = 0,0\n        alt1,alt2 = \"\",\"\"\n        s=s+s\n        alt1, alt2 = \"01\" * n, \"10\" * n\n        l=0\n        res = len(s)\n        for r in range(len(s)):\n            if s[r]!=alt1[r]:\n                diff1+=1\n            if s[r]!=alt2[r]:\n                diff2+=1\n            if r>=n:\n                if n%2!=0: # if 0th(Lth) bit are different with alt1,alt2 then n+1 bit will be same and vice versa\n                    if s[l]!=alt1[l]:\n                        diff1-=1\n                    if s[l]!=alt2[l]:\n                        diff2-=1\n                l+=1\n            if r >= n-1:\n                res = min(res,diff1,diff2)\n        return res"}
{"nl": "Instant JAZZ", "code": "def jazzify(lst):\n  return [i if i.endswith('7') else i + '7' for i in lst]"}
{"nl": "Python Program to Calculate the Surface Area and Volume of a Hemisphere", "code": "# Import the math module using the import keyword.\nimport math\n# Give the hemisphere's radius as user input using the float(input()) function and\n# store it in a variable.\ngvn_radus = float(input(\"Enter some random variable = \"))\n# Take a variable and initialize it with the value of pi as 3.14 .\nvalof_pi = 3.14\n# Calculate the surface area of the given hemisphere using the above given mathematical\n# formula and math.pow() function.\n# Store it in another variable.\nhemi_surfceara = 3*valof_pi*math.pow(gvn_radus, 2)\n# Calculate the volume of the given hemisphere using the above given mathematical formula\n# and math.pow() function.\n# Store it in another variable.\nhemi_volum = (2.0/3.0)*valof_pi*math.pow(gvn_radus, 3)\n# Print the hemisphere's surface area with the given radius of the hemisphere.\nprint(\"The Surface Area of the given Hemisphere with radius {\",\n      gvn_radus, \" } = \", hemi_surfceara)\n# Print the hemisphere's perimeter with the given radius of the hemisphere.\nprint(\"The Volume of the given Hemisphere with radius {\",\n      gvn_radus, \"} = \", hemi_volum)"}
{"nl": "Print nth Iteration of Lucas Sequence using for loop", "code": "# Give the First term =2 (since the first term in Lucas Sequence is 2 which is a constant)\n# as static input and store it in a variable.\nfst_trm = 2\n# Give the Second term =1 (since the second term in Lucas Sequence is 1 which is a constant)\n# as static input and store it in another variable.\nsecnd_trm = 1\n# Give the number as static input and store it in another variable.\ngvn_n_vlue = 6\n# Loop from '1' to the above given n+1 value (since doesn't include last term) range\n# using For loop.\nfor i in range(1, gvn_n_vlue+1):\n # Inside the loop , get the third term which is the sum of first and the second term\n    # and store it in a variable.\n    third_trm = fst_trm+secnd_trm\n # Assign the value of second term to the first term.\n    fst_trm = secnd_trm\n  # Assign the value of the third term to the second term and come out of For Loop.\n    secnd_trm = third_trm\n# Print the Value of above given nth iteration of Lucas Sequence(i.e. first term).\nprint(\"The above Given nth iteration of Lucas Sequence = \", fst_trm)"}
{"nl": "Letter Occurrences Per Word\n", "code": "def find_occurrences(txt, ch):\n        return {w:w.count(ch.lower()) for w in txt.lower().split()}"}
{"nl": "Floor and Ceil from a BST", "code": "# Python3 program to find floor and\n# ceil of a given key in BST\n\n# A binary tree node has key,\n#. left child and right child\nclass Node:\n\t\n\tdef __init__(self, x):\n\t\t\n\t\tself.data = x\n\t\tself.left = None\n\t\tself.right = None\n\n# Helper function to find floor and\n# ceil of a given key in BST\ndef floorCeilBSTHelper(root, key):\n\t\n\tglobal floor, ceil\n\n\twhile (root):\n\t\tif (root.data == key):\n\t\t\tceil = root.data\n\t\t\tfloor = root.data\n\t\t\treturn\n\t\tif (key > root.data):\n\t\t\tfloor = root.data\n\t\t\troot = root.right\n\t\telse:\n\t\t\tceil = root.data\n\t\t\troot = root.left\n\n# Display the floor and ceil of a given\n# key in BST. If key is less than the min\n# key in BST, floor will be -1; If key is\n# more than the max key in BST, ceil will be -1;\ndef floorCeilBST(root, key):\n\t\n\tglobal floor, ceil\n\n\t# Variables 'floor' and 'ceil'\n\t# are passed by reference\n\tfloor = -1\n\tceil = -1\n\n\tfloorCeilBSTHelper(root, key)\n\n\tprint(key, floor, ceil)\n\n# Driver code\nif __name__ == '__main__':\n\t\n\tfloor, ceil = -1, -1\n\t\n\troot = Node(8)\n\troot.left = Node(4)\n\troot.right = Node(12)\n\troot.left.left = Node(2)\n\troot.left.right = Node(6)\n\troot.right.left = Node(10)\n\troot.right.right = Node(14)\n\n\tfor i in range(16):\n\t\tfloorCeilBST(root, i)\n\n# This code is contributed by mohit kumar 29"}
{"nl": "Mona's Sort", "code": "def number_of_swaps(lst):\n  swaps, target = 0, sorted(lst)\n  while lst != target:\n    for i in range(len(lst) - 1):\n      if lst[i] > lst[i+1]:\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n        swaps += 1\n  return swaps"}
{"nl": "String manipulation", "code": "def superheroes(heroes):\r\n  return sorted([i for i in heroes if i.endswith(\"man\") and not i.lower().endswith(\"woman\")])"}
{"nl": "Surface area and volume of a hemisphere", "code": "# Import the math module using the import keyword.\n import math\n # Give the hemisphere's radius as static input and store it in a variable.\n gvn_radus = 9\n # Take a variable and initialize it with the value of pi as 3.14 .\n valof_pi = 3.14\n # Calculate the surface area of the given hemisphere using the above given mathematical\n # formula and math.pow() function.\n # Store it in another variable.\n hemi_surfceara = 3*valof_pi*math.pow(gvn_radus, 2)\n # Calculate the volume of the given hemisphere using the above given mathematical formula\n # and math.pow() function.\n # Store it in another variable.\n hemi_volum = (2.0/3.0)*valof_pi*math.pow(gvn_radus, 3)\n # Print the hemisphere's surface area with the given radius of the hemisphere.\n print(\"The Surface Area of the given Hemisphere with radius {\",\n  gvn_radus, \" } = \", hemi_surfceara)\n # Print the hemisphere's perimeter with the given radius of the hemisphere.\n print(\"The Volume of the given Hemisphere with radius {\",\n  gvn_radus, \"} = \", hemi_volum)"}
{"nl": "Scrabble Hand", "code": "def maximum_score(tile_hand):\n  return sum([i['score'] for i in tile_hand])"}
{"nl": "Print unique rows in a given Binary matrix", "code": "# Given a binary matrix of M X N of\n# integers, you need to return only\n# unique rows of binary array\nROW = 4\nCOL = 5\n\u00a0\n# The main function that prints\n# all unique rows in a given matrix.\ndef findUniqueRows(M):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Traverse through the matrix\n\u00a0\u00a0\u00a0\u00a0for i in range(ROW):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if there is similar column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# is already printed, i.e if i and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# jth column match.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(i):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(COL):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (M[i][k] != M[j][k]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (flag == 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If no row is similar\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (flag == 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Print the row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(COL):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(M[i][j], end = \" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\u00a0\u00a0\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0M = [ [ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 1, 0 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0, 1, 0, 0, 1 ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1, 0, 1, 0, 0 ] ]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0findUniqueRows(M)\n\u00a0\n# This code is contributed by mohit kumar 29\n"}
{"nl": "Python Program to Print Right Triangle of Numbers in Reverse\n", "code": "rows = int(input(\"Right Triangle Reverse Numbers Rows = \"))\n\nprint(\"==Right Triangle of Numbers in Reverse Order Pattern==\")\n\nfor i in range(rows, 0, -1):\n    for j in range(rows, i - 1, -1):\n        print(j, end = ' ')\n    print()"}
{"nl": "find the volume of the Dodecahedron", "code": "# Import the math module using the math keyword.\r\nimport math\r\n# Give the side of the Dodecahedron as static input and store it in a variable.\r\nsideval = 5\r\n# Calculate the volume of the Dodecahedron using the above mathematical formula\r\n# ( (15 + 7\u221a5)*s3/4).\r\n# We Calculate the \u221a5 in the above formula using the sqrt() function.\r\n# We can calculate the s^3 using the pow() function or '**' operator.\r\n# By using the above functions we calculate the volume of the Dodecahedron\r\n# and store it in a variable say volDode.\r\nvolDode = (((15 + (7 * (math.sqrt(5)))) / 4) * (math.pow(sideval, 3)))\r\n# Print the volDode value.\r\nprint(\r\n    'The Volume of the Dodecahedron with side {', sideval, '} is = ', volDode)"}
{"nl": "Create Test DataSets using Sklearn", "code": "# Creating Test DataSets using sklearn.datasets.make_moon\r\nfrom sklearn.datasets import make_moons\r\nfrom matplotlib import pyplot as plt\r\nfrom matplotlib import style\r\n \r\nX, y = make_moons(n_samples = 1000, noise = 0.1)\r\nplt.scatter(X[:, 0], X[:, 1], s = 40, color ='g')\r\nplt.xlabel(\"X\")\r\nplt.ylabel(\"Y\")\r\n \r\nplt.show()\r\nplt.clf()"}
{"nl": "construct tree in inorder and postorder traversal", "code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        def helper(in_left, in_right):\n            # if there is no elements to construct subtrees\n            if in_left > in_right:\n                return None\n            \n            # pick up the last element as a root\n            val = postorder.pop()\n            root = TreeNode(val)\n\n            # root splits inorder list\n            # into left and right subtrees\n            index = idx_map[val]\n \n            # build right subtree\n            root.right = helper(index + 1, in_right)\n            # build left subtree\n            root.left = helper(in_left, index - 1)\n            return root\n        \n        # build a hashmap value -> its index\n        idx_map = {val:idx for idx, val in enumerate(inorder)} \n        return helper(0, len(inorder) - 1)"}
{"nl": "Fibonacci series in Python", "code": "# Python program to print fibonacci series up to n-th term # take input num = int(input('Enter number of terms: ')) # print fibonacci series a, b = 0, 1 i = 0 # check if the number of terms is valid if num <= 0: print('Please enter a positive integer.') elif num == 1: print('The Fibonacci series: ') print(a) else: print('The Fibonacci series: ') while i < num: print(a, end=' ') c = a + b a = b b = c i = i+1"}
{"nl": "Find XOR of Two Numbers Without Using XOR operator", "code": "# Create a function XOR_result() which accepts the given two numbers as the argument and\r\n# returns the XOR result of the given first and second numbers.\r\n\r\n\r\ndef XOR_result(gvnfst_numb, gvnscnd_numb):\r\n    # Inside the XOR_result() function.\r\n    # Calculate and the value of (gvnfst_numb | gvnscnd_numb) & (~gvnfst_numb | ~gvnscnd_numb)\r\n    # which gives the XOR result of the given first and second numbers and store it in a\r\n    # variable say xor_rslt.\r\n\r\n    xor_rslt = (gvnfst_numb | gvnscnd_numb) & (~gvnfst_numb | ~gvnscnd_numb)\r\n    # Return the value of xor_rslt (Which is the XOR result of the given first and\r\n    # second numbers).\r\n    return(xor_rslt)\r\n\r\n\r\n# Inside the main code.\r\n# Give the first number as static input and store it in a variable.\r\ngvnfst_numb = 4\r\n# Give the second number as static input and store it in another variable.\r\ngvnscnd_numb = 2\r\n# Pass the given first and second numbers as the arguments to XOR_result() function and\r\n# store the result in a variable (xorreslt_val).\r\nxorreslt_val = XOR_result(gvnfst_numb, gvnscnd_numb)\r\n# Print the xorreslt_val value.\r\nprint(\"The XOR result of the given first and second numbers{\",\r\n      gvnfst_numb, \",\", gvnscnd_numb, \"} =\", xorreslt_val)"}
{"nl": "Check if one string swap can make strings equal", "code": "class Solution:\n  def areAlmostEqual(self, s1: str, s2: str) -> bool:\n  diff = [[x, y] for x, y in zip(s1, s2) if x != y]\n  return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]"}
{"nl": "Find Bionomial Coefficient using Dynamic Programming", "code": "# A Dynamic Programming based Python\n# Program that uses table C[][]\n# to calculate the Binomial Coefficient\n\n# Returns value of Binomial Coefficient C(n, k)\n\n\ndef binomialCoef(n, k):\n\tC = [[0 for x in range(k+1)] for x in range(n+1)]\n\n\t# Calculate value of Binomial\n\t# Coefficient in bottom up manner\n\tfor i in range(n+1):\n\t\tfor j in range(min(i, k)+1):\n\t\t\t# Base Cases\n\t\t\tif j == 0 or j == i:\n\t\t\t\tC[i][j] = 1\n\n\t\t\t# Calculate value using\n\t\t\t# previously stored values\n\t\t\telse:\n\t\t\t\tC[i][j] = C[i-1][j-1] + C[i-1][j]\n\n\treturn C[n][k]\n\n\n# Driver program to test above function\nn = 5\nk = 2\nprint(\"Value of C[\" + str(n) + \"][\" + str(k) + \"] is \"\n\t+ str(binomialCoef(n, k)))\n\n# This code is contributed by Bhavya Jain"}
{"nl": "Deleting from a Binary Search Tree", "code": "# Python3 program to implement\n# optimized delete in BST.\n\nclass Node:\n\n\t# Constructor to create a new node\n\tdef __init__(self, key):\n\t\tself.key = key\n\t\tself.left = None\n\t\tself.right = None\n\n# A utility function to do\n# inorder traversal of BST\ndef inorder(root):\n\tif root is not None:\n\t\tinorder(root.left)\n\t\tprint(root.key, end=\" \")\n\t\tinorder(root.right)\n\n# A utility function to insert a\n# new node with given key in BST\ndef insert(node, key):\n\n\t# If the tree is empty,\n\t# return a new node\n\tif node is None:\n\t\treturn Node(key)\n\n\t# Otherwise recur down the tree\n\tif key < node.key:\n\t\tnode.left = insert(node.left, key)\n\telse:\n\t\tnode.right = insert(node.right, key)\n\n\t# return the (unchanged) node pointer\n\treturn node\n\n\n# Given a binary search tree\n# and a key, this function\n# delete the key and returns the new root\ndef deleteNode(root, key):\n\n\t# Base Case\n\tif root is None:\n\t\treturn root\n\n\t# Recursive calls for ancestors of\n\t# node to be deleted\n\tif key < root.key:\n\t\troot.left = deleteNode(root.left, key)\n\t\treturn root\n\n\telif(key > root.key):\n\t\troot.right = deleteNode(root.right, key)\n\t\treturn root\n\n\t# We reach here when root is the node\n\t# to be deleted.\n\t\n\t# If root node is a leaf node\n\t\n\tif root.left is None and root.right is None:\n\t\treturn None\n\n\t# If one of the children is empty\n\n\tif root.left is None:\n\t\ttemp = root.right\n\t\troot = None\n\t\treturn temp\n\n\telif root.right is None:\n\t\ttemp = root.left\n\t\troot = None\n\t\treturn temp\n\n\t# If both children exist\n\n\tsuccParent = root\n\n\t# Find Successor\n\n\tsucc = root.right\n\n\twhile succ.left != None:\n\t\tsuccParent = succ\n\t\tsucc = succ.left\n\n\t# Delete successor.Since successor\n\t# is always left child of its parent\n\t# we can safely make successor's right\n\t# right child as left of its parent.\n\t# If there is no succ, then assign\n\t# succ->right to succParent->right\n\tif succParent != root:\n\t\tsuccParent.left = succ.right\n\telse:\n\t\tsuccParent.right = succ.right\n\n\t# Copy Successor Data to root\n\n\troot.key = succ.key\n\n\treturn root\n\n\n# Driver code\n\"\"\" Let us create following BST\n\t\t\t50\n\t\t/\t \\\n\t\t30\t 70\n\t\t/ \\ / \\\n\t20 40 60 80 \"\"\"\n\nroot = None\nroot = insert(root, 50)\nroot = insert(root, 30)\nroot = insert(root, 20)\nroot = insert(root, 40)\nroot = insert(root, 70)\nroot = insert(root, 60)\nroot = insert(root, 80)\n\nprint(\"Inorder traversal of the given tree\")\ninorder(root)\n\nprint(\"\\nDelete 20\")\nroot = deleteNode(root, 20)\nprint(\"Inorder traversal of the modified tree\")\ninorder(root)\n\nprint(\"\\nDelete 30\")\nroot = deleteNode(root, 30)\nprint(\"Inorder traversal of the modified tree\")\ninorder(root)\n\nprint(\"\\nDelete 50\")\nroot = deleteNode(root, 50)\nprint(\"Inorder traversal of the modified tree\")\ninorder(root)\n\n# This code is contributed by Shivam Bhat (shivambhat45)\n"}
{"nl": "Program for Tower of Hanoi", "code": "# Recursive Python function to solve tower of hanoi\n\ndef TowerOfHanoi(n , from_rod, to_rod, aux_rod):\n\tif n == 0:\n\t\treturn\n\tTowerOfHanoi(n-1, from_rod, aux_rod, to_rod)\n\tprint(\"Move disk\",n,\"from rod\",from_rod,\"to rod\",to_rod)\n\tTowerOfHanoi(n-1, aux_rod, to_rod, from_rod)\n\t\t\n# Driver code\nn = 4\nTowerOfHanoi(n, 'A', 'C', 'B')\n# A, C, B are the name of rods\n\n# Contributed By Harshit Agrawal"}
{"nl": "Algorithms: Binary Search", "code": "def is_prime(p,n,l=0,r=None):\n  r=len(p)-1\n  while r>=l:\n    m=l+(r-l)//2\n    if p[m]==n:return'yes'\n    elif p[m]>n:r=m-1 \n    else:l=m+1\n  return'no'"}
{"nl": "Implement Queue", "code": "class Queue:\n    def __init__(self):\n        self.items = []\n\u00a0\n    def is_empty(self):\n        return self.items == []\n\u00a0\n    def enqueue(self, data):\n        self.items.append(data)\n\u00a0\n    def dequeue(self):\n        return self.items.pop(0)\n\u00a0\n\u00a0\nq = Queue()\nwhile True:\n    print('enqueue <value>')\n    print('dequeue')\n    print('quit')\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'enqueue':\n        q.enqueue(int(do[1]))\n    elif operation == 'dequeue':\n        if q.is_empty():\n            print('Queue is empty.')\n        else:\n            print('Dequeued value: ', q.dequeue())\n    elif operation == 'quit':\n        break"}
{"nl": "Longest Path with Same Values in a Binary Tree", "code": "# Python3 program to find the length of longest\n# path with same values in a binary tree.\n\n# Helper function that allocates a\n# new node with the given data and\n# None left and right pointers.\nclass newNode:\ndef __init__(self, data):\n\tself.val = data\n\tself.left = self.right = None\n\t\n# Function to print the longest path\n# of same values\ndef length(node, ans):\nif (not node):\n\treturn 0\n\t\n# Recursive calls to check for subtrees\nleft = length(node.left, ans)\nright = length(node.right, ans)\n\t\n# Variables to store maximum lengths\n# in two directions\nLeftmax = 0\nRightmax = 0\n\t\n# If curr node and it's left child has same value\nif (node.left and node.left.val == node.val):\n\tLeftmax += left + 1\n\t\n# If curr node and it's right child has same value\nif (node.right and node.right.val == node.val):\n\tRightmax += right + 1\n\t\nans[0] = max(ans[0], Leftmax + Rightmax)\nreturn max(Leftmax, Rightmax)\n\t\n# Driver function to find length of\n# longest same value path\ndef longestSameValuePath(root):\nans = [0]\nlength(root, ans)\nreturn ans[0]\n\t\n# Driver code\nif __name__ == '__main__':\n\t\n# Let us construct a Binary Tree\n#\t 4\n#\t / \\\n# 4 4\n# / \\ \\\n# 4 9 5\nroot = None\nroot = newNode(4)\nroot.left = newNode(4)\nroot.right = newNode(4)\nroot.left.left = newNode(4)\nroot.left.right = newNode(9)\nroot.right.right = newNode(5)\nprint(longestSameValuePath(root))\n\n# This code is contributed by PranchalK"}
{"nl": "Minimum number of bracket reversals needed to make an expression balanced", "code": "# Python3 program to find minimum number of\n# reversals required to balance an expression\n\u00a0\n# Returns count of minimum reversals\n# for making expr balanced. Returns -1\n# if expr cannot be balanced.\n\u00a0\n\u00a0\ndef countMinReversals(expr):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0lenn = len(expr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# length of expression must be even\n\u00a0\u00a0\u00a0\u00a0# to make it balanced by using reversals.\n\u00a0\u00a0\u00a0\u00a0if (lenn % 2):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# After this loop, stack contains\n\u00a0\u00a0\u00a0\u00a0# unbalanced part of expression,\n\u00a0\u00a0\u00a0\u00a0# i.e., expression of the form \"....\"\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\u00a0\u00a0\u00a0for i in range(lenn):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (expr[i] == '' and len(s)):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (s[0] == ''):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.insert(0, expr[i])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.insert(0, expr[i])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Length of the reduced expression\n\u00a0\u00a0\u00a0\u00a0# red_len = (m+n)\n\u00a0\u00a0\u00a0\u00a0red_len = len(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# count opening brackets at the\n\u00a0\u00a0\u00a0\u00a0# end of stack\n\u00a0\u00a0\u00a0\u00a0n = 0\n\u00a0\u00a0\u00a0\u00a0while (len(s)and s[0] == ''):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return ceil(m/2) + ceil(n/2) which\n\u00a0\u00a0\u00a0\u00a0# is actually equal to (m+n)/2 + n%2\n\u00a0\u00a0\u00a0\u00a0# when m+n is even.\n\u00a0\u00a0\u00a0\u00a0return (red_len // 2 + n % 2)\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0expr = \"}}{{\"\n\u00a0\u00a0\u00a0\u00a0print(countMinReversals(expr.strip()))\n\u00a0\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Find the Deepest Node in a Binary Tree", "code": "\"\"\"Python3 program to find value of the\ndeepest node in a given binary tree\"\"\"\n\n# A Binary Tree Node\n# Utility function to create a\n# new tree node\nclass newNode:\n\n\t# Constructor to create a newNode\n\tdef __init__(self, data):\n\t\tself.data= data\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.visited = False\n\n# maxLevel : keeps track of maximum\n# level seen so far.\n# res : Value of deepest node so far.\n# level : Level of root\ndef find(root, level, maxLevel, res):\n\n\tif (root != None):\n\t\tlevel += 1\n\t\tfind(root.left, level, maxLevel, res)\n\n\t\t# Update level and rescue\n\t\tif (level > maxLevel[0]):\n\t\t\n\t\t\tres[0] = root.data\n\t\t\tmaxLevel[0] = level\n\t\t\n\t\tfind(root.right, level, maxLevel, res)\n\t\t\n# Returns value of deepest node\ndef deepestNode(root) :\n\n\t# Initialize result and max level\n\tres = [-1]\n\tmaxLevel = [-1]\n\n\t# Updates value \"res\" and \"maxLevel\"\n\t# Note that res and maxLen are passed\n\t# by reference.\n\tfind(root, 0, maxLevel, res)\n\treturn res[0]\n\t\t\t\t\t\t\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(1)\n\troot.left = newNode(2)\n\troot.right = newNode(3)\n\troot.left.left = newNode(4)\n\troot.right.left = newNode(5)\n\troot.right.right = newNode(6)\n\troot.right.left.right = newNode(7)\n\troot.right.right.right = newNode(8)\n\troot.right.left.right.left = newNode(9)\n\tprint(deepestNode(root))\n\n# This code is contributed by\n# SHUBHAMSINGH10\n"}
{"nl": "Find the sum of all oddly occuring elements in a matrix.", "code": "# import the Counter Function from collections using the import keyword\r\nfrom collections import Counter\r\n# Give the matrix as static input and store it in a variable.\r\nmtrx = [[1, 2, 2], [3, 4, 2], [5, 1, 5]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# take a list and initialize it to empty using [] or list() function\r\nmtrxlist = []\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n    # Inside the For loop, Iterate till the given number of columns using another\r\n    # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # add the gvnmatrix[n][m] value to the list using the append() function\r\n        # where n is the iterator value of the parent For loop and m is the iterator\r\n        # value of the inner For loop.\r\n        mtrxlist.append(mtrx[n][m])\r\n# Apply the Counter function to the matrix elements list which stores the matrix element\r\n# as key and its frequency as value\r\nmtrxfreq = Counter(mtrxlist)\r\n# Take a variable(say oddFreqSum) that stores the sum of all the odd frequency elements\r\n# of the matrix and initialize its value to 0.\r\noddFreqSum = 0\r\n# Loop in this frequency dictionary using the For loop.\r\nfor key in mtrxfreq:\r\n    # Check if any key has frequency odd using the if conditional statement.\r\n    if(mtrxfreq[key] % 2 != 0):\r\n        # If it is true then add the key(Matrix Element) to the oddFreqSum.\r\n        oddFreqSum = oddFreqSum+key\r\n# Print the oddFreqSum.\r\nprint(\r\n    'The sum of all the odd frequency elements in the given matrix is = {', oddFreqSum, '}')"}
{"nl": "Return the elements of a list that are larger than half the total number of elements.", "code": "# Create a function to say getElementsLarger() which takes the given list and length of\r\n# the given list as the arguments and prints the elements in a list that are greater than\r\n# half of the total number of elements in the given list.\r\n\r\n\r\ndef getElementsLarger(gvn_lst, lengt_lst):\r\n        # Inside the function, sort the given list using the sorted() function and store\r\n        # it in a variable.\r\n    k = sorted(gvn_lst)\r\n    # Loop from half the length of the given list to the length of the given list-1\r\n    # using the for loop.\r\n    for itr in range(lengt_lst//2, lengt_lst):\r\n     # Inside the loop, print the element present at the iterator value of the\r\n     # above-sorted list.\r\n\r\n        print(k[itr])\r\n\r\n\r\n# Give the list as static input and store it in a variable.\r\ngvn_lst = [4, 6, 3, 1, 8, 9]\r\n# Calculate the length of the given list using the len() function and store it in\r\n# another variable.\r\nlengt_lst = len(gvn_lst)\r\nprint(\"The elements in a list that are greater than half of the total number of elements in the given list\")\r\n# Pass the given list and length of the given list as the arguments to the\r\n# getElementsLarger() function.\r\ngetElementsLarger(gvn_lst, lengt_lst)"}
{"nl": "Given a string, find the word \"Nemo\", and return a string like this: \"I found Nemo at [the order of the word you find Nemo]!\".", "code": "def find_nemo(sentence):\r\n    s=sentence.split()\r\n    if 'Nemo' in s:\r\n        return 'I found Nemo at {}!'.format(s.index('Nemo')+1)\r\n    return \"I can't find Nemo :(\"\r"}
{"nl": "Recursion: Reverse a String", "code": "def reverse(str):\n  return reverse(str[1:]) + str[0] if str else str"}
{"nl": "Longest Path in a Directed Acyclic Graph", "code": "# A recursive function used by longestPath. See below\n# link for details\n# https:#www.geeksforgeeks.org/topological-sorting/\ndef topologicalSortUtil(v):\n\u00a0\u00a0\u00a0\u00a0global Stack, visited, adj\n\u00a0\u00a0\u00a0\u00a0visited[v] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Recur for all the vertices adjacent to this vertex\n\u00a0\u00a0\u00a0\u00a0# list<AdjListNode>::iterator i\n\u00a0\u00a0\u00a0\u00a0for i in adj[v]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (not visited[i[0]]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0topologicalSortUtil(i[0])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Push current vertex to stack which stores topological\n\u00a0\u00a0\u00a0\u00a0# sort\n\u00a0\u00a0\u00a0\u00a0Stack.append(v)\n\u00a0\n# The function to find longest distances from a given vertex.\n# It uses recursive topologicalSortUtil() to get topological\n# sorting.\ndef longestPath(s):\n\u00a0\u00a0\u00a0\u00a0global Stack, visited, adj, V\n\u00a0\u00a0\u00a0\u00a0dist = [-10**9 for i in range(V)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Call the recursive helper function to store Topological\n\u00a0\u00a0\u00a0\u00a0# Sort starting from all vertices one by one\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (visited[i] == False):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0topologicalSortUtil(i)\n\u00a0\u00a0\u00a0\u00a0# print(Stack)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize distances to all vertices as infinite and\n\u00a0\u00a0\u00a0\u00a0# distance to source as 0\n\u00a0\u00a0\u00a0\u00a0dist[s] = 0\n\u00a0\u00a0\u00a0\u00a0# Stack.append(1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Process vertices in topological order\n\u00a0\u00a0\u00a0\u00a0while (len(Stack) > 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the next vertex from topological order\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u = Stack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0del Stack[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#print(u)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Update distances of all adjacent vertices\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# list<AdjListNode>::iterator i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dist[u] != 10**9):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in adj[u]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# print(u, i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dist[i[0]] < dist[u] + i[1]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i[0]] = dist[u] + i[1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Print calculated longest distances\n\u00a0\u00a0\u00a0\u00a0# print(dist)\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"INF \",end=\"\") if (dist[i] == -10**9) else print(dist[i],end=\" \")\n\u00a0\n# Driver code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0V, Stack, visited = 6, [], [False for i in range(7)]\n\u00a0\u00a0\u00a0\u00a0adj = [[] for i in range(7)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Create a graph given in the above diagram.\n\u00a0\u00a0\u00a0\u00a0# Here vertex numbers are 0, 1, 2, 3, 4, 5 with\n\u00a0\u00a0\u00a0\u00a0# following mappings:\n\u00a0\u00a0\u00a0\u00a0# 0=r, 1=s, 2=t, 3=x, 4=y, 5=z\n\u00a0\u00a0\u00a0\u00a0adj[0].append([1, 5])\n\u00a0\u00a0\u00a0\u00a0adj[0].append([2, 3])\n\u00a0\u00a0\u00a0\u00a0adj[1].append([3, 6])\n\u00a0\u00a0\u00a0\u00a0adj[1].append([2, 2])\n\u00a0\u00a0\u00a0\u00a0adj[2].append([4, 4])\n\u00a0\u00a0\u00a0\u00a0adj[2].append([5, 2])\n\u00a0\u00a0\u00a0\u00a0adj[2].append([3, 7])\n\u00a0\u00a0\u00a0\u00a0adj[3].append([5, 1])\n\u00a0\u00a0\u00a0\u00a0adj[3].append([4, -1])\n\u00a0\u00a0\u00a0\u00a0adj[4].append([5, -2])\n\u00a0\n\u00a0\u00a0\u00a0\u00a0s = 1\n\u00a0\u00a0\u00a0\u00a0print(\"Following are longest distances from source vertex \",s)\n\u00a0\u00a0\u00a0\u00a0longestPath(s)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# This code is contributed by mohit kumar 29.\n"}
{"nl": "Detect Cycle in a Graph using Disjoint Set (Or Union-Find)", "code": "# Python Program for union-find algorithm to detect cycle in a undirected graph\n# we have one egde for any two vertex i.e 1-2 is either 1-2 or 2-1 but not both\n\nfrom collections import defaultdict\n\n#This class represents a undirected graph using adjacency list representation\nclass Graph:\n\n\tdef __init__(self,vertices):\n\t\tself.V= vertices #No. of vertices\n\t\tself.graph = defaultdict(list) # default dictionary to store graph\n\n\n\t# function to add an edge to graph\n\tdef addEdge(self,u,v):\n\t\tself.graph[u].append(v)\n\n\t# A utility function to find the subset of an element i\n\tdef find_parent(self, parent,i):\n\t\tif parent[i] == -1:\n\t\t\treturn i\n\t\tif parent[i]!= -1:\n\t\t\treturn self.find_parent(parent,parent[i])\n\n\t# A utility function to do union of two subsets\n\tdef union(self,parent,x,y):\n\t\tparent[x] = y\n\n\n\n\t# The main function to check whether a given graph\n\t# contains cycle or not\n\tdef isCyclic(self):\n\t\t\n\t\t# Allocate memory for creating V subsets and\n\t\t# Initialize all subsets as single element sets\n\t\tparent = [-1]*(self.V)\n\n\t\t# Iterate through all edges of graph, find subset of both\n\t\t# vertices of every edge, if both subsets are same, then\n\t\t# there is cycle in graph.\n\t\tfor i in self.graph:\n\t\t\tfor j in self.graph[i]:\n\t\t\t\tx = self.find_parent(parent, i)\n\t\t\t\ty = self.find_parent(parent, j)\n\t\t\t\tif x == y:\n\t\t\t\t\treturn True\n\t\t\t\tself.union(parent,x,y)\n\n\n# Create a graph given in the above diagram\ng = Graph(3)\ng.addEdge(0, 1)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\n\nif g.isCyclic():\n\tprint (\"Graph contains cycle\")\nelse :\n\tprint (\"Graph does not contain cycle \")\n\n#This code is contributed by Neelam Yadav"}
{"nl": "Find all possible binary trees with given Inorder Traversal", "code": "# Python program to find binary tree with given\r\n# inorder traversal\r\n\r\n# Node Structure\r\nclass Node:\r\n\r\n\t# Utility to create a new node\r\n\tdef __init__(self , item):\r\n\t\tself.key = item\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\r\n# A utility function to do preorder traversal of BST\r\ndef preorder(root):\r\n\tif root is not None:\r\n\t\tprint (root.key,end=\" \")\r\n\t\tpreorder(root.left)\r\n\t\tpreorder(root.right)\r\n\r\n\r\n# Function for constructing all possible trees with\r\n# given inorder traversal stored in an array from\r\n# arr[start] to arr[end]. This function returns a\r\n# vector of trees.\r\ndef getTrees(arr , start , end):\r\n\r\n\t# List to store all possible trees\r\n\ttrees = []\r\n\t\r\n\t\"\"\" if start > end then subtree will be empty so\r\n\treturning NULL in the list \"\"\"\r\n\tif start > end :\r\n\t\ttrees.append(None)\r\n\t\treturn trees\r\n\t\r\n\r\n\t\"\"\" Iterating through all values from start to end\r\n\t\tfor constructing left and right subtree\r\n\t\trecursively \"\"\"\r\n\tfor i in range(start , end+1):\r\n\r\n\t\t# Constructing left subtree\r\n\t\tltrees = getTrees(arr , start , i-1)\r\n\t\t\r\n\t\t# Constructing right subtree\r\n\t\trtrees = getTrees(arr , i+1 , end)\r\n\t\t\r\n\t\t\"\"\" Looping through all left and right subtrees\r\n\t\tand connecting to ith root below\"\"\"\r\n\t\tfor j in ltrees :\r\n\t\t\tfor k in rtrees :\r\n\r\n\t\t\t\t# Making arr[i] as root\r\n\t\t\t\tnode = Node(arr[i])\r\n\t\r\n\t\t\t\t# Connecting left subtree\r\n\t\t\t\tnode.left = j\r\n\r\n\t\t\t\t# Connecting right subtree\r\n\t\t\t\tnode.right = k\r\n\r\n\t\t\t\t# Adding this tree to list\r\n\t\t\t\ttrees.append(node)\r\n\treturn trees\r\n\r\n# Driver program to test above function\r\ninp = [4 , 5, 7]\r\nn = len(inp)\r\n\r\ntrees = getTrees(inp , 0 , n-1)\r\n\r\nprint (\"Preorder traversals of different possible\\\r\nBinary Trees are \")\r\nfor i in trees :\r\n\tpreorder(i);\r\n\tprint (\"\")\r\n\r\n# This program is contributed by Nikhil Kumar Singh(nickzuck_007)\r"}
{"nl": "Calculate HCF (GCD) & LCM", "code": "# Python program to find hcf (gcd) & lcm\r\n\r\n# Defining function to calculate hcf\r\ndef find_gcd(a,b):\r\n    gcd = 1\r\n    for i in range(1,a+1):\r\n        if a%i==0 and b%i==0:\r\n           gcd = i\r\n    return gcd\r\n\r\n# Reading numbers from user\r\nfirst = int(input('Enter first number: '))\r\nsecond = int(input('Enter second number: '))\r\n\r\n# Function call & displaying output HCF (GCD)\r\nprint('HCF or GCD of %d and %d is %d' %(first, second, find_gcd(first, second)))\r\n\r\n# Calculating LCM\r\nlcm = first * second / find_gcd(first, second)\r\nprint('LCM of %d and %d is %d' %(first, second, lcm))"}
{"nl": "find the Nth Pentagonal Number in Python.", "code": "# Create a function nthPentagonalNumb() which accepts the given number\r\n# as an argument and returns the nth pentagonal number.\r\n\r\n\r\ndef nthPentagonalNumb(numb):\r\n        # Inside the nthPentagonalNumb() function.\r\n        # Calculate the value of (3*n*n - n)/2 where n is the argument and\r\n    # store it in a variable say reslt.\r\n    reslt = (3*numb*numb - numb)/2\r\n    # Return the reslt.\r\n    return int(reslt)\r\n\r\n\r\n# Give the number N as static Input and store it in a variable.\r\ngvnnumb = 4\r\n# Pass the given Number as an argument to nthPentagonalNumb() \r\n# function and store the result returned from the function in a variable say nthNumb.\r\nnthNumb = nthPentagonalNumb(gvnnumb)\r\n# Print the nthNumb value.\r\nprint('The {', gvnnumb, '} pentagonal number = ', nthNumb)"}
{"nl": "Check a Binary Number is Divisible by a Number N", "code": "# Give the binary number as user input using int(input()) and store it in a variable.\r\nbinry = int(input(\"Enter some random number = \"))\r\n# Given the number as user input using int(input()) and store it in another variable.\r\nnum = int(input(\"Enter some random number = \"))\r\n# Convert the given binary number into a decimal number using int(str(binary number),2)\r\n# function and store it in another variable say \"deci\".\r\ndeci = int(str(binry), 2)\r\n# Check if the above-obtained decimal number modulus given number is equal to 0 using the if\r\n# conditional statement.\r\nif deci % num == 0:\r\n    # If the statement is true, then print \"The binary number is divisible by the given\r\n    # input number\".\r\n    print(\"The given binary number is divisible by{\", num, \"}\")\r\nelse:\r\n # Else print \"\"The binary number is not divisible by the given input number\".\r\n    print(\"The given binary number is not divisible by{\", num, \"}\")"}
{"nl": "Python Program to Select a Random Element from a Tuple", "code": "# Import random module using the import keyword.\n \n import random\n \n # Give the tuple as static input and store it in a variable.\n \n gvn_tupl = (255, \"hello\", \"btechgeeks\", 150,\n \n  \"good morning\", [1, 2, 3, 4], 100, 98)\n \n # Apply random.choice() method for the above given tuple and store it in another variable.\n \n reslt = random.choice(gvn_tupl)\n \n # Print the random element from the above given tuple\n \n print(\"The random element from the above given tuple = \", reslt)\n \n </pre>"}
{"nl": "Python Program to Display Fibonacci Sequence Using Recursion", "code": "# Python program to display the Fibonacci sequence\n\ndef recur_fibo(n):\n   if n <= 1:\n       return n\n   else:\n       return(recur_fibo(n-1) + recur_fibo(n-2))\n\nnterms = 10\n\n# check if the number of terms is valid\nif nterms <= 0:\n   print(\"Plese enter a positive integer\")\nelse:\n   print(\"Fibonacci sequence:\")\n   for i in range(nterms):\n       print(recur_fibo(i))"}
{"nl": "Python Program to Print Triangle Numbers Pattern\n", "code": "rows = int(input(\"Enter Triangle Numbers Pattern Rows = \"))\n\nprint(\"====The Triangle Numbers Pattern====\")\n\nfor i in range(1, rows + 1):\n    for j in range(rows, i, -1):\n        print(end = ' ')\n    for k in range(1, i + 1):\n        print(k, end = ' ')\n    print()"}
{"nl": "Python Program to Check If a String Is a Number (Float)", "code": "def isfloat(num):\n    try:\n        float(num)\n        return True\n    except ValueError:\n        return False\n\nprint(isfloat('s12'))\nprint(isfloat('1.123'))"}
{"nl": "Write a program to calculate pow(x,n)", "code": "# Python3 code for extended version\n# of power function that can work\n# for float x and negative y\n\ndef power(x, y):\n\n\tif(y == 0): return 1\n\ttemp = power(x, int(y / 2))\n\t\n\tif (y % 2 == 0):\n\t\treturn temp * temp\n\telse:\n\t\tif(y > 0): return x * temp * temp\n\t\telse: return (temp * temp) / x\n\t\n# Driver Code\nx, y = 2, -3\nprint('%.6f' %(power(x, y)))\n\n# This code is contributed by Smitha Dinesh Semwal.\n"}
{"nl": "Print an even number pyramid given the number of rows", "code": "# Give the number of rows as static input and store it in a variable.\r\nnumberOfRows = 10\r\n# Take a variable and initialize it with 2*double the number of rows say lastnumb.\r\nlastnumb = 2*numberOfRows\r\n# Take another variable and initialize it with the lastnumb say evennumb.\r\nevennumb = lastnumb\r\n# Loop from 1 to the number of rows using For loop.\r\nfor m in range(1, numberOfRows+1):\r\n    # Initialize the evennumb with the lastnumb.\r\n    evennumb = lastnumb\r\n    # Loop from 0 to the iterator value of the parent For loop using\r\n    # another for loop(Nested For loop).\r\n    for n in range(0, m):\r\n        # Print the evennumb.\r\n        print(evennumb, end=' ')\r\n        # Reduce the evennumb by 2.\r\n        evennumb = evennumb-2\r\n\r\n    # Print the Newline character after the end of the inner loop.\r\n    print()"}
{"nl": "Count Consonants in a String in Python", "code": "# Python program to count consonant in a string def countConsonants(string): num_consonants = 0 # to count the consonants for char in string: if char not in \"aeiouAEIOU \": num_consonants += 1 return num_consonants # take input string = input('Enter any string: ') # calling function and display result print('No of consonants:',countConsonants(string))"}
{"nl": "Filter by Digit Length", "code": "def filter_digit_length(lst, num):\n    return [number for number in lst if len(str(number)) == num]"}
{"nl": "How to create a dictionary in Python", "code": "dict = {}  \nprint(\"Empty Dictionary is: \")  \nprint(dict)  \n  \n# Creating a Dictionary  \n# using the dict() method  \ndict1 = dict({1: 'Hello', 2: 'Hi', 3: 'Hey'})  \nprint(\"\\nCreate Dictionary by using the dict() method : \")  \nprint(dict1)  \n  \n# Creating a Dictionary  \n# with each item as a Pair  \ndict2 = dict([('Devansh', 90014), ('Arun', 90015)])  \nprint(\"\\nDictionary with each item as a pair: \")  \nprint(dict2)  "}
{"nl": "Python Tuple Length\r\n", "code": "thistuple = (\"apple\", \"banana\", \"cherry\")\r\nprint(len(thistuple))"}
{"nl": "find a string that represents the largest possible integer after mutating a single substring of an original string", "code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        l = r = 0\n        n = len(num)\n        result = ''\n        while r<n:\n            curr_digit = int(num[r])\n            new_digit = change[curr_digit]\n            if curr_digit >= new_digit and l == r:\n                result += num[r]\n                l += 1\n                r += 1\n                continue\n\n            if l < r and new_digit < curr_digit:\n                break\n            \n            result += str(change[curr_digit])\n            r += 1\n\n        while r<n:\n            result += num[r]\n            r += 1\n        \n        return result"}
{"nl": "Exercise working with conditional code and loops: given a 3 x 4 grid of pipes, underscores, and spaces, determine which number is represented, or whether it is garbled.", "code": "VALID_NUMBERS = [[\" _ \", \"| |\", \"|_|\", \"   \"], [\"   \", \"  |\", \"  |\", \"   \"], [\" _ \", \" _|\", \"|_ \", \"   \"], [\" _ \", \" _|\", \" _|\", \"   \"], [\"   \",\"|_|\", \"  |\", \"   \"],    [\" _ \", \"|_ \", \" _|\", \"   \"], [\" _ \", \"|_ \", \"|_|\", \"   \"], [\" _ \", \"  |\", \"  |\", \"   \"], [\" _ \", \"|_|\", \"|_|\", \"   \"], [\" _ \", \"|_|\", \" _|\", \"   \"]]\r\ndef convert(input_grid):\r\n    if len(input_grid) % 4 != 0:\r\n        raise ValueError(\"Number of input lines is not a multiple of four\")\r\n    for line in input_grid:\r\n        if len(line) % 3 != 0:\r\n            raise ValueError(\"Number of input columns is not a multiple of three\")\r\n    \r\n    rows = [[input_grid[i+j][k:k+3]\r\n            for k in range(0, len(input_grid[0]), 3)\r\n            for j in range(0, 4) ]\r\n            for i in range(0, len(input_grid), 4)\r\n           ]\r\n    # print(rows)\r\n    result = \"\"\r\n    for row in rows:\r\n        for i in range(0, len(row), 4):\r\n            result += convert_single_digit(row[i: i+4])\r\n        result += \",\"\r\n    return result[0:-1] #slice off the last comma\r\n            \r\ndef convert_single_digit(input):\r\n    print(input)\r\n    if input in VALID_NUMBERS:\r\n        return str(VALID_NUMBERS.index(input))\r\n    return \"?\"\r\n"}
{"nl": "create a class and get all possible subsets from a list", "code": "class sublist:\n  def sortlist(self, given_list):\n  # To compute all possible subsets of the list, the method\n  # printSubsets() is called from sortlist() method.\n  return self.printSubsets([], sorted(given_list))\n  # The printSubsetsis used to return all possible sublists of the given list.\n  def printSubsets(self, curr, given_list):\n  if given_list:\n  return self.printSubsets(curr, given_list[1:]) + self.printSubsets(curr + [given_list[0]], given_list[1:])\n  return [curr]\n# given list\ngiven_list = [4, 19, 2, 5, 3]\n# Create an object to represent the class.\nlistobj = sublist()\n# Call the sortlist method with the object created above.\nprint(\"Subsets of the given list\", given_list, \":\")\nprint(sublist().sortlist(given_list))"}
{"nl": "Python Program to Find K\u2019th Smallest/Largest Element in Unsorted Array or List", "code": "# Give the list as static input and store it in a variable.\n gvnlst = [19, 24, 25, 36, 81, 144, 600, 900,\n  225, 4, 9, 1, 16, 49, 23, 49, 25, 10, 25]\n print('The given list before sorting is', gvnlst)\n # Give the value of K as static input and store it in a variable.\n kth = 6\n # Sort the given list using the sort() function\n # which sorts the given list in ascending order.\n gvnlst.sort()\n print('The given list after sorting is', gvnlst)\n # We can get the Kth smallest element in the given list\n # by printing the k-1 index element in this sorted list.\n print('The', kth,\n  'th smallest element in the given list is [', gvnlst[kth-1], ']')\n # We can get the Kth largest element in the given list\n # by printing the -k index element in this sorted list\n # ( '-' refers to negative indexing).\n print('The', kth,\n  'th largest element in the given list is [', gvnlst[-kth], ']')"}
{"nl": "The minimum number of rotations to maximize a profit", "code": "import sys\nMIN_INT = -sys.maxsize-1\nclass Solution:\n  def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n  maxx = MIN_INT\n  rotate = total =  ans = money = num = i = 0\n  for i in range(len(customers)):\n  total += customers[i]\n  rotate = i+1\n  if total >= 4:\n  num += 4\n  total -= 4\n  else: \n  num += total\n  total = 0\n  money = num * boardingCost - rotate * runningCost\n  if maxx < money:\n  maxx = money\n  ans = rotate\n  i+=1\n  while(total > 0):\n  rotate = i+1\n  if total >= 4:\n  num += 4\n  total -= 4\n  else: \n  num += total\n  total = 0\n  money = num * boardingCost - rotate * runningCost\n  if maxx < money:\n  maxx = money\n  ans = rotate\n  i+=1\n  if maxx < 0: return -1\n  return ans"}
{"nl": "Generate Strong Numbers in an Interval", "code": "# Import the math module using import keyword.\r\nimport math\r\n#Give the lower limit range as user input using int(input()) and\r\n#store it in a variable.\r\ngvn_lower_lmt = int(input(\"Enter some random number = \"))\r\n#Give the upper limit range as user input using int(input()) and \r\n#store it in another variable.\r\ngvn_upper_lmt = int(input(\"Enter some random number = \"))\r\n# Loop from lower limit range to upper limit range using For loop.\r\nprint(\"The Strong Numbers in a given range\",\r\n      gvn_lower_lmt, \"and\", gvn_upper_lmt, \"are :\")\r\nfor itr in range(gvn_lower_lmt, gvn_upper_lmt+1):\r\n   # Taking a variable totalSum and initializing it with 0\r\n    totalSum = 0\r\n    # Put the iterator value in a temporary variable called tempNum.\r\n    tempNum = itr\r\n    # using while to extract digit by digit of the given iterator value\r\n    while(itr):\r\n        s = 1\r\n        factNum = 1\r\n        # Getting the last digit of the iterator value\r\n        remainder = itr % 10\r\n        # calculating the factorial of the digit(extracted by remainder variable)\r\n        # using math.fatorial function\r\n        factNum = math.factorial(remainder)\r\n        # Adding the factorial to the totalSum\r\n        totalSum = totalSum + factNum\r\n        # Dividing the given itertor value by 10\r\n        itr = itr//10\r\n    # checking if the totalSum is equal to the iterator value\r\n    # if it is true then it is strong number then return true\r\n    if(totalSum == tempNum):\r\n        print(tempNum, end=' ')"}
{"nl": "Median in a stream of integers (running integers)", "code": "# code\r\nfrom heapq import heappush, heappop, heapify\r\nimport math\r\nminHeap=[]\r\nheapify(minHeap)\r\nmaxHeap=[]\r\nheapify(maxHeap)\r\ndef insertHeaps(num):\r\n\theappush(maxHeap,-num)\t\t\t ### Pushing negative element to obtain a minHeap for\r\n\theappush(minHeap,-heappop(maxHeap)) ### the negative counterpart\r\n\r\n\tif len(minHeap) > len(maxHeap):\r\n\t\theappush(maxHeap,-heappop(minHeap))\r\n\t\r\ndef getMedian():\r\n\tif len(minHeap)!= len(maxHeap):\r\n\t\treturn -maxHeap[0]\r\n\telse:\r\n\t\treturn (minHeap[0]- maxHeap[0])/2\r\n\r\n\r\nif __name__== '__main__':\r\n\tA= [5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4]\r\n\tn= len(A)\r\n\tfor i in range(n):\r\n\t\tinsertHeaps(A[i])\r\n\t\tprint(math.floor(getMedian()))\r"}
{"nl": "Logistic Regression v/s Decision Tree Classification", "code": "\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\ncd C:\\Users\\Dev\\Desktop\\Kaggle\\Sinking Titanic\n# Changing the working location to the location of the file\ndf = pd.read_csv('_train.csv')\ny = df['Survived']\n \nX = df.drop('Survived', axis = 1)\nX = X.drop(['Name', 'Ticket', 'Cabin', 'Embarked'], axis = 1)\n \nX = X.replace(['male', 'female'], [2, 3])\n# Hot-encoding the categorical variables\n \nX.fillna(method ='ffill', inplace = True)\n# Handling the missing values\nX_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size = 0.3, random_state = 0)\n \nlr = LogisticRegression()\nlr.fit(X_train, y_train)\nprint(lr.score(X_test, y_test))\r\ncriteria = ['gini', 'entropy']\r\nscores = {}\r\n \r\nfor c in criteria:\r\n    dt = DecisionTreeClassifier(criterion = c)\r\n    dt.fit(X_train, y_train)\r\n    test_score = dt.score(X_test, y_test)\r\n    scores = test_score\r\n \r\nprint(scores)"}
{"nl": "Skip List  (Insertion)", "code": "# Python3 code for inserting element in skip list\n\nimport random\n\nclass Node(object):\n\t'''\n\tClass to implement node\n\t'''\n\tdef __init__(self, key, level):\n\t\tself.key = key\n\n\t\t# list to hold references to node of different level\n\t\tself.forward = [None]*(level+1)\n\nclass SkipList(object):\n\t'''\n\tClass for Skip list\n\t'''\n\tdef __init__(self, max_lvl, P):\n\t\t# Maximum level for this skip list\n\t\tself.MAXLVL = max_lvl\n\n\t\t# P is the fraction of the nodes with level\n\t\t# i references also having level i+1 references\n\t\tself.P = P\n\n\t\t# create header node and initialize key to -1\n\t\tself.header = self.createNode(self.MAXLVL, -1)\n\n\t\t# current level of skip list\n\t\tself.level = 0\n\t\n\t# create new node\n\tdef createNode(self, lvl, key):\n\t\tn = Node(key, lvl)\n\t\treturn n\n\t\n\t# create random level for node\n\tdef randomLevel(self):\n\t\tlvl = 0\n\t\twhile random.random()<self.P and \\\n\t\t\tlvl<self.MAXLVL:lvl += 1\n\t\treturn lvl\n\n\t# insert given key in skip list\n\tdef insertElement(self, key):\n\t\t# create update array and initialize it\n\t\tupdate = [None]*(self.MAXLVL+1)\n\t\tcurrent = self.header\n\n\t\t'''\n\t\tstart from highest level of skip list\n\t\tmove the current reference forward while key\n\t\tis greater than key of node next to current\n\t\tOtherwise inserted current in update and\n\t\tmove one level down and continue search\n\t\t'''\n\t\tfor i in range(self.level, -1, -1):\n\t\t\twhile current.forward[i] and \\\n\t\t\t\tcurrent.forward[i].key < key:\n\t\t\t\tcurrent = current.forward[i]\n\t\t\tupdate[i] = current\n\n\t\t'''\n\t\treached level 0 and forward reference to\n\t\tright, which is desired position to\n\t\tinsert key.\n\t\t'''\n\t\tcurrent = current.forward[0]\n\n\t\t'''\n\t\tif current is NULL that means we have reached\n\t\tto end of the level or current's key is not equal\n\t\tto key to insert that means we have to insert\n\t\tnode between update[0] and current node\n\t'''\n\t\tif current == None or current.key != key:\n\t\t\t# Generate a random level for node\n\t\t\trlevel = self.randomLevel()\n\n\t\t\t'''\n\t\t\tIf random level is greater than list's current\n\t\t\tlevel (node with highest level inserted in\n\t\t\tlist so far), initialize update value with reference\n\t\t\tto header for further use\n\t\t\t'''\n\t\t\tif rlevel > self.level:\n\t\t\t\tfor i in range(self.level+1, rlevel+1):\n\t\t\t\t\tupdate[i] = self.header\n\t\t\t\tself.level = rlevel\n\n\t\t\t# create new node with random level generated\n\t\t\tn = self.createNode(rlevel, key)\n\n\t\t\t# insert node by rearranging references\n\t\t\tfor i in range(rlevel+1):\n\t\t\t\tn.forward[i] = update[i].forward[i]\n\t\t\t\tupdate[i].forward[i] = n\n\n\t\t\tprint(\"Successfully inserted key {}\".format(key))\n\n\t# Display skip list level wise\n\tdef displayList(self):\n\t\tprint(\"\\n*****Skip List******\")\n\t\thead = self.header\n\t\tfor lvl in range(self.level+1):\n\t\t\tprint(\"Level {}: \".format(lvl), end=\" \")\n\t\t\tnode = head.forward[lvl]\n\t\t\twhile(node != None):\n\t\t\t\tprint(node.key, end=\" \")\n\t\t\t\tnode = node.forward[lvl]\n\t\t\tprint(\"\")\n\n# Driver to test above code\ndef main():\n\tlst = SkipList(3, 0.5)\n\tlst.insertElement(3)\n\tlst.insertElement(6)\n\tlst.insertElement(7)\n\tlst.insertElement(9)\n\tlst.insertElement(12)\n\tlst.insertElement(19)\n\tlst.insertElement(17)\n\tlst.insertElement(26)\n\tlst.insertElement(21)\n\tlst.insertElement(25)\n\tlst.displayList()\n\nmain()\n"}
{"nl": "How given string interact", "code": "def neutralise(s1, s2):\n  return ''.join(a if a == b else '0' for a, b in zip(s1, s2))"}
{"nl": "Python Program to Print Inverted Right Triangle of Decreasing Order Numbers", "code": "rows = int(input(\"Inverted Right Triangle Numbers in Decreasing Ord Rows = \"))\n\nprint(\"==Inverted Right Triangle of Numbers in Decreasing Order Pattern==\")\n\nfor i in range(rows, 0, -1):\n    for j in range(i, 0, -1):\n        print(j, end = ' ')\n    print()"}
{"nl": "Inorder Successor in Binary Search Tree", "code": "# Python program to find the inorder successor in a BST\n\u00a0\n# A binary tree node\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\ndef inOrderSuccessor(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Step 1 of the above algorithm\n\u00a0\u00a0\u00a0\u00a0if n.right is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return minValue(n.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Step 2 of the above algorithm\n\u00a0\u00a0\u00a0\u00a0p = n.parent\n\u00a0\u00a0\u00a0\u00a0while( p is not None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if n != p.right :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n = p\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p = p.parent\n\u00a0\u00a0\u00a0\u00a0return p\n\u00a0\n# Given a non-empty binary search tree, return the\n# minimum data value found in that tree. Note that the\n# entire tree doesn't need to be searched\ndef minValue(node):\n\u00a0\u00a0\u00a0\u00a0current = node\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# loop down to find the leftmost leaf\n\u00a0\u00a0\u00a0\u00a0while(current is not None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if current.left is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = current.left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return current\n\u00a0\n\u00a0\n# Given a binary search tree and a number, inserts a\n# new node with the given number in the correct place\n# in the tree. Returns the new root pointer which the\n# caller should then use( the standard trick to avoid\n# using reference parameters)\ndef insert( node, data):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 1) If tree is empty then return a new singly node\n\u00a0\u00a0\u00a0\u00a0if node is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(data)\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# 2) Otherwise, recur down the tree\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if data <= node.data:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = insert(node.left, data)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.left = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.parent = node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = insert(node.right, data)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.right = temp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.parent = node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# return\u00a0 the unchanged node pointer\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\n\u00a0\n# Driver program to test above function\n\u00a0\nroot = None\n\u00a0\n# Creating the tree given in the above diagram\nroot = insert(root, 20)\nroot = insert(root, 8);\nroot = insert(root, 22);\nroot = insert(root, 4);\nroot = insert(root, 12);\nroot = insert(root, 10);\u00a0\nroot = insert(root, 14);\u00a0\u00a0\u00a0\ntemp = root.left.right.right\n\u00a0\nsucc = inOrderSuccessor(temp)\nif succ is not None:\n\u00a0\u00a0\u00a0\u00a0print (\"\\nInorder Successor of % d is % d \"%(temp.data, succ.data))\nelse:\n\u00a0\u00a0\u00a0\u00a0print (\"\\nInorder Successor doesn't exist\")\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Implement a Stack", "code": "class Stack:\n    def __init__(self):\n        self.items = []\n\u00a0\n    def is_empty(self):\n        return self.items == []\n\u00a0\n    def push(self, data):\n        self.items.append(data)\n\u00a0\n    def pop(self):\n        return self.items.pop()\n\u00a0\n\u00a0\ns = Stack()\nwhile True:\n    print('push <value>')\n    print('pop')\n    print('quit')\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'push':\n        s.push(int(do[1]))\n    elif operation == 'pop':\n        if s.is_empty():\n            print('Stack is empty.')\n        else:\n            print('Popped value: ', s.pop())\n    elif operation == 'quit':\n        break"}
{"nl": "all possible valid IP addresses that can be formed by inserting dots into s", "code": "class Solution:\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def valid(segment):\n            \"\"\"\n            Check if the current segment is valid :\n            1. less or equal to 255      \n            2. the first character could be '0' \n               only if the segment is equal to '0'\n            \"\"\"\n            return int(segment) <= 255 if segment[0] != '0' else len(segment) == 1\n            \n        def update_output(curr_pos):\n            \"\"\"\n            Append the current list of segments \n            to the list of solutions\n            \"\"\"\n            segment = s[curr_pos + 1:n]\n            if valid(segment):\n                segments.append(segment)\n                output.append('.'.join(segments))\n                segments.pop()    \n            \n        def backtrack(prev_pos = -1, dots = 3):\n            \"\"\"\n            prev_pos : the position of the previously placed dot\n            dots : number of dots to place\n            \"\"\"\n            # The current dot curr_pos could be placed \n            # in a range from prev_pos + 1 to prev_pos + 4.\n            # The dot couldn't be placed \n            # after the last character in the string.\n            for curr_pos in range(prev_pos + 1, min(n - 1, prev_pos + 4)):\n                segment = s[prev_pos + 1:curr_pos + 1]\n                if valid(segment):\n                    segments.append(segment)  # place dot\n                    if dots - 1 == 0:  # if all 3 dots are placed\n                        update_output(curr_pos)  # add the solution to output\n                    else:\n                        backtrack(curr_pos, dots - 1)  # continue to place dots\n                    segments.pop()  # remove the last placed dot\n        \n        n = len(s)\n        output, segments = [], []\n        backtrack() "}
{"nl": "Program to check Involutory Matrix", "code": "# Program to implement involutory matrix.\nN = 3;\n\u00a0\n# Function for matrix multiplication.\ndef multiply(mat, res):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[i][j] = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for k in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res[i][j] += mat[i][k] * mat[k][j];\n\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\n# Function to check involutory matrix.\ndef InvolutoryMatrix(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0res=[[0 for i in range(N)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N)];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# multiply function call.\n\u00a0\u00a0\u00a0\u00a0res = multiply(mat, res);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(N):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == j and res[i][j] != 1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i != j and res[i][j] != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False;\n\u00a0\u00a0\u00a0\u00a0return True;\n\u00a0\n# Driver Code\nmat = [[1, 0, 0], [0, -1, 0], [0, 0, -1]];\n\u00a0\n# Function call. If function\n# return true then if part\n# will execute otherwise\n# else part will execute.\nif (InvolutoryMatrix(mat)):\n\u00a0\u00a0\u00a0\u00a0print(\"Involutory Matrix\");\nelse:\n\u00a0\u00a0\u00a0\u00a0print(\"Not Involutory Matrix\");\n\u00a0\n# This code is contributed by mits\n"}
{"nl": "Kaggle Breast Cancer Wisconsin Diagnosis using Logistic Regression\r\n", "code": "\n# performing linear algebra\nimport numpy as np\n \n# data processing\nimport pandas as pd\n \n# visualisation\nimport matplotlib.pyplot as plt\ndata = pd.read_csv(\"..\\\\breast-cancer-wisconsin-data\\\\data.csv\")\n \nprint (data.head)\ndata.info()\ndata.drop(['Unnamed: 32', 'id'], axis = 1)\ndata.diagnosis = [1 if each == \"M\" else 0 for each in data.diagnosis]\ny = data.diagnosis.values\nx_data = data.drop(['diagnosis'], axis = 1)\nx = (x_data - np.min(x_data))/(np.max(x_data) - np.min(x_data)).values\nfrom sklearn.model_selection import train_test_split\nx_train, x_test, y_train, y_test = train_test_split(\n    x, y, test_size = 0.15, random_state = 42)\n \nx_train = x_train.T\nx_test = x_test.T\ny_train = y_train.T\ny_test = y_test.T\n \nprint(\"x train: \", x_train.shape)\nprint(\"x test: \", x_test.shape)\nprint(\"y train: \", y_train.shape)\nprint(\"y test: \", y_test.shape)\ndef initialize_weights_and_bias(dimension):\n    w = np.full((dimension, 1), 0.01)\n    b = 0.0\n    return w, b\n# z = np.dot(w.T, x_train)+b\ndef sigmoid(z):\n    y_head = 1/(1 + np.exp(-z))\n    return y_head\ndef forward_backward_propagation(w, b, x_train, y_train):\n    z = np.dot(w.T, x_train) + b\n    y_head = sigmoid(z)\n    loss = - y_train * np.log(y_head) - (1 - y_train) * np.log(1 - y_head)\n    # x_train.shape[1]  is for scaling\n    cost = (np.sum(loss)) / x_train.shape[1]     \n \n    # backward propagation\n    derivative_weight = (np.dot(x_train, (\n        (y_head - y_train).T))) / x_train.shape[1]\n    derivative_bias = np.sum(\n        y_head-y_train) / x_train.shape[1]                \n    gradients = {\"derivative_weight\": derivative_weight,\n                 \"derivative_bias\": derivative_bias}\n    return cost, gradients\ndef update(w, b, x_train, y_train, learning_rate, number_of_iterarion):\n    cost_list = []\n    cost_list2 = []\n    index = []\n \n    # updating(learning) parameters is number_of_iterarion times\n    for i in range(number_of_iterarion):\n        # make forward and backward propagation and find cost and gradients\n        cost, gradients = forward_backward_propagation(w, b, x_train, y_train)\n        cost_list.append(cost)\n \n        # lets update\n        w = w - learning_rate * gradients[\"derivative_weight\"]\n        b = b - learning_rate * gradients[\"derivative_bias\"]\n        if i % 10 == 0:\n            cost_list2.append(cost)\n            index.append(i)\n            print (\"Cost after iteration % i: % f\" %(i, cost))\n \n    # update(learn) parameters weights and bias\n    parameters = {\"weight\": w, \"bias\": b}\n    plt.plot(index, cost_list2)\n    plt.xticks(index, rotation ='vertical')\n    plt.xlabel(\"Number of Iterarion\")\n    plt.ylabel(\"Cost\")\n    plt.show()\n    return parameters, gradients, cost_list"}
{"nl": "Implement the Front Middle Back Queue", "code": "class FrontMiddleBackQueue(object):\n\n  def __init__(self):\n  self.A, self.B = collections.deque(), collections.deque()\n\n  def pushFront(self, val):\n  self.A.appendleft(val)\n  self.balance()\n\n  def pushMiddle(self, val):\n  if len(self.A) > len(self.B):\n  self.B.appendleft(self.A.pop())\n  self.A.append(val)\n\n  def pushBack(self, val):\n  self.B.append(val)\n  self.balance()\n\n  def popFront(self):\n  val = self.A.popleft() if self.A else -1\n  self.balance()\n  return val\n\n  def popMiddle(self):\n  val = (self.A or [-1]).pop()\n  self.balance()\n  return val\n\n  def popBack(self):\n  val = (self.B or self.A or [-1]).pop()\n  self.balance()\n  return val\n\n  # keep A.size() >= B.size()\n  def balance(self):\n  if len(self.A) > len(self.B) + 1:\n  self.B.appendleft(self.A.pop())\n  if len(self.A) < len(self.B):\n  self.A.append(self.B.popleft())"}
{"nl": "Python math.atan2() Method", "code": "# Import math Library\r\nimport math\r\n\r\n# Return the arc tangent of y/x in radians\r\nprint(math.atan2(8, 5))\r\nprint(math.atan2(20, 10))\r\nprint(math.atan2(34, -7))"}
{"nl": "Cowboy Shootout", "code": "def roger_shots(lst):\n  return sum(i in ('Bang!', 'BangBang!') for i in lst)/2"}
{"nl": "Python break Keyword", "code": "for i in range(9):\r\n  if i > 3:\r\n    break\r\n  print(i)"}
{"nl": "Python Program to Compute the Area and Perimeter of Octagon", "code": "# Import the math module using the import keyword.\nimport math\n# Give the Octagon's side length as user input using float(input()) function and\n# store it in a variable.\nside_len = float(input(\"Enter some random number = \"))\n# Calculate the area of the given Octagon using the above given mathematical formula\n# and sqrt(), math.pow() functions.\n# Store it in another variable.\noctgn_area = (2*(1+math.sqrt(2))*math.pow(side_len, 2))\n# Calculate the perimeter of the given Octagon using the above given mathematical formula.\n# Store it in another variable.\noctgn_perimetr = (8*side_len)\n# Print the Octagon's area with the given side length.\nprint(\n    \"The Octagon's Area with given side length {\", side_len, \"} =\", octgn_area)\n# Print the Octagon's perimeter with the given side length.\nprint(\n    \"The Octagon's Perimeter with the given side length {\", side_len, \"} =\", octgn_perimetr)"}
{"nl": "Find product of values of elements in a dictionary", "code": "# Give the dictionary as static input and store it in a variable.\ngvn_dict = {'jan': 10, 'Feb': 5, 'Mar': 22, 'April': 32, 'May': 6}\n# Get all the values of given dictionary using dictionary.values() method\n# and store it in another variable.\ndict_vlue = gvn_dict.values()\n# Take a variable say 'product' and initialize it's value with '1'\nfnl_prod = 1\n# Iterate in the above given dictionary values using using For loop.\nfor itrator in dict_vlue:\n  # Inside the loop, Multiply the above initialized product variable with the iterator\n  # and store it in a same variable.\n  fnl_prod = fnl_prod*itrator\n# Print the product of values for the above given dictionary.\nprint(\"The Product of values in a given dictionary = \", fnl_prod)"}
{"nl": "Sort a List of Integer Tuples using sort()", "code": "def sortlastElementTuple(listTuple):\r\n    # The key has been configured to sort using the\r\n    # last element of the sublist lambda has been used\r\n    listTuple.sort(key=lambda k: k[-1])\r\n    # returning the sorted list of tuples\r\n    return listTuple\r\n\r\n\r\nlistofTuples = [(5, 12, 98), (7, 1), (4, 19, 11, 9),\r\n                (36, 82, 19, 1, 2, 5, 3, 6, 9, 6)]\r\n# printing the sorted list of tuples by last element\r\nprint(\"Printing the sorted list of tuples : \")\r\n# Passing the given list of tuples to sortlastElementTuple function\r\nprint(sortlastElementTuple(listofTuples))"}
{"nl": "Rearrange array such that arr[i] >= arr[j] if i is even and arr[i]<=arr[j] if i is odd and j < i", "code": "# Python3 code to rearrange the array\n# as per the given condition\nimport array as a\nimport numpy as np\n\n# function to rearrange the array\ndef rearrangeArr(arr, n):\n\t\n\t# total even positions\n\tevenPos = int(n / 2)\n\n\t# total odd positions\n\toddPos = n - evenPos\n\n\t# initialising empty array in python\n\ttempArr = np.empty(n, dtype = object)\n\n\t# copy original array in an\n\t# auxiliary array\n\tfor i in range(0, n):\n\t\t\n\t\ttempArr[i] = arr[i]\n\n\t# sort the auxiliary array\n\ttempArr.sort()\n\n\tj = oddPos - 1\n\n\t# fill up odd position in original\n\t# array\n\tfor i in range(0, n, 2):\n\n\t\tarr[i] = tempArr[j]\n\t\tj = j - 1\n\t\n\tj = oddPos\n\n\t# fill up even positions in original\n\t# array\n\tfor i in range(1, n, 2):\n\t\tarr[i] = tempArr[j]\n\t\tj = j + 1\n\t\n\t# display array\n\tfor i in range(0, n):\n\t\tprint (arr[i], end = ' ')\n\n# Driver code\narr = a.array('i', [ 1, 2, 3, 4, 5, 6, 7 ])\nrearrangeArr(arr, 7)\n\n# This code is contributed by saloni1297"}
{"nl": "Python File writable() Method", "code": "f = open(\"demofile.txt\", \"a\")\r\nprint(f.writable())\r\n"}
{"nl": "Given a moment, determine the moment that would be after a gigasecond has passed", "code": "from datetime import datetime, timedelta\nGIGASECOND = timedelta(seconds=10**9)\ndef add(moment: datetime) -> datetime:\n    return moment + GIGASECOND"}
{"nl": "First and Last Index", "code": "def char_index(word, char):\n  return None if char not in word else [word.index(char), word.rindex(char)]"}
{"nl": "Exercise working with string manipulation: implement the classic method for composing secret messages called a square code.", "code": "import math\r\nimport string\r\ndef cipher_text(plain_text):\r\n    text = sanitize_text(plain_text)\r\n    if len(text) == 0:\r\n        return ''\r\n    cols = math.ceil(math.sqrt(len(text)))\r\n    rows = math.ceil(len(text) / cols)\r\n    text += ' ' * ((cols * rows) - len(text))\r\n    return ' '.join(text[i::cols] for i in range(cols))\r\ndef sanitize_text(plain_text):\r\n    trantab = str.maketrans('', '', string.punctuation + string.whitespace)\r\n    return plain_text.lower().strip().translate(trantab)"}
{"nl": "Python RegEx Match Object\r\n", "code": "import re\r\n\r\ntxt = \"The rain in Spain\"\r\nx = re.search(\"ai\", txt)\r\nprint(x) #this will print an object"}
{"nl": "Count Inversions in an array", "code": "from heapq import heappush, heappop\r\nfrom bisect import bisect, insort\r\n\r\n\r\ndef getNumOfInversions(A):\r\n\tN = len(A)\r\n\tif N <= 1:\r\n\t\treturn 0\r\n\r\n\tsortList = []\r\n\tresult = 0\r\n\r\n\t# heapsort, O(N*log(N))\r\n\tfor i, v in enumerate(A):\r\n\t\theappush(sortList, (v, i))\r\n\r\n\tx = [] # create a sorted list of indexes\r\n\twhile sortList: # O(N)\r\n\t\tv, i = heappop(sortList) # O(log(N))\r\n\t\t# find the current minimum's index\r\n\t\t# the index y can represent how many minimums on the left\r\n\t\ty = bisect(x, i) # O(log(N))\r\n\t\t# i can represent how many elements on the left\r\n\t\t# i - y can find how many bigger nums on the left\r\n\t\tresult += i - y\r\n\r\n\t\tinsort(x, i) # O(log(N))\r\n\r\n\treturn result\r\n\r\n# Driver Code\r\n# Given array is\r\nA = [-1, 6, 3, 4, 7, 4]\r\nresult = getNumOfInversions(A)\r\nprint(f'Number of inversions are {result}')\r"}
{"nl": "Exercise verifying if a sentence is a panagram", "code": "from string import ascii_lowercase\nALPHABET = set(ascii_lowercase)\ndef is_pangram(string):\n    return ALPHABET.issubset(string.lower())"}
{"nl": "given two matrices reprsenting islands, find all islands in grid 1 that contain all the cells that contain this island in grid 2", "code": "class Solution:\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\n        m, n = len(grid2), len(grid2[0])\n        \n        def dfs(i, j):\n            if i < 0 or j < 0 or i == m or j == n or grid2[i][j] == 0:\n                return True\n            \n            is_subisland = True\n            if grid1[i][j] == 0:\n                is_subisland = False\n            \n            grid2[i][j] = 0\n            \n            is_subisland = dfs(i+1, j) and is_subisland\n            is_subisland = dfs(i-1, j) and is_subisland\n            is_subisland = dfs(i, j+1) and is_subisland\n            is_subisland = dfs(i, j-1) and is_subisland\n            \n            return is_subisland\n        \n        sub_islands = sum(grid2[i][j] and dfs(i, j) for i in range(m) for j in range(n))\n        return sub_islands"}
{"nl": "Implement Counting Sort", "code": "def counting_sort(alist, largest):\n    c = [0]*(largest + 1)\n    for i in range(len(alist)):\n        c[alist[i]] = c[alist[i]] + 1\n\u00a0\n    # Find the last index for each element\n    c[0] = c[0] - 1 # to decrement each element for zero-based indexing\n    for i in range(1, largest + 1):\n        c[i] = c[i] + c[i - 1]\n\u00a0\n    result = [None]*len(alist)\n\u00a0\n    # Though it is not required here,\n    # it becomes necessary to reverse the list\n    # when this function needs to be a stable sort\n    for x in reversed(alist):\n        result[c[x]] = x\n        c[x] = c[x] - 1\n\u00a0\n    return result\n\u00a0\n\u00a0\nalist = input('Enter the list of (nonnegative) numbers: ').split()\nalist = [int(x) for x in alist]\nk = max(alist)\nsorted_list = counting_sort(alist, k)\nprint('Sorted list: ', end='')\nprint(sorted_list)"}
{"nl": "Python Program to Print all Prime Numbers in an Interval", "code": "# Python program to display all the prime numbers within an interval\n\nlower = 900\nupper = 1000\n\nprint(\"Prime numbers between\", lower, \"and\", upper, \"are:\")\n\nfor num in range(lower, upper + 1):\n   # all prime numbers are greater than 1\n   if num > 1:\n       for i in range(2, num):\n           if (num % i) == 0:\n               break\n       else:\n           print(num)"}
{"nl": "Get the File Extension", "code": "def get_extension(lst):\n  return [i.split(\".\")[1] for i in lst]"}
{"nl": "Spectral clustering machine learning", "code": "\r\nimport pandas as pd\r\nimport matplotlib.pyplot as plt\r\nfrom sklearn.cluster import SpectralClustering\r\nfrom sklearn.preprocessing import StandardScaler, normalize\r\nfrom sklearn.decomposition import PCA\r\nfrom sklearn.metrics import silhouette_score\r\n\r\n# Changing the working location to the location of the data\r\ncd \"C:\\Users\\Dev\\Desktop\\Kaggle\\Credit_Card\"\r\n  \r\n# Loading the data\r\nX = pd.read_csv('CC_GENERAL.csv')\r\n  \r\n# Dropping the CUST_ID column from the data\r\nX = X.drop('CUST_ID', axis = 1)\r\n  \r\n# Handling the missing values if any\r\nX.fillna(method ='ffill', inplace = True)\r\n  \r\nX.head()\r\n\r\n\r\n# Preprocessing the data to make it visualizable\r\n  \r\n# Scaling the Data\r\nscaler = StandardScaler()\r\nX_scaled = scaler.fit_transform(X)\r\n  \r\n# Normalizing the Data\r\nX_normalized = normalize(X_scaled)\r\n  \r\n# Converting the numpy array into a pandas DataFrame\r\nX_normalized = pd.DataFrame(X_normalized)\r\n  \r\n# Reducing the dimensions of the data\r\npca = PCA(n_components = 2)\r\nX_principal = pca.fit_transform(X_normalized)\r\nX_principal = pd.DataFrame(X_principal)\r\nX_principal.columns = ['P1', 'P2']\r\n  \r\nX_principal.head()\r\n\r\n\r\n# Building the clustering model\r\nspectral_model_rbf = SpectralClustering(n_clusters = 2, affinity ='rbf')\r\n  \r\n# Training the model and Storing the predicted cluster labels\r\nlabels_rbf = spectral_model_rbf.fit_predict(X_principal)\r\n# Building the label to colour mapping\r\ncolours = {}\r\ncolours[0] = 'b'\r\ncolours[1] = 'y'\r\n  \r\n# Building the colour vector for each data point\r\ncvec = [colours[label] for label in labels_rbf]\r\n  \r\n# Plotting the clustered scatter plot\r\n  \r\nb = plt.scatter(X_principal['P1'], X_principal['P2'], color ='b');\r\ny = plt.scatter(X_principal['P1'], X_principal['P2'], color ='y');\r\n  \r\nplt.figure(figsize =(9, 9))\r\nplt.scatter(X_principal['P1'], X_principal['P2'], c = cvec)\r\nplt.legend((b, y), ('Label 0', 'Label 1'))\r\nplt.show()\r\n\r\n\r\n# Building the clustering model\r\nspectral_model_nn = SpectralClustering(n_clusters = 2, affinity ='nearest_neighbors')\r\n  \r\n# Training the model and Storing the predicted cluster labels\r\nlabels_nn = spectral_model_nn.fit_predict(X_principal)\r\n# List of different values of affinity\r\naffinity = ['rbf', 'nearest-neighbours']\r\n  \r\n# List of Silhouette Scores\r\ns_scores = []\r\n  \r\n# Evaluating the performance\r\ns_scores.append(silhouette_score(X, labels_rbf))\r\ns_scores.append(silhouette_score(X, labels_nn))\r\n  \r\nprint(s_scores)\r\n# Plotting a Bar Graph to compare the models\r\nplt.bar(affinity, s_scores)\r\nplt.xlabel('Affinity')\r\nplt.ylabel('Silhouette Score')\r\nplt.title('Comparison of different Clustering Models')\r\nplt.show()"}
{"nl": "Check Perfect Square Number", "code": "# Check for perfect square\r\ndef is_perfect_sqaure(n):\r\n    root = n ** 0.5\r\n    int_root = int(root)\r\n    return int_root ** 2 == n\r\n\r\n# Function Call\r\nprint(is_perfect_sqaure(1))\r\nprint(is_perfect_sqaure(5))\r\nprint(is_perfect_sqaure(88))\r\nprint(is_perfect_sqaure(121))"}
{"nl": "Exercise working with string manipulation and basic calculations: given a string of digits, calculate the largest product for a contiguous substring of digits of length n.", "code": "from functools import reduce\r\ndef largest_product(series: str, size: int) -> int:\r\n    if len(series) < size:\r\n        raise ValueError(\"span must be smaller than string length\")\r\n    if size < 0:\r\n        raise ValueError(\"span must not be negative\")\r\n    if len(series) > 0 and not series.isnumeric():\r\n        raise ValueError(\"digits input must only contain digits\")\r\n    series_list = [float(digit) for digit in series]\r\n    return int(max([reduce((lambda x, y: x * y), series_list[start_index:start_index + size])\r\n                    for start_index in range(0, (len(series) + 1) - size)])) if size > 0 else 1\r\n"}
{"nl": "Faker Module", "code": "# Import faker from Faker module using the import keyword.\r\nfrom faker import Faker\r\n# Create an object for the Faker library and store it in a variable.\r\nfaker_obj = Faker()\r\n# Generate a random name using faker_obj.name() function and print it\r\nprint(faker_obj.name())"}
{"nl": "Python Program to Check Pronic Number or Not", "code": "# Give the number as static input and store it in a variable.\n numb = 156\n # Take a variable say 'count' and initialize its value with '0'.\n count = 0\n # Loop from 0 to above-given number using for loop. \n for itr in range(numb):\n  # Inside the loop, check if the product of the iterator value and iterator+1 value\n  # (consecutive integers) is equal to the given number using the if conditional statement.\n  if itr * (itr + 1) == numb:\n  # If the statement is true, then increment the value of count (i.e. 1),\n  # give the break condition and come out of the loop.\n  count = 1\n  break\n # Check if the value of count is equal to '1' using the if conditional statement.\n if count == 1:\n  # If the statement is true, then print \"The given number is a pronic number\".\n  print(\"The given number{\",numb,\"} is a pronic number\")\n # Else print \"The given number is Not a pronic number\".\n else:\n  print(\"The given number{\",numb,\"} is Not a pronic number\")"}
{"nl": "Swapping nodes in a linked list", "code": "class Solution:\n  def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n  # Find kth node from left\n  l = r = head\n  for _ in range(k-1):\n  l = l.next\n  # Find kth node from right\n  # by finding tail node\n  tail = l\n  while tail.next:\n  r, tail = r.next, tail.next\n  # Swap values and return\n  l.val, r.val = r.val, l.val\n  return head"}
{"nl": "Find if there is a path of more than k length from a source", "code": "# Program to find if there is a simple path with\n# weight more than k\n\u00a0\u00a0\u00a0\n# This class represents a dipathted graph using\n# adjacency list representation\nclass Graph:\n\u00a0\u00a0\u00a0\u00a0# Allocates memory for adjacency list\n\u00a0\u00a0\u00a0\u00a0def __init__(self, V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.V = V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj = [[] for i in range(V)]\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Returns true if graph has path more than k length\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanK(self,src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a path array with nothing included\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path = [False]*self.V\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Add source vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[src] = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.pathMoreThanKUtil(src, k, path)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Prints shortest paths from src to all other vertices\n\u00a0\u00a0\u00a0\u00a0def pathMoreThanKUtil(self,src, k, path):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If k is 0 or negative, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (k <= 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get all adjacent vertices of source vertex src and\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# recursively explore all paths from src.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while i != len(self.adj[src]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get adjacent vertex and weight of edge\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = self.adj[src][i][0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w = self.adj[src][i][1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If vertex v is already there in path, then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# there is a cycle (we ignore this edge)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (path[v] == True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If weight of is more than k, return true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (w >= k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Else add this vertex to path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If this adjacent can provide a path longer\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# than k, return true.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (self.pathMoreThanKUtil(v, k-w, path)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Backtrack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path[v] = False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If no adjacent could produce longer path, return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Utility function to an edge (u, v) of weight w\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u, v, w):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[u].append([v, w])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.adj[v].append([u, w])\n\u00a0\u00a0\u00a0\n# Driver program to test methods of graph class\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# create the graph given in above figure\n\u00a0\u00a0\u00a0\u00a0V = 9\n\u00a0\u00a0\u00a0\u00a0g = Graph(V)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0#\u00a0 making above shown graph\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 1, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(0, 7, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 2, 8)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(1, 7, 11)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 3, 7)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 8, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(2, 5, 4)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 4, 9)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(3, 5, 14)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(4, 5, 10)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(5, 6, 2)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 7, 1)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(6, 8, 6)\n\u00a0\u00a0\u00a0\u00a0g.addEdge(7, 8, 7)\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0src = 0\n\u00a0\u00a0\u00a0\u00a0k = 62\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0k = 60\n\u00a0\u00a0\u00a0\u00a0if g.pathMoreThanK(src, k):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Yes\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"No\")\n"}
{"nl": "Print Powerful Numbers In An Interval", "code": "# Function definition to get all prime factors\r\ndef get_prime_factors(n):\r\n    i = 2\r\n    prime_factors = []\r\n    while i*i <= n:\r\n        if n%i == 0:\r\n            prime_factors.append(i)\r\n            n //= i\r\n        else:\r\n            i += 1\r\n    \r\n    if n>1:\r\n        prime_factors.append(n)\r\n    \r\n    return prime_factors\r\n\r\n# Function definition to check powerful number\r\ndef is_powerful(n):\r\n    # get prime factors\r\n    prime_factors = get_prime_factors(n)\r\n    \r\n    # filter to get unique prime factors\r\n    unique_prime_factors = tuple(dict.fromkeys(prime_factors))\r\n    for p in unique_prime_factors:\r\n        if n % p != 0 or n % (p*p) != 0:\r\n            return False\r\n    return True\r\n\r\n# Reading minimum and maximum number\r\nmin_num = int(input('Enter lower range: '))\r\nmax_num = int(input('Enter upper range: '))\r\n\r\nprint('All powerful numbers from %d to %d are:' %(min_num, max_num))\r\nfor i in range(min_num, max_num+1):\r\n    if is_powerful(i):\r\n        print(i, end=' ')"}
{"nl": "Tallest Skyscraper", "code": "def tallest_skyscraper(lst):\n  return sum(1 for i in lst if sum(i)>0)"}
{"nl": "Program for Page Replacement Algorithms (FIFO)", "code": "# Python3 implementation of FIFO page\n# replacement in Operating Systems.\nfrom queue import Queue\u00a0\n\u00a0\u00a0\n# Function to find page faults using FIFO\u00a0\ndef pageFaults(pages, n, capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# To represent set of current pages.\u00a0\n\u00a0\u00a0\u00a0\u00a0# We use an unordered_set so that we\n\u00a0\u00a0\u00a0\u00a0# quickly check if a page is present\n\u00a0\u00a0\u00a0\u00a0# in set or not\u00a0\n\u00a0\u00a0\u00a0\u00a0s = set()\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# To store the pages in FIFO manner\u00a0\n\u00a0\u00a0\u00a0\u00a0indexes = Queue()\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Start from initial page\u00a0\n\u00a0\u00a0\u00a0\u00a0page_faults = 0\n\u00a0\u00a0\u00a0\u00a0for i in range(n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if the set can hold\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# more pages\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (len(s) < capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Insert it into set if not present\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# already which represents page fault\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (pages[i] not in s):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.add(pages[i])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# increment page fault\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0page_faults += 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Push the current page into\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the queue\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0indexes.put(pages[i])\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the set is full then need to perform FIFO\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# i.e. remove the first page of the queue from\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# set and queue both and insert the current page\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Check if current page is not\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# already present in the set\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (pages[i] not in s):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Pop the first page from the queue\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val = indexes.queue[0]\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0indexes.get()\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Remove the indexes page\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.remove(val)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# insert the current page\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.add(pages[i])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push the current page into\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the queue\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0indexes.put(pages[i])\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Increment page faults\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0page_faults += 1\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return page_faults\n\u00a0\u00a0\n# Driver code\u00a0\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0pages = [7, 0, 1, 2, 0, 3, 0,\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04, 2, 3, 0, 3, 2]\u00a0\n\u00a0\u00a0\u00a0\u00a0n = len(pages)\u00a0\n\u00a0\u00a0\u00a0\u00a0capacity = 4\n\u00a0\u00a0\u00a0\u00a0print(pageFaults(pages, n, capacity))\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "sum up the least element of all the subarrays", "code": "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        A = [0]+A\n        result = [0]*len(A)\n        stack = [0]\n        for i in range(len(A)):\n            while A[stack[-1]] > A[i]:\n                stack.pop() \n            j = stack[-1]\n            result[i] = result[j] + (i-j)*A[i]\n            stack.append(i)\n        return sum(result) % (10**9+7)"}
{"nl": "First element occurring k times in an array", "code": "# Python3 implementation to\n# find first element\n# occurring k times\n\n# function to find the\n# first element occurring\n# k number of times\ndef firstElement(arr, n, k):\n\n\t# dictionary to count\n\t# occurrences of\n\t# each element\n\tcount_map = {};\n\tfor i in range(0, n):\n\t\tif(arr[i] in count_map.keys()):\n\t\t\tcount_map[arr[i]] += 1\n\t\telse:\n\t\t\tcount_map[arr[i]] = 1\n\t\ti += 1\n\t\n\tfor i in range(0, n):\n\t\t\n\t\t# if count of element == k ,\n\t\t# then it is the required\n\t\t# first element\n\t\tif (count_map[arr[i]] == k):\n\t\t\treturn arr[i]\n\t\ti += 1\n\t\t\t\n\t# no element occurs k times\n\treturn -1\n\n# Driver Code\nif __name__==\"__main__\":\n\n\tarr = [1, 7, 4, 3, 4, 8, 7];\n\tn = len(arr)\n\tk = 2\n\tprint(firstElement(arr, n, k))\n\n# This code is contributed\n# by Abhishek Sharma"}
{"nl": "print the series (0, 6, 10, 17, 22, 30, 36\u2026N) till the given number N in Python.", "code": "# Give the number N(limit) as static input and store it in a variable.\r\ngvn_numb = 16\r\n# Take a variable to say itr and initialize its value to 1.\r\nitr = 1\r\n# Take another variable say m and initialize its value to 0.\r\nm = 0\r\n# Take another variable say n and initialize its value to 6.\r\nn = 6\r\n# Take another variable say x and initialize its value to 10.\r\nx = 10\r\n# Take another variable say y and initialize its value to 11.\r\ny = 11\r\nprint(\"The above series till the given number{\", gvn_numb, \"} is :\")\r\n# Loop until the above-declared variable itr value is less than or equal to the\r\n# given number using the while loop.\r\nwhile(itr <= gvn_numb):\r\n        # Inside the loop, check if the above variable itr value is even or not using the\r\n    # if conditional statement.\r\n    if (itr % 2 == 0):\r\n        # If it is true, then print the value of n separated by spaces.\r\n        print(n, end=\" \")\r\n        # Add the above y value to n and store it in the same variable n.\r\n        n += y\r\n        # Increment the above y value by 2.\r\n        y += 2\r\n    else:\r\n        # Else, print the value of m separated by spaces.\r\n        print(m, end=\" \")\r\n        # Add the above x value to m and store it in the same variable m.\r\n        m += x\r\n        # Increment the above x value by 2.\r\n        x += 2\r\n   # Increment the above itr value by 1.\r\n    itr += 1"}
{"nl": "Length and Element of Range", "code": "def length_element(r,i):\n    return [len(r), r[i]]"}
{"nl": "Python statistics.stdev() Method\r\n\r\n", "code": "# Import statistics Library\r\nimport statistics\r\n\r\n# Calculate the standard deviation from a sample of data\r\nprint(statistics.stdev([1, 3, 5, 7, 9, 11]))\r\nprint(statistics.stdev([2, 2.5, 1.25, 3.1, 1.75, 2.8]))\r\nprint(statistics.stdev([-11, 5.5, -3.4, 7.1]))\r\nprint(statistics.stdev([1, 30, 50, 100]))"}
{"nl": "Is the Die Loaded", "code": "def fair_die(lst):\n  avg = sum(lst) / len(lst)\n  return sum((x - avg) ** 2 / avg for x in lst) < 11.0705"}
{"nl": "Python Program to Find Even Digits Sum and Odd Digits Sum Divisible by 4 and 3 Respectively", "code": "# Give the number as static input and store it in a variable.\nnumb = 123452\n# Convert the given number to string using the str() function.\nstringnum = str(numb)\n# Create a list of digits say \"digtslst\" using map(),list(),int functions.\ndigtslst = list(map(int, stringnum))\n# Take a variable say \"evn_sum\" and initialize it with 0.\nevn_sum = 0\n# Take another variable say \"od_sum\" and initialize it with 0.\nod_sum = 0\n# Loop in the above list of digits until the length of the \"digtslst\" using the for loop.\nfor itr in range(len(digtslst)):\n    # Check if the element of the \"digtslst\" is even or not using the if conditional statement.\n    if(digtslst[itr] % 2 == 0):\n     # If the statement is true, then add the element of the \"digtslst\" to the \"evn_sum\"\n        # and store it in the same variable evn_sum.\n        evn_sum += digtslst[itr]\n    else:\n        # If the statement is false, then add the element of the \"digtslst\" to the \"od_sum\"\n        # and store it in the same variable od_sum.\n        od_sum += digtslst[itr]\n# Check if the evn_sum modulus 4 is equal to 0 and od_sum modulus 3 is equal to 0\n# using the if conditional statement.\nif(evn_sum % 4 == 0 and od_sum % 3 == 0):\n  # If the statement is true, print \"yes, the even digits sum and odd digits sum of a\n    # given number are divisible by 4 and 3 respectively.\n    print(\n        \"yes, the even digits sum and odd digits sum of a given number{\", numb, \"} is divisible by 4 and 3 respectively.\")\nelse:\n # If the statement is false, print \"No, the even digits sum and odd digits sum\n    # of a given number are not divisible by 4 and 3 respectively.\n    print(\n        \"No, the even digits sum and odd digits sum of a given number{\", numb, \"} is not divisible by 4 and 3 respectively.\")"}
{"nl": "number of ways to select buildings where two consecutive buidings are different", "code": "class Solution:\n    def numberOfWays(self, s: str) -> int:\n        ans=0\n        n=len(s)\n        left=[0]*n\n        right=[0]*n\n        zeros,ones=0,0\n        for i in range(n):\n            if s[i]==\"0\": \n                zeros+=1\n                left[i]=ones\n            else: \n                ones+=1\n                left[i]=zeros\n        zeros,ones=0,0\n        for i in range(n-1,-1,-1):\n            if s[i]==\"0\": \n                zeros+=1\n                right[i]=ones\n            else: \n                ones+=1\n                right[i]=zeros\n            ans+=left[i]*right[i]\n        return ans\n            "}
{"nl": "The minimum time to make the rope colorful", "code": "def minCost(self, s, cost):\n  res = max_cost = 0\n  for i in xrange(len(s)):\n  if i > 0 and s[i] != s[i - 1]:\n  max_cost = 0\n  res += min(max_cost, cost[i])\n  max_cost = max(max_cost, cost[i])\n  return res"}
{"nl": "Area and perimeter of pentagon", "code": "# Import the math module using the import keyword.\n import math\n # Give the Pentagon's side length as static input and store it in a variable.\n side_len = 10\n # Calculate the area of the given pentagon using the above given mathematical formula and\n # math.sqrt() function.\n # Store it in another variable.\n pentgn_area = (math.sqrt(5*(5+2*math.sqrt(5)))*pow(side_len, 2))/4.0\n # Calculate the perimeter of the given pentagon using the above given mathematical formula.\n # Store it in another variable.\n pentgn_perimtr = (5*side_len)\n # Print the Pentagon's area with the given side length.\n print(\"The Pentagon's area with given side length {\", side_len, \"} =\", pentgn_area)\n # Print the Pentagon's perimeter with the given side length.\n print(\"The Pentagon's Perimeter with given side length {\", side_len, \"} =\", pentgn_perimtr)"}
{"nl": "Generate a List of 15 Palindrome Numbers", "code": "def generate_palindromes(limit):\n  is_pal = lambda n: str(n) == str(n)[::-1]\n  ans = []\n  while len(ans)<15:\n    if is_pal(limit): ans = [limit] + ans\n    limit-=1\n  return ans"}
{"nl": "0-1 BFS (Shortest Path in a Binary Weight Graph)", "code": "# Python3 program to implement single source\n# shortest path for a Binary Graph\nfrom sys import maxsize as INT_MAX\nfrom collections import deque\n\u00a0\n# no.of vertices\nV = 9\n\u00a0\n# a structure to represent edges\nclass node:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, to, weight):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# two variable one denote the node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# and other the weight\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.to = to\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.weight = weight\n\u00a0\n# vector to store edges\nedges = [0] * V\nfor i in range(V):\n\u00a0\u00a0\u00a0\u00a0edges[i] = []\n\u00a0\n# Prints shortest distance from\n# given source to every other vertex\ndef zeroOneBFS(src: int):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Initialize distances from given source\n\u00a0\u00a0\u00a0\u00a0dist = [0] * V\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[i] = INT_MAX\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# double ende queue to do BFS.\n\u00a0\u00a0\u00a0\u00a0Q = deque()\n\u00a0\u00a0\u00a0\u00a0dist[src] = 0\n\u00a0\u00a0\u00a0\u00a0Q.append(src)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while Q:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = Q[0]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.popleft()\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in range(len(edges[v])):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# checking for the optimal distance\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dist[edges[v][i].to] >\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[v] + edges[v][i].weight):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dist[edges[v][i].to] = dist[v] + edges[v][i].weight\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Put 0 weight edges to front and 1 weight\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# edges to back so that vertices are processed\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in increasing order of weights.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if edges[v][i].weight == 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.appendleft(edges[v][i].to)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q.append(edges[v][i].to)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# printing the shortest distances\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(dist[i], end = \" \")\n\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\ndef addEdge(u: int, v: int, wt: int):\n\u00a0\u00a0\u00a0\u00a0edges[u].append(node(v, wt))\n\u00a0\u00a0\u00a0\u00a0edges[u].append(node(v, wt))\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(0, 1, 0)\n\u00a0\u00a0\u00a0\u00a0addEdge(0, 7, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(1, 7, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(1, 2, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(2, 3, 0)\n\u00a0\u00a0\u00a0\u00a0addEdge(2, 5, 0)\n\u00a0\u00a0\u00a0\u00a0addEdge(2, 8, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(3, 4, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(3, 5, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(4, 5, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(5, 6, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(6, 7, 1)\n\u00a0\u00a0\u00a0\u00a0addEdge(7, 8, 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# source node\n\u00a0\u00a0\u00a0\u00a0src = 0\n\u00a0\u00a0\u00a0\u00a0zeroOneBFS(src)\n\u00a0\n# This code is contributed by\n# sanjeev2552\n"}
{"nl": "Python Program for Frequencies of Even and Odd Numbers in a Matrix", "code": "# Give the matrix as static input and store it in a variable.\n mtrx = [[9, 0, 2],\n  [7, 5, 6],\n  [7, 1, 9]]\n # Calculate the number of rows of the given matrix by\n # calculating the length of the nested list using the len() function\n # and store it in a variable mtrxrows.\n mtrxrows = len(mtrx)\n # Calculate the number of columns of the given matrix by\n # calculating the length of the first list in the nested list\n # using the len() function and store it in a variable mtrxcols.\n mtrxcols = len(mtrx[0])\n # Take a variable to say evnnum_freqcy and initialize its value to 0.\n evnnum_freqcy = 0\n # Take another variable to say oddnum_freqcy and initialize its value to 0.\n oddnum_freqcy = 0\n # Loop till the given number of rows using the For loop.\n for n in range(mtrxrows):\n  # Inside the For loop, Iterate till the given number of columns using another Nested\n  # For loop(Inner For loop).\n  for m in range(mtrxcols):\n  # Check if the mtrx[n][m] is even using the if conditional statement (where n is the\n  # iterator value of the parent For loop and m is the iterator value of the\n  # inner For loop.).\n  if ((mtrx[n][m] % 2) == 0):\n  # If it is true, then increment the value of above evnnum_freqcy by 1.\n  evnnum_freqcy += 1\n  else:\n  # Else increment the value of above oddnum_freqcy by 1.\n  oddnum_freqcy += 1\n # Print the frequency of even numbers and odd numbers of a given matrix.\n print(\" The odd number frequency of the given matrix =\", oddnum_freqcy)\n print(\" The even number frequency of the given matrix \", evnnum_freqcy)"}
{"nl": "Find the Index", "code": "def find_index(lst, str):\n  return lst.index(str)"}
{"nl": "Exercise working with queues with priority queues", "code": "\"\"\"Chaitanas Colossal Coaster\"\"\"\r\ndef add_me_to_the_queue(express_queue: list, normal_queue: list, ticket_type: int, person_name: str) -> None:\r\n    \"\"\"\r\n \r\n    :param express_queue: list - names in the Fast-track queue.\r\n    :param normal_queue:  list - names in the normal queue.\r\n    :param ticket_type:  int - type of ticket. 1 = express, 0 = normal.\r\n    :param person_name: str - name of person to add to a queue.\r\n    :return: list - the (updated) queue the name was added to.\r\n    \"\"\"\r\n    if ticket_type == 0:\r\n        normal_queue.append(person_name)\r\n        return normal_queue\r\n    if ticket_type == 1:\r\n        express_queue.append(person_name)\r\n        return express_queue\r\n    raise ValueError(\"Invalid Ticket Type\")\r\ndef find_my_friend(queue: list, friend_name: str) -> int:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param friend_name: str - name of friend to find.\r\n    :return: int - index at which the friends name was found.\r\n    \"\"\"\r\n    if friend_name in queue:\r\n        return queue.index(friend_name)\r\n    return -1\r\ndef add_me_with_my_friends(queue: list, index: int, person_name: str) -> list:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param index: int - the index at which to add the new name.\r\n    :param person_name: str - the name to add.\r\n    :return: list - queue updated with new name.\r\n    \"\"\"\r\n    queue.insert(index, person_name)\r\n    return queue\r\ndef remove_the_mean_person(queue: list, person_name: str) -> list:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name of mean person.\r\n    :return:  list - queue update with the mean persons name removed.\r\n    \"\"\"\r\n    queue.remove(person_name)\r\n    return queue\r\ndef how_many_namefellows(queue: list, person_name: str) -> int:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name you wish to count or track.\r\n    :return:  int - the number of times the name appears in the queue.\r\n    \"\"\"\r\n    count = 0\r\n    for name in queue:\r\n        if name == person_name:\r\n            count += 1\r\n    return count\r\ndef remove_the_last_person(queue: list) -> str:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :return: str - name that has been removed from the end of the queue.\r\n    \"\"\"\r\n    return queue.pop()\r\ndef sorted_names(queue: list) -> list:\r\n    \"\"\"\r\n \r\n    :param queue: list - names in the queue.\r\n    :return: list - copy of the queue in alphabetical order.\r\n    \"\"\"\r\n    queue.sort()\r\n    return queue\r"}
{"nl": "Print nth Fibonacci Number using Dynamic Programming with Memoization", "code": "def fibonacci(n):\n    \"\"\"Return the nth Fibonacci number.\"\"\"\n    # r[i] will contain the ith Fibonacci number\n    r = [-1]*(n + 1)\n    return fibonacci_helper(n, r)\n\u00a0\n\u00a0\ndef fibonacci_helper(n, r):\n    \"\"\"Return the nth Fibonacci number and store the ith Fibonacci number in\n    r[i] for 0 <= i <= n.\"\"\"\n    if r[n] >= 0:\n        return r[n]\n\u00a0\n    if (n == 0 or n == 1):\n        q = n\n    else:\n        q = fibonacci_helper(n - 1, r) + fibonacci_helper(n - 2, r)\n    r[n] = q\n\u00a0\n    return q\n\u00a0\n\u00a0\nn = int(input('Enter n: '))\n\u00a0\nans = fibonacci(n)\nprint('The nth Fibonacci number:', ans)"}
{"nl": "Sum of Digits of a Number in Python", "code": "# Python program to compute sum of digits in number def ComputeSum(num): #user-defined function sum = 0 while (num != 0): sum += (num % 10) num //= 10 return sum # take input num = int(input('Enter a number: ')) # calling function & display result print('Sum of digits in number =', ComputeSum(num))"}
{"nl": "Minimize (max(A[i], B[j], C[k]) \u2013 min(A[i], B[j], C[k])) of three different sorted arrays", "code": "# python code for above approach.\r\n\r\ndef solve(A, B, C):\r\n\r\n\t\t# assigning the length -1 value\r\n\t\t# to each of three variables\r\n\t\ti = len(A) - 1\r\n\t\tj = len(B) - 1\r\n\t\tk = len(C) - 1\r\n\r\n\t\t# calculating min difference\r\n\t\t# from last index of lists\r\n\t\tmin_diff = abs(max(A[i], B[j], C[k]) -\r\n\t\tmin(A[i], B[j], C[k]))\r\n\r\n\t\twhile i != -1 and j != -1 and k != -1:\r\n\t\t\tcurrent_diff = abs(max(A[i], B[j],\r\n\t\t\tC[k]) - min(A[i], B[j], C[k]))\r\n\r\n\t\t\t# checking condition\r\n\t\t\tif current_diff < min_diff:\r\n\t\t\t\tmin_diff = current_diff\r\n\r\n\t\t\t# calculating max term from list\r\n\t\t\tmax_term = max(A[i], B[j], C[k])\r\n\r\n\t\t\t# Moving to smaller value in the\r\n\t\t\t# array with maximum out of three.\r\n\t\t\tif A[i] == max_term:\r\n\t\t\t\ti -= 1\r\n\t\t\telif B[j] == max_term:\r\n\t\t\t\tj -= 1\r\n\t\t\telse:\r\n\t\t\t\tk -= 1\r\n\t\treturn min_diff\r\n\r\n# driver code\r\n\r\nA = [ 5, 8, 10, 15 ]\r\nB = [ 6, 9, 15, 78, 89 ]\r\nC = [ 2, 3, 6, 6, 8, 8, 10 ]\r\nprint(solve(A, B, C))\r\n"}
{"nl": "Inorder predecessor and successor for a given key in BST", "code": "# Python program to find the inorder successor in a BST\n\n# A binary tree node\nclass Node:\n\n        # Constructor to create a new node\n        def __init__(self, key):\n                self.data = key\n                self.left = None\n                self.right = None\n\ndef inOrderSuccessor(n):\n        \n        # Step 1 of the above algorithm\n        if n.right is not None:\n                return minValue(n.right)\n\n        # Step 2 of the above algorithm\n        p = n.parent\n        while( p is not None):\n                if n != p.right :\n                        break\n                n = p\n                p = p.parent\n        return p\n\n# Given a non-empty binary search tree, return the\n# minimum data value found in that tree. Note that the\n# entire tree doesn't need to be searched\ndef minValue(node):\n        current = node\n\n        # loop down to find the leftmost leaf\n        while(current is not None):\n                if current.left is None:\n                        break\n                current = current.left\n\n        return current\n\n\n# Given a binary search tree and a number, inserts a\n# new node with the given number in the correct place\n# in the tree. Returns the new root pointer which the\n# caller should then use( the standard trick to avoid\n# using reference parameters)\ndef insert( node, data):\n\n        # 1) If tree is empty then return a new singly node\n        if node is None:\n                return Node(data)\n        else:\n                \n                # 2) Otherwise, recur down the tree\n                if data <= node.data:\n                        temp = insert(node.left, data)\n                        node.left = temp\n                        temp.parent = node\n                else:\n                        temp = insert(node.right, data)\n                        node.right = temp\n                        temp.parent = node\n                \n                # return the unchanged node pointer\n                return node\n\n\n# Driver program to test above function\n\nroot = None\n\n# Creating the tree given in the above diagram\nroot = insert(root, 20)\nroot = insert(root, 8);\nroot = insert(root, 22);\nroot = insert(root, 4);\nroot = insert(root, 12);\nroot = insert(root, 10);\nroot = insert(root, 14);\ntemp = root.left.right.right\n\nsucc = inOrderSuccessor(temp)\nif succ is not None:\n        print (\"\\nInorder Successor of % d is % d \"%(temp.data, succ.data))\nelse:\n        print (\"\\nInorder Successor doesn't exist\")\n\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Leap Year Function \u231a", "code": "from calendar import isleap as leapYear"}
{"nl": "Compute the integer absolute value (abs) without branching", "code": "# Python3 implementation of above approach\nCHARBIT = 8;\nSIZE_INT = 8;\n\n# This function will return\n# absolute value of n\ndef getAbs(n):\n\tmask = n >> (SIZE_INT * CHARBIT - 1);\n\treturn ((n + mask) ^ mask);\n\n# Driver Code\nn = -6;\nprint(\"Absolute value of\",n,\"is\",getAbs(n));\n\n# This code is contributed by mits\n"}
{"nl": "Python Program to Remove Adjacent Duplicate Characters from a String", "code": "# Function to remove adjacent duplicates characters from a string\ndef remAdj(givenstrng):\n    # convert the given string to list using list() function\n    charslist = list(givenstrng)\n    prevele = None\n    p = 0\n    # Traverse the given string\n    for chars in givenstrng:\n        if prevele != chars:\n            charslist[p] = chars\n            prevele = chars\n            p = p + 1\n    # join the list which contains characters to string using join function and return it\n    return ''.join(charslist[:p])\n\n\n# Driver code\n# Give the string as user input using the input() function.\n# Store it in a variable.\ngivenstrng = input('Enter some random string = ')\n# printing the given string before removing adjacent duplicate characters\nprint('given string before removing adjacent duplicate characters = ', givenstrng)\n# Pass the given string to the remAdj function which accepts\n# the given string as the argument\n# and returns the modified string with no adjacent duplicates.\nmodistring = remAdj(givenstrng)\n# printing the given string after removing adjacent duplicate characters\nprint('given string without after adjacent duplicate characters = ', modistring)"}
{"nl": "Print next greater number of Q queries", "code": "# Python3 program to print\n# next greater number\n# of Q queries\n\u00a0\n# array to store the next\n# greater element index\ndef next_greatest(next, a, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# use of stl\n\u00a0\u00a0\u00a0\u00a0# stack in c++\n\u00a0\u00a0\u00a0\u00a0s = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# push the 0th\n\u00a0\u00a0\u00a0\u00a0# index to the stack\n\u00a0\u00a0\u00a0\u00a0s.append(0);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# traverse in the\n\u00a0\u00a0\u00a0\u00a0# loop from 1-nth index\n\u00a0\u00a0\u00a0\u00a0for\u00a0 i in range(1, n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# iterate till loop is empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (len(s) != 0):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# get the topmost\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# index in the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = s[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if the current element is\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# greater then the top indexth\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element, then this will be\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# the next greatest index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# of the top indexth element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (a[cur] < a[i]):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# initialise the cur\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# index position's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next greatest as index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next[cur] = i;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop the cur index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# as its greater\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element has been found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop();\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# if not greater\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then break\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# push the i index so that its\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next greatest can be found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.append(i);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# iterate for all other\n\u00a0\u00a0\u00a0\u00a0# index left inside stack\n\u00a0\u00a0\u00a0\u00a0while(len(s) != 0):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cur = s[-1]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mark it as -1 as no\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# element in greater\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# then it in right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next[cur] = -1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\n# answers all\n# queries in O(1)\ndef answer_query(a, next, n, index):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# stores the next greater\n\u00a0\u00a0\u00a0\u00a0# element positions\n\u00a0\u00a0\u00a0\u00a0position = next[index];\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if position is -1 then no\n\u00a0\u00a0\u00a0\u00a0# greater element is at right.\n\u00a0\u00a0\u00a0\u00a0if(position == -1):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# if there is a index that\n\u00a0\u00a0\u00a0\u00a0# has greater element\n\u00a0\u00a0\u00a0\u00a0# at right then return its\n\u00a0\u00a0\u00a0\u00a0# value as a[position]\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return a[position];\n\u00a0\n# Driver Code\nif __name__=='__main__':\n\u00a0\n\u00a0\u00a0\u00a0\u00a0a = [3, 4, 2, 7, 5, 8, 10, 6 ]\n\u00a0\u00a0\u00a0\u00a0n = len(a)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# initializes the\n\u00a0\u00a0\u00a0\u00a0# next array as 0\n\u00a0\u00a0\u00a0\u00a0next=[0 for i in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# calls the function\n\u00a0\u00a0\u00a0\u00a0# to pre-calculate\n\u00a0\u00a0\u00a0\u00a0# the next greatest\n\u00a0\u00a0\u00a0\u00a0# element indexes\n\u00a0\u00a0\u00a0\u00a0next_greatest(next, a, n);\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# query 1 answered\n\u00a0\u00a0\u00a0\u00a0print(answer_query(a, next, n, 3), end = ' ')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# query 2 answered\n\u00a0\u00a0\u00a0\u00a0print(answer_query(a, next, n, 6), end = ' ')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# query 3 answered\n\u00a0\u00a0\u00a0\u00a0print(answer_query(a, next, n, 1), end = ' ')\n\u00a0\n# This code is contributed by rutvik_56.\n"}
{"nl": "Find Itinerary from a given list of tickets", "code": "class Solution():\n        #Solution class carries method for printing itinerary\n        def __init__(self):\n                pass\n        #method for printing itinerary\n        def printitinerary(self,d):\n                # First step : create a reversed mapping. Here also for storing key value pairs dictionary is used.\n                reverse_d = dict()\n                for i in d:\n                        reverse_d[d[i]] = i\n                # Second step : find the starting point. Starting point will be that value which is not present in 'd' as key.\n                for i in reverse_d:\n                        if reverse_d[i] not in reverse_d:\n                                starting_pt = reverse_d[i]\n                                break;\n                #Third step : simply proceed one by one to print whole route. Assuming that there exist Starting point.\n                while(starting_pt in d):\n                        print(starting_pt,\"->\",d[starting_pt],end=\", \")\n                        starting_pt = d[starting_pt]\n                #method prints here only. Does not return anything.\n\n\nif __name__==\"__main__\":\n        # Mapping using inbuilt data structure 'dictionary'\n        d = dict()\n        d[\"Chennai\"] = \"Banglore\"\n        d[\"Bombay\"] = \"Delhi\"\n        d[\"Goa\"] = \"Chennai\"\n        d[\"Delhi\"] = \"Goa\"\n\n        # call for method that would print itinerary.\n        obj = Solution()\n        obj.printIterary(d)\n"}
{"nl": "Deep List Count", "code": "def deep_count(lst):\n    if not isinstance(lst, list):\n        return 0\n    return len(lst) + sum(map(deep_count, lst))"}
{"nl": "Check for Palindrome Number in Python", "code": "# Python program to check if number is Palindrome # take inputs num = int(input('Enter the number : ')) # calculate reverse of number reverse = 0 number = num while(num != 0): remainder = num % 10 reverse = reverse * 10 + remainder num = int(num / 10) # compare reverse to original number if(number == reverse): print(number,'is a Palindrome') else: print(number,'is not a Palindrome')"}
{"nl": "Python Program to Find Volume and Surface Area of Sphere", "code": "# Give the radius of a sphere as user input using the float(input()) function\n# and store it in a variable\ngvn_radis = float(input(\"Enter some random variable = \"))\n# Take a variable and initialize it with the \"pi\" value i.e. 3.14 and\n# store it in another variable.\nstandard_pi_val = 3.14\n# Calculate the surface area of the given sphere using the above mathematical formula\n# and store it in another variable.\nsurf_area = 4 * standard_pi_val * gvn_radis * gvn_radis\n# Calculate the volume of the given sphere using the above mathematical formula and\n# store it in another variable.\nsphre_volm = (4 / 3) * standard_pi_val * gvn_radis * gvn_radis * gvn_radis\n# Print the surface area of the given sphere.\nprint(\n    \"The Surface area of the given Sphere with the radius [\", gvn_radis, \"]= %.3f\" % surf_area)\n# Print the volume of the given sphere.\nprint(\n    \"The volume of the given Sphere with the radius [\", gvn_radis, \"]= %.3f\" % sphre_volm)"}
{"nl": "Anna Likes Daniel", "code": "import re\ndef anna_likes(boy):\n    return len(re.findall(r\"[aeiou]\", boy, re.I))==len(boy)/2"}
{"nl": "delete all nodes that have duplicate numbers and sort the list", "code": "class Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        # sentinel\n        sentinel = ListNode(0, head)\n\n        # predecessor = the last node \n        # before the sublist of duplicates\n        pred = sentinel\n        \n        while head:\n            # if it's a beginning of duplicates sublist \n            # skip all duplicates\n            if head.next and head.val == head.next.val:\n                # move till the end of duplicates sublist\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                # skip all duplicates\n                pred.next = head.next \n            # otherwise, move predecessor\n            else:\n                pred = pred.next \n                \n            # move forward\n            head = head.next\n            \n        return sentinel.next"}
{"nl": "the minimal length of a contiguous subarray", "code": "class Solution:\n\ndef minSubArrayLen(self, s, nums):\n    total = left = 0\n    result = len(nums) + 1\n    for right, n in enumerate(nums):\n        total += n\n        while total >= s:\n            result = min(result, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return result if result <= len(nums) else 0"}
{"nl": "Breadth First Search or BFS for a Graph", "code": "# Python3 Program to print BFS traversal\n# from a given source vertex. BFS(int s)\n# traverses vertices reachable from s.\nfrom collections import defaultdict\n\u00a0\n# This class represents a directed graph\n# using adjacency list representation\nclass Graph:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor\n\u00a0\u00a0\u00a0\u00a0def __init__(self):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# default dictionary to store graph\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph = defaultdict(list)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# function to add an edge to graph\n\u00a0\u00a0\u00a0\u00a0def addEdge(self,u,v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.graph[u].append(v)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function to print a BFS of graph\n\u00a0\u00a0\u00a0\u00a0def BFS(self, s):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark all the vertices as not visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited = [False] * (max(self.graph) + 1)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Create a queue for BFS\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue = []\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Mark the source node as\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited and enqueue it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(s)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[s] = True\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while queue:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Dequeue a vertex from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# queue and print it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s = queue.pop(0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (s, end = \" \")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get all adjacent vertices of the\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# dequeued vertex s. If a adjacent\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# has not been visited, then mark it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# visited and enqueue it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in self.graph[s]:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if visited[i] == False:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.append(i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[i] = True\n\u00a0\n# Driver code\n\u00a0\n# Create a graph given in\n# the above diagram\ng = Graph()\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n\u00a0\nprint (\"Following is Breadth First Traversal\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\" (starting from vertex 2)\")\ng.BFS(2)\n\u00a0\n# This code is contributed by Neelam Yadav\n"}
{"nl": "get the IP Address of your Computer", "code": "# To utilize the method gethostbyname() in the socket library,\r\n# first import the socket module using the import statement.\r\nimport socket\r\n# To obtain the IP address of the host,\r\n# we must give hostname as an argument to gethostbyname ().\r\n# So, let's acquire our computer's hostname using the gethostname() method\r\n# and send it as an argument to gethostbyname() to get the IP address.\r\n# Also, assign the variable the value provided by the gethostbyname() method.\r\n\r\ncompIpAdress = socket.gethostbyname(socket.gethostname())\r\n# Print the IP address of the computer.\r\nprint(\"The IP Address of this computer is [\", compIpAdress, ']')"}
{"nl": "Python none Keyword", "code": "x = None\r\n\r\nprint(x)"}
{"nl": "generate matrix in spiral order", "code": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        res = [[0] * n for _ in range(n)]\n        \n        def fill_circle(el, start, n):\n            i, j = start, start            \n            for k in range(j, j + n): \n                res[i][k], el = el, el + 1\n            for k in range(i + 1, i + n): \n                res[k][j + n - 1], el = el, el + 1\n            for k in reversed(range(j, j + n - 1)): \n                res[i + n - 1][k], el = el, el + 1\n            for k in reversed(range(i + 1, i + n - 1)): \n                res[k][j], el = el, el + 1\n        \n        el, start = 1, 0\n        while n > 0:\n            fill_circle(el, start, n)\n            el = el + 4*(n - 1)\n            n, start = n - 2, start + 1\n            \n        return res"}
{"nl": "Find another graph which is the transpose of the given graph", "code": "# Python3 program to find transpose of a graph.\u00a0\n\u00a0\u00a0\n# function to add an edge from vertex\u00a0\n# source to vertex dest\u00a0\ndef addEdge(adj, src, dest):\n\u00a0\u00a0\u00a0\u00a0adj[src].append(dest)\n\u00a0\u00a0\n# function to pradjacency list\u00a0\n# of a graph\u00a0\ndef displayGraph(adj, v):\n\u00a0\u00a0\u00a0\u00a0for i in range(v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(i, \"--> \", end = \"\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(adj[i])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(adj[i][j], end = \" \")\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\u00a0\n# function to get Transpose of a graph\u00a0\n# taking adjacency list of given graph\n# and that of Transpose graph\u00a0\ndef transposeGraph(adj, transpose, v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# traverse the adjacency list of given\u00a0\n\u00a0\u00a0\u00a0\u00a0# graph and for each edge (u, v) add\u00a0\n\u00a0\u00a0\u00a0\u00a0# an edge (v, u) in the transpose graph's\n\u00a0\u00a0\u00a0\u00a0# adjacency list\n\u00a0\u00a0\u00a0\u00a0for i in range(v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(len(adj[i])):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addEdge(transpose, adj[i][j], i)\n\u00a0\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0v = 5\n\u00a0\u00a0\u00a0\u00a0adj = [[] for i in range(v)]\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 1)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 4)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 0, 3)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 2, 0)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 3, 2)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 4, 1)\u00a0\n\u00a0\u00a0\u00a0\u00a0addEdge(adj, 4, 3)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Finding transpose of graph represented\u00a0\n\u00a0\u00a0\u00a0\u00a0# by adjacency list adj[]\u00a0\n\u00a0\u00a0\u00a0\u00a0transpose = [[]for i in range(v)]\n\u00a0\u00a0\u00a0\u00a0transposeGraph(adj, transpose, v)\u00a0\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# displaying adjacency list of\u00a0\n\u00a0\u00a0\u00a0\u00a0# transpose graph i.e. b\u00a0\n\u00a0\u00a0\u00a0\u00a0displayGraph(transpose, v)\n\u00a0\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "Implement Stack using One Queue", "code": "class Stack:\n    def __init__(self):\n        self.q = Queue()\n\u00a0\n    def is_empty(self):\n        return self.q.is_empty()\n\u00a0\n    def push(self, data):\n        self.q.enqueue(data)\n\u00a0\n    def pop(self):\n        for _ in range(self.q.get_size() - 1):\n            dequeued = self.q.dequeue()\n            self.q.enqueue(dequeued)\n        return self.q.dequeue()\n\u00a0\n\u00a0\nclass Queue:\n    def __init__(self):\n        self.items = []\n        self.size = 0\n\u00a0\n    def is_empty(self):\n        return self.items == []\n\u00a0\n    def enqueue(self, data):\n        self.size += 1\n        self.items.append(data)\n\u00a0\n    def dequeue(self):\n        self.size -= 1\n        return self.items.pop(0)\n\u00a0\n    def get_size(self):\n        return self.size\n\u00a0\n\u00a0\ns = Stack()\n\u00a0\nprint('Menu')\nprint('push <value>')\nprint('pop')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'push':\n        s.push(int(do[1]))\n    elif operation == 'pop':\n        if s.is_empty():\n            print('Stack is empty.')\n        else:\n            print('Popped value: ', s.pop())\n    elif operation == 'quit':\n        break"}
{"nl": "The minimum operations to make the sums equal", "code": "def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n  if len(nums1) * 6 < len(nums2) or len(nums1) > len(nums2) * 6:\n  return -1\n  sm1, sm2 = map(sum, (nums1, nums2))\n  if sm1 > sm2:\n  return self.minOperations(nums2, nums1)\n  cnt = Counter([6 - n for n in nums1] + [n - 1 for n in nums2])\n  i, operations = 5, 0\n  while sm2 > sm1:\n  while cnt[i] == 0:\n  i -= 1\n  sm1 += i\n  cnt[i] -= 1\n  operations += 1\n  return operations"}
{"nl": "Read last n lines of a file", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Give the n value static input and store it in a variable.\ngvn_n_val = 2\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent: \n  # Get the lines of the file using the readlines() function\n  lines_lst= givenfilecontent.readlines()\n  print(\"The last\",gvn_n_val,\"lines of a given file are:\")\n  # Iterate in the above lines list using the for loop to get the last\n  # n lines of a file using the negative indexing.\n  for fline in (lines_lst[-gvn_n_val:]):\n  # Print the last n lines of a given file.\n  print(fline, end ='')"}
{"nl": "Count the number of occurrence of key-value pair in a text file", "code": "# import the Counter from collections module using the import keyword\nfrom collections import Counter\n# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Take a empty list to store all the words\nl = []\nprint('The Count of frequency of each key-value pair is :')\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\nwith open(givenFilename, 'r') as givenfilecontent:\n  # Iterate through the lines of the file using the For loop.\n  for gvnfileline in givenfilecontent:\n  # Remove the newline character (\\n) using strip() function and store it in a variable.\n  keyval = gvnfileline.strip('\\n')\n  # Inside the For loop append each key-value pair to list using the append() function.\n  l.append(keyval)\n# Get frequency of all the words using the Counter() function and store it in a variable(of type dictionary)\nfreqword = Counter(l)\n# Traverse in the frequency dictionary using the For loop\nfor key in freqword:\n  # print its corresponding key(frequency)\n  print(key, '->', freqword[key])"}
{"nl": "return the kth permutation sequence", "code": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        factorials, nums = [1], ['1']\n        for i in range(1, n):\n            # generate factorial system bases 0!, 1!, ..., (n - 1)!\n            factorials.append(factorials[i - 1] * i)\n            # generate nums 1, 2, ..., n\n            nums.append(str(i + 1))\n        \n        # fit k in the interval 0 ... (n! - 1)\n        k -= 1\n        \n        # compute factorial representation of k\n        output = []\n        for i in range(n - 1, -1, -1):\n            idx = k // factorials[i]\n            k -= idx * factorials[i]\n            \n            output.append(nums[idx])\n            del nums[idx]\n        \n        return ''.join(output)"}
{"nl": "Reverse all Words in Input Sentence", "code": "# Give the string as User input using input() function and store it in a variable.\r\nstrng = input(\" Enter some random String = \")\r\n# Split the words of the given string to a list of words using the built-in split() function and store it in another variable.\r\nsplt_wrds = strng.split()\r\n# Traverse in the above Given List of words using For Loop.\r\n# Inside the Loop, Reverse each word of the list Using Slicing method and\r\n# store it in a variable.\r\nrversd_wrds = [wrd[::-1] for wrd in splt_wrds]\r\n# Join all the reversed words of a given sentence using the built-in join( ) function\r\n# and store it in another variable.\r\nfinl_sentnce = \" \".join(rversd_wrds)\r\n# Print the reversed Sentence of each word of a given String.\r\nprint(\"The Reverse of each word of the above given sentence = \", finl_sentnce)"}
{"nl": "Missing Third Angle", "code": "def missing_angle(angle1, angle2):\n  if (angle1+angle2) < 90: return \"obtuse\"\n  if (angle1+angle2) == 90: return \"right\"\n  if (angle1+angle2) > 90: return \"acute\""}
{"nl": "Time when cars collide", "code": "def getCollisionTimes(self, A):\n  stack = []\n  n = len(A)\n  res = [-1] * n\n  for i in range(n-1, -1, -1):\n  p, s = A[i]\n  while stack and (s <= A[stack[-1]][1] or (A[stack[-1]][0] - p) / (s - A[stack[-1]][1]) >= res[stack[-1]] > 0):\n  stack.pop()\n  if stack:\n  res[i] = (A[stack[-1]][0] - p) / (s - A[stack[-1]][1])\n  stack.append(i)\n  return res"}
{"nl": "Python Program to Print Square Number Pattern", "code": "# Python Program to Print Square Number Pattern\n \nside = int(input(\"Please Enter any Side of a Square  : \"))\n\nprint(\"Square Number Pattern\") \n\nfor i in range(side):\n    for i in range(side):\n        print('1', end = '  ')\n    print()"}
{"nl": "How to efficiently implement k Queues in a single array?", "code": "# A Python program to demonstrate implementation of k queues in a single\n# array in time and space efficient way\n\u00a0\nclass KQueues:\n\u00a0\u00a0\u00a0\u00a0def __init__(self, number_of_queues, array_length):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.number_of_queues = number_of_queues\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array_length = array_length\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array = [-1] * array_length\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front = [-1] * number_of_queues\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear = [-1] * number_of_queues\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array = list(range(1, array_length))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array.append(-1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.free = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To check whether the current queue_number is empty or not\n\u00a0\u00a0\u00a0\u00a0def is_empty(self, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.front[queue_number] == -1 else False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To check whether the current queue_number is full or not\n\u00a0\u00a0\u00a0\u00a0def is_full(self, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.free == -1 else False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To enqueue the given item in the given queue_number where\n\u00a0\u00a0\u00a0\u00a0# queue_number is from 0 to number_of_queues-1\n\u00a0\u00a0\u00a0\u00a0def enqueue(self, item, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.is_full(queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue FULL\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next_free = self.next_array[self.free]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.is_empty(queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front[queue_number] = self.rear[queue_number] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array[self.rear[queue_number]] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.rear[queue_number] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array[self.free] = -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array[self.free] = item\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.free = next_free\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# To dequeue an item from the given queue_number where\n\u00a0\u00a0\u00a0\u00a0# queue_number is from 0 to number_of_queues-1\n\u00a0\u00a0\u00a0\u00a0def dequeue(self, queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if self.is_empty(queue_number):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Queue EMPTY\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0front_index = self.front[queue_number]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.front[queue_number] = self.next_array[front_index]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.next_array[front_index] = self.free\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.free = front_index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.array[front_index]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0# Let us create 3 queue in an array of size 10\u00a0\n\u00a0\u00a0\u00a0\u00a0ks =\u00a0 KQueues(3, 10)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us put some items in queue number 2\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(15, 2)\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(45, 2)\n\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us put some items in queue number 1\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(17, 1);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(49, 1);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(39, 1);\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us put some items in queue number 0\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(11, 0);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(9, 0);\u00a0\n\u00a0\u00a0\u00a0\u00a0ks.enqueue(7, 0);\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"Dequeued element from queue 2 is {}\".format(ks.dequeue(2)))\n\u00a0\u00a0\u00a0\u00a0print(\"Dequeued element from queue 1 is {}\".format(ks.dequeue(1)))\n\u00a0\u00a0\u00a0\u00a0print(\"Dequeued element from queue 0 is {}\".format(ks.dequeue(0)))\n"}
{"nl": "The count of all possible routes", "code": "def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n  @lru_cache(None)\n  def dfs(i: int, f: int) -> int:\n  return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n  return dfs(start, fuel) % 1000000007"}
{"nl": "Loves Me, Loves Me Not...", "code": "def loves_me(n):\n    arr = (['Loves me', 'Loves me not']*n)[:n]\n    arr[-1] = arr[-1].upper()\n    return ', '.join(arr)"}
{"nl": "Python Access Arrays\r\n", "code": "cars = [\"Ford\", \"Volvo\", \"BMW\"]"}
{"nl": "Find if given matrix is Toeplitz or not", "code": "# Python3 program to check whether given\n# matrix is a Toeplitz matrix or not\nN = 5\nM = 4\n\u00a0\n# Function to check if all elements present in\n# descending diagonal starting from position\n# (i, j) in the matrix are all same or not\n\u00a0\n\u00a0\ndef checkDiagonal(mat, i, j):\n\u00a0\u00a0\u00a0\u00a0res = mat[i][j]\n\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while (i < N and j < M):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# mismatch found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mat[i][j] != res):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# we only reach here when all elements\n\u00a0\u00a0\u00a0\u00a0# in given diagonal are same\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n# Function to check whether given\n# matrix is a Toeplitz matrix or not\n\u00a0\n\u00a0\ndef isToeplitz(mat):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# do for each element in first row\n\u00a0\u00a0\u00a0\u00a0for j in range(M):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check descending diagonal starting from\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# position (0, j) in the matrix\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not(checkDiagonal(mat, 0, j)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# do for each element in first column\n\u00a0\u00a0\u00a0\u00a0for i in range(1, N):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# check descending diagonal starting\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# from position (i, 0) in the matrix\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not(checkDiagonal(mat, i, 0)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\n\u00a0\n# Driver Code\nif __name__ == \"__main__\":\n\u00a0\n\u00a0\u00a0\u00a0\u00a0mat = [[6, 7, 8, 9],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[4, 6, 7, 8],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1, 4, 6, 7],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[0, 1, 4, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[2, 0, 1, 4]]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Function call\n\u00a0\u00a0\u00a0\u00a0if(isToeplitz(mat)):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Matrix is a Toeplitz\")\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(\"Matrix is not a Toeplitz\")\n\u00a0\n# This code is contributed by Jasmine K Grewal\n"}
{"nl": "Exercise working with string manipulation and conditional code: given a number from 0 to 999,999,999,999, spell out that number in English.", "code": "_say = lambda x: say(x)\r\nones = lambda x: 'zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen nineteen'.split()[x]\r\ntens = lambda x: 'zero ten twenty thirty forty fifty sixty seventy eighty ninety'.split()[x]\r\ndone = lambda f, q, r, t, h: f(q) + t\r\nnope = lambda f, q, r, t, h: f(q) + t + h + say(r)\r\ndef say(n):\r\n    if not (0 <= n < 1e12): \r\n        raise ValueError(\"input out of range\")    \r\n    condition, d, func, txt, hyphen = list(filter(lambda x: x[0],\r\n        [( n <  20,           1, ones, '',           ''),\r\n         ( n < 1e2,          10, tens, '',          '-'),\r\n         ( n < 1e3,         100, ones, ' hundred',  ' '),\r\n         ( n < 1e6,        1000, _say, ' thousand', ' '),\r\n         ( n < 1e9,     1000000, _say, ' million',  ' '),\r\n         ( n < 1e12, 1000000000, _say, ' billion',  ' ')]))[0]\r\n    q, r = divmod(n, d)                                     \r\n    return {0: done}.get(r, nope)(func, q, r, txt, hyphen)"}
{"nl": "Magic Square | ODD Order", "code": "# Python program to generate\n# odd sized magic squares\n# A function to generate odd\n# sized magic squares\n\u00a0\n\u00a0\ndef generateSquare(n):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# 2-D array with all\n\u00a0\u00a0\u00a0\u00a0# slots set to 0\n\u00a0\u00a0\u00a0\u00a0magicSquare = [[0 for x in range(n)]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for y in range(n)]\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# initialize position of 1\n\u00a0\u00a0\u00a0\u00a0i = n // 2\n\u00a0\u00a0\u00a0\u00a0j = n - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Fill the magic square\n\u00a0\u00a0\u00a0\u00a0# by placing values\n\u00a0\u00a0\u00a0\u00a0num = 1\n\u00a0\u00a0\u00a0\u00a0while num <= (n * n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i == -1 and j == n:\u00a0 # 3rd condition\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = n - 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next number goes out of\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# right side of square\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == n:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = 0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# next number goes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# out of upper side\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i < 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = n - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if magicSquare[int(i)][int(j)]:\u00a0 # 2nd condition\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = j - 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0magicSquare[int(i)][int(j)] = num\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0num = num + 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j = j + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = i - 1\u00a0 # 1st condition\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Printing magic square\n\u00a0\u00a0\u00a0\u00a0print(\"Magic Square for n =\", n)\n\u00a0\u00a0\u00a0\u00a0print(\"Sum of each row or column\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n * (n * n + 1) // 2, \"\\n\")\n\u00a0\n\u00a0\u00a0\u00a0\u00a0for i in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for j in range(0, n):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print('%2d ' % (magicSquare[i][j]),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end='')\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# To display output\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# in matrix form\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if j == n - 1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print()\n\u00a0\n# Driver Code\n\u00a0\n\u00a0\n# Works only when n is odd\nn = 7\ngenerateSquare(n)\n\u00a0\n# This code is contributed\n# by Harshit Agrawal\n"}
{"nl": "Reverse the tuple", "code": "tuple1 = (10, 20, 30, 40, 50)\r\ntuple1 = tuple1[::-1]\r\nprint(tuple1)\r"}
{"nl": "RegEx XI-C: Whitespace Character Class", "code": "import re\npattern = '\\S\\?$'"}
{"nl": "File mode property", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in write mode. In this case, we're writing the contents into the file.\nsamplefile_1 = open(\"givenFilename\", \"w\")\n# Open the file in read mode. In this case, we're simply reading the contents of the file.\nsamplefile_2 = open(\"givenFilename\", \"r\")\n# Open the file in write-binary mode. In this case, we're simply writing the contents in binary mode into the file.\nsamplefile_3 = open(\"givenFilename\", \"wb\")\n# Print the mode of above file samplefile_1 using the mode property\nprint(\"The mode of samplefile_1:\", samplefile_1.mode)\n# Print the mode of above file samplefile_2 using the mode property\nprint(\"The mode of samplefile_2:\", samplefile_2.mode)\n# Print the mode of above file samplefile_3 using the mode property\nprint(\"The mode of samplefile_3:\", samplefile_3.mode)\n# Close the above file samplefile_1 using the close() function\nsamplefile_1.close()\n# Close the above file samplefile_2 using the close() function\nsamplefile_2.close()\n# Close the above file samplefile_3 using the close() function\nsamplefile_3.close()"}
{"nl": "Implement the Authentication Manager", "code": "def __init__(self, timeToLive: int):\n  self.expiry = OrderedDict()\n  self.life = timeToLive\n\n  def generate(self, tokenId: str, currentTime: int) -> None:\n self.evict_expired(currentTime)\n  self.expiry[tokenId] = self.life + currentTime\n\n  def renew(self, tokenId: str, currentTime: int) -> None:\n self.evict_expired(currentTime)\n  if tokenId in self.expiry:\n self.expiry.move_to_end(tokenId) # necessary to move to the end to keep expiry time in ascending order.\n  self.expiry[tokenId] = self.life + currentTime\n\n  def countUnexpiredTokens(self, currentTime: int) -> int:\n self.evict_expired(currentTime)\n  return len(self.expiry)  \n  \n  def evict_expired(self, currentTime: int) -> None:\n  while self.expiry and next(iter(self.expiry.values())) <= currentTime:\n self.expiry.popitem(last=False)"}
{"nl": "Print unique rows in a given Binary matrix", "code": "# Python3 code to print unique row in a\n# given binary matrix\n \ndef printArray(matrix):\n \n    rowCount = len(matrix)\n    if rowCount == 0:\n        return\n \n    columnCount = len(matrix[0])\n    if columnCount == 0:\n        return\n \n    row_output_format = \" \".join([\"%s\"] * columnCount)\n \n    printed = {}\n \n    for row in matrix:\n        routput = row_output_format % tuple(row)\n        if routput not in printed:\n            printed[routput] = True\n            print(routput)\n \n# Driver Code\nmat = [[0, 1, 0, 0, 1],\n       [1, 0, 1, 1, 0],\n       [0, 1, 0, 0, 1],\n       [1, 1, 1, 0, 0]]\n \nprintArray(mat)\n \n# This code is contributed by myronwalker"}
{"nl": "Maximum sum of nodes in Binary tree such that no two are adjacent", "code": "# Python3 program to find\n# maximum sum from a subset\n# of nodes of binary tree\n\n# A binary tree node structure\nclass Node:\n\t\n\tdef __init__(self, data):\n\t\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Utility function to create\n# a new Binary Tree node\ndef newNode(data):\n\n\ttemp = Node(data)\n\treturn temp;\n\n# method returns maximum sum\n# possible from subtrees rooted\n# at grandChildrens of node 'node'\ndef sumOfGrandChildren(node, mp):\n\n\tsum = 0;\n\n\t# call for children of left\n\t# child only if it is not NULL\n\tif (node.left):\n\t\tsum += (getMaxSumUtil(node.left.left, mp) +\n\t\t\t\tgetMaxSumUtil(node.left.right, mp));\n\n\t# call for children of right\n\t# child only if it is not NULL\n\tif (node.right):\n\t\tsum += (getMaxSumUtil(node.right.left, mp) +\n\t\t\t\tgetMaxSumUtil(node.right.right, mp));\n\n\treturn sum;\n\n# Utility method to return\n# maximum sum rooted at node\n# 'node'\ndef getMaxSumUtil(node, mp):\n\n\tif (node == None):\n\t\treturn 0;\n\n\t# If node is already processed\n\t# then return calculated\n\t# value from map\n\tif node in mp:\n\t\treturn mp[node];\n\n\t# take current node value\n\t# and call for all grand children\n\tincl = (node.data +\n\t\t\tsumOfGrandChildren(node, mp));\n\n\t# don't take current node\n\t# value and call for all children\n\texcl = (getMaxSumUtil(node.left, mp) +\n\t\t\tgetMaxSumUtil(node.right, mp));\n\n\t# choose maximum from both\n\t# above calls and store that\n\t# in map\n\tmp[node] = max(incl, excl);\n\n\treturn mp[node];\n\n# Returns maximum sum from\n# subset of nodes of binary\n# tree under given constraints\ndef getMaxSum(node):\n\n\tif (node == None):\n\t\treturn 0;\n\t\n\tmp = dict()\n\treturn getMaxSumUtil(node, mp);\n\n# Driver code\nif __name__==\"__main__\":\n\t\n\troot = newNode(1);\n\troot.left = newNode(2);\n\troot.right = newNode(3);\n\troot.right.left = newNode(4);\n\troot.right.right = newNode(5);\n\troot.left.left = newNode(1);\n\t\n\tprint(getMaxSum(root))\n\t\n# This code is contributed by Rutvik_56\n"}
{"nl": "Hours Passed", "code": "from datetime import datetime as dt\ndef hours_passed(time1, time2):\n    delta = (dt.strptime(time2, \"%I:%M %p\") -\n             dt.strptime(time1, \"%I:%M %p\")).seconds // 3600\n    return '{} hours'.format(delta) if delta else 'no time passed'"}
{"nl": "Python not Keyword", "code": "x = False\r\n\r\nprint(not x)"}
{"nl": "Python Module Variables\n", "code": "#Save this code in the file mymodule.py\r\n\r\nperson1 = {\r\n  \"name\": \"John\",\r\n  \"age\": 36,\r\n  \"country\": \"Norway\"\r\n}\r\n#Example\r\n#Import the module named mymodule, and access the person1 dictionary:\r\n\r\nimport mymodule\r\n\r\na = mymodule.person1[\"age\"]\r\nprint(a)"}
{"nl": "Boolean Values\r\n", "code": "print(10 > 9)\r\nprint(10 == 9)\r\nprint(10 < 9)"}
{"nl": "Implement fibonacci search algorithm", "code": "# function which implements the fibonacci search\r\ndef fib_search(givenlist, givenelement):\r\n    # ffinding the length of given list\r\n    length = len(givenlist)\r\n\r\n    first = -1\r\n\r\n    x0 = 0\r\n    x1 = 1\r\n    x2 = 1\r\n    while(x2 < length):\r\n        x0 = x1\r\n        x1 = x2\r\n        x2 = x1 + x0\r\n\r\n    while(x2 > 1):\r\n        eleIndex = min(first + x0, length - 1)\r\n        if givenlist[eleIndex] < givenelement:\r\n            x2, x1 = x1, x0\r\n            x0 = x2 - x1\r\n            start = eleIndex\r\n        elif givenlist[eleIndex] > givenelement:\r\n            x2 = x0\r\n            x1 = x1 - x0\r\n            x0 = x2 - x1\r\n        else:\r\n            return eleIndex\r\n    if (x1) and (givenlist[length - 1] == givenelement):\r\n        return length - 1\r\n    return None\r\n\r\n\r\n# given list\r\ngiven_list = [1, 9, 4, 7, 2, 8, 6]\r\n# sorting the given list\r\ngiven_list.sort()\r\n# given element to search\r\ngiven_element = 4\r\n# passing given list and given element to fibonacci search function to check whether\r\n# the given element is present in list or not\r\nprint(fib_search(given_list, given_element))"}
{"nl": "How Close to the Speed of Light?", "code": "import math\ndef how_close_to_c(rap):\n  return '{:.2e}'.format(1/math.cosh(2*rap)).replace('-0','-')"}
{"nl": "Python Program to Check Whether a String is Palindrome or Not", "code": "# Program to check if a string is palindrome or not\n\nmy_str = 'aIbohPhoBiA'\n\n# make it suitable for caseless comparison\nmy_str = my_str.casefold()\n\n# reverse the string\nrev_str = reversed(my_str)\n\n# check if the string is equal to its reverse\nif list(my_str) == list(rev_str):\n   print(\"The string is a palindrome.\")\nelse:\n   print(\"The string is not a palindrome.\")"}
{"nl": "Find the Sum of all Nodes in a Tree", "code": "class Tree:\n    def __init__(self, data=None):\n        self.key = data\n        self.children = []\n\u00a0\n    def set_root(self, data):\n        self.key = data\n\u00a0\n    def add(self, node):\n        self.children.append(node)\n\u00a0\n    def search(self, key):\n        if self.key == key:\n            return self\n        for child in self.children:\n            temp = child.search(key)\n            if temp is not None:\n                return temp\n        return None\n\u00a0\n    def sum_nodes(self):\n        summation = self.key\n        for child in self.children:\n            summation = summation + child.sum_nodes()\n        return summation\n\u00a0\n\u00a0\ntree = None\n\u00a0\nprint('Menu (this assumes no duplicate keys)')\nprint('add <data> at root')\nprint('add <data> below <data>')\nprint('sum')\nprint('quit')\n\u00a0\nwhile True:\n    do = input('What would you like to do? ').split()\n\u00a0\n    operation = do[0].strip().lower()\n    if operation == 'add':\n        data = int(do[1])\n        new_node = Tree(data)\n        suboperation = do[2].strip().lower() \n        if suboperation == 'at':\n            tree = new_node\n        elif suboperation == 'below':\n            position = do[3].strip().lower()\n            key = int(position)\n            ref_node = None\n            if tree is not None:\n                ref_node = tree.search(key)\n            if ref_node is None:\n                print('No such key.')\n                continue\n            ref_node.add(new_node)\n\u00a0\n    elif operation == 'sum':\n        if tree is None:\n            print('Tree is empty.')\n        else:\n            summation = tree.sum_nodes()\n            print('Sum of all nodes: {}'.format(summation))\n\u00a0\n    elif operation == 'quit':\n        break"}
{"nl": "Convert min Heap to max Heap", "code": "# A Python3 program to convert min Heap\n# to max Heap\n\n# to heapify a subtree with root\n# at given index\ndef MaxHeapify(arr, i, n):\n\tl = 2 * i + 1\n\tr = 2 * i + 2\n\tlargest = i\n\tif l < n and arr[l] > arr[i]:\n\t\tlargest = l\n\tif r < n and arr[r] > arr[largest]:\n\t\tlargest = r\n\tif largest != i:\n\t\tarr[i], arr[largest] = arr[largest], arr[i]\n\t\tMaxHeapify(arr, largest, n)\n\n# This function basically builds max heap\ndef convertMaxHeap(arr, n):\n\t\n\t# Start from bottommost and rightmost\n\t# internal mode and heapify all\n\t# internal modes in bottom up way\n\tfor i in range(int((n - 2) / 2), -1, -1):\n\t\tMaxHeapify(arr, i, n)\n\n# A utility function to print a\n# given array of given size\ndef printArray(arr, size):\n\tfor i in range(size):\n\t\tprint(arr[i], end = \" \")\n\tprint()\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# array representing Min Heap\n\tarr = [3, 5, 9, 6, 8, 20, 10, 12, 18, 9]\n\tn = len(arr)\n\n\tprint(\"Min Heap array : \")\n\tprintArray(arr, n)\n\n\tconvertMaxHeap(arr, n)\n\n\tprint(\"Max Heap array : \")\n\tprintArray(arr, n)\n\n# This code is contributed by PranchalK"}
{"nl": "Synonyms and antonnyms from nltk wordnet", "code": "\r\n# First, you're going to need to import wordnet:\r\nfrom nltk.corpus import wordnet\r\n  \r\n# Then, we're going to use the term \"program\" to find synsets like so:\r\nsyns = wordnet.synsets(\"program\")\r\n  \r\n# An example of a synset:\r\nprint(syns[0].name())\r\n  \r\n# Just the word:\r\nprint(syns[0].lemmas()[0].name())\r\n  \r\n# Definition of that first synset:\r\nprint(syns[0].definition())\r\n  \r\n# Examples of the word in use in sentences:\r\nprint(syns[0].examples())"}
{"nl": "Get the Last Character of String in Python", "code": "# Python Program get last character of string # take input string = input('Enter any string: ') # get last character last_char = string[-1] # printing last character of string print('Last character:', last_char)"}
{"nl": "Create a List in Python", "code": "list = [1, 2, 3, 4, 5] print(list)"}
{"nl": "Python Program to Check Whether the given Two Numbers are Amicable Numbers or Not", "code": "# python program to cheeck whether the given number is Amicable numbers or not\n # function which returns true if the given number is\n # Amicable numbers else it will return False\n def checkAmicableNumb(given_numb1, given_numb2):\n  # Taking a variable totalSum1 and initializing it with 1\n  totalSum1 = 1\n  # Iterating from 2 to n-1\n  for i in range(2, given_numb1):\n  # if the iterator value is divides the number then add the given\n  # number to totalSum1\n  if given_numb1 % i == 0:\n  totalSum1 += i\n  # repeating the same step for number 2\n  # Taking a variable totalSum2 and initializing it with 1\n  totalSum2 = 1\n  # Iterating from 2 to n-1\n  for i in range(2, given_numb2):\n  # if the iterator value is divides the number then add the given\n  # number to totalSum2\n  if given_numb2 % i == 0:\n  totalSum2 += i\n  # if the totalSum1 is equal to the given number2 and\n  # totalSum2 is equal to the given number1 then both the numbers are amicable numbers\n  # else they are not amicable numbers\n  if(totalSum1 == given_numb2 and totalSum2 == given_numb1):\n  # if it is true then they are amicable numbers so return true\n  return True\n  # if nothing is returned then they are not a amicable numbers so return False\n  return False\n # Given two numbers\n # given number1(numb1)\n given_numb1 = 220\n # given number2(numb2)\n given_numb2 = 284\n # passing the given two numbers to checkAmicableNumb to check whether it is\n # Amicable numbers or not\n if(checkAmicableNumb(given_numb1, given_numb2)):\n  print(\"The given numbers\", given_numb1, \"and\",\n  given_numb2, \"are amicable numbers\")\n else:\n  print(\"The given numbers\", given_numb1, \"and\",\n  given_numb2, \"are not amicable numbers\")"}
{"nl": "Meme Sum :)", "code": "def meme_sum(a, b):\n  a, b = sorted([str(a), str(b)], key=len)\n    res = ''\n  for i, j in zip(a.zfill(len(b)), b):\n    res += str(int(i) + int(j))\n  return int(res)"}
{"nl": "Implement Bubble Sort", "code": "def bubble_sort(alist):\n    for i in range(len(alist) - 1, 0, -1):\n        no_swap = True\n        for j in range(0, i):\n            if alist[j + 1] < alist[j]:\n                alist[j], alist[j + 1] = alist[j + 1], alist[j]\n                no_swap = False\n        if no_swap:\n            return\n\u00a0\n\u00a0\nalist = input('Enter the list of numbers: ').split()\nalist = [int(x) for x in alist]\nbubble_sort(alist)\nprint('Sorted list: ', end='')\nprint(alist)"}
{"nl": "Find the Fulcrum", "code": "def find_fulcrum(lst):\n  for idx, i in enumerate(lst):\n    if sum(lst[:idx]) == sum(lst[idx+1:]):\n      return i\n  return -1"}
{"nl": "Python Program to Convert Binary to Decimal using Recursion", "code": "# Create a recursive function to say binaryToDeci()\n \n # which accepts the binary number as an argument\n \n # and returns the decimal equivalent of the given binary string.\n \n \n \n \n \n def binaryToDeci(binanumb):\n \n  # Inside the binaryToDeci() function,\n \n  # Check if the binary number is equal to 0 using the if conditional statement.\n \n  if(binanumb == 0):\n \n  # If it is true then return 0.\n \n  return 0\n \n  # Else return (n% 10 + 2* binaryToDeci(n // 10))\n \n  # {Recursive logic where n%10 gives rightmostbit and n//10 divides the number by 10}.\n \n  return (binanumb % 10 + 2 * binaryToDeci(binanumb // 10))\n \n \n \n \n \n # Give the binary number as static input and store it in a variable.\n \n gvnbinarynumb = 1011\n \n # Inside the main function pass the given binary number as an argument\n \n # to binaryToDeci() which returns the decimal equivalent of the given binary number.\n \n resdecimalnumbr = binaryToDeci(gvnbinarynumb)\n \n # Print the decimal equivalent of the given binary number.\n \n print(\n \n  'The decimal Equivalent of the given binary number {', gvnbinarynumb, '} is :', resdecimalnumbr)"}
{"nl": "Convert a given Binary Tree to Doubly Linked List", "code": "# A simple inorder traversal based program to convert a\n# Binary Tree to DLL\n\n# A Binary Tree node\nclass Node:\n\t\n\t# Constructor to create a new tree node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# Standard Inorder traversal of tree\ndef inorder(root):\n\t\n\tif root is not None:\n\t\tinorder(root.left)\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\tinorder(root.right)\n\n# Changes left pointers to work as previous pointers\n# in converted DLL\n# The function simply does inorder traversal of\n# Binary Tree and updates\n# left pointer using previously visited node\ndef fixPrevPtr(root):\n\tif root is not None:\n\t\tfixPrevPtr(root.left)\n\t\troot.left = fixPrevPtr.pre\n\t\tfixPrevPtr.pre = root\n\t\tfixPrevPtr(root.right)\n\n# Changes right pointers to work as next pointers in\n# converted DLL\ndef fixNextPtr(root):\n\n\tprev = None\n\t# Find the right most node in BT or last node in DLL\n\twhile(root and root.right != None):\n\t\troot = root.right\n\n\t# Start from the rightmost node, traverse back using\n\t# left pointers\n\t# While traversing, change right pointer of nodes\n\twhile(root and root.left != None):\n\t\tprev = root\n\t\troot = root.left\n\t\troot.right = prev\n\n\t# The leftmost node is head of linked list, return it\n\treturn root\n\n# The main function that converts BST to DLL and returns\n# head of DLL\ndef BTToDLL(root):\n\t\n\t# Set the previous pointer\n\tfixPrevPtr(root)\n\n\t# Set the next pointer and return head of DLL\n\treturn fixNextPtr(root)\n\n# Traversses the DLL from left to right\ndef printList(root):\n\twhile(root != None):\n\t\tprint (\"\\t%d\" %(root.data),end=\" \")\n\t\troot = root.right\n\n# Driver program to test above function\nroot = Node(10)\nroot.left = Node(12)\nroot.right = Node(15)\nroot.left.left = Node(25)\nroot.left.right = Node(30)\nroot.right.left = Node(36)\n\nprint (\"Inorder Tree Traversal\")\ninorder(root)\n\n# Static variable pre for function fixPrevPtr\nfixPrevPtr.pre = None\nhead = BTToDLL(root)\n\nprint (\"\\nDLL Traversal\")\nprintList(head)\n\t\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Python Program to Iterate Over Dictionaries Using for Loop", "code": "dt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key, value in dt.items():\n    print(key, value)\ndt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key in dt:\n    print(key, dt[key])\ndt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key, value in dt.iteritems():\n    print(key, value)\ndt = {'a': 'juice', 'b': 'grill', 'c': 'corn'}\n\nfor key in dt.keys():\n    print(key)\n\nfor value in dt.values():\n    print(value)"}
{"nl": "Alternative Sorting", "code": "# Give the list as static input and store it in a variable.\r\ngvn_lst = [2, 3, 7, 8, 1, 3, 6]\r\n# Calculate the length of the given list using the len() function and\r\n# store it in another variable.\r\nlen_lst = len(gvn_lst)\r\n# Sort the given list using the sort() method and store it in another variable.\r\ngvn_lst.sort()\r\n# Take a variable say 'p' and initialize its value with zero.\r\np = 0\r\n# Take another variable say 'q' and initialize its value with the length of the\r\n# given list -1.\r\nq = len_lst-1\r\nprint(\"The Alternative sorting of the above given list is :\")\r\n# Check if the value of p is less than q using the while loop.\r\nwhile (p < q):\r\n    # If the statement is true, then print the value of the given list of q.\r\n    print(gvn_lst[q], end=\" \")\r\n    # Subtract 1 from q (q-1)and store it in the same variable 'q'.\r\n    q -= 1\r\n    # Print the value of the given list of p.\r\n    print(gvn_lst[p], end=\" \")\r\n    # Increment the value of p by 1 and store it in the same variable 'p'.\r\n    p += 1\r\n   # Check if the length of the given list is odd(len_lst % 2 != 0) by using the\r\n   # if conditional statement.\r\nif (len_lst % 2 != 0):\r\n    # If the statement is true, print the value of the given list of p.\r\n    print(gvn_lst[p])"}
{"nl": "Topological Sorting for a Directed Acyclic Graph", "code": "# Python program to print topological sorting of a DAG\r\nfrom collections import defaultdict\r\n \r\n# Class to represent a graph\r\n \r\n \r\nclass Graph:\r\n    def __init__(self, vertices):\r\n        self.graph = defaultdict(list)  # dictionary containing adjacency List\r\n        self.V = vertices  # No. of vertices\r\n \r\n    # function to add an edge to graph\r\n    def addEdge(self, u, v):\r\n        self.graph[u].append(v)\r\n \r\n    # A recursive function used by topologicalSort\r\n    def topologicalSortUtil(self, v, visited, stack):\r\n \r\n        # Mark the current node as visited.\r\n        visited[v] = True\r\n \r\n        # Recur for all the vertices adjacent to this vertex\r\n        for i in self.graph[v]:\r\n            if visited[i] == False:\r\n                self.topologicalSortUtil(i, visited, stack)\r\n \r\n        # Push current vertex to stack which stores result\r\n        stack.append(v)\r\n \r\n    # The function to do Topological Sort. It uses recursive\r\n    # topologicalSortUtil()\r\n    def topologicalSort(self):\r\n        # Mark all the vertices as not visited\r\n        visited = [False]*self.V\r\n        stack = []\r\n \r\n        # Call the recursive helper function to store Topological\r\n        # Sort starting from all vertices one by one\r\n        for i in range(self.V):\r\n            if visited[i] == False:\r\n                self.topologicalSortUtil(i, visited, stack)\r\n \r\n        # Print contents of the stack\r\n        print(stack[::-1])  # return list in reverse order\r\n \r\n \r\n# Driver Code\r\ng = Graph(6)\r\ng.addEdge(5, 2)\r\ng.addEdge(5, 0)\r\ng.addEdge(4, 0)\r\ng.addEdge(4, 1)\r\ng.addEdge(2, 3)\r\ng.addEdge(3, 1)\r\n \r\nprint (\"Following is a Topological Sort of the given graph\")\r\n \r\n# Function Call\r\ng.topologicalSort()\r\n \r\n# This code is contributed by Neelam Yadav"}
{"nl": "Double Letters", "code": "def double_letters(word):\n  return any(i*2 in word for i in word)"}
{"nl": "Remove Special Characters From list Python", "code": "# Python program to remove all special characters from list # importing RegEx module import re # take list my_list = ['@know*', 'pr#ogra!m^', '(py_th@on_3}'] # using regular expression to remove special characters out_list = [re.sub(r'[^a-zA-Z0-9]','',string) for string in my_list] # print list without special characters print('List after removal of special characters:', out_list)"}
{"nl": "Construct a Maximum Sum Linked List out of two Sorted Linked Lists having some Common nodes", "code": "# Python program to construct a Maximum Sum Linked List out of\n# two Sorted Linked Lists having some Common nodes\nclass LinkedList(object):\n\tdef __init__(self):\n\t# head of list\n\t\tself.head = None\n\n\t# Linked list Node\n\tclass Node(object):\n\t\tdef __init__(self, d):\n\t\t\tself.data = d\n\t\t\tself.next = None\n\n\t# Method to adjust pointers and print final list\n\tdef finalMaxSumList(self, a, b):\n\t\tresult = None\n\t\t# assigning pre and cur to head\n\t\t# of the linked list\n\t\tpre1 = a\n\t\tcurr1 = a\n\t\tpre2 = b\n\t\tcurr2 = b\n\t\t# Till either of current pointers is not null\n\t\t# execute the loop\n\t\twhile curr1 != None or curr2 != None:\n\t\t\t# Keeping 2 local variables at the start of every\n\t\t\t# loop run to keep track of the sum between pre\n\t\t\t# and cur reference elements.\n\t\t\tsum1 = 0\n\t\t\tsum2 = 0\n\t\t\t# Calculating sum by traversing the nodes of linked\n\t\t\t# list as the merging of two linked list. The loop\n\t\t\t# stops at a common node\n\t\t\twhile curr1 != None and curr2 != None and curr1.data != curr2.data:\n\t\t\t\tif curr1.data < curr2.data:\n\t\t\t\t\tsum1 += curr1.data\n\t\t\t\t\tcurr1 = curr1.next\n\t\t\t\telse:\n\t\t\t\t\tsum2 += curr2.data\n\t\t\t\t\tcurr2 = curr2.next\n\t\t\t# If either of current pointers becomes null\n\t\t\t# carry on the sum calculation for other one.\n\t\t\tif curr1 == None:\n\t\t\t\twhile curr2 != None:\n\t\t\t\t\tsum2 += curr2.data\n\t\t\t\t\tcurr2 = curr2.next\n\t\t\tif curr2 == None:\n\t\t\t\twhile curr1 != None:\n\t\t\t\t\tsum1 += curr1.data\n\t\t\t\t\tcurr1 = curr1.next\n\t\t\t# First time adjustment of resultant head based on\n\t\t\t# the maximum sum.\n\t\t\tif pre1 == a and pre2 == b:\n\t\t\t\tresult = pre1 if (sum1 > sum2) else pre2\n\t\t\telse:\n\t\t\t\t# If pre1 and pre2 don't contain the head references of\n\t\t\t\t# lists adjust the next pointers of previous pointers.\n\t\t\t\tif sum1 > sum2:\n\t\t\t\t\tpre2.next = pre1.next\n\t\t\t\telse:\n\t\t\t\t\tpre1.next = pre2.next\n\t\t\t# Adjusting previous pointers\n\t\t\tpre1 = curr1\n\t\t\tpre2 = curr2\n\t\t\t# If curr1 is not NULL move to the next.\n\t\t\tif curr1 != None:\n\t\t\t\tcurr1 = curr1.next\n\t\t\t# If curr2 is not NULL move to the next.\n\t\t\tif curr2 != None:\n\t\t\t\tcurr2 = curr2.next\n\n\t\twhile result != None:\n\t\t\tprint (str(result.data),end=\" \")\n\t\t\tresult = result.next\n\t\tprint ()\n\n\t# Utility functions\n\t# Inserts a new Node at front of the list.\n\tdef push(self, new_data):\n\t\t# 1 & 2: Allocate the Node &\n\t\t# Put in the data\n\t\tnew_node = self.Node(new_data)\n\t\t# 3. Make next of new Node as head\n\t\tnew_node.next = self.head\n\t\t# 4. Move the head to point to new Node\n\t\tself.head = new_node\n\n# Driver program\nllist1 = LinkedList()\nllist2 = LinkedList()\n\n# Linked List 1 : 1->3->30->90->110->120->NULL\n# Linked List 2 : 0->3->12->32->90->100->120->130->NULL\n\nllist1.push(120)\nllist1.push(110)\nllist1.push(90)\nllist1.push(30)\nllist1.push(3)\nllist1.push(1)\n\nllist2.push(130)\nllist2.push(120)\nllist2.push(100)\nllist2.push(90)\nllist2.push(32)\nllist2.push(12)\nllist2.push(3)\nllist2.push(0)\n\nllist1.finalMaxSumList(llist1.head, llist2.head)\n\n# This code is contributed by BHAVYA JAIN\n"}
{"nl": "find Longest Common Subsequence using Dynamic Programming with Bottom-Up Approach", "code": "def lcs(u, v):\n    \"\"\"Return c where c[i][j] contains length of LCS of u[i:] and v[j:].\"\"\"\n    c = [[-1]*(len(v) + 1) for _ in range(len(u) + 1)]\n\u00a0\n    for i in range(len(u) + 1):\n        c[i][len(v)] = 0\n    for j in range(len(v)):\n        c[len(u)][j] = 0\n\u00a0\n    for i in range(len(u) - 1, -1, -1):\n        for j in range(len(v) - 1, -1, -1):\n            if u[i] == v[j]:\n                c[i][j] = 1 + c[i + 1][j + 1]\n            else:\n                c[i][j] = max(c[i + 1][j], c[i][j + 1])\n\u00a0\n    return c\n\u00a0\n\u00a0\ndef print_lcs(u, v, c):\n    \"\"\"Print one LCS of u and v using table c.\"\"\"\n    i = j = 0\n    while not (i == len(u) or j == len(v)):\n        if u[i] == v[j]:\n            print(u[i], end='')\n            i += 1\n            j += 1\n        elif c[i][j + 1] > c[i + 1][j]:\n            j += 1\n        else:\n            i += 1\n\u00a0\n\u00a0\nu = input('Enter first string: ')\nv = input('Enter second string: ')\nc = lcs(u, v)\nprint('Longest Common Subsequence: ', end='')\nprint_lcs(u, v, c)"}
{"nl": "Squares of Matrix Diagonal Elements", "code": "# Efficient Python program\n# to print squares of\n# diagonal elements.\n\n# function of diagonal square\ndef diagonalsquare(mat, row,\n                                column) :\n        \n        # This loop is for finding\n        # of square of the first\n        # side of diagonal elements\n        print (\"Diagonal one : \",\n                                        end = \"\")\n        for i in range(0, row) :\n\n                # printing direct square\n                # of diagonal element\n                # there is no need to\n                # check condition\n                print (mat[i][i] *\n                        mat[i][i], end = \" \")\n        \n\n        # This loop is for finding\n        # square of the second side\n        # of diagonal elements\n        print (\"\\n\\nDiagonal two : \",\n                                                end = \"\")\n        \n        for i in range(0, row) :        \n                \n                # printing direct square\n                # of diagonal element in\n                # the second side\n                print (mat[i][row - i - 1] *\n                        mat[i][row - i - 1] ,\n                                                end = \" \")\n\n# Driver code\nmat = [[2, 5, 7 ],\n        [3, 7, 2 ],\n        [5, 6, 9 ]]\ndiagonalsquare(mat, 3, 3)\n        \n# This code is contributed by\n# Manish Shaw(manishshaw1)\n"}
{"nl": "Find a pair with given sum in a Balanced BST", "code": "# Python3 code to find a pair with given sum\n# in a Balanced BST\nclass Node:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Construct to create a new Node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.data = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = self.right = None\n\u00a0\n# A utility function to insert a new\n# Node with given key in BST\ndef insert(root: Node, key: int):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty, return a new Node\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Otherwise, recur down the tree\n\u00a0\u00a0\u00a0\u00a0if root.data > key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = insert(root.left, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0elif root.data < key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = insert(root.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return the (unchanged) Node pointer\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n# Function that adds values of given BST into\n# ArrayList and hence returns the ArrayList\ndef tree_to_list(root: Node, arr: list):\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if not root:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return arr\n\u00a0\n\u00a0\u00a0\u00a0\u00a0tree_to_list(root.left, arr)\n\u00a0\u00a0\u00a0\u00a0arr.append(root.data)\n\u00a0\u00a0\u00a0\u00a0tree_to_list(root.right, arr)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return arr\n\u00a0\n# Function that checks if there is a pair present\ndef isPairPresent(root: Node, target: int) -> bool:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# This list a1 is passed as an argument\n\u00a0\u00a0\u00a0\u00a0# in treeToList method which is later\n\u00a0\u00a0\u00a0\u00a0# on filled by the values of BST\n\u00a0\u00a0\u00a0\u00a0arr1 = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# a2 list contains all the values of BST\n\u00a0\u00a0\u00a0\u00a0# returned by treeToList method\n\u00a0\u00a0\u00a0\u00a0arr2 = tree_to_list(root, arr1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Starting index of a2\n\u00a0\u00a0\u00a0\u00a0start = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Ending index of a2\n\u00a0\u00a0\u00a0\u00a0end = len(arr2) - 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0while start < end:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If target found\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr2[start] + arr2[end] == target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(f\"Pair Found: {arr2[start]} + {arr2[end]} = {target}\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Decrements end\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr2[start] + arr2[end] > target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Increments start\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if arr2[start] + arr2[end] < target:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0start += 1\n\u00a0\n\u00a0\u00a0\u00a0\u00a0print(\"No such values are found!\")\n\u00a0\u00a0\u00a0\u00a0return False\n\u00a0\n# Driver code\nif __name__ == \"__main__\":\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 15)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 10)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 20)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 8)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 12)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 16)\n\u00a0\u00a0\u00a0\u00a0root = insert(root, 25)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0isPairPresent(root, 33)\n\u00a0\n# This code is contributed by shindesharad71\n"}
{"nl": "Python Raise an Exception\r\n", "code": "x = -1\r\n\r\nif x < 0:\r\n  raise Exception(\"Sorry, no numbers below zero\")"}
{"nl": "Python Program To Write Inline If Statement", "code": "numb = 10\ntemp = 3\nprint(numb if temp else 0)"}
{"nl": "Capitalize  a string title of one or more words", "code": "class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        title = title.title().split()\n        for i in range(len(title)):\n            if len(title[i]) < 3:\n                title[i] = title[i].lower()\n        return ' '.join(title)"}
{"nl": "Exercise implementing a simple discount system for a bookstore: simple arithmetic calculations.", "code": "\"\"\"\nExercism solution for \"book-store\"\n\"\"\"\nimport math\nfrom collections import Counter\nfrom decimal import Decimal\nfrom functools import lru_cache, reduce\nfrom typing import List, Tuple\nPER_BOOK = Decimal(\"800.00\")\nPER_GROUP = {\n    1: 1 * PER_BOOK * Decimal(\"1.00\"),\n    2: 2 * PER_BOOK * Decimal(\"0.95\"),\n    3: 3 * PER_BOOK * Decimal(\"0.90\"),\n    4: 4 * PER_BOOK * Decimal(\"0.80\"),\n    5: 5 * PER_BOOK * Decimal(\"0.75\"),\n}\n# memoize the results; cap memory and degrade performance with HUGE number of books\n@lru_cache(maxsize=1024)\ndef _recursive_total(books: Tuple[int]) -> float:\n    \"\"\"\n    Recurse to find the best discounted price for a non-empty, pre-sorted tuple of books.\n    \"\"\"\n    volumes = Counter(books)\n    num_books, num_volumes = len(books), len(volumes)\n    # optimization 1: we only have N copies of the same volume\n    if num_volumes == 1:\n        return num_books * PER_BOOK\n    # optimization 2: we only have 1 copy of each unique volume\n    if num_books == num_volumes:\n        return PER_GROUP[num_books]\n    # optimization 3: we happen to have gotten counts that share a GCD > 1\n    gcd = reduce(math.gcd, volumes.values())\n    if gcd != 1:\n        minimal = Counter({k: v // gcd for k, v in volumes.items()})\n        minimal_books = tuple(sorted(minimal.elements()))\n        return _recursive_total(minimal_books) * gcd\n    # in all other cases we recurse into the groups to find the minimum discount\n    price = num_books * PER_BOOK\n    for num in range(num_volumes, 1, -1):\n        # remove the first copy of each of the num most common volumes\n        group = volumes - Counter(k for k, _ in volumes.most_common(num))\n        group_books = tuple(sorted(group.elements()))\n        # calculate the minimum price for the group\n        price = min(price, PER_GROUP[num] + _recursive_total(group_books))\n    return price\ndef total(books: List[int]) -> float:\n    \"\"\"\n    Calculate the best discounted price for a list of books.\n    \"\"\"\n    if not books:\n        return 0\n    return _recursive_total(tuple(sorted(books)))"}
{"nl": "Python Program to Make a Simple Calculator", "code": "# Program make a simple calculator\n\n# This function adds two numbers\ndef add(x, y):\n    return x + y\n\n# This function subtracts two numbers\ndef subtract(x, y):\n    return x - y\n\n# This function multiplies two numbers\ndef multiply(x, y):\n    return x * y\n\n# This function divides two numbers\ndef divide(x, y):\n    return x / y\n\n\nprint(\"Select operation.\")\nprint(\"1.Add\")\nprint(\"2.Subtract\")\nprint(\"3.Multiply\")\nprint(\"4.Divide\")\n\nwhile True:\n    # take input from the user\n    choice = input(\"Enter choice(1/2/3/4): \")\n\n    # check if choice is one of the four options\n    if choice in ('1', '2', '3', '4'):\n        num1 = float(input(\"Enter first number: \"))\n        num2 = float(input(\"Enter second number: \"))\n\n        if choice == '1':\n            print(num1, \"+\", num2, \"=\", add(num1, num2))\n\n        elif choice == '2':\n            print(num1, \"-\", num2, \"=\", subtract(num1, num2))\n\n        elif choice == '3':\n            print(num1, \"*\", num2, \"=\", multiply(num1, num2))\n\n        elif choice == '4':\n            print(num1, \"/\", num2, \"=\", divide(num1, num2))\n        \n        # check if user wants another calculation\n        # break the while loop if answer is no\n        next_calculation = input(\"Let's do next calculation? (yes/no): \")\n        if next_calculation == \"no\":\n          break\n    \n    else:\n        print(\"Invalid Input\")"}
{"nl": "Find the Length of a List in Python", "code": "# Python program to find the length of a list # take list list = [0,8,7,6] # find length of the list len = len(list) # print length of the list print(\"The length of a list is\", len)"}
{"nl": "Python Program to Reverse a String", "code": "# Python program to reverse a string using for loop # take inputs string = input('Enter the string: ') # calculate reverse of string reverse = '' for i in range(len(string), 0, -1): reverse += string[i-1] # print reverse of string print('The reverse string is', reverse)"}
{"nl": "Remove duplicates from an unsorted linked list", "code": "# Python3 program to remove duplicates\n# from unsorted linked list\n\n\nclass Node():\n\n\tdef __init__(self, data):\n\n\t\tself.data = data\n\t\tself.next = None\n\n\nclass LinkedList():\n\n\tdef __init__(self):\n\n\t\t# Head of list\n\t\tself.head = None\n\n\tdef remove_duplicates(self):\n\n\t\tptr1 = None\n\t\tptr2 = None\n\t\tdup = None\n\t\tptr1 = self.head\n\n\t\t# Pick elements one by one\n\t\twhile (ptr1 != None and ptr1.next != None):\n\n\t\t\tptr2 = ptr1\n\n\t\t\t# Compare the picked element with rest\n\t\t\t# of the elements\n\t\t\twhile (ptr2.next != None):\n\n\t\t\t\t# If duplicate then delete it\n\t\t\t\tif (ptr1.data == ptr2.next.data):\n\n\t\t\t\t\t# Sequence of steps is important here\n\t\t\t\t\tdup = ptr2.next\n\t\t\t\t\tptr2.next = ptr2.next.next\n\t\t\t\telse:\n\t\t\t\t\tptr2 = ptr2.next\n\n\t\t\tptr1 = ptr1.next\n\n\t# Function to print nodes in a\n\t# given linked list\n\tdef printList(self):\n\t\ttemp = self.head\n\n\t\twhile(temp != None):\n\t\t\tprint(temp.data, end=\" \")\n\t\t\ttemp = temp.next\n\n\t\tprint()\n\n\n# Driver code\nlist = LinkedList()\nlist.head = Node(10)\nlist.head.next = Node(12)\nlist.head.next.next = Node(11)\nlist.head.next.next.next = Node(11)\nlist.head.next.next.next.next = Node(12)\nlist.head.next.next.next.next.next = Node(11)\nlist.head.next.next.next.next.next.next = Node(10)\n\nprint(\"Linked List before removing duplicates :\")\nlist.printList()\nlist.remove_duplicates()\nprint()\nprint(\"Linked List after removing duplicates :\")\nlist.printList()\n\n# This code is contributed by maheshwaripiyush9"}
{"nl": "Python Program for Modular Multiplicative Inverse from 1 to n", "code": "# Create a function to say modularmultInverse() which takes the iterator value and the\n# given number as the arguments and returns the modular multiplicative inverse from 1\n# to the given number n.\n\n\ndef modularmultInverse(itrvl, gvn_primenum):\n  # Inside the function, calculate the iterator value modulus given prime number and\n  # store it in the same variable iterator value.\n    itrvl = itrvl % gvn_primenum\n    # Loop from 1 to the given prime number using the for loop.\n    for k in range(1, gvn_primenum):\n     # Check if the iterator value multiplied by k (where k is the iterator value of for loop)\n     # modulus given prime number is equal to 1 using the if conditional statement.\n        if ((itrvl*k) % gvn_primenum == 1):\n          # If it is true, return the value of k.\n            return k\n    #Return -1.\n    return -1\n    \n    \n# Give the number as user input using the int(input()) function and store it in a variable.\ngvn_numb = int(input(\"Enter some random number = \"))\n# Give the prime number as user input using the int(input()) function and \n# store it in another variable.\ngvn_primenum = int(input(\"Enter some random number = \"))\n# Loop from 1 to the given number using the for loop.\nprint(\n    \"The modular multiplicative inverse from 1 to the given number{\", gvn_numb, \"} :\")\nfor itr in range(1, gvn_numb+1):\n  # Pass the iterator value and the given prime number to the modularmultInverse() function\n  # and print it.\n    print(modularmultInverse(itr, gvn_primenum), end=\" \")"}
{"nl": "The number of ways of cutting the pizza with apple in each piece", "code": "class Solution:\n  def ways(self, pizza: List[str], K: int) -> int:\n  m, n, MOD = len(pizza), len(pizza[0]), 10 ** 9 + 7\n  preSum = [[0] * (n + 1) for _ in range(m + 1)]\n  for r in range(m - 1, -1, -1):\n  for c in range(n - 1, -1, -1):\n  preSum[r][c] = preSum[r][c + 1] + preSum[r + 1][c] - preSum[r + 1][c + 1] + (pizza[r][c] == 'A')\n\n  @lru_cache(None)\n  def dp(k, r, c):\n  if preSum[r][c] == 0: return 0\n  if k == 0: return 1\n  ans = 0\n  # cut horizontally\n  for nr in range(r + 1, m):\n  if preSum[r][c] - preSum[nr][c] > 0:\n  ans = (ans + dp(k - 1, nr, c)) % MOD\n  # cut vertically  \n  for nc in range(c + 1, n):\n  if preSum[r][c] - preSum[r][nc] > 0:\n  ans = (ans + dp(k - 1, r, nc)) % MOD\n  return ans\n\n  return dp(K - 1, 0, 0)"}
{"nl": "find interleaving strings", "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    \n    if len(s3) != len(s1) + len(s2):\n        return False\n    \n    def helper(i, j, k):\n        if (i, j) in seen:\n            return False\n        seen.add((i, j))\n        if i == len(s1):\n            return s2[j:] == s3[k:]\n        if j == len(s2):\n            return s1[i:] == s3[k:]\n        if ((s1[i] == s3[k] and helper(i + 1, j, k + 1)) or\n                (s2[j] == s3[k] and helper(i, j + 1, k + 1))):\n            return True\n        return False\n\n    seen = set()\n    return helper(0, 0, 0)"}
{"nl": "New Numbers", "code": "def is_new(n):\n    s = sorted(str(n))\n    zeros = s.count('0')\n    s[:zeros + 1] = reversed(s[:zeros + 1])\n    return n <= int(''.join(s))"}
{"nl": "Get level of a node in binary tree iterative approach", "code": "# Python3 program to find closest\n# value in Binary search Tree\n\n_MIN = -2147483648\n_MAX = 2147483648\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pointers.\t\t\t\t\t\t\t\t\t\nclass getnode:\n\n\t# Constructor to create a new node\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\n# utility function to return level\n# of given node\ndef getlevel(root, data):\n\n\tq = []\n\tlevel = 1\n\tq.append(root)\n\n\t# extra None is appended to keep track\n\t# of all the nodes to be appended\n\t# before level is incremented by 1\n\tq.append(None)\n\twhile (len(q)):\n\t\ttemp = q[0]\n\t\tq.pop(0)\n\t\tif (temp == None) :\n\t\t\tif len(q) == 0:\n\t\t\t\treturn 0\n\t\t\tif (q[0] != None):\n\t\t\t\tq.append(None)\n\t\t\tlevel += 1\n\t\telse :\n\t\t\tif (temp.data == data) :\n\t\t\t\treturn level\n\t\t\tif (temp.left):\n\t\t\t\tq.append(temp.left)\n\t\t\tif (temp.right) :\n\t\t\t\tq.append(temp.right)\t\n\treturn 0\n\n# Driver Code\nif __name__ == '__main__':\n\t\n\t# create a binary tree\n\troot = getnode(20)\n\troot.left = getnode(10)\n\troot.right = getnode(30)\n\troot.left.left = getnode(5)\n\troot.left.right = getnode(15)\n\troot.left.right.left = getnode(12)\n\troot.right.left = getnode(25)\n\troot.right.right = getnode(40)\n\n\t# return level of node\n\tlevel = getlevel(root, 30)\n\tif level != 0:\n\t\tprint(\"level of node 30 is\", level)\n\telse:\n\t\tprint(\"node 30 not found\")\n\n\tlevel = getlevel(root, 12)\n\tif level != 0:\n\t\tprint(\"level of node 12 is\", level)\n\telse:\n\t\tprint(\"node 12 not found\")\n\t\t\n\tlevel = getlevel(root, 25)\n\tif level != 0:\n\t\tprint(\"level of node 25 is\", level)\n\telse:\n\t\tprint(\"node 25 not found\")\n\n\tlevel = getlevel(root, 27)\n\tif level != 0:\n\t\tprint(\"level of node 27 is\", level)\n\telse:\n\t\tprint(\"node 27 not found\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "Python File tell() Method", "code": "f = open(\"demofile.txt\", \"r\")\r\nprint(f.tell())"}
{"nl": "Spelling it Out", "code": "def spelling(txt):\n  return [txt[:i + 1] for i in range(len(txt))]"}
{"nl": "binary tree inorder traversal", "code": "def inorder(root):\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []"}
{"nl": "Sort by Frequency", "code": "def sort_freq(lst):\n    return sorted(lst, key=lambda k: (-lst.count(k), k))"}
{"nl": "Truncate String at a Given Length", "code": "def truncate(txt, length):\n  return \" \".join([word for word in txt[:length].split() if word in txt.split()])"}
{"nl": "Find the trace value and the normal value of a matrix, given the matrix.", "code": "# Import the math module using the import keyword.\r\nimport math\r\n# Give the matrix as static input and store it in a variable.\r\nmtrx = [[2, 6, 4], [8, 5, 3], [1, 6, 8]]\r\n# Calculate the number of rows of the given matrix by\r\n# calculating the length of the nested list using the len() function\r\n# and store it in a variable mtrxrows.\r\nmtrxrows = len(mtrx)\r\n# Calculate the number of columns of the given matrix by\r\n# calculating the length of the first list in the nested list\r\n# using the len() function and store it in a variable mtrxcols.\r\nmtrxcols = len(mtrx[0])\r\n# Take a variable say mtrxtrace which stores the trace of the given matrix\r\n# and initialize its value to 0.\r\nmtrxtrace = 0\r\n# Take a variable say mtrxsum which stores the sum of all elements of the matrix\r\n# and initialize its value to 0.\r\nmtrxsum = 0\r\n# Loop till the given number of rows using the For loop.\r\nfor n in range(mtrxrows):\r\n        # Inside the For loop, Iterate till the given number of columns using another\r\n        # Nested For loop(Inner For loop).\r\n    for m in range(mtrxcols):\r\n        # Check if the parent loop iterator value is equal to the inner loop iterator value\r\n        # using the if conditional statement\r\n        # (This is whether the element is diagonal element or not)\r\n        if(n == m):\r\n            # If it is true then add this value to mtrxtrace.\r\n            mtrxtrace = mtrxtrace+mtrx[n][m]\r\n\r\n        # After the if conditional statement,\r\n        # Add the gvnmatrix[n][m] to the above-initialized mtrxsum\r\n        # and store it in the same variable mtrxsum.\r\n        mtrxsum = mtrxsum+mtrx[n][m]\r\n# After the end of two loops calculate the square root of the mtrxsum value\r\n# using the sqrt() function\r\n# and store this result in mtrxnormal variable.\r\nmtrxnormal = math.sqrt(mtrxsum)\r\n# Print the value of mtrxtrace which gives the value of the trace of the given matrix.\r\nprint('The trace value of the given matrix is :', mtrxtrace)\r\n# Print the value of mtrxnormal which gives the value of the normal of the given matrix.\r\nprint('The normal value of the given matrix is :', mtrxnormal)"}
{"nl": "Building a Pie Chart", "code": "def pie_chart(data):\n  total = sum(data.values())\n  return {i:round(data[i]/total * 360, 1) for i in data}"}
{"nl": "Count number of instances created of a class.", "code": "class User:\r\n\tuser_count=0\r\n\tdef __init__(self,u):\r\n\t\tself.username = u \r\n\t\tUser.user_count+=1"}
{"nl": "Recursion: Array Sum", "code": "def sum_recursively(lst):\n  if not lst: return 0\n  return lst.pop() + sum_recursively(lst)"}
{"nl": "Exponentially increasing star pattern", "code": "# Give the number of rows of the pattern as static input and store it in a variable.\nrowsnumb = 5\n# Loop till a given number of rows using For loop.\nfor m in range(rowsnumb+1):\n  # Calculate the exponential value of the first loop iterator\n  # value using 2**(iterator value of the first loop).\n    expvalue = 2**m\n    # Loop till the exponential value using another For loop(Nested For loop).\n    for n in range(expvalue):\n      # Print the star character in the inner for loop.\n        print(\"*\", end=\" \")\n    # Print the newline character after the end of the inner for loop.\n    print()"}
{"nl": "Python Program to Find the Sine Series for the Given range", "code": "# Import math module using the import keyword.\n \n import math\n \n # Give the lower limit range as static input and store it in a variable.\n \n lwer_lmt = 0\n \n # Give the upper limit range as static input and store it in another variable.\n \n upp_lmt = 181\n \n # Give the step size as static input and store it in another variable.\n \n stp_sze = 30\n \n # Loop from lower limit range to upper limit range using For loop.\n \n print(\"The Sine values in a given range are : \")\n \n for vale in range(lwer_lmt, upp_lmt, stp_sze):\n \n  # Get the angle value in radians from the given range(converting from degree to radians )\n \n  # and store it in a variable.\n \n  radns = math.radians(vale)\n \n  # Calculate the Sine value in a given range of above obtained radian values using\n \n  # math.Sine()function and store it in another variable.\n \n  sine_vlue = math.sin(radns)\n \n  # print the Sine Values in the above given range.\n \n  print(\"sin\",vale, \"=\", sine_vlue)\n \n </pre>"}
{"nl": "Find Common Divisors of Two Numbers", "code": "# Give the first number as the user input using the int(input())\r\n# function and store it in a variable.\r\nfirstnumbe = int(input('Enter some random first number ='))\r\n# Give the second number as the user input using the int(input())\r\n# function and store it in another variable.\r\nsecondnumbe = int(input('Enter some random second number ='))\r\n# Calculate the minimum number among the two numbers using the min()\r\n# function and store it in a variable.\r\nmininumb = min(firstnumbe, secondnumbe)\r\nprint(\r\n    'The common divisors of the two numbers {', firstnumbe, secondnumbe, '} are :')\r\n# Loop from 1 to minimum number using the For loop.\r\nfor itrnumb in range(1, mininumb+1):\r\n    # Inside the For loop.\r\n    # Check if the iterator value divides the given two numbers\r\n    # using the If conditional Statement.\r\n    if(firstnumbe % itrnumb == 0 and secondnumbe % itrnumb == 0):\r\n          # If it is true then print the iterator value.\r\n        print(itrnumb)"}
{"nl": "Arithmetic Progression", "code": "def arithmetic_progression(start, diff, n):\n    return \", \".join((str(start+diff*i) for i in range(n)))"}
{"nl": "File writelines() method", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in append mode. In this case, we're simply appending/adding the contents into the file.\ngvn_file = open(givenFilename, 'a') \n# Write some random lines to the file by passing lines in the form of list as an\n# argument to the writelines() function.\ngvn_file.writelines([\"good morning btechgeeks\\n\", \"welcome to python coding platform\\n\"])\n# Close the given file using the close function\ngvn_file.close()\n# Open the file in read mode. In this case, we're simply reading the contents of the file.\ngvn_file = open(givenFilename, 'r') \n# Read the contents of the file using the read() function\nprint(gvn_file.read())"}
{"nl": "Euler's Phi Function", "code": "def get_gcd(a, b):\n    while b:\n        a, b = b, a%b\n    return a\ndef phi(n):\n    return sum(get_gcd(i, n) == 1 for i in range(1, n+1))"}
{"nl": "Evaluation of Postfix Expression", "code": "# Python program to evaluate value of a postfix expression\n\u00a0\n# Class to convert the expression\nclass Evaluate:\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to initialize the class variables\n\u00a0\u00a0\u00a0\u00a0def __init__(self, capacity):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.top = -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.capacity = capacity\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# This array is used a stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array = []\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# check if the stack is empty\n\u00a0\u00a0\u00a0\u00a0def isEmpty(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return True if self.top == -1 else False\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Return the value of the top of the stack\n\u00a0\u00a0\u00a0\u00a0def peek(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.array[-1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Pop the element from the stack\n\u00a0\u00a0\u00a0\u00a0def pop(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if not self.isEmpty():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.top -= 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return self.array.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return \"$\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Push the element to the stack\n\u00a0\u00a0\u00a0\u00a0def push(self, op):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.top += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.array.append(op)\n\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# The main function that converts given infix expression\n\u00a0\u00a0\u00a0\u00a0# to postfix expression\n\u00a0\u00a0\u00a0\u00a0def evaluatePostfix(self, exp):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Iterate over the expression for conversion\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for i in exp:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the scanned character is an operand\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (number here) push it to the stack\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if i.isdigit():\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.push(i)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# If the scanned character is an operator,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# pop two elements from stack and apply it.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val1 = self.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val2 = self.pop()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.push(str(eval(val2 + i + val1)))\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return int(self.pop())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n# Driver program to test above function\nexp = \"231*+9-\"\nobj = Evaluate(len(exp))\nprint (\"postfix evaluation: %d\"%(obj.evaluatePostfix(exp)))\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Python Program to Get the Position of Max Value in a List", "code": "# Give the List as static input and store it in a variable.\n Gvn_lst = [1, 5, 9, 2, 7, 3, 8]\n # Get the maximum value of the given list using the built-in max() function and\n # store it in another variable\n maxim_vle = max(Gvn_lst)\n # Print the maximum value of the above given List.\n print(\"Maximum Value in the above Given list = \", maxim_vle)\n # Get the position of the maximum value of the List using the built-in index() function\n # and store it in another variable.\n maxim_positn = Gvn_lst.index(maxim_vle)\n # Print the position of the maximum value of the given List i.e. maximum position+1\n # ( since list index starts from zero).\n print(\"Position of Maximum value of the above Given List = \", maxim_positn+1)"}
{"nl": "Binary Search Tree | Set 2 (Delete)", "code": "# Python program to demonstrate delete operation\n# in binary search tree\n\u00a0\n# A Binary Tree Node\n\u00a0\n\u00a0\nclass Node:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Constructor to create a new node\n\u00a0\u00a0\u00a0\u00a0def __init__(self, key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.key = key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.left = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.right = None\n\u00a0\n\u00a0\n# A utility function to do inorder traversal of BST\ndef inorder(root):\n\u00a0\u00a0\u00a0\u00a0if root is not None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print (root.key,end=\" \")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inorder(root.right)\n\u00a0\n\u00a0\n# A utility function to insert a\n# new node with given key in BST\ndef insert(node, key):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the tree is empty, return a new node\n\u00a0\u00a0\u00a0\u00a0if node is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Node(key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Otherwise recur down the tree\n\u00a0\u00a0\u00a0\u00a0if key < node.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.left = insert(node.left, key)\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.right = insert(node.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# return the (unchanged) node pointer\n\u00a0\u00a0\u00a0\u00a0return node\n\u00a0\n# Given a non-empty binary\n# search tree, return the node\n# with minimum key value\n# found in that tree. Note that the\n# entire tree does not need to be searched\n\u00a0\n\u00a0\ndef minValueNode(node):\n\u00a0\u00a0\u00a0\u00a0current = node\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# loop down to find the leftmost leaf\n\u00a0\u00a0\u00a0\u00a0while(current.left is not None):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = current.left\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return current\n\u00a0\n# Given a binary search tree and a key, this function\n# delete the key and returns the new root\n\u00a0\n\u00a0\ndef deleteNode(root, key):\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base Case\n\u00a0\u00a0\u00a0\u00a0if root is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the key to be deleted\n\u00a0\u00a0\u00a0\u00a0# is smaller than the root's\n\u00a0\u00a0\u00a0\u00a0# key then it lies in\u00a0 left subtree\n\u00a0\u00a0\u00a0\u00a0if key < root.key:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.left = deleteNode(root.left, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If the kye to be delete\n\u00a0\u00a0\u00a0\u00a0# is greater than the root's key\n\u00a0\u00a0\u00a0\u00a0# then it lies in right subtree\n\u00a0\u00a0\u00a0\u00a0elif(key > root.key):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = deleteNode(root.right, key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0# If key is same as root's key, then this is the node\n\u00a0\u00a0\u00a0\u00a0# to be deleted\n\u00a0\u00a0\u00a0\u00a0else:\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Node with only one child or no child\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if root.left is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = root.right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return temp\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elif root.right is None:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = root.left\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = None\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return temp\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Node with two children:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Get the inorder successor\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# (smallest in the right subtree)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp = minValueNode(root.right)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Copy the inorder successor's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# content to this node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.key = temp.key\n\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# Delete the inorder successor\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root.right = deleteNode(root.right, temp.key)\n\u00a0\n\u00a0\u00a0\u00a0\u00a0return root\n\u00a0\n\u00a0\n# Driver code\n\"\"\" Let us create following BST\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a050\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0\u00a0\u00a0\u00a0 \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a030\u00a0\u00a0\u00a0\u00a0\u00a0 70\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0 \\\u00a0\u00a0\u00a0 /\u00a0 \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a020\u00a0\u00a0 40\u00a0 60\u00a0\u00a0 80 \"\"\"\n\u00a0\nroot = None\nroot = insert(root, 50)\nroot = insert(root, 30)\nroot = insert(root, 20)\nroot = insert(root, 40)\nroot = insert(root, 70)\nroot = insert(root, 60)\nroot = insert(root, 80)\n\u00a0\nprint (\"Inorder traversal of the given tree\")\ninorder(root)\n\u00a0\nprint (\"\\nDelete 20\")\nroot = deleteNode(root, 20)\nprint (\"Inorder traversal of the modified tree\")\ninorder(root)\n\u00a0\nprint (\"\\nDelete 30\")\nroot = deleteNode(root, 30)\nprint (\"Inorder traversal of the modified tree\")\ninorder(root)\n\u00a0\nprint (\"\\nDelete 50\")\nroot = deleteNode(root, 50)\nprint (\"Inorder traversal of the modified tree\")\ninorder(root)\n\u00a0\n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"}
{"nl": "Python Program to Sort a Dictionary by Value", "code": "dt = {5:4, 1:6, 6:3}\n\nsorted_dt = {key: value for key, value in sorted(dt.items(), key=lambda item: item[1])}\n\nprint(sorted_dt)\ndt = {5:4, 1:6, 6:3}\n\nsorted_dt_value = sorted(dt.values())\nprint(sorted_dt_value)"}
{"nl": "Time when all ants fall out of a plank", "code": "def getLastMoment(self, n, left, right):\n  return max(max(left or [0]), n - min(right or [n]))"}
{"nl": "Period.freqstr Attribute", "code": "# Import pandas module using the import keyword.\r\nimport pandas as pd\r\n# Pass freq ='D'(here D represents Date), some random year, month, day, \r\n# as the arguments to the Period() function of the\r\n# pandas module to get the period object\r\nperiod_obj = pd.Period(freq ='D', year = 2021, month = 8, day = 15)\r\n# Print the above obtained period object\r\nprint(\"The above obtained period object:\", period_obj)\r\n\r\n# Apply freqstr attribute to the above period object to get a \r\n# string alias of the Time series frequency applied to the given Period object\r\nprint(\"String alias of the Time series frequency applied to the given Period object:\")\r\nperiod_obj.freqstr"}
{"nl": "Add two matrices and return the new matrix.", "code": "# given matrix A\nA = [[11, -2, 0],\n     [4, 8, 6]]\n# given matrix B\nB = [[5, 1, -5],\n     [2, 3, 0]]\n# Initialize the sum of matrices elements to 0\nmatrixSum = [[0, 0, 0],\n             [0, 0, 0]]\n\n# Traverse the rows\nfor rows in range(len(A)):\n    # Traverse the  columns\n    for columns in range(len(A[0])):\n        matrixSum[rows][columns] = A[rows][columns] + B[rows][columns]\n# printing the sum of matrices\nprint(\"Printing the sum of matrices : \")\nfor rows in matrixSum:\n    print(*rows)"}
{"nl": "Convert the date string to the format YYYY-MM-DD", "code": "class Solution:\n  def reformatDate(self, date: str) -> str:\n  M = {\"Jan\" : \"01\", \"Feb\" : \"02\", \"Mar\" : \"03\", \"Apr\" : \"04\", \"May\" : \"05\", \"Jun\" : \"06\", \"Jul\" : \"07\", \"Aug\" : \"08\", \"Sep\" : \"09\", \"Oct\" : \"10\", \"Nov\" : \"11\", \"Dec\" : \"12\", }\n  \n  D = \"\"\n  if (len(date) == 13):\n  D += date[-4:] + \"-\" + M[date[-8:-5]] + \"-\" + date[:2]\n  else:\n  D += date[-4:] + \"-\" + M[date[-8:-5]] + \"-0\" + date[0]\n  return D"}
{"nl": "Calculate n permutation r", "code": "# Import math module using the import keyword.\n import math\n # Give the number as static input and store it in a variable.\n gvn_n_val = 5\n # Give another number as static input and store it in another variable.\n gvn_r_val = 4\n # Calculate the value of nPr with reference to standard mathematical formula n!/(n-r)!\n # using factorial() function \n # Store it in a variable.\n n_p_r = math.factorial(gvn_n_val)//math.factorial(gvn_n_val-gvn_r_val)\n # Print the value of nPr for the above given n, r values.\n print(\"The value of nPr for above given n, r values = \", n_p_r)"}
{"nl": "Is It a Triangle?", "code": "def is_triangle(*sides):\n  return all(s < sum(sides) - s for s in sides)"}
{"nl": "Shortest path with exactly k edges in a directed and weighted graph", "code": "# Python3 program to find shortest path\n# with exactly k edges\n\u00a0\n# Define number of vertices in the graph\n# and infinite value\n\u00a0\n# A naive recursive function to count\n# walks from u to v with k edges\ndef shortestPath(graph, u, v, k):\n\u00a0\u00a0\u00a0\u00a0V = 4\n\u00a0\u00a0\u00a0\u00a0INF = 999999999999\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Base cases\n\u00a0\u00a0\u00a0\u00a0if k == 0 and u == v:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0\n\u00a0\u00a0\u00a0\u00a0if k == 1 and graph[u][v] != INF:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return graph[u][v]\n\u00a0\u00a0\u00a0\u00a0if k <= 0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return INF\n\u00a0\n# Initialize result\n\u00a0\u00a0\u00a0\u00a0res = INF\n\u00a0\n# Go to all adjacents of u and recur\n\u00a0\u00a0\u00a0\u00a0for i in range(V):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if graph[u][i] != INF and u != i and v != i:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rec_res = shortestPath(graph, i, v, k - 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if rec_res != INF:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = min(res, graph[u][i] + rec_res)\n\u00a0\u00a0\u00a0\u00a0return res\n\u00a0\n# Driver Code\nif __name__ == '__main__':\n\u00a0\u00a0\u00a0\u00a0INF = 999999999999\n\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0# Let us create the graph shown\n\u00a0\u00a0\u00a0\u00a0# in above diagram\n\u00a0\u00a0\u00a0\u00a0graph = [[0, 10, 3, 2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, 0, INF, 7],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, 0, 6],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[INF, INF, INF, 0]]\n\u00a0\u00a0\u00a0\u00a0u = 0\n\u00a0\u00a0\u00a0\u00a0v = 3\n\u00a0\u00a0\u00a0\u00a0k = 2\n\u00a0\u00a0\u00a0\u00a0print(\"Weight of the shortest path is\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0shortestPath(graph, u, v, k))\n\u00a0\n# This code is contributed by PranchalK\n"}
{"nl": "finish course schedules", "code": "class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        from collections import defaultdict\n        courseDict = defaultdict(list)\n\n        for relation in prerequisites:\n            nextCourse, prevCourse = relation[0], relation[1]\n            courseDict[prevCourse].append(nextCourse)\n\n        path = [False] * numCourses\n        for currCourse in range(numCourses):\n            if self.isCyclic(currCourse, courseDict, path):\n                return False\n        return True\n\n\n    def isCyclic(self, currCourse, courseDict, path):\n        \"\"\"\n        backtracking method to check that no cycle would be formed starting from currCourse\n        \"\"\"\n        if path[currCourse]:\n            # come across a previously visited node, i.e. detect the cycle\n            return True\n\n        # before backtracking, mark the node in the path\n        path[currCourse] = True\n\n        # backtracking\n        ret = False\n        for child in courseDict[currCourse]:\n            ret = self.isCyclic(child, courseDict, path)\n            if ret: break\n\n        # after backtracking, remove the node from the path\n        path[currCourse] = False\n        return ret"}
{"nl": "Image compression using K-means clustering", "code": "\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.image as img\r\n# from scipy.io import loadmat\r\nfrom scipy import misc\r\n  \r\ndef read_image():\r\n      \r\n    # loading the png image as a 3d matrix \r\n    img = misc.imread('bird_small.png') \r\n  \r\n    # uncomment the below code to view the loaded image\r\n    # plt.imshow(A) # plotting the image\r\n    # plt.show() \r\n      \r\n    # scaling it so that the values are small\r\n    img = img / 255 \r\n  \r\n    return img\r\n  \r\ndef initialize_means(img, clusters):\r\n      \r\n    # reshaping it or flattening it into a 2d matrix\r\n    points = np.reshape(img, (img.shape[0] * img.shape[1],\r\n                                             img.shape[2])) \r\n    m, n = points.shape\r\n  \r\n    # clusters is the number of clusters\r\n    # or the number of colors that we choose.\r\n      \r\n    # means is the array of assumed means or centroids. \r\n    means = np.zeros((clusters, n)) \r\n  \r\n    # random initialization of means. \r\n    for i in range(clusters):\r\n        rand1 = int(np.random.random(1)*10)\r\n        rand2 = int(np.random.random(1)*8)\r\n        means[i, 0] = points[rand1, 0]\r\n        means[i, 1] = points[rand2, 1]\r\n  \r\n    return points, means\r\n  \r\n  \r\n# Function to measure the euclidean\r\n# distance (distance formula)\r\ndef distance(x1, y1, x2, y2):\r\n      \r\n    dist = np.square(x1 - x2) + np.square(y1 - y2)\r\n    dist = np.sqrt(dist)\r\n  \r\n    return dist\r\n  \r\n  \r\ndef k_means(points, means, clusters):\r\n  \r\n    iterations = 10 # the number of iterations \r\n    m, n = points.shape\r\n      \r\n    # these are the index values that\r\n    # correspond to the cluster to\r\n    # which each pixel belongs to.\r\n    index = np.zeros(m) \r\n  \r\n    # k-means algorithm.\r\n    while(iterations > 0):\r\n  \r\n        for j in range(len(points)):\r\n              \r\n            # initialize minimum value to a large value\r\n            minv = 1000\r\n            temp = None\r\n              \r\n            for k in range(clusters):\r\n                  \r\n                x1 = points[j, 0]\r\n                y1 = points[j, 1]\r\n                x2 = means[k, 0]\r\n                y2 = means[k, 1]\r\n                  \r\n                if(distance(x1, y1, x2, y2) < minv):         \r\n                    minv = distance(x1, y1, x2, y2)\r\n                    temp = k\r\n                    index[j] = k \r\n          \r\n        for k in range(clusters):\r\n              \r\n            sumx = 0\r\n            sumy = 0\r\n            count = 0\r\n              \r\n            for j in range(len(points)):\r\n                  \r\n                if(index[j] == k):\r\n                    sumx += points[j, 0]\r\n                    sumy += points[j, 1] \r\n                    count += 1\r\n              \r\n            if(count == 0):\r\n                count = 1    \r\n              \r\n            means[k, 0] = float(sumx / count)\r\n            means[k, 1] = float(sumy / count)     \r\n              \r\n        iterations -= 1\r\n  \r\n    return means, index\r\n  \r\n  \r\ndef compress_image(means, index, img):\r\n  \r\n    # recovering the compressed image by\r\n    # assigning each pixel to its corresponding centroid.\r\n    centroid = np.array(means)\r\n    recovered = centroid[index.astype(int), :]\r\n      \r\n    # getting back the 3d matrix (row, col, rgb(3))\r\n    recovered = np.reshape(recovered, (img.shape[0], img.shape[1],\r\n                                                     img.shape[2]))\r\n  \r\n    # plotting the compressed image.\r\n    plt.imshow(recovered)\r\n    plt.show()\r\n  \r\n    # saving the compressed image.\r\n    misc.imsave('compressed_' + str(clusters) +\r\n                        '_colors.png', recovered)\r\n  \r\n  \r\n# Driver Code\r\nif __name__ == '__main__':\r\n  \r\n    img = read_image()\r\n  \r\n    clusters = 16\r\n    clusters = int(input('Enter the number of colors in the compressed image. default = 16\\n'))\r\n  \r\n    points, means = initialize_means(img, clusters)\r\n    means, index = k_means(points, means, clusters)\r\n    compress_image(means, index, img)"}
{"nl": "Python Program to get the Last Word from a String", "code": "# Give the string as user input using the input() function and store it in the variable.\ngvnstrng = input('Enter some random string = ')\n# Split the words of the given string to a list of words\n# using the built-in split() function.\nlsttofwrds = gvnstrng.split()\n# Get the last word from the above list of words using negative indexing\n# and store it in a variable.\nlstwrd = lsttofwrds[-1]\n# Print the last word of the given string by printing the above variable.\nprint('The last word in the given string {', gvnstrng, '} is:', lstwrd)"}
{"nl": "Python Program to Check a number is Narcissistic Number or Not", "code": "# Give the number as static input and store it in a variable.\n givennmb = 370\n # Convert this number into list of digits using list(),map(),int(),str() functions.\n # Store it in a variable.\n numbedigis = list(map(int, str(givennmb)))\n # Calculate the length of the list using the len() function\n # and store it in a variable say listleng.\n listleng = len(numbedigis)\n # Take a variable tempo and initialize its value to 0.\n tempo = 0\n # Loop in this digits list using For loop.\n for numbrdigit in numbedigis:\n  # Calculate the iterator value^listleng where ^ represents\n  # the power operator and store it in a variable.\n  powevalu = numbrdigit**listleng\n  # Increment the tempo by the above variable.\n  tempo = tempo+powevalu\n # After the end of For loop check if the tempo value is equal\n # to the given number using the If conditional Statement.\n if(tempo == givennmb):\n  # If it is true then print the given number as a Narcissistic Number.\n  print('The given Number {', givennmb, '} is a Narcissistic Number')\n else:\n  # Else it is not a Narcissistic Number.\n  print('The given Number {', givennmb, '} is not a Narcissistic Number')"}
{"nl": "Print all k-sum paths in a binary tree", "code": "# Python3 program to print all paths\n# with sum k\n\n# utility function to print contents of\n# a vector from index i to it's end\n\n\ndef printVector(v, i):\n\tfor j in range(i, len(v)):\n\t\tprint(v[j], end=\" \")\n\tprint()\n\n\n# Binary Tree Node\n\"\"\" utility that allocates a newNode\nwith the given key \"\"\"\n\n\nclass newNode:\n\n\t# Construct to create a newNode\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# This function prints all paths\n# that have sum k\n\n\ndef printKPathUtil(root, path, k):\n\n\t# empty node\n\tif (not root):\n\t\treturn\n\n\t# add current node to the path\n\tpath.append(root.data)\n\n\t# check if there's any k sum path\n\t# in the left sub-tree.\n\tprintKPathUtil(root.left, path, k)\n\n\t# check if there's any k sum path\n\t# in the right sub-tree.\n\tprintKPathUtil(root.right, path, k)\n\n\t# check if there's any k sum path that\n\t# terminates at this node\n\t# Traverse the entire path as\n\t# there can be negative elements too\n\tf = 0\n\tfor j in range(len(path) - 1, -1, -1):\n\t\tf += path[j]\n\n\t\t# If path sum is k, print the path\n\t\tif (f == k):\n\t\t\tprintVector(path, j)\n\n\t# Remove the current element\n\t# from the path\n\tpath.pop(-1)\n\n# A wrapper over printKPathUtil()\n\n\ndef printKPath(root, k):\n\n\tpath = []\n\tprintKPathUtil(root, path, k)\n\n\n# Driver Code\nif __name__ == '__main__':\n\n\troot = newNode(1)\n\troot.left = newNode(3)\n\troot.left.left = newNode(2)\n\troot.left.right = newNode(1)\n\troot.left.right.left = newNode(1)\n\troot.right = newNode(-1)\n\troot.right.left = newNode(4)\n\troot.right.left.left = newNode(1)\n\troot.right.left.right = newNode(2)\n\troot.right.right = newNode(5)\n\troot.right.right.right = newNode(2)\n\n\tk = 5\n\tprintKPath(root, k)\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)"}
{"nl": "return the  number of ways a 2d matrix can be painted in three colors with no two adjacent cells having the same color", "code": "class Solution:\n    def colorTheGrid(self, m: int, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        # Get valid states for a column\n        valid_states = generate_states(m)\n        # Init rolling array dp\n        dp = [[0] * len(valid_states) for _ in range(2)]\n        # Init the first column of dp to all ones\n        for i in range(len(dp[0])):\n            dp[0][i] = 1\n\n        # Memorize valid current and previous states pairs\n        # memo: {(current state index, [previous valid state indexes])}\n        memo = {}\n        for i in range(1, n):\n            for j in range(len(valid_states)):\n                # Init the dp value of current column at this state to zero\n                dp[i % 2][j] = 0\n                # Iterate through all the valid states in previous column\n                # First check if the current state index is in memo\n                if j in memo:\n                    for k in memo[j]:\n                        dp[i % 2][j] = (dp[i % 2][j] + dp[(i - 1) % 2][k]) % MOD\n                    continue\n\n                # If not, iterate through all the valid states in previous column\n                valid_prev_states = []\n                for k in range(len(valid_states)):\n                    # Accumulate to the dp value of current column at this state if the two states are valid\n                    if check_valid_states(valid_states[j], valid_states[k]):\n                        dp[i % 2][j] = (dp[i % 2][j] + dp[(i - 1) % 2][k]) % MOD\n                        valid_prev_states.append(k)\n\n                # Save the current state index and previous valid state indexes list to memo\n                memo[j] = valid_prev_states\n        \n        # Add up the dp values of the last column\n        res = 0\n        for i in range(len(dp[0])):\n            res = (res + dp[(n - 1) % 2][i]) % MOD\n        return res\n\ndef generate_states(m):\n    states = []\n    # Iterate over all possible states in 10 digit base\n    for i in range(3 ** m):\n        state_tmp = i\n        state = []\n        # Convert the state to 3 digit base\n        for j in range(m):\n            last_bit = state_tmp % 3\n            if state and last_bit == state[-1]:\n                break\n            state.append(last_bit)\n            state_tmp //= 3\n\n        # Add the state to states if valid\n        if len(state) == m:\n            states.append(state)\n    \n    return states\n\ndef check_valid_states(state1, state2):\n    for i in range(len(state1)):\n        if state1[i] == state2[i]:\n            return False\n    return True"}
{"nl": "simulate a bank system", "code": "class Bank:\n\n    def __init__(self, balance: List[int]):\n        self.bankaccount=balance\n\n    def transfer(self, account1: int, account2: int, money: int) -> bool:\n        account1-=1\n        account2-=1\n        if(account1<len(self.bankaccount) and account2<len(self.bankaccount)):\n            if(self.bankaccount[account1]>=money):\n                self.bankaccount[account1]-=money\n                self.bankaccount[account2]+=money\n                return True\n        return False\n\n    def deposit(self, account: int, money: int) -> bool:\n        account-=1\n        if(account<len(self.bankaccount)):\n            self.bankaccount[account]+=money\n            return True\n        return False\n\n\n    def withdraw(self, account: int, money: int) -> bool:\n        account-=1\n        if(account<len(self.bankaccount) and money<=self.bankaccount[account]):\n            self.bankaccount[account]-=money\n            return True\n        return False"}
{"nl": "Special Lists", "code": "def is_special_array(lst):\n        return all(lst[i]%2==i%2 for i in range(len(lst)))"}
{"nl": "Check if a given Binary Tree is height balanced like a Red-Black Tree", "code": "\"\"\" Program to check if a given Binary\nTree is balanced like a Red-Black Tree \"\"\"\n\n# Helper function that allocates a new\n# node with the given data and None\n# left and right pointers.\t\t\t\t\t\t\t\t\nclass newNode:\n\n\t# Construct to create a new node\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\n# Returns returns tree if the Binary\n# tree is balanced like a Red-Black\n# tree. This function also sets value\n# in maxh and minh (passed by\n# reference). maxh and minh are set\n# as maximum and minimum heights of root.\ndef isBalancedUtil(root, maxh, minh) :\n\n\t# Base case\n\tif (root == None) :\n\t\n\t\tmaxh = minh = 0\n\t\treturn True\n\t\n\n\tlmxh=0\n\t\n\t# To store max and min\n\t# heights of left subtree\n\tlmnh=0\n\t\n\t# To store max and min\n\t# heights of right subtree\n\trmxh, rmnh=0,0\n\n\t# Check if left subtree is balanced,\n\t# also set lmxh and lmnh\n\tif (isBalancedUtil(root.left, lmxh, lmnh) == False) :\n\t\treturn False\n\n\t# Check if right subtree is balanced,\n\t# also set rmxh and rmnh\n\tif (isBalancedUtil(root.right, rmxh, rmnh) == False) :\n\t\treturn False\n\n\t# Set the max and min heights of\n\t# this node for the parent call\n\tmaxh = max(lmxh, rmxh) + 1\n\tminh = min(lmnh, rmnh) + 1\n\n\t# See if this node is balanced\n\tif (maxh <= 2 * minh) :\n\t\treturn True\n\n\treturn False\n\n\n# A wrapper over isBalancedUtil()\ndef isBalanced(root) :\n\n\tmaxh, minh =0,0\n\treturn isBalancedUtil(root, maxh, minh)\n\n# Driver Code\nif __name__ == '__main__':\n\troot = newNode(10)\n\troot.left = newNode(5)\n\troot.right = newNode(100)\n\troot.right.left = newNode(50)\n\troot.right.right = newNode(150)\n\troot.right.left.left = newNode(40)\n\tif (isBalanced(root)):\n\t\tprint(\"Balanced\")\n\telse:\n\t\tprint(\"Not Balanced\")\n\n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"}
{"nl": "Tweaking Letters", "code": "l = 'abcdefghijklmnopqrstuvwxyz'\ndef tweak_letters(txt, lst):\n  return ''.join([l[(l.find(txt[i]) + lst[i])%26] for i in range(len(lst))])"}
{"nl": "Python Program to Remove Odd Occurring Characters from the String", "code": "# Take a dictionary and initialize it to empty\n \n # using the {} or dict() say freqncyDictionary.\n \n freqncyDictionary = {}\n \n # Give the string as static input and store it in a variable\n \n gvnstrng = \"goodmorning\"\n \n # Loop in the given string using the For loop.\n \n for i in gvnstrng:\n \n  # Inside the For loop,\n \n  # Check if the string character is present in the dictionary\n \n  # or not using the if conditional statement and 'in' keyword.\n \n  if i in freqncyDictionary.keys():\n \n  # If it is true then increment the count of the string character\n \n  # in the dictionary by 1.\n \n  freqncyDictionary[i] = freqncyDictionary[i]+1\n \n  # Else initialize the dictionary with the string character as key and value as 1.\n \n  else:\n \n  freqncyDictionary[i] = 1\n \n # Take a string which stores all the characters which are not occuring odd number\n \n # of times and initialize it to null string using \"\" or str()\n \n modifd_string = \"\"\n \n # loop in the given string using the for loop\n \n for charac in gvnstrng:\n \n \n \n  # check if the character has even frequency by checking value of that character in frequency dictionary\n \n  # we check using the if conditional statement\n \n  if(freqncyDictionary[charac] % 2 == 0):\n \n  # if it is true then concatenate this character to modifd_string using string concatenation\n \n  modifd_string = modifd_string+charac\n \n \n \n \n \n # print the modifd_string string\n \n print('The given string {', gvnstrng,\n \n  '} after removing odd frequency elements is :', modifd_string)"}
{"nl": "Check if the line of music contains any syncopatio", "code": "def has_syncopation(s):\n  return '#' in s[1::2]"}
{"nl": "Almost Palindrome", "code": "def almost_palindrome(txt):\n  return sum(a != b for a, b in zip(txt, txt[::-1])) == 2"}
{"nl": "substring with concatenation of all words", "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(s)\n        k = len(words)\n        word_length = len(words[0])\n        substring_size = word_length * k\n        word_count = collections.Counter(words)\n        \n        def sliding_window(left):\n            words_found = collections.defaultdict(int)\n            words_used = 0\n            excess_word = False\n            \n            # Do the same iteration pattern as the previous approach - iterate\n            # word_length at a time, and at each iteration we focus on one word\n            for right in range(left, n, word_length):\n                if right + word_length > n:\n                    break\n\n                sub = s[right : right + word_length]\n                if sub not in word_count:\n                    # Mismatched word - reset the window\n                    words_found = collections.defaultdict(int)\n                    words_used = 0\n                    excess_word = False\n                    left = right + word_length # Retry at the next index\n                else:\n                    # If we reached max window size or have an excess word\n                    while right - left == substring_size or excess_word:\n                        # Move the left bound over continously\n                        leftmost_word = s[left : left + word_length]\n                        left += word_length\n                        words_found[leftmost_word] -= 1\n\n                        if words_found[leftmost_word] == word_count[leftmost_word]:\n                            # This word was the excess word\n                            excess_word = False\n                        else:\n                            # Otherwise we actually needed it\n                            words_used -= 1\n                    \n                    # Keep track of how many times this word occurs in the window\n                    words_found[sub] += 1\n                    if words_found[sub] <= word_count[sub]:\n                        words_used += 1\n                    else:\n                        # Found too many instances already\n                        excess_word = True\n                    \n                    if words_used == k and not excess_word:\n                        # Found a valid substring\n                        answer.append(left)\n        \n        answer = []\n        for i in range(word_length):\n            sliding_window(i)\n\n        return answer"}
{"nl": "Sorting a neatly sorted array", "code": "# A Python3 program to sort a\r\n# nearly sorted array.\r\n \r\nfrom heapq import heappop, heappush, heapify\r\n \r\n \r\n# A utility function to print\r\n# array elements\r\ndef print_array(arr: list):\r\n    for elem in arr:\r\n        print(elem, end=' ')\r\n \r\n# Given an array of size n, where every\r\n# element is k away from its target\r\n# position, sorts the array in O(nLogk) time.\r\n \r\n \r\ndef sort_k(arr: list, n: int, k: int):\r\n    \"\"\"\r\n    :param arr: input array\r\n    :param n: length of the array\r\n    :param k: max distance, which every\r\n     element is away from its target position.\r\n    :return: None\r\n    \"\"\"\r\n    # List of first k+1 items\r\n    heap = arr[:k + 1]\r\n \r\n    # using heapify to convert list\r\n    # into heap(or min heap)\r\n    heapify(heap)\r\n \r\n    # \"rem_elmnts_index\" is index for remaining\r\n    # elements in arr and \"target_index\" is\r\n    # target index of for current minimum element\r\n    # in Min Heap \"heap\".\r\n    target_index = 0\r\n    for rem_elmnts_index in range(k + 1, n):\r\n        arr[target_index] = heappop(heap)\r\n        heappush(heap, arr[rem_elmnts_index])\r\n        target_index += 1\r\n \r\n    while heap:\r\n        arr[target_index] = heappop(heap)\r\n        target_index += 1\r\n \r\n \r\n# Driver Code\r\nk = 3\r\narr = [2, 6, 3, 12, 56, 8]\r\nn = len(arr)\r\nsort_k(arr, n, k)\r\n \r\nprint('Following is sorted array')\r\nprint_array(arr)\r\n \r\n# This code is contributed by\r\n# Veerat Beri(viratberi)"}
{"nl": "in an array of obstacles of different heights, find the longest valid course at each position", "code": "class Solution:\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\n        # at every i, we need to find all j <i of height less than i\n        # it also has to be an increasing sequence, which makes it harder\n        n = len(obstacles)\n        ansr = [0]*n\n        ansr[0] = 1\n        \n        # for each obstacle_course_length, keep track of the minimum height\n        lengths = defaultdict(lambda : float('Inf'))\n        lengths[1] = obstacles[0]\n      \n        for i in range(1,n):\n            #binary search lengths from 1 to i: these are possible lengths of the obstacle course for i\n            l,r = 0, i+1\n            while(l<r):\n                mid = (l+r+1)//2 # this is a length\n                #print(l,r,mid)\n                if(lengths[mid] <= obstacles[i]):\n                    l = mid\n                else:\n                    r = mid-1\n                    \n            best = l+1\n            # for j in range(i):\n            #     if(obstacles[j]<=obstacles[i]):\n            #         best = max(best, ansr[j])\n            lengths[best] = min(lengths[best], obstacles[i])\n            ansr[i] = best\n        return ansr"}
{"nl": "Kernal PCA machine learning", "code": "from sklearn.decomposition import PCA\r\npca = PCA(n_components = 2)\r\nX_pca = pca.fit_transform(X)\r\n   \r\nplt.title(\"PCA\")\r\nplt.scatter(X_pca[:, 0], X_pca[:, 1], c = y)\r\nplt.xlabel(\"Component 1\")\r\nplt.ylabel(\"Component 2\")\r\nplt.show()"}
{"nl": "The minimum total distance between each house and its nearest mailbox", "code": "class Solution:  # 575 ms, faster than 57.25%\n  def minDistance(self, houses: List[int], k: int) -> int:\n  n = len(houses)\n  houses = sorted(houses)\n  costs = [[0] * n for _ in range(n)]\n  for i in range(n):\n  for j in range(n):\n  medianPos = houses[(i + j) // 2]\n  for m in range(i, j + 1):\n  costs[i][j] += abs(medianPos - houses[m])\n\n  @lru_cache(None)\n  def dp(k, i):\n  if k == 0 and i == n: return 0\n  if k == 0 or i == n: return math.inf\n  ans = math.inf\n  for j in range(i, n):\n  cost = costs[i][j]  # Try to put a mailbox among house[i:j]\n  ans = min(ans, cost + dp(k - 1, j + 1))\n  return ans\n\n  return dp(k, 0)"}
{"nl": "Count the Towers", "code": "def count_towers(towers):\n  return towers[-1][0].count('##')"}
{"nl": "Swap bits in a given number", "code": "# Python program to\n# swap bits in a given number\n\ndef swapBits(x, p1, p2, n):\n\n\t# Move all bits of first\n\t# set to rightmost side\n\tset1 = (x >> p1) & ((1<< n) - 1)\n\n\t# Move all bits of second\n\t# set to rightmost side\n\tset2 = (x >> p2) & ((1 << n) - 1)\n\n\t# XOR the two sets\n\txor = (set1 ^ set2)\n\n\t# Put the xor bits back\n\t# to their original positions\n\txor = (xor << p1) | (xor << p2)\n\n\t# XOR the 'xor' with the\n\t# original number so that the\n\t# two sets are swapped\n\tresult = x ^ xor\n\n\treturn result\n\t\n# Driver code\n\nres = swapBits(28, 0, 3, 2)\nprint(\"Result =\", res)\n\n# This code is contributed\n# by Anant Agarwal."}
{"nl": "Python Program to Calculate Age in Days from Date of Birth", "code": "# Import datetime(), timedelta() functions from datetime module using import keyword.\nfrom datetime import datetime, timedelta\n# Give the date of birth as static input in the format (YY, MM, DD) using datetime() function\n# and store it in a variable.\ngvn_DOB = datetime(1999, 5, 16)\n# Get the current/today date using datetime.today() function and store it in\n# another variable.\ncurrent_date = datetime.today()\n# Subtract the given date of birth from the current date to get the age in days\n# and store it in another variable.\nage_in_days = current_date - gvn_DOB\n# Print the age in days and time from the given date of birth.\nprint(\"The age in days and time for the Given DOB = \", age_in_days)"}
{"nl": "Python Why Lambda Function\r\n", "code": "def myfunc(n):\r\n  return lambda a : a * n\r\n\r\nmytripler = myfunc(3)\r\n\r\nprint(mytripler(11))"}
{"nl": "Sort array by increasing frequency", "code": "class Solution:\n  def frequencySort(self, nums: List[int]) -> List[int]:\n  r = Counter(nums)\n  return sorted(nums, key=lambda x: (r[x], -x))"}
{"nl": "The minimum number of steps to make the grid valid", "code": "class Solution:\n  def minSwaps(self, grid: List[List[int]]) -> int:\n  n = len(grid)\n  \n  def count(arr):\n  ans = 0\n  for i in range(n-1, -1, -1):\n  if arr[i] == 0:\n  ans += 1\n  else:\n  break\n  return ans\n  \n  arr = [count(row) for row in grid]\n  ans = 0\n  for i in range(n):\n  target = n - i - 1\n  if arr[i] >= target:\n  continue\n  flag = False\n  for j in range(i+1, n):\n  if arr[j] >= target:\n  flag = True\n  ans += (j - i)\n  arr[i+1:j+1] = arr[i:j]\n  break\n  if not flag:\n  return -1\n  \n  return ans"}
{"nl": "Print Odd Numbers Within a Given Range", "code": "# Give the lower limit and upper limit as static input\r\n# and store them in two separate variables.\r\n# given lower limit range\r\nlowLimitRange = 23\r\n# given upper limit range\r\nuppLimitRange = 143\r\nprint('Odd numbers from', lowLimitRange, 'to', uppLimitRange, 'are :')\r\n# Loop from lower limit range to upper limit range using For loop.\r\nfor iterval in range(lowLimitRange, uppLimitRange+1):\r\n    # Check if the iterator value is even or odd using if statement and modulus operator.\r\n    if(iterval % 2 != 0):\r\n        # If the iterator value is odd then print it.\r\n        print(iterval, end=\" \")"}
{"nl": "Print output using string.format()", "code": "quantity = 3\ntotalMoney = 1000\nprice = 450\nstatement1 = \"I have {1} dollars so I can buy {0} football for {2:.2f} dollars.\"\nprint(statement1.format(quantity, totalMoney, price))"}
{"nl": "Find Union and Intersection of two unsorted arrays", "code": "# Python3 program to find union and intersection\r\n# using similar Hashing Technique\r\n# without using any predefined Java Collections\r\n# Time Complexity best case & avg case = O(m+n)\r\n# Worst case = O(nlogn)\r\n\r\n\r\n# Prints intersection of arr1[0..n1-1] and\r\n# arr2[0..n2-1]\r\ndef findPosition(a, b):\r\n\tv = len(a) + len(b);\r\n\tans = [0]*v;\r\n\tzero1 = zero2 = 0;\r\n\tprint(\"Intersection :\",end=\" \");\r\n\t\r\n\t# Iterate first array\r\n\tfor i in range(len(a)):\r\n\t\tzero1 = iterateArray(a, v, ans, i);\r\n\t\r\n\t# Iterate second array\r\n\tfor j in range(len(b)):\r\n\t\tzero2 = iterateArray(b, v, ans, j);\r\n\t\r\n\tzero = zero1 + zero2;\r\n\tplaceZeros(v, ans, zero);\r\n\tprintUnion(v, ans, zero);\r\n\t\r\n# Prints union of arr1[0..n1-1] and arr2[0..n2-1]\r\ndef printUnion(v, ans,zero):\r\n\tzero1 = 0;\r\n\tprint(\"\\nUnion :\",end=\" \");\r\n\tfor i in range(v):\r\n\t\tif ((zero == 0 and ans[i] == 0) or\r\n\t\t\t(ans[i] == 0 and zero1 > 0)):\r\n\t\t\tcontinue;\r\n\t\tif (ans[i] == 0):\r\n\t\t\tzero1+=1;\r\n\t\tprint(ans[i],end=\",\");\r\n\r\ndef placeZeros(v, ans, zero):\r\n\tif (zero == 2):\r\n\t\tprint(\"0\");\r\n\t\td = [0];\r\n\t\tplaceValue(d, ans, 0, 0, v);\r\n\tif (zero == 1):\r\n\t\td=[0];\r\n\t\tplaceValue(d, ans, 0, 0, v);\r\n\r\n# Function to iterate array\r\ndef iterateArray(a,v,ans,i):\r\n\tif (a[i] != 0):\r\n\t\tp = a[i] % v;\r\n\t\tplaceValue(a, ans, i, p, v);\r\n\telse:\r\n\t\treturn 1;\r\n\t\r\n\treturn 0;\r\n\r\ndef placeValue(a,ans,i,p,v):\r\n\tp = p % v;\r\n\tif (ans[p] == 0):\r\n\t\tans[p] = a[i];\r\n\telse:\r\n\t\tif (ans[p] == a[i]):\r\n\t\t\tprint(a[i],end=\",\");\r\n\t\telse:\r\n\t\t\t# Hashing collision happened increment\r\n\t\t\t# position and do recursive call\r\n\t\t\tp = p + 1;\r\n\t\t\tplaceValue(a, ans, i, p, v);\r\n\r\n# Driver code\r\na = [ 7, 1, 5, 2, 3, 6 ];\r\nb = [ 3, 8, 6, 20, 7 ];\r\nfindPosition(a, b);\r\n\r\n# This code is contributed by mits\r"}
{"nl": "Check if an array has a majority element", "code": "# Hashing based Python\r\n# program to find if\r\n# there is a majority\r\n# element in input array.\r\n\r\n# Returns true if there\r\n# is a majority element\r\n# in a[]\r\ndef isMajority(a):\r\n\t\r\n\t# Insert all elements\r\n\t# in a hash table\r\n\tmp = {}\r\n\t\r\n\tfor i in a:\r\n\t\tif i in mp: mp[i] += 1\r\n\t\telse: mp[i] = 1\r\n\t\r\n\t# Check if frequency\r\n\t# of any element is\r\n\t# n/2 or more.\r\n\tfor x in mp:\r\n\t\tif mp[x] >= len(a)//2:\r\n\t\t\treturn True\r\n\treturn False\r\n\r\n# Driver code\r\na = [ 2, 3, 9, 2, 2 ]\r\n\r\nprint(\"Yes\" if isMajority(a) else \"No\")\r\n\r\n#This code is contributed by Ansu Kumari\r"}
{"nl": "Python Program for Double Factorial", "code": "# Give the number as static input and store it in a variable.\nnumbr = 8\n# Take a variable, initialize it with the value '1', and store it in another\n# variable say 'c'.\nc = 1\n# Loop from the given number to 0 in decreasing order with the stepsize of -2\n# using the for loop.\nfor i in range(numbr, 0, -2):\n    # Inside the loop multiply the above initialized variable c with the iterator value\n    # and store it in the same variable 'c'.\n    c *= i\n # Print the double factorial of a given number.\nprint(\"The double factorial of a given number{\", numbr, \"} = \", c)"}
{"nl": "Python Dictionary get() Method\r\n\r", "code": "car = {\r\n  \"brand\": \"Ford\",\r\n  \"model\": \"Mustang\",\r\n  \"year\": 1964\r\n}\r\n\r\nx = car.get(\"model\")\r\n\r\nprint(x)"}
{"nl": "Implementing Deletion in AVL Tree", "code": "# Python code to delete a node in AVL tree\n# Generic tree node class\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n \n# AVL tree class which supports insertion,\n# deletion operations\nclass AVL_Tree(object):\n \n    def insert(self, root, key):\n         \n        # Step 1 - Perform normal BST\n        if not root:\n            return TreeNode(key)\n        elif key < root.val:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n \n        # Step 2 - Update the height of the\n        # ancestor node\n        root.height = 1 + max(self.getHeight(root.left),\n                          self.getHeight(root.right))\n \n        # Step 3 - Get the balance factor\n        balance = self.getBalance(root)\n \n        # Step 4 - If the node is unbalanced,\n        # then try out the 4 cases\n        # Case 1 - Left Left\n        if balance > 1 and key < root.left.val:\n            return self.rightRotate(root)\n \n        # Case 2 - Right Right\n        if balance < -1 and key > root.right.val:\n            return self.leftRotate(root)\n \n        # Case 3 - Left Right\n        if balance > 1 and key > root.left.val:\n            root.left = self.leftRotate(root.left)\n            return self.rightRotate(root)\n \n        # Case 4 - Right Left\n        if balance < -1 and key < root.right.val:\n            root.right = self.rightRotate(root.right)\n            return self.leftRotate(root)\n \n        return root\n \n    # Recursive function to delete a node with\n    # given key from subtree with given root.\n    # It returns root of the modified subtree.\n    def delete(self, root, key):\n \n        # Step 1 - Perform standard BST delete\n        if not root:\n            return root\n \n        elif key < root.val:\n            root.left = self.delete(root.left, key)\n \n        elif key > root.val:\n            root.right = self.delete(root.right, key)\n \n        else:\n            if root.left is None:\n                temp = root.right\n                root = None\n                return temp\n \n            elif root.right is None:\n                temp = root.left\n                root = None\n                return temp\n \n            temp = self.getMinValueNode(root.right)\n            root.val = temp.val\n            root.right = self.delete(root.right,\n                                      temp.val)\n \n        # If the tree has only one node,\n        # simply return it\n        if root is None:\n            return root\n \n        # Step 2 - Update the height of the\n        # ancestor node\n        root.height = 1 + max(self.getHeight(root.left),\n                            self.getHeight(root.right))\n \n        # Step 3 - Get the balance factor\n        balance = self.getBalance(root)\n \n        # Step 4 - If the node is unbalanced,\n        # then try out the 4 cases\n        # Case 1 - Left Left\n        if balance > 1 and self.getBalance(root.left) >= 0:\n            return self.rightRotate(root)\n \n        # Case 2 - Right Right\n        if balance < -1 and self.getBalance(root.right) <= 0:\n            return self.leftRotate(root)\n \n        # Case 3 - Left Right\n        if balance > 1 and self.getBalance(root.left) < 0:\n            root.left = self.leftRotate(root.left)\n            return self.rightRotate(root)\n \n        # Case 4 - Right Left\n        if balance < -1 and self.getBalance(root.right) > 0:\n            root.right = self.rightRotate(root.right)\n            return self.leftRotate(root)\n \n        return root\n \n    def leftRotate(self, z):\n \n        y = z.right\n        T2 = y.left\n \n        # Perform rotation\n        y.left = z\n        z.right = T2\n \n        # Update heights\n        z.height = 1 + max(self.getHeight(z.left),\n                         self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                         self.getHeight(y.right))\n \n        # Return the new root\n        return y\n \n    def rightRotate(self, z):\n \n        y = z.left\n        T3 = y.right\n \n        # Perform rotation\n        y.right = z\n        z.left = T3\n \n        # Update heights\n        z.height = 1 + max(self.getHeight(z.left),\n                          self.getHeight(z.right))\n        y.height = 1 + max(self.getHeight(y.left),\n                          self.getHeight(y.right))\n \n        # Return the new root\n        return y\n \n    def getHeight(self, root):\n        if not root:\n            return 0\n \n        return root.height\n \n    def getBalance(self, root):\n        if not root:\n            return 0\n \n        return self.getHeight(root.left) - self.getHeight(root.right)\n \n    def getMinValueNode(self, root):\n        if root is None or root.left is None:\n            return root\n \n        return self.getMinValueNode(root.left)\n \n    def preOrder(self, root):\n \n        if not root:\n            return\n \n        print(\"{0} \".format(root.val), end=\"\")\n        self.preOrder(root.left)\n        self.preOrder(root.right)\n \n \nmyTree = AVL_Tree()\nroot = None\nnums = [9, 5, 10, 0, 6, 11, -1, 1, 2]\n \nfor num in nums:\n    root = myTree.insert(root, num)\n \n# Preorder Traversal\nprint(\"Preorder Traversal after insertion -\")\nmyTree.preOrder(root)\nprint()\n \n# Delete\nkey = 10\nroot = myTree.delete(root, key)\n \n# Preorder Traversal\nprint(\"Preorder Traversal after deletion -\")\nmyTree.preOrder(root)\nprint()\n \n# This code is contributed by Ajitesh Pathak"}
{"nl": "Shuffle Elements of a Tuple", "code": "# Import the random module using import method.\r\nimport random\r\n# Give the tuple as user input using tuple(),map(),input(),and split() functions\r\n#and Store it in a variable.\r\ngvn_tup = tuple(map(int, input(\r\n   'Enter some random tuple Elements separated by spaces = ').split()))\r\n# Convert the given tuple into list using the list() function and\r\n# store it in another variable.\r\nlst = list(gvn_tup)\r\n# Apply random.shuffle() method on the above obtained list .\r\nrandom.shuffle(lst)\r\n# Convert the above shuffled list into tuple again using the tuple() function\r\n# and store it in another variable.\r\nshuffld_tupl = tuple(lst)\r\n# Print the above given tuple after shuffling the elements of a given tuple.\r\nprint(\"The given tuple after Shuffling the elements = \", shuffld_tupl)"}
{"nl": "Python Program to Check if all Characters of String are Alphanumeric or Not", "code": "# Give the string as user input using the input()function and store it in a variable.\ngvn_strng = input('Enter some random string = ')\n# Check whether the Given string is alphanumeric using built-in alnum() method\n# and store it in another variable.\nBol_val = gvn_strng.isalnum()\n# Check whether the above result is True or not using the if conditional statement.\nif(Bol_val == True):\n # If it is True, Print the given string is  alphanumeric.\n    print(\"The Given string {\", gvn_strng, \"} is Alpha Numeric\")\nelse:\n  # If it is False, Print the given string is not alphanumeric.\n    print(\"The Given string {\", gvn_strng, \"} is not Alpha Numeric\")"}
{"nl": "Python Nested Loops\r\n", "code": "adj = [\"red\", \"big\", \"tasty\"]\r\nfruits = [\"apple\", \"banana\", \"cherry\"]\r\n\r\nfor x in adj:\r\n  for y in fruits:\r\n    print(x, y)"}
{"nl": "Create a custom set type.", "code": "class CustomSet(object):\n    def __init__(self, elements=[]):\n        self.elements = []\n        for element in elements:\n            self.add(element)\n    def isempty(self):\n        return len(self.elements) == 0\n    def __contains__(self, element):\n        return element in self.elements\n    def issubset(self, other):\n        for element in self.elements:\n            if element not in other.elements:\n                return False\n        return True\n    def isdisjoint(self, other):\n        for element in self.elements:\n            if element in other.elements:\n                return False\n        return True\n    def __eq__(self, other):\n        if len(self.elements) != len(other.elements):\n            return False\n        else:\n            for element in self.elements:\n                if element not in other.elements:\n                    return False\n            return True\n    def add(self, element):\n        if element not in self.elements:\n            self.elements.append(element)\n    def intersection(self, other):\n        result_elements = []\n        for element in self.elements:\n            if element in other.elements:\n                result_elements.append(element)\n        return CustomSet(result_elements)\n    def __sub__(self, other):\n        result_elements = []\n        for element in self.elements:\n            if element not in other.elements:\n                result_elements.append(element)\n        return CustomSet(result_elements)\n    def __add__(self, other):\n        result = CustomSet(self.elements)\n        for element in other.elements:\n            result.add(element)\n        return result"}
{"nl": "Check if there is a path for queries", "code": "class UnionFind:\n  def __init__(self, N: int):\n  self.parent = list(range(N))\n  self.rank = [1] * N\n\n  def find(self, p: int) -> int:\n  if p != self.parent[p]:\n  self.parent[p] = self.find(self.parent[p])\n  return self.parent[p]\n\n  def union(self, p: int, q: int) -> bool:\n  prt, qrt = self.find(p), self.find(q)\n  if prt == qrt: return False \n  if self.rank[prt] > self.rank[qrt]: \n  prt, qrt = qrt, prt \n  self.parent[prt] = qrt \n  self.rank[qrt] += self.rank[prt] \n  return True \n\n\nclass Solution:\n  def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n  queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\n  edgeList = sorted((w, u, v) for u, v, w in edgeList)\n  \n  uf = UnionFind(n)\n  \n  ans = [None] * len(queries)\n  ii = 0\n  for w, p, q, i in queries: \n  while ii < len(edgeList) and edgeList[ii][0] < w: \n  _, u, v = edgeList[ii]\n  uf.union(u, v)\n  ii += 1\n  ans[i] = uf.find(p) == uf.find(q)\n  return ans"}
{"nl": "File fileno() method", "code": "# Make a single variable to store the path of the file. This is a constant value.\n# This value must be replaced with the file path from your own system in the example below.\ngivenFilename = \"samplefile.txt\"\n# Open the file in read-only mode. In this case, we're simply reading the contents of the file.\ngvn_file = open(givenFilename, 'r') \n# Get the file descriptor of a file using the fileno() function and store it in a variable\nrslt= gvn_file.fileno()\n# Print the above result\nprint(rslt)"}
{"nl": "Python Program to Multiply Two Numbers", "code": "# Python program to find\r\n# multiply two numbers\r\n\r\n# Reading two numbers\r\nnumber1 = input('Enter first number: ')\r\nnumber2 = input('Enter second number: ')\r\n\r\n# Converting to float\r\n# Conversion is required because\r\n# input() function return string\r\nnumber1 = float(number1)\r\nnumber2 = float(number2)\r\n\r\n# Multiplication\r\nresult = number1 * number2\r\n\r\n# Displaying result\r\nprint('%0.2f * %0.2f = %0.2f' % (number1, number2, result))"}
